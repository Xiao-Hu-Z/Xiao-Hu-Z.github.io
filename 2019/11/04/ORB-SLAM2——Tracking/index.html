<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">
  <link rel="alternate" href="/atom.xml" title="xiaohu博客" type="application/atom+xml">


  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "b7ba025a"
    });
  daovoice('update');
  </script>


<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="整体流程图作为ORB-SLAM2里三大线程中的第一个，Tracking线程接收传感器（摄像头）传来的每一帧，并将处理的关键帧传递给LocalMapping线程。Tracking线程其实是系统里的主线程，通过反复调用Track函数进行。Tracking模块主要作用： 单目地图的初始化 当前帧的位姿估计 当前帧的局部地图跟踪 生成候选关键帧">
<meta name="keywords" content="ORB-SLAM2">
<meta property="og:type" content="article">
<meta property="og:title" content="ORB-SLAM2——Tracking">
<meta property="og:url" content="https:&#x2F;&#x2F;xiao-hu.com.cn&#x2F;2019&#x2F;11&#x2F;04&#x2F;ORB-SLAM2%E2%80%94%E2%80%94Tracking&#x2F;index.html">
<meta property="og:site_name" content="xiaohu博客">
<meta property="og:description" content="整体流程图作为ORB-SLAM2里三大线程中的第一个，Tracking线程接收传感器（摄像头）传来的每一帧，并将处理的关键帧传递给LocalMapping线程。Tracking线程其实是系统里的主线程，通过反复调用Track函数进行。Tracking模块主要作用： 单目地图的初始化 当前帧的位姿估计 当前帧的局部地图跟踪 生成候选关键帧">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191104210725639.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191114105531451.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-11-14T07:11:01.270Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191104210725639.png?x-oss-process=image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="https://xiao-hu.com.cn/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94Tracking/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ORB-SLAM2——Tracking | xiaohu博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaohu博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiao-hu.com.cn/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94Tracking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="xiaohu">
      <meta itemprop="description" content="博观而约取,厚积而薄发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaohu博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ORB-SLAM2——Tracking
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-04 20:59:45" itemprop="dateCreated datePublished" datetime="2019-11-04T20:59:45+08:00">2019-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 15:11:01" itemprop="dateModified" datetime="2019-11-14T15:11:01+08:00">2019-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ORB-SLAM2/" itemprop="url" rel="index">
                    <span itemprop="name">ORB-SLAM2</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>47k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>43 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h1><p>作为ORB-SLAM2里三大线程中的第一个，Tracking线程接收传感器（摄像头）传来的每一帧，并将处理的关键帧传递给LocalMapping线程。Tracking线程其实是系统里的主线程，通过反复调用Track函数进行。<br>Tracking模块主要作用：</p><ul>
<li>单目地图的初始化</li>
<li>当前帧的位姿估计</li>
<li>当前帧的局部地图跟踪</li>
<li>生成候选关键帧</li>
</ul><a id="more"></a>

<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191104210725639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191114105531451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="System-TrackMonocular"><a href="#System-TrackMonocular" class="headerlink" title="System::TrackMonocular"></a>System::TrackMonocular</h1><p>将图片传给slam系统<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat System::TrackMonocular(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mSensor!=MONOCULAR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: you called TrackMonocular but input sensor was not set to Monocular."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check mode change</span></span><br><span class="line">    &#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lock(mMutexMode);</span><br><span class="line">        <span class="keyword">if</span>(mbActivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpLocalMapper-&gt;RequestStop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until Local Mapping has effectively stopped</span></span><br><span class="line">            <span class="keyword">while</span>(!mpLocalMapper-&gt;isStopped())</span><br><span class="line">            &#123;</span><br><span class="line">                usleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">true</span>);</span><br><span class="line">            mbActivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mbDeactivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">false</span>);</span><br><span class="line">            mpLocalMapper-&gt;Release();</span><br><span class="line">            mbDeactivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check reset</span></span><br><span class="line">    &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(mMutexReset);</span><br><span class="line">    <span class="keyword">if</span>(mbReset)</span><br><span class="line">    &#123;</span><br><span class="line">        mpTracker-&gt;Reset();</span><br><span class="line">        mbReset = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat Tcw = mpTracker-&gt;GrabImageMonocular(im,timestamp);</span><br><span class="line"></span><br><span class="line">    unique_lock&lt;mutex&gt; lock2(mMutexState);</span><br><span class="line">    mTrackingState = mpTracker-&gt;mState;</span><br><span class="line">    mTrackedMapPoints = mpTracker-&gt;mCurrentFrame.mvpMapPoints;</span><br><span class="line">    mTrackedKeyPointsUn = mpTracker-&gt;mCurrentFrame.mvKeysUn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Tcw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Tracking-GrabImageMonocular"><a href="#Tracking-GrabImageMonocular" class="headerlink" title="Tracking::GrabImageMonocular"></a>Tracking::GrabImageMonocular</h1><p>将RGB图像化为灰度图像，之后Frame() 建立新帧，提取特征点。数据流以Frame的形式进入Track()函数，输出世界坐标系到该帧相机坐标系的变换矩阵（注意此时返回的变换矩阵是tracking的位姿估计）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat Tracking::GrabImageMonocular(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    mImGray = im;</span><br><span class="line">    <span class="comment">// 步骤1：将RGB或RGBA图像转为灰度图像</span></span><br><span class="line">    <span class="keyword">if</span>(mImGray.channels()==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mbRGB)</span><br><span class="line">            cvtColor(mImGray,mImGray,CV_RGB2GRAY);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cvtColor(mImGray,mImGray,CV_BGR2GRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mImGray.channels()==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mbRGB)</span><br><span class="line">            cvtColor(mImGray,mImGray,CV_RGBA2GRAY);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cvtColor(mImGray,mImGray,CV_BGRA2GRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤2：构造Frame</span></span><br><span class="line">    <span class="keyword">if</span>(mState==NOT_INITIALIZED || mState==NO_IMAGES_YET)<span class="comment">// 没有成功初始化的前一个状态就是NO_IMAGES_YET</span></span><br><span class="line">        mCurrentFrame = Frame(mImGray,timestamp,mpIniORBextractor,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mCurrentFrame = Frame(mImGray,timestamp,mpORBextractorLeft,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);</span><br><span class="line"></span><br><span class="line">    Track();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mCurrentFrame.mTcw.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Frame-Frame"><a href="#Frame-Frame" class="headerlink" title="Frame::Frame"></a>Frame::Frame</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Frame::Frame(<span class="keyword">const</span> cv::Mat &amp;imGray, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timeStamp, ORBextractor* extractor,ORBVocabulary* voc, cv::Mat &amp;K, cv::Mat &amp;distCoef, <span class="keyword">const</span> <span class="keyword">float</span> &amp;bf, <span class="keyword">const</span> <span class="keyword">float</span> &amp;thDepth)</span><br><span class="line">    :mpORBvocabulary(voc),mpORBextractorLeft(extractor),mpORBextractorRight(<span class="keyword">static_cast</span>&lt;ORBextractor*&gt;(<span class="literal">NULL</span>)),</span><br><span class="line">     mTimeStamp(timeStamp), mK(K.clone()),mDistCoef(distCoef.clone()), mbf(bf), mThDepth(thDepth)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Frame ID</span></span><br><span class="line">    mnId=nNextId++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale Level Info</span></span><br><span class="line">    mnScaleLevels = mpORBextractorLeft-&gt;GetLevels();</span><br><span class="line">    mfScaleFactor = mpORBextractorLeft-&gt;GetScaleFactor();</span><br><span class="line">    mfLogScaleFactor = <span class="built_in">log</span>(mfScaleFactor);</span><br><span class="line">    mvScaleFactors = mpORBextractorLeft-&gt;GetScaleFactors();</span><br><span class="line">    mvInvScaleFactors = mpORBextractorLeft-&gt;GetInverseScaleFactors();</span><br><span class="line">    mvLevelSigma2 = mpORBextractorLeft-&gt;GetScaleSigmaSquares();</span><br><span class="line">    mvInvLevelSigma2 = mpORBextractorLeft-&gt;GetInverseScaleSigmaSquares();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ORB extraction</span></span><br><span class="line">    ExtractORB(<span class="number">0</span>,imGray);</span><br><span class="line"></span><br><span class="line">    N = mvKeys.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mvKeys.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    UndistortKeyPoints();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set no stereo information</span></span><br><span class="line">    mvuRight = <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(N,<span class="number">-1</span>);</span><br><span class="line">    mvDepth = <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(N,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    mvpMapPoints = <span class="built_in">vector</span>&lt;MapPoint*&gt;(N,<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>));</span><br><span class="line">    mvbOutlier = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is done only for the first Frame (or after a change in the calibration)</span></span><br><span class="line">    <span class="keyword">if</span>(mbInitialComputations)</span><br><span class="line">    &#123;</span><br><span class="line">        ComputeImageBounds(imGray);</span><br><span class="line"></span><br><span class="line">        mfGridElementWidthInv=<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(FRAME_GRID_COLS)/<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mnMaxX-mnMinX);</span><br><span class="line">        mfGridElementHeightInv=<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(FRAME_GRID_ROWS)/<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mnMaxY-mnMinY);</span><br><span class="line"></span><br><span class="line">        fx = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        fy = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        cx = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        cy = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        invfx = <span class="number">1.0f</span>/fx;</span><br><span class="line">        invfy = <span class="number">1.0f</span>/fy;</span><br><span class="line"></span><br><span class="line">        mbInitialComputations=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mb = mbf/fx;</span><br><span class="line"></span><br><span class="line">    AssignFeaturesToGrid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="void-Tracking-Track"><a href="#void-Tracking-Track" class="headerlink" title="void Tracking::Track()"></a>void Tracking::Track()</h1><ol>
<li><p>判断tracking状态：如果是未初始化（NOT_INITIALIZED），则对单目和非单目分别执行MonocularInitialization()、StereoInitialization()进行初始化，并更新地图视图。</p>
</li>
<li><p>对于初始化成功的，接下来进行跟踪ORB-SLAM中关于跟踪状态有两种选择（由mbOnlyTracking判断）</p>
<p>（1）只进行跟踪不建图</p>
<p>（2）同时跟踪和建图：</p>
</li>
</ol>
<p>初始化之后ORB-SLAM有三种跟踪模型可供选择</p>
<ul>
<li><p>a.TrackWithMotionModel(); 运动模型：根据运动模型估计当前帧位姿——根据匀速运动模型对上一帧的地图点进行跟踪——优化位姿。</p>
</li>
<li><p>b.TrackReferenceKeyFrame(); 关键帧模型：BoW搜索当前帧与参考帧的匹配点——将上一帧的位姿作为当前帧的初始值——通过优化3D-2D的重投影误差来获得位姿。</p>
</li>
<li><p>c.Relocalization()；重定位模型：计算当前帧的BoW——检测满足重定位条件的候选帧——通过BoW搜索当前帧与候选帧的匹配点——大于15个点就进行PnP位姿估计——优化。</p>
</li>
</ul>
<p>这三个模型的选择方法：</p>
<p>首先假设相机恒速（即Rt和上一帧相同），然后计算匹配点数（如果匹配足够多则认为跟踪成功），如果匹配点数目较少，说明恒速模型失效，则选择参考帧模型（即特征匹配，PnP求解），如果参考帧模型同样不能进行跟踪，说明两帧键没有相关性，这时需要进行重定位，即和已经产生的关键帧中进行匹配（看看是否到了之前已经到过的地方）确定相机位姿，如果重定位仍然不能成功，则说明跟踪彻底丢失，要么等待相机回转，要不进行重置。</p>
<h2 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::Track()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mState==NO_IMAGES_YET)</span><br><span class="line">    &#123;</span><br><span class="line">        mState = NOT_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastProcessedState=mState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Map Mutex -&gt; Map cannot be changed</span></span><br><span class="line">    unique_lock&lt;mutex&gt; lock(mpMap-&gt;mMutexMapUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mState==NOT_INITIALIZED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mSensor==System::STEREO || mSensor==System::RGBD)</span><br><span class="line">            StereoInitialization();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            MonocularInitialization();</span><br><span class="line"></span><br><span class="line">        mpFrameDrawer-&gt;Update(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mState!=OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tracking-MonocularInitialization"><a href="#Tracking-MonocularInitialization" class="headerlink" title="Tracking::MonocularInitialization()"></a>Tracking::MonocularInitialization()</h3><p>并行地计算基础矩阵和单应性矩阵，选取其中一个模型，恢复出最开始两帧之间的相对姿态以及点云，得到初始两帧的匹配、相对运动、初始MapPoints</p>
<ol>
<li>当第一次进入该方法的时候，没有先前的帧数据，将当前帧保存为初始帧和最后一帧，并初始化一个初始化器。</li>
<li>第二次进入该方法的时候，已经有初始化器了。 </li>
<li>利用ORB匹配器，对当前帧和初始帧进行匹配，对应关系小于100个时失败。 </li>
<li>利用八点法的对极约束，启动两个线程分别计算单应矩阵和基础矩阵，并通过score判断用单应矩阵回复运动轨迹还是使用基础矩阵回复运动轨迹。 </li>
<li>将初始帧和当前帧创建为关键帧，并创建地图点MapPoint </li>
<li>通过全局BundleAdjustment优化相机位姿和关键点坐标 </li>
<li>设置单位深度并缩放初试基线和地图点。 </li>
<li>其他变量的初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::MonocularInitialization()<span class="comment">//单目初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果单目初始器还没有被创建，则创建单目初始器</span></span><br><span class="line">    <span class="keyword">if</span>(!mpInitializer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set Reference Frame</span></span><br><span class="line">        <span class="comment">// 单目初始帧的特征点数必须大于100</span></span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvKeys.size()&gt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤1：得到用于初始化的第一帧，初始化需要两帧</span></span><br><span class="line">            mInitialFrame = Frame(mCurrentFrame);</span><br><span class="line">            <span class="comment">// 记录最后的一帧</span></span><br><span class="line">            mLastFrame = Frame(mCurrentFrame);</span><br><span class="line">            <span class="comment">// mvbPrevMatched最大的情况就是所有特征点都被跟踪上</span></span><br><span class="line">            mvbPrevMatched.resize(mCurrentFrame.mvKeysUn.size());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.mvKeysUn.size(); i++)</span><br><span class="line">                mvbPrevMatched[i]=mCurrentFrame.mvKeysUn[i].pt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mpInitializer)</span><br><span class="line">                <span class="keyword">delete</span> mpInitializer;</span><br><span class="line">            <span class="comment">// 由当前帧构造初始器 sigma:1.0 iterations:200</span></span><br><span class="line">            mpInitializer =  <span class="keyword">new</span> Initializer(mCurrentFrame,<span class="number">1.0</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            fill(mvIniMatches.begin(),mvIniMatches.end(),<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//如果是第二次进入，已经创建了初始器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Try to initialize</span></span><br><span class="line">        <span class="comment">// 步骤2：如果当前帧特征点数大于100，则得到用于单目初始化的第二帧</span></span><br><span class="line">        <span class="comment">// 如果当前帧特征点太少，重新构造初始器</span></span><br><span class="line">        <span class="comment">// 因此只有连续两帧的特征点个数都大于100时，才能继续进行初始化过程</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)mCurrentFrame.mvKeys.size()&lt;=<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mpInitializer;</span><br><span class="line">            mpInitializer = <span class="keyword">static_cast</span>&lt;Initializer*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">            fill(mvIniMatches.begin(),mvIniMatches.end(),<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find correspondences</span></span><br><span class="line">        <span class="comment">// 步骤3：在mInitialFrame与mCurrentFrame中找匹配的特征点对</span></span><br><span class="line">        <span class="comment">// mvbPrevMatched为前一帧的特征点，存储了mInitialFrame中哪些点将进行接下来的匹配</span></span><br><span class="line">        <span class="comment">// mvIniMatches存储mInitialFrame,mCurrentFrame之间匹配的特征点</span></span><br><span class="line">        <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.9</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> nmatches = matcher.SearchForInitialization(mInitialFrame,mCurrentFrame,mvbPrevMatched,mvIniMatches,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if there are enough correspondences</span></span><br><span class="line">        <span class="comment">// 步骤4：如果初始化的两帧之间的匹配点太少，重新初始</span></span><br><span class="line">        <span class="keyword">if</span>(nmatches&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mpInitializer;</span><br><span class="line">            mpInitializer = <span class="keyword">static_cast</span>&lt;Initializer*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::Mat Rcw; <span class="comment">// Current Camera Rotation</span></span><br><span class="line">        cv::Mat tcw; <span class="comment">// Current Camera Translation</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbTriangulated; <span class="comment">// Triangulated Correspondences (mvIniMatches)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤5：通过H模型或F模型进行单目初始化，得到两帧间相对运动、初始MapPoints</span></span><br><span class="line">        <span class="keyword">if</span>(mpInitializer-&gt;Initialize(mCurrentFrame, mvIniMatches, Rcw, tcw, mvIniP3D, vbTriangulated))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤6：删除那些无法进行三角化的匹配点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=mvIniMatches.size(); i&lt;iend;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mvIniMatches[i]&gt;=<span class="number">0</span> &amp;&amp; !vbTriangulated[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    mvIniMatches[i]=<span class="number">-1</span>;</span><br><span class="line">                    nmatches--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set Frame Poses</span></span><br><span class="line">            <span class="comment">// 将初始化的第一帧作为世界坐标系，因此第一帧变换矩阵为单位矩阵</span></span><br><span class="line">            mInitialFrame.SetPose(cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F));</span><br><span class="line">            <span class="comment">// 由Rcw和tcw构造Tcw,并赋值给mTcw，mTcw为世界坐标系到该帧的变换矩阵</span></span><br><span class="line">            cv::Mat Tcw = cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F);</span><br><span class="line">            Rcw.copyTo(Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).colRange(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">            tcw.copyTo(Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).col(<span class="number">3</span>));</span><br><span class="line">            mCurrentFrame.SetPose(Tcw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤6：将三角化得到的3D点包装成MapPoints</span></span><br><span class="line">            <span class="comment">// Initialize函数会得到mvIniP3D，</span></span><br><span class="line">            <span class="comment">// mvIniP3D是cv::Point3f类型的一个容器，是个存放3D点的临时变量，</span></span><br><span class="line">            <span class="comment">// CreateInitialMapMonocular将3D点包装成MapPoint类型存入KeyFrame和Map中</span></span><br><span class="line">            CreateInitialMapMonocular();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="void-Tracking-CreateInitialMapMonocular"><a href="#void-Tracking-CreateInitialMapMonocular" class="headerlink" title="void Tracking::CreateInitialMapMonocular()"></a>void Tracking::CreateInitialMapMonocular()</h4><blockquote>
<ol>
<li>当第一次进入该方法的时候，没有先前的帧数据，将当前帧保存为初始帧和最后一帧，并初始化一个初始化器。</li>
<li>利用ORB匹配器，对当前帧和初始帧进行匹配，对应关系小于100个时失败。</li>
<li>利用八点法的对极约束，启动两个线程分别计算单应矩阵和基础矩阵，并通过score判断用单应矩阵&gt;回复运动轨迹还是使用基础矩阵回复运动轨迹。  </li>
<li>将初始帧和当前帧创建为关键帧，并创建地图点MapPoint </li>
<li>通过全局BundleAdjustment优化相机位姿和关键点坐标 </li>
<li>设置单位深度并缩放初试基线和地图点。  </li>
<li>其他变量的初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">void</span> Tracking::CreateInitialMapMonocular()</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="comment">// 创建两帧，一个为初始帧，一个为当前帧</span></span><br><span class="line">&gt;KeyFrame* pKFini = <span class="keyword">new</span> KeyFrame(mInitialFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">&gt;KeyFrame* pKFcur = <span class="keyword">new</span> KeyFrame(mCurrentFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">&gt;<span class="comment">// 步骤1：将初始关键帧的描述子转为BoW</span></span><br><span class="line">&gt;pKFini-&gt;ComputeBoW();</span><br><span class="line">&gt;<span class="comment">// 步骤2：将当前关键帧的描述子转为BoW</span></span><br><span class="line">&gt;pKFcur-&gt;ComputeBoW();</span><br><span class="line">&gt;<span class="comment">// Insert KFs in the map</span></span><br><span class="line">&gt;<span class="comment">// 步骤3：将关键帧插入到地图</span></span><br><span class="line">&gt;<span class="comment">// 凡是关键帧，都要插入地图</span></span><br><span class="line">&gt;mpMap-&gt;AddKeyFrame(pKFini);</span><br><span class="line">&gt;mpMap-&gt;AddKeyFrame(pKFcur);</span><br><span class="line">&gt;<span class="comment">// Create MapPoints and asscoiate to keyframes</span></span><br><span class="line">&gt;<span class="comment">// 步骤4：将3D点包装成MapPoints</span></span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;mvIniMatches.size();i++)<span class="comment">//遍历所有匹配</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span>(mvIniMatches[i]&lt;<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">//Create MapPoint.</span></span><br><span class="line">  cv::<span class="function">Mat <span class="title">worldPos</span><span class="params">(mvIniP3D[i])</span></span>;</span><br><span class="line">  <span class="comment">// 步骤4.1：用3D点构造MapPoint</span></span><br><span class="line">  MapPoint* pMP = <span class="keyword">new</span> MapPoint(worldPos,pKFcur,mpMap);</span><br><span class="line">  <span class="comment">// 步骤4.2：为该MapPoint添加属性：</span></span><br><span class="line">  <span class="comment">// a.观测到该MapPoint的关键帧</span></span><br><span class="line">  <span class="comment">// b.该MapPoint的描述子</span></span><br><span class="line">  <span class="comment">// c.该MapPoint的平均观测方向和深度范围</span></span><br><span class="line">  <span class="comment">// 步骤4.3：表示该KeyFrame的哪个特征点可以观测到哪个3D点</span></span><br><span class="line">pKFini-&gt;AddMapPoint(pMP,i);</span><br><span class="line">  pKFcur-&gt;AddMapPoint(pMP,mvIniMatches[i]);</span><br><span class="line">  <span class="comment">// a.表示该MapPoint可以被哪个KeyFrame的哪个特征点观测到</span></span><br><span class="line">  pMP-&gt;AddObservation(pKFini,i);</span><br><span class="line">  pMP-&gt;AddObservation(pKFcur,mvIniMatches[i]);</span><br><span class="line">  <span class="comment">// b.从众多观测到该MapPoint的特征点中挑选区分读最高的描述子</span></span><br><span class="line">  pMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line"> <span class="comment">// c.更新该MapPoint平均观测方向以及观测距离的范围</span></span><br><span class="line">  pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line">  <span class="comment">//Fill Current Frame structure</span></span><br><span class="line">  mCurrentFrame.mvpMapPoints[mvIniMatches[i]] = pMP;</span><br><span class="line">  mCurrentFrame.mvbOutlier[mvIniMatches[i]] = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//Add to Map</span></span><br><span class="line">  <span class="comment">// 步骤4.4：在地图中添加该MapPoint</span></span><br><span class="line">  mpMap-&gt;AddMapPoint(pMP);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// Update Connections</span></span><br><span class="line">&gt;<span class="comment">// 步骤5：更新关键帧间的连接关系</span></span><br><span class="line">&gt;<span class="comment">// 在3D点和关键帧之间建立边，每个边有一个权重，边的权重是该关键帧与当前帧公共3D点的个数</span></span><br><span class="line">&gt;pKFini-&gt;UpdateConnections();</span><br><span class="line">&gt;pKFcur-&gt;UpdateConnections();</span><br><span class="line">&gt;<span class="comment">// Bundle Adjustment</span></span><br><span class="line">&gt;<span class="built_in">cout</span> &lt;&lt; <span class="string">"New Map created with "</span> &lt;&lt; mpMap-&gt;MapPointsInMap() &lt;&lt; <span class="string">" points"</span> &lt;&lt; <span class="built_in">endl</span>；</span><br><span class="line">&gt;<span class="comment">// 步骤5：BA优化</span></span><br><span class="line">&gt;Optimizer::GlobalBundleAdjustemnt(mpMap,<span class="number">20</span>);</span><br><span class="line">&gt;<span class="comment">// Set median depth to 1</span></span><br><span class="line">&gt;<span class="comment">// 步骤6：!!!将MapPoints的中值深度归一化到1，并归一化两帧之间变换</span></span><br><span class="line">&gt;<span class="comment">// 评估关键帧场景深度，q=2表示中值</span></span><br><span class="line">&gt;<span class="keyword">float</span> medianDepth = pKFini-&gt;ComputeSceneMedianDepth(<span class="number">2</span>);</span><br><span class="line">&gt;<span class="keyword">float</span> invMedianDepth = <span class="number">1.0f</span>/medianDepth;</span><br><span class="line">&gt;<span class="keyword">if</span>(medianDepth&lt;<span class="number">0</span> || pKFcur-&gt;TrackedMapPoints(<span class="number">1</span>)&lt;<span class="number">100</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong initialization, reseting..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  Reset();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// Scale initial baseline</span></span><br><span class="line">&gt;cv::Mat Tc2w = pKFcur-&gt;GetPose();</span><br><span class="line">&gt;<span class="comment">// x/z y/z 将z归一化到1 </span></span><br><span class="line">&gt;Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>) = Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>)*invMedianDepth;</span><br><span class="line">&gt;pKFcur-&gt;SetPose(Tc2w);</span><br><span class="line">&gt;<span class="comment">// Scale point</span></span><br><span class="line">&gt;<span class="comment">// 把3D点的尺度也归一化到</span></span><br><span class="line">&gt;<span class="built_in">vector</span>&lt;MapPoint*&gt; vpAllMapPoints = pKFini-&gt;GetMapPointMatches();</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">size_t</span> iMP=<span class="number">0</span>; iMP&lt;vpAllMapPoints.size(); iMP++)</span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(vpAllMapPoints[iMP])</span><br><span class="line">  &#123;</span><br><span class="line">      MapPoint* pMP = vpAllMapPoints[iMP];</span><br><span class="line">      pMP-&gt;SetWorldPos(pMP-&gt;GetWorldPos()*invMedianDepth);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 这部分和SteroInitialization()相似</span></span><br><span class="line">&gt;mpLocalMapper-&gt;InsertKeyFrame(pKFini);</span><br><span class="line">&gt;mpLocalMapper-&gt;InsertKeyFrame(pKFcur);</span><br><span class="line">&gt;mCurrentFrame.SetPose(pKFcur-&gt;GetPose());</span><br><span class="line">&gt;mnLastKeyFrameId=mCurrentFrame.mnId;</span><br><span class="line">&gt;mpLastKeyFrame = pKFcur;</span><br><span class="line">&gt;mvpLocalKeyFrames.push_back(pKFcur)</span><br><span class="line">&gt;mvpLocalKeyFrames.push_back(pKFini);</span><br><span class="line">&gt;mvpLocalMapPoints=mpMap-&gt;GetAllMapPoints();</span><br><span class="line">&gt;mpReferenceKF = pKFcur;</span><br><span class="line">&gt;mCurrentFrame.mpReferenceKF = pKFcur;</span><br><span class="line">&gt;mLastFrame = Frame(mCurrentFrame);</span><br><span class="line">&gt;mpMap-&gt;SetReferenceMapPoints(mvpLocalMapPoints)</span><br><span class="line">&gt;mpMapDrawer-&gt;SetCurrentCameraPose(pKFcur-&gt;GetPose());</span><br><span class="line">&gt;mpMap-&gt;mvpKeyFrameOrigins.push_back(pKFini);</span><br><span class="line">&gt;mState=OK;<span class="comment">// 初始化成功，至此，初始化过程完成 </span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="跟踪部分"><a href="#跟踪部分" class="headerlink" title="跟踪部分"></a>跟踪部分</h2><h3 id="跟踪步骤1"><a href="#跟踪步骤1" class="headerlink" title="跟踪步骤1"></a>跟踪步骤1</h3><ul>
<li>局部地图激活(!mbOnlyTracking)：如果(mState==OK)，CheckReplacedInLastFrame()首先更新上一帧被替换的MapPoints，然后如果特征点匹配太少，需要匹配参考关键帧bOK = TrackReferenceKeyFrame()，否则根据匀速运动模型匹配bOK = TrackWithMotionModel()。特殊情况初始化跟踪失败需要重定位bOK = Relocalization();  </li>
<li>局部地图不工作，只跟踪当前地图中地图点：<blockquote>
<p>1.if :(mState==LOST)，需要重定位Relocalization()。<br>2.else: 当匹配特征点不够多，小于10个，使用运动模型和重定位计算两种相机位姿，如果重定位失败，保持VO结果，否则更相信重定位结果。</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span><span class="comment">//步骤2：跟踪</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// System is initialized. Track Frame.</span></span><br><span class="line">    <span class="comment">// bOK为临时变量，用于表示每个函数是否执行成功</span></span><br><span class="line">    <span class="keyword">bool</span> bOK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initial camera pose estimation using motion model or relocalization (if tracking is lost)</span></span><br><span class="line">    <span class="comment">// 在viewer中有个开关menuLocalizationMode，有它控制是否ActivateLocalizationMode，并最终管控mbOnlyTracking</span></span><br><span class="line">    <span class="comment">// mbOnlyTracking等于false表示正常VO模式（有地图更新），mbOnlyTracking等于true表示用户手动选择定位模式</span></span><br><span class="line">    <span class="keyword">if</span>(!mbOnlyTracking)<span class="comment">//mbOnlyTracking==false</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Local Mapping is activated. This is the normal behaviour, unless</span></span><br><span class="line">        <span class="comment">// you explicitly activate the "only tracking" mode.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常初始化成功</span></span><br><span class="line">        <span class="keyword">if</span>(mState==OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Local Mapping might have changed some MapPoints tracked in last frame</span></span><br><span class="line">            <span class="comment">// 检查并更新上一帧被替换的MapPoints</span></span><br><span class="line">            <span class="comment">// 更新Fuse函数和SearchAndFuse函数替换的MapPoints</span></span><br><span class="line">            CheckReplacedInLastFrame();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤2.1：跟踪上一帧或者参考帧或者重定位</span></span><br><span class="line">            <span class="comment">// 上一帧速度为0或当前帧与上一次重定位帧之间ID差大于2，跟踪关键帧</span></span><br><span class="line">            <span class="comment">// mnLastRelocFrameId上一次重定位的那一帧</span></span><br><span class="line">            <span class="keyword">if</span>(mVelocity.empty() || mCurrentFrame.mnId&lt;mnLastRelocFrameId+<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将上一帧的位姿作为当前帧的初始位姿</span></span><br><span class="line">                <span class="comment">// 通过BoW的方式在参考帧中找当前帧特征点的匹配点</span></span><br><span class="line">                <span class="comment">// 优化每个特征点都对应3D点重投影误差即可得到位姿</span></span><br><span class="line">                bOK = TrackReferenceKeyFrame();<span class="comment">//跟踪参考帧</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据恒速模型设定当前帧的初始位姿</span></span><br><span class="line">                <span class="comment">// 通过投影的方式在参考帧中找当前帧特征点的匹配点</span></span><br><span class="line">                <span class="comment">// 优化每个特征点所对应3D点的投影误差即可得到位姿</span></span><br><span class="line">                <span class="comment">// 应该只要mVelocity不为空，就优先选择TrackWithMotionModel</span></span><br><span class="line">                bOK = TrackWithMotionModel();<span class="comment">//根据固定运动速度模型预测当前帧的位姿</span></span><br><span class="line">                <span class="keyword">if</span>(!bOK)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TrackReferenceKeyFrame是跟踪参考帧，不能根据固定运动速度模型预测当前帧的位姿态，通过bow加速匹配（SearchByBow）</span></span><br><span class="line">                <span class="comment">// 最后通过优化得到优化后的位姿</span></span><br><span class="line">                    bOK = TrackReferenceKeyFrame();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//初始化失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// BOW搜索，PnP求解位姿</span></span><br><span class="line">            bOK = Relocalization();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//没有激活局部地图，只进行跟踪tracking</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Localization Mode: Local Mapping is deactivated</span></span><br><span class="line">        <span class="comment">// 步骤2.1：跟踪上一帧或者参考帧或者重定位</span></span><br><span class="line">        <span class="comment">// tracking跟丢了</span></span><br><span class="line">        <span class="keyword">if</span>(mState==LOST)</span><br><span class="line">        &#123;</span><br><span class="line">            bOK = Relocalization();<span class="comment">//判断重定位成功与否标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// mbVO是mbOnlyTracking为true时的才有的一个变量</span></span><br><span class="line">            <span class="comment">// mbVO为false表示此帧匹配了很多的MapPoints，跟踪很正常，</span></span><br><span class="line">            <span class="comment">// mbVO为true表明此帧匹配了很少的MapPoints，少于10个，要跪的节奏</span></span><br><span class="line">            <span class="keyword">if</span>(!mbVO)<span class="comment">//跟踪正常, mbVO为false则表明此帧匹配了很多的3D map点，非常好</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// In last frame we tracked enough MapPoints in the map</span></span><br><span class="line">                <span class="keyword">if</span>(!mVelocity.empty())<span class="comment">//上一帧有速度，跟踪模型</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bOK = TrackWithMotionModel();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//上一帧没速度，跟踪关键帧</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bOK = TrackReferenceKeyFrame();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//特征点不够多,小于10个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// In last frame we tracked mainly "visual odometry" points.</span></span><br><span class="line">                <span class="comment">// We compute two camera poses, one from motion model and one doing relocalization.</span></span><br><span class="line">                <span class="comment">// If relocalization is sucessfull we choose that solution, otherwise we retain the "visual odometry" solution.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 先使用运动模型和重定位计算两种相机位姿，如果重定位失败，保持VO结果</span></span><br><span class="line">                    <span class="comment">// mbVO为1，则表明此帧匹配了很少的3D map点，少于10个，要跪的节奏，既做跟踪又做定位</span></span><br><span class="line">                <span class="keyword">bool</span> bOKMM = <span class="literal">false</span>;<span class="comment">//运动模型是否成功判断标志</span></span><br><span class="line">                <span class="keyword">bool</span> bOKReloc = <span class="literal">false</span>;<span class="comment">//重定位是否成功判断标志</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMPsMM;<span class="comment">//记录地图点</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbOutMM;<span class="comment">//记录外点</span></span><br><span class="line">                cv::Mat TcwMM;<span class="comment">//变换矩阵</span></span><br><span class="line">                <span class="keyword">if</span>(!mVelocity.empty())<span class="comment">//有速度</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bOKMM = TrackWithMotionModel();<span class="comment">//用运动模型追踪</span></span><br><span class="line">                    vpMPsMM = mCurrentFrame.mvpMapPoints;<span class="comment">//记录地图点</span></span><br><span class="line">                    vbOutMM = mCurrentFrame.mvbOutlier;<span class="comment">//记录外点</span></span><br><span class="line">                    TcwMM = mCurrentFrame.mTcw.clone();<span class="comment">//当前帧的变换矩阵</span></span><br><span class="line">                &#125;</span><br><span class="line">                bOKReloc = Relocalization();<span class="comment">//用重定位</span></span><br><span class="line">                <span class="comment">// 重定位没有成功，但是运动模型跟踪成功</span></span><br><span class="line">                <span class="keyword">if</span>(bOKMM &amp;&amp; !bOKReloc)</span><br><span class="line">                &#123;</span><br><span class="line">                    mCurrentFrame.SetPose(TcwMM);</span><br><span class="line">                    mCurrentFrame.mvpMapPoints = vpMPsMM;</span><br><span class="line">                    mCurrentFrame.mvbOutlier = vbOutMM;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(mbVO)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 更新当前帧的MapPoints被观测程度</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i] &amp;&amp; !mCurrentFrame.mvbOutlier[i])</span><br><span class="line">                            &#123;</span><br><span class="line">                                mCurrentFrame.mvpMapPoints[i]-&gt;IncreaseFound();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(bOKReloc)<span class="comment">// 只要重定位成功整个跟踪过程正常进行（定位与跟踪，更相信重定位）</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mbVO = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bOK = bOKReloc || bOKMM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 将最新的关键帧作为reference frame</span></span><br><span class="line">    mCurrentFrame.mpReferenceKF = mpReferenceKF;</span><br></pre></td></tr></table></figure>
<h4 id="void-Tracking-CheckReplacedInLastFrame"><a href="#void-Tracking-CheckReplacedInLastFrame" class="headerlink" title="void Tracking::CheckReplacedInLastFrame()"></a>void Tracking::CheckReplacedInLastFrame()</h4><p>ocal Mapping线程可能会将关键帧中某些MapPoints进行替换，由于tracking中需要用到mLastFrame，这里检查并更新上一帧中被替换的MapPoints</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::CreateInitialMapMonocular()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create KeyFrames</span></span><br><span class="line">    <span class="comment">// 创建两帧，一个为初始帧，一个为当前帧</span></span><br><span class="line">    KeyFrame* pKFini = <span class="keyword">new</span> KeyFrame(mInitialFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">    KeyFrame* pKFcur = <span class="keyword">new</span> KeyFrame(mCurrentFrame,mpMap,mpKeyFrameDB);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：将初始关键帧的描述子转为BoW</span></span><br><span class="line">    pKFini-&gt;ComputeBoW();</span><br><span class="line">    <span class="comment">// 步骤2：将当前关键帧的描述子转为BoW</span></span><br><span class="line">    pKFcur-&gt;ComputeBoW();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert KFs in the map</span></span><br><span class="line">    <span class="comment">// 步骤3：将关键帧插入到地图</span></span><br><span class="line">    <span class="comment">// 凡是关键帧，都要插入地图</span></span><br><span class="line">    mpMap-&gt;AddKeyFrame(pKFini);</span><br><span class="line">    mpMap-&gt;AddKeyFrame(pKFcur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create MapPoints and asscoiate to keyframes</span></span><br><span class="line">    <span class="comment">// 步骤4：将3D点包装成MapPoints</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;mvIniMatches.size();i++)<span class="comment">//遍历所有匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mvIniMatches[i]&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create MapPoint.</span></span><br><span class="line">        cv::<span class="function">Mat <span class="title">worldPos</span><span class="params">(mvIniP3D[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤4.1：用3D点构造MapPoint</span></span><br><span class="line">        MapPoint* pMP = <span class="keyword">new</span> MapPoint(worldPos,pKFcur,mpMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤4.2：为该MapPoint添加属性：</span></span><br><span class="line">        <span class="comment">// a.观测到该MapPoint的关键帧</span></span><br><span class="line">        <span class="comment">// b.该MapPoint的描述子</span></span><br><span class="line">        <span class="comment">// c.该MapPoint的平均观测方向和深度范围</span></span><br><span class="line">        <span class="comment">// 步骤4.3：表示该KeyFrame的哪个特征点可以观测到哪个3D点</span></span><br><span class="line">        pKFini-&gt;AddMapPoint(pMP,i);</span><br><span class="line">        pKFcur-&gt;AddMapPoint(pMP,mvIniMatches[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a.表示该MapPoint可以被哪个KeyFrame的哪个特征点观测到</span></span><br><span class="line">        pMP-&gt;AddObservation(pKFini,i);</span><br><span class="line">        pMP-&gt;AddObservation(pKFcur,mvIniMatches[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.从众多观测到该MapPoint的特征点中挑选区分读最高的描述子</span></span><br><span class="line">        pMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line">        <span class="comment">// c.更新该MapPoint平均观测方向以及观测距离的范围</span></span><br><span class="line">        pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Fill Current Frame structure</span></span><br><span class="line">        mCurrentFrame.mvpMapPoints[mvIniMatches[i]] = pMP;</span><br><span class="line">        mCurrentFrame.mvbOutlier[mvIniMatches[i]] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Add to Map</span></span><br><span class="line">        <span class="comment">// 步骤4.4：在地图中添加该MapPoint</span></span><br><span class="line">        mpMap-&gt;AddMapPoint(pMP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update Connections</span></span><br><span class="line">    <span class="comment">// 步骤5：更新关键帧间的连接关系</span></span><br><span class="line">    <span class="comment">// 在3D点和关键帧之间建立边，每个边有一个权重，边的权重是该关键帧与当前帧公共3D点的个数</span></span><br><span class="line">    pKFini-&gt;UpdateConnections();</span><br><span class="line">    pKFcur-&gt;UpdateConnections();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bundle Adjustment</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"New Map created with "</span> &lt;&lt; mpMap-&gt;MapPointsInMap() &lt;&lt; <span class="string">" points"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 步骤5：BA优化</span></span><br><span class="line">    Optimizer::GlobalBundleAdjustemnt(mpMap,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set median depth to 1</span></span><br><span class="line">    <span class="comment">// 步骤6：!!!将MapPoints的中值深度归一化到1，并归一化两帧之间变换</span></span><br><span class="line">    <span class="comment">// 评估关键帧场景深度，q=2表示中值</span></span><br><span class="line">    <span class="keyword">float</span> medianDepth = pKFini-&gt;ComputeSceneMedianDepth(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">float</span> invMedianDepth = <span class="number">1.0f</span>/medianDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(medianDepth&lt;<span class="number">0</span> || pKFcur-&gt;TrackedMapPoints(<span class="number">1</span>)&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong initialization, reseting..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Reset();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale initial baseline</span></span><br><span class="line">    cv::Mat Tc2w = pKFcur-&gt;GetPose();</span><br><span class="line">    <span class="comment">// x/z y/z 将z归一化到1</span></span><br><span class="line">    Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>) = Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>)*invMedianDepth;</span><br><span class="line">    pKFcur-&gt;SetPose(Tc2w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale points</span></span><br><span class="line">    <span class="comment">// 把3D点的尺度也归一化到</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpAllMapPoints = pKFini-&gt;GetMapPointMatches();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> iMP=<span class="number">0</span>; iMP&lt;vpAllMapPoints.size(); iMP++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vpAllMapPoints[iMP])</span><br><span class="line">        &#123;</span><br><span class="line">            MapPoint* pMP = vpAllMapPoints[iMP];</span><br><span class="line">            pMP-&gt;SetWorldPos(pMP-&gt;GetWorldPos()*invMedianDepth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部分和SteroInitialization()相似</span></span><br><span class="line">    mpLocalMapper-&gt;InsertKeyFrame(pKFini);</span><br><span class="line">    mpLocalMapper-&gt;InsertKeyFrame(pKFcur);</span><br><span class="line"></span><br><span class="line">    mCurrentFrame.SetPose(pKFcur-&gt;GetPose());</span><br><span class="line">    mnLastKeyFrameId=mCurrentFrame.mnId;</span><br><span class="line">    mpLastKeyFrame = pKFcur;</span><br><span class="line"></span><br><span class="line">    mvpLocalKeyFrames.push_back(pKFcur);</span><br><span class="line">    mvpLocalKeyFrames.push_back(pKFini);</span><br><span class="line">    mvpLocalMapPoints=mpMap-&gt;GetAllMapPoints();</span><br><span class="line">    mpReferenceKF = pKFcur;</span><br><span class="line">    mCurrentFrame.mpReferenceKF = pKFcur;</span><br><span class="line"></span><br><span class="line">    mLastFrame = Frame(mCurrentFrame);</span><br><span class="line"></span><br><span class="line">    mpMap-&gt;SetReferenceMapPoints(mvpLocalMapPoints);</span><br><span class="line"></span><br><span class="line">    mpMapDrawer-&gt;SetCurrentCameraPose(pKFcur-&gt;GetPose());</span><br><span class="line"></span><br><span class="line">    mpMap-&gt;mvpKeyFrameOrigins.push_back(pKFini);</span><br><span class="line"></span><br><span class="line">    mState=OK;<span class="comment">// 初始化成功，至此，初始化过程完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-TrackReferenceKeyFrame"><a href="#bool-Tracking-TrackReferenceKeyFrame" class="headerlink" title="bool Tracking::TrackReferenceKeyFrame()"></a>bool Tracking::TrackReferenceKeyFrame()</h4><p>关键帧中查找BOW相近的帧，进行匹配优化位姿</p>
<ul>
<li>1.按照关键帧进行Track的方法和运动模式恢复相机运动位姿的方法接近。首先求解当前帧的BOW向量。 </li>
<li>2.再搜索当前帧和关键帧之间的关键点匹配关系，如果这个匹配关系小于15对的话，就Track失败了。 </li>
<li>3.接着将当前帧的位置假定到上一帧的位置那里 </li>
<li>4.并通过最小二乘法优化相机的位姿。 </li>
<li>5.最后依然是抛弃无用的杂点，当match数大于等于10的时候，返回true成功。 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::TrackReferenceKeyFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compute Bag of Words vector</span></span><br><span class="line">    <span class="comment">//mCurrentFrame.ComputeBoW()将当前帧的描述子转为BOW向量，加块匹配速度</span></span><br><span class="line">    mCurrentFrame.ComputeBoW();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We perform first an ORB matching with the reference keyframe</span></span><br><span class="line">    <span class="comment">// If enough matches are found we setup a PnP solver</span></span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.7</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPointMatches;</span><br><span class="line">    <span class="comment">//matcher.SearchByBoW()通过特征点的BoW加快当前帧与参考帧之间的特征点匹配</span></span><br><span class="line">    <span class="keyword">int</span> nmatches = matcher.SearchByBoW(mpReferenceKF,mCurrentFrame,vpMapPointMatches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nmatches&lt;<span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    mCurrentFrame.mvpMapPoints = vpMapPointMatches;</span><br><span class="line">    <span class="comment">//mCurrentFrame.SetPose(mLastFrame.mTcw)将上一帧的位姿态作为当前帧位姿的初始值</span></span><br><span class="line">    mCurrentFrame.SetPose(mLastFrame.mTcw);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PoseOptimization通过优化3D-2D的重投影误差来获得位姿</span></span><br><span class="line">    Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discard outliers</span></span><br><span class="line">    <span class="comment">//剔除优化后的outlier匹配点（MapPoints）</span></span><br><span class="line">    <span class="keyword">int</span> nmatchesMap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[i])</span><br><span class="line">            &#123;</span><br><span class="line">                MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line"></span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">                mCurrentFrame.mvbOutlier[i]=<span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mbTrackInView = <span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mnLastFrameSeen = mCurrentFrame.mnId;</span><br><span class="line">                nmatches--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)</span><br><span class="line">                nmatchesMap++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nmatchesMap&gt;=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-TrackWithMotionModel"><a href="#bool-Tracking-TrackWithMotionModel" class="headerlink" title="bool Tracking::TrackWithMotionModel()"></a>bool Tracking::TrackWithMotionModel()</h4><p>假设匀速运动，用上一帧位姿和速度估计当前帧位姿。方法：上一帧地图点投影到当前帧，完成匹配。</p>
<ul>
<li><p>1.先通过上一帧的位姿和速度预测当前帧相机的位姿</p>
</li>
<li><p>2.通过PnP方法估计相机位姿，在将上一帧的地图点投影到当前固定大小范围的帧平面上，如果匹配点少，那么扩大两倍的采点范围。</p>
</li>
<li><p>3.然后进行一次BA算法，通过最小二乘法优化相机的位姿。</p>
</li>
<li><p>4.优化位姿之后，对当前帧的关键点和地图点，抛弃无用的杂点，剩下的点供下一次操作使用。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::TrackWithMotionModel()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.9</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Update last frame pose according to its reference keyframe</span></span><br><span class="line">    <span class="comment">// Create "visual odometry" points</span></span><br><span class="line">    <span class="comment">// 步骤1：对于双目或rgbd摄像头，根据深度值为上一关键帧生成新的MapPoints</span></span><br><span class="line">    <span class="comment">// （跟踪过程中需要将当前帧与上一帧进行特征点匹配，将上一帧的MapPoints投影到当前帧可以缩小匹配范围）</span></span><br><span class="line">    <span class="comment">// 在跟踪过程中，去除outlier的MapPoint，如果不及时增加MapPoint会逐渐减少</span></span><br><span class="line">    <span class="comment">// 这个函数的功能就是补充增加RGBD和双目相机上一帧的MapPoints数</span></span><br><span class="line">    UpdateLastFrame();</span><br><span class="line">    <span class="comment">// 根据Const Velocity Model(认为这两帧之间的相对运动和之前两帧间相对运动相同)估计当前帧的位姿</span></span><br><span class="line">    mCurrentFrame.SetPose(mVelocity*mLastFrame.mTcw);<span class="comment">//当前帧位置等于mVelocity*mLastFrame.mTcw</span></span><br><span class="line"> </span><br><span class="line">    fill(mCurrentFrame.mvpMapPoints.begin(),mCurrentFrame.mvpMapPoints.end(),<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// Project points seen in previous frame</span></span><br><span class="line">    <span class="keyword">int</span> th;</span><br><span class="line">    <span class="keyword">if</span>(mSensor!=System::STEREO)<span class="comment">//非双目搜索范围系数设为15</span></span><br><span class="line">        th=<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        th=<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：根据匀速度模型进行对上一帧的MapPoints进行跟踪</span></span><br><span class="line">    <span class="comment">// 根据上一帧特征点对应的3D点投影的位置缩小特征点匹配范围</span></span><br><span class="line">    <span class="keyword">int</span> nmatches = matcher.SearchByProjection(mCurrentFrame,mLastFrame,th,mSensor==System::MONOCULAR);</span><br><span class="line">    <span class="comment">// If few matches, uses a wider window search</span></span><br><span class="line">    <span class="comment">// 如果跟踪的点少，则扩大搜索半径再来一次</span></span><br><span class="line">    <span class="keyword">if</span>(nmatches&lt;<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fill(mCurrentFrame.mvpMapPoints.begin(),mCurrentFrame.mvpMapPoints.end(),<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>));</span><br><span class="line">        nmatches = matcher.SearchByProjection(mCurrentFrame,mLastFrame,<span class="number">2</span>*th,mSensor==System::MONOCULAR); <span class="comment">// 2*th</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(nmatches&lt;<span class="number">20</span>)<span class="comment">//如果匹配点少于20，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Optimize frame pose with all matches</span></span><br><span class="line">    <span class="comment">// 步骤3：优化位姿</span></span><br><span class="line">    Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">    <span class="comment">// Discard outliers</span></span><br><span class="line">    <span class="comment">// 步骤4：优化位姿后剔除outlier的mvpMapPoints</span></span><br><span class="line">    <span class="keyword">int</span> nmatchesMap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[i])</span><br><span class="line">            &#123;</span><br><span class="line">                MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">                mCurrentFrame.mvbOutlier[i]=<span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mbTrackInView = <span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mnLastFrameSeen = mCurrentFrame.mnId;</span><br><span class="line">                nmatches--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)</span><br><span class="line">                nmatchesMap++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(mbOnlyTracking)<span class="comment">//如果仅跟踪</span></span><br><span class="line">    &#123;</span><br><span class="line">        mbVO = nmatchesMap&lt;<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> nmatches&gt;<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nmatchesMap&gt;=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="void-Tracking-UpdateLastFrame"><a href="#void-Tracking-UpdateLastFrame" class="headerlink" title="void Tracking::UpdateLastFrame()"></a>void Tracking::UpdateLastFrame()</h5><ul>
<li>1.更新最近一帧的位姿</li>
<li>2.对于双目或rgbd摄像头，为上一帧临时生成新的MapPoints,注意这些MapPoints不加入到Map中，在tracking的最后会删除,跟踪过程中需要将将上一帧的MapPoints投影到当前帧可以缩小匹配范围，加快当前帧与上一帧进行特征点匹配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::UpdateLastFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Update pose according to reference keyframe</span></span><br><span class="line">    <span class="comment">// 步骤1：更新最近一帧的位姿</span></span><br><span class="line">    KeyFrame* pRef = mLastFrame.mpReferenceKF;</span><br><span class="line">    cv::Mat Tlr = mlRelativeFramePoses.back();</span><br><span class="line"> </span><br><span class="line">    mLastFrame.SetPose(Tlr*pRef-&gt;GetPose()); <span class="comment">// Tlr*Trw = Tlw 1:last r:reference w:world</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果上一帧为关键帧，或者单目的情况，则退出</span></span><br><span class="line">    <span class="keyword">if</span>(mnLastKeyFrameId==mLastFrame.mnId || mSensor==System::MONOCULAR)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：对于双目或rgbd摄像头，为上一帧临时生成新的MapPoints</span></span><br><span class="line">    <span class="comment">// 注意这些MapPoints不加入到Map中，在tracking的最后会删除</span></span><br><span class="line">    <span class="comment">// 跟踪过程中需要将将上一帧的MapPoints投影到当前帧可以缩小匹配范围，加快当前帧与上一帧进行特征点匹配</span></span><br><span class="line">    <span class="comment">// Create "visual odometry" MapPoints</span></span><br><span class="line">    <span class="comment">// We sort points according to their measured depth by the stereo/RGB-D sensor</span></span><br><span class="line">    <span class="comment">// 步骤2.1：得到上一帧有深度值的特征点</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">float</span>,<span class="keyword">int</span>&gt; &gt; vDepthIdx;</span><br><span class="line">    vDepthIdx.reserve(mLastFrame.N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mLastFrame.N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> z = mLastFrame.mvDepth[i];</span><br><span class="line">        <span class="keyword">if</span>(z&gt;<span class="number">0</span>)<span class="comment">//如果深度大于0</span></span><br><span class="line">        &#123;</span><br><span class="line">            vDepthIdx.push_back(make_pair(z,i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(vDepthIdx.empty())<span class="comment">//如果没深度值则退出</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 步骤2.2：按照深度从小到大排序</span></span><br><span class="line">    sort(vDepthIdx.begin(),vDepthIdx.end());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We insert all close points (depth&lt;mThDepth)</span></span><br><span class="line">    <span class="comment">// If less than 100 close points, we insert the 100 closest ones.</span></span><br><span class="line">    <span class="comment">// 步骤2.3：将距离比较近的点包装成MapPoints</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> nPoints = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>; j&lt;vDepthIdx.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = vDepthIdx[j].second;</span><br><span class="line">        <span class="keyword">bool</span> bCreateNew = <span class="literal">false</span>;</span><br><span class="line">        MapPoint* pMP = mLastFrame.mvpMapPoints[i];</span><br><span class="line">        <span class="keyword">if</span>(!pMP)</span><br><span class="line">            bCreateNew = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pMP-&gt;Observations()&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bCreateNew = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(bCreateNew)</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这些生成MapPoints后并没有通过：</span></span><br><span class="line">            <span class="comment">// a.AddMapPoint、</span></span><br><span class="line">            <span class="comment">// b.AddObservation、</span></span><br><span class="line">            <span class="comment">// c.ComputeDistinctiveDescriptors、</span></span><br><span class="line">            <span class="comment">// d.UpdateNormalAndDepth添加属性，</span></span><br><span class="line">            <span class="comment">// 这些MapPoint仅仅为了提高双目和RGBD的跟踪成功率</span></span><br><span class="line">            cv::Mat x3D = mLastFrame.UnprojectStereo(i);</span><br><span class="line">            MapPoint* pNewMP = <span class="keyword">new</span> MapPoint(x3D,mpMap,&amp;mLastFrame,i);</span><br><span class="line">            mLastFrame.mvpMapPoints[i]=pNewMP; <span class="comment">// 添加新的MapPoint</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 标记为临时添加的MapPoint，之后在CreateNewKeyFrame之前会全部删除</span></span><br><span class="line">            mlpTemporalPoints.push_back(pNewMP);</span><br><span class="line">            nPoints++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nPoints++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vDepthIdx[j].first&gt;mThDepth &amp;&amp; nPoints&gt;<span class="number">100</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-Relocalization"><a href="#bool-Tracking-Relocalization" class="headerlink" title="bool Tracking::Relocalization()"></a>bool Tracking::Relocalization()</h4><p>重定位，从之前的关键帧中找出与当前帧之间拥有充足匹配点的候选帧，利用Ransac迭代，通过PnP求解位姿。</p>
<blockquote>
<ol>
<li>先计算当前帧的BOW值，并从关键帧数据库中查找候选的匹配关键帧</li>
<li>构建PnP求解器，标记杂点，准备好每个关键帧和当前帧的匹配点集</li>
<li>用PnP算法求解位姿，进行若干次P4P Ransac迭代，并使用非线性最小二乘优化，直到发现一个有充足inliers支持的相机位置</li>
<li>返回成功或失败</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::Relocalization()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compute Bag of Words Vector</span></span><br><span class="line">    <span class="comment">// 步骤1：计算当前帧特征点的Bow映射</span></span><br><span class="line">    mCurrentFrame.ComputeBoW();</span><br><span class="line">    <span class="comment">// Relocalization is performed when tracking is lost当跟踪丢失执行重定位</span></span><br><span class="line">    <span class="comment">// Track Lost: Query KeyFrame Database for keyframe candidates for relocalisation</span></span><br><span class="line">    <span class="comment">// 步骤2：找到与当前帧相似的候选关键帧</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpCandidateKFs = mpKeyFrameDB-&gt;DetectRelocalizationCandidates(&amp;mCurrentFrame);</span><br><span class="line">    <span class="keyword">if</span>(vpCandidateKFs.empty())<span class="comment">//如果没找到候选关键帧，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nKFs = vpCandidateKFs.size();<span class="comment">//候选关键帧个数</span></span><br><span class="line">    <span class="comment">// We perform first an ORB matching with each candidat</span></span><br><span class="line">    <span class="comment">// If enough matches are found we setup a PnP solver</span></span><br><span class="line">    <span class="comment">//我们首先执行与每个候选匹配的ORB匹配</span></span><br><span class="line">    <span class="comment">//如果找到足够的匹配，我们设置一个PNP解算器</span></span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.75</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PnPsolver*&gt; vpPnPsolvers;</span><br><span class="line">    vpPnPsolvers.resize(nKFs);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;MapPoint*&gt; &gt; vvpMapPointMatches;</span><br><span class="line">    vvpMapPointMatches.resize(nKFs);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbDiscarded;</span><br><span class="line">    vbDiscarded.resize(nKFs);</span><br><span class="line">    <span class="keyword">int</span> nCandidates=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nKFs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = vpCandidateKFs[i];</span><br><span class="line">        <span class="keyword">if</span>(pKF-&gt;isBad())</span><br><span class="line">            vbDiscarded[i] = <span class="literal">true</span>;<span class="comment">//去除不好的候选关键帧</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤3：通过BoW进行匹配</span></span><br><span class="line">            <span class="keyword">int</span> nmatches = matcher.SearchByBoW(pKF,mCurrentFrame,vvpMapPointMatches[i]);</span><br><span class="line">            <span class="keyword">if</span>(nmatches&lt;<span class="number">15</span>)<span class="comment">//如果匹配点小于15剔除</span></span><br><span class="line">            &#123;</span><br><span class="line">                vbDiscarded[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//用pnp求解</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 初始化PnPsolver</span></span><br><span class="line">                PnPsolver* pSolver = <span class="keyword">new</span> PnPsolver(mCurrentFrame,vvpMapPointMatches[i]);</span><br><span class="line">                pSolver-&gt;SetRansacParameters(<span class="number">0.99</span>,<span class="number">10</span>,<span class="number">300</span>,<span class="number">4</span>,<span class="number">0.5</span>,<span class="number">5.991</span>);</span><br><span class="line">                vpPnPsolvers[i] = pSolver;</span><br><span class="line">                nCandidates++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Alternatively perform some iterations of P4P RANSAC可选地执行P4P RANSAC的一些迭代</span></span><br><span class="line">    <span class="comment">// Until we found a camera pose supported by enough inliers直到早到符合很多内点的相机位置</span></span><br><span class="line">    <span class="keyword">bool</span> bMatch = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher2</span><span class="params">(<span class="number">0.9</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(nCandidates&gt;<span class="number">0</span> &amp;&amp; !bMatch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nKFs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vbDiscarded[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Perform 5 Ransac Iterations</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbInliers;</span><br><span class="line">            <span class="keyword">int</span> nInliers;</span><br><span class="line">            <span class="keyword">bool</span> bNoMore;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 步骤4：通过EPnP算法估计姿态</span></span><br><span class="line">            PnPsolver* pSolver = vpPnPsolvers[i];</span><br><span class="line">            cv::Mat Tcw = pSolver-&gt;iterate(<span class="number">5</span>,bNoMore,vbInliers,nInliers);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// If Ransac reachs max. iterations discard keyframe</span></span><br><span class="line">            <span class="keyword">if</span>(bNoMore)</span><br><span class="line">            &#123;</span><br><span class="line">                vbDiscarded[i]=<span class="literal">true</span>;</span><br><span class="line">                nCandidates--;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// If a Camera Pose is computed, optimize</span></span><br><span class="line">            <span class="keyword">if</span>(!Tcw.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                Tcw.copyTo(mCurrentFrame.mTcw);</span><br><span class="line">                <span class="built_in">set</span>&lt;MapPoint*&gt; sFound;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> np = vbInliers.size();<span class="comment">//内点个数</span></span><br><span class="line"> </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;np; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(vbInliers[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        mCurrentFrame.mvpMapPoints[j]=vvpMapPointMatches[i][j];</span><br><span class="line">                        sFound.insert(vvpMapPointMatches[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        mCurrentFrame.mvpMapPoints[j]=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 步骤5：通过PoseOptimization对姿态进行优化求解</span></span><br><span class="line"> </span><br><span class="line">                <span class="keyword">int</span> nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">                <span class="keyword">if</span>(nGood&lt;<span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> io =<span class="number">0</span>; io&lt;mCurrentFrame.N; io++)</span><br><span class="line">                    <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[io])</span><br><span class="line">                        mCurrentFrame.mvpMapPoints[io]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// If few inliers, search by projection in a coarse window and optimize again</span></span><br><span class="line">                <span class="comment">// 步骤6：如果内点较少，则通过投影的方式对之前未匹配的点进行匹配，再进行优化求解</span></span><br><span class="line">                <span class="keyword">if</span>(nGood&lt;<span class="number">50</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">int</span> nadditional =matcher2.SearchByProjection(mCurrentFrame,vpCandidateKFs[i],sFound,<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">if</span>(nadditional+nGood&gt;=<span class="number">50</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);<span class="comment">//优化</span></span><br><span class="line"> </span><br><span class="line">                        <span class="comment">// If many inliers but still not enough, search by projection again in a narrower window</span></span><br><span class="line"><span class="comment">//如果许多内点仍然不够，则在较窄的窗口中再次用投影搜索</span></span><br><span class="line">                        <span class="comment">// the camera has been already optimized with many points</span></span><br><span class="line">                        <span class="keyword">if</span>(nGood&gt;<span class="number">30</span> &amp;&amp; nGood&lt;<span class="number">50</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            sFound.clear();</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> ip =<span class="number">0</span>; ip&lt;mCurrentFrame.N; ip++)</span><br><span class="line">                                <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[ip])</span><br><span class="line">                                    sFound.insert(mCurrentFrame.mvpMapPoints[ip]);</span><br><span class="line">                            nadditional =matcher2.SearchByProjection(mCurrentFrame,vpCandidateKFs[i],sFound,<span class="number">3</span>,<span class="number">64</span>);</span><br><span class="line">                            <span class="comment">// Final optimization</span></span><br><span class="line">                            <span class="keyword">if</span>(nGood+nadditional&gt;=<span class="number">50</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> io =<span class="number">0</span>; io&lt;mCurrentFrame.N; io++)</span><br><span class="line">                                    <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[io])</span><br><span class="line">                                       mCurrentFrame.mvpMapPoints[io]=<span class="literal">NULL</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// If the pose is supported by enough inliers stop ransacs and continue</span></span><br><span class="line">                <span class="keyword">if</span>(nGood&gt;=<span class="number">50</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bMatch = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!bMatch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mnLastRelocFrameId = mCurrentFrame.mnId;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跟踪步骤2"><a href="#跟踪步骤2" class="headerlink" title="跟踪步骤2"></a>跟踪步骤2</h3><ul>
<li>1.如果局部地图激活(!mbOnlyTracking)跟踪局部地图bOK = TrackLocalMap()，否则在重定位后特征点足够(bOK &amp;&amp; !mbVO)也会跟踪局部地图bOK = TrackLocalMap()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we have an initial estimation of the camera pose and matching. Track the local map.</span></span><br><span class="line"><span class="keyword">if</span>(!mbOnlyTracking)<span class="comment">//不是只跟踪还插入关键帧，局部地图工作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bOK)</span><br><span class="line">        bOK = TrackLocalMap();<span class="comment">//跟踪局部地图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// mbVO true means that there are few matches to MapPoints in the map. We cannot retrieve</span></span><br><span class="line">    <span class="comment">// a local map and therefore we do not perform TrackLocalMap(). Once the system relocalizes</span></span><br><span class="line">    <span class="comment">// the camera we will use the local map again.</span></span><br><span class="line">    <span class="keyword">if</span>(bOK &amp;&amp; !mbVO) <span class="comment">// 局部地图不工作，特征点足够且重定位成功</span></span><br><span class="line">        bOK = TrackLocalMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.更新运动模型中的速度mVelocity，mVelocity = mCurrentFrame.mTcw*LastTwc</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bOK)</span><br><span class="line">    mState = OK;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    mState=LOST;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update drawer</span></span><br><span class="line">mpFrameDrawer-&gt;Update(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If tracking were good, check if we insert a keyframe</span></span><br><span class="line"><span class="keyword">if</span>(bOK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Update motion model</span></span><br><span class="line">    <span class="keyword">if</span>(!mLastFrame.mTcw.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//// 步骤2.3：更新恒速运动模型TrackWithMotionModel中的mVelocity</span></span><br><span class="line">        cv::Mat LastTwc = cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F);</span><br><span class="line">        mLastFrame.GetRotationInverse().copyTo(LastTwc.rowRange(<span class="number">0</span>,<span class="number">3</span>).colRange(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        mLastFrame.GetCameraCenter().copyTo(LastTwc.rowRange(<span class="number">0</span>,<span class="number">3</span>).col(<span class="number">3</span>));</span><br><span class="line">        mVelocity = mCurrentFrame.mTcw*LastTwc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mVelocity = cv::Mat();</span><br><span class="line"></span><br><span class="line">    mpMapDrawer-&gt;SetCurrentCameraPose(mCurrentFrame.mTcw);</span><br></pre></td></tr></table></figure>
<ul>
<li>3.清除临时的MapPoints，这些MapPoints在TrackWithMotionModel的UpdateLastFrame函数里生成（仅双目和rgbd）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clean VO matches</span></span><br><span class="line"><span class="comment">//步骤2.4：清除UpdateLastFrame中为当前帧临时添加的MapPoints</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">    <span class="keyword">if</span>(pMP)</span><br><span class="line">        <span class="comment">//排除UpdateLastFrame函数中为了跟踪增加的MapPoints</span></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;Observations()&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mCurrentFrame.mvbOutlier[i] = <span class="literal">false</span>;</span><br><span class="line">            mCurrentFrame.mvpMapPoints[i]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete temporal MapPoints</span></span><br><span class="line"><span class="comment">// 步骤2.5：清除临时的MapPoints，这些MapPoints在TrackWithMotionModel的UpdateLastFrame函数里生成（仅双目和rgbd）</span></span><br><span class="line"><span class="comment">// 步骤2.4中只是在当前帧中将这些MapPoints剔除，这里从MapPoints数据库中删除</span></span><br><span class="line"><span class="comment">// 这里生成的仅仅是为了提高双目或rgbd摄像头的帧间跟踪效果，用完以后就扔了，没有添加到地图中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">list</span>&lt;MapPoint*&gt;::iterator lit = mlpTemporalPoints.begin(), lend =  mlpTemporalPoints.end(); lit!=lend; lit++)</span><br><span class="line">&#123;</span><br><span class="line">    MapPoint* pMP = *lit;</span><br><span class="line">    <span class="keyword">delete</span> pMP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不仅仅是清除mlpTemporalPoints，通过delete pMP还删除了指针指向的MapPoint</span></span><br><span class="line">mlpTemporalPoints.clear();</span><br></pre></td></tr></table></figure>
<ul>
<li>4.检测（NeedNewKeyFrame()）并插入关键帧CreateNewKeyFrame()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤2.6：检测并插入关键帧，对于双目会产生新的MapPoints</span></span><br><span class="line"><span class="keyword">if</span>(NeedNewKeyFrame())</span><br><span class="line">    CreateNewKeyFrame();</span><br></pre></td></tr></table></figure>
<ul>
<li>6.保存最新一帧的数据mLastFrame = Frame(mCurrentFrame);</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!mCurrentFrame.mpReferenceKF)</span><br><span class="line">        mCurrentFrame.mpReferenceKF = mpReferenceKF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存上一帧的数据</span></span><br><span class="line">    mLastFrame = Frame(mCurrentFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7.记录位姿信息，用于轨迹复现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store frame pose information to retrieve the complete camera trajectory afterwards.</span></span><br><span class="line"><span class="keyword">if</span>(!mCurrentFrame.mTcw.empty())</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat Tcr = mCurrentFrame.mTcw*mCurrentFrame.mpReferenceKF-&gt;GetPoseInverse();</span><br><span class="line">    mlRelativeFramePoses.push_back(Tcr);</span><br><span class="line">    mlpReferences.push_back(mpReferenceKF);</span><br><span class="line">    mlFrameTimes.push_back(mCurrentFrame.mTimeStamp);</span><br><span class="line">    mlbLost.push_back(mState==LOST);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This can happen if tracking is lost</span></span><br><span class="line">    mlRelativeFramePoses.push_back(mlRelativeFramePoses.back());</span><br><span class="line">    mlpReferences.push_back(mlpReferences.back());</span><br><span class="line">    mlFrameTimes.push_back(mlFrameTimes.back());</span><br><span class="line">    mlbLost.push_back(mState==LOST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-TrackLocalMap"><a href="#bool-Tracking-TrackLocalMap" class="headerlink" title="bool Tracking::TrackLocalMap()"></a>bool Tracking::TrackLocalMap()</h4>投影，从已经生成的地图点中找到更多对应关系</li>
<li>1.更新Covisibility Graph， 更新局部关键帧 </li>
<li>2.根据局部关键帧，更新局部地图点，接下来运行过滤函数 isInFrustum </li>
<li>3.将地图点投影到当前帧上，超出图像范围的舍弃</li>
<li>4.当前视线方向v和地图点云平均视线方向n, 舍弃n*v&lt;cos(60)的点云</li>
<li>5.舍弃地图点到相机中心距离不在一定阈值内的点 </li>
<li>6.计算图像的尺度因子 isInFrustum 函数结束 </li>
<li>7.进行非线性最小二乘优化 </li>
<li>8.更新地图点的统计量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::TrackLocalMap()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We have an estimation of the camera pose and some map points tracked in the frame.</span></span><br><span class="line">    <span class="comment">// We retrieve the local map and try to find matches to points in the local map.</span></span><br><span class="line">    <span class="comment">// Update Local KeyFrames and Local Points</span></span><br><span class="line">    <span class="comment">// 步骤1：更新局部关键帧mvpLocalKeyFrames和局部地图点mvpLocalMapPoints</span></span><br><span class="line"> </span><br><span class="line">    UpdateLocalMap();</span><br><span class="line">    <span class="comment">// 步骤2：在局部地图中查找与当前帧匹配的MapPoints</span></span><br><span class="line">    SearchLocalPoints();</span><br><span class="line">    <span class="comment">// Optimize Pos</span></span><br><span class="line">    <span class="comment">// 在这个函数之前，在Relocalization、TrackReferenceKeyFrame、TrackWithMotionModel中都有位姿优化，</span></span><br><span class="line">    <span class="comment">// 步骤3：更新局部所有MapPoints后对位姿再次优化</span></span><br><span class="line">    Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">    mnMatchesInliers = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update MapPoints Statistics</span></span><br><span class="line">    <span class="comment">// 步骤3：更新当前帧的MapPoints被观测程度，并统计跟踪局部地图的效果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 由于当前帧的MapPoints可以被当前帧观测到，其被观测统计量加1</span></span><br><span class="line">            <span class="keyword">if</span>(!mCurrentFrame.mvbOutlier[i])</span><br><span class="line">            &#123;</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]-&gt;IncreaseFound();</span><br><span class="line">                <span class="keyword">if</span>(!mbOnlyTracking)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 该MapPoint被其它关键帧观测到过</span></span><br><span class="line">                    <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)</span><br><span class="line">                        mnMatchesInliers++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 记录当前帧跟踪到的MapPoints，用于统计跟踪效果</span></span><br><span class="line">                    mnMatchesInliers++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mSensor==System::STEREO)</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i] = <span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Decide if the tracking was succesful</span></span><br><span class="line">    <span class="comment">//More restrictive if there was a relocalization recently</span></span><br><span class="line">    <span class="comment">// 步骤4：决定是否跟踪成功</span></span><br><span class="line">    <span class="keyword">if</span>(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; mnMatchesInliers&lt;<span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(mnMatchesInliers&lt;<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="void-Tracking-UpdateLocalMap"><a href="#void-Tracking-UpdateLocalMap" class="headerlink" title="void Tracking::UpdateLocalMap()"></a>void Tracking::UpdateLocalMap()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::UpdateLocalMap()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is for visualization</span></span><br><span class="line">    <span class="comment">// 这行程序放在UpdateLocalPoints函数后面是不是好一些</span></span><br><span class="line">    mpMap-&gt;SetReferenceMapPoints(mvpLocalMapPoints);</span><br><span class="line">    <span class="comment">// Update</span></span><br><span class="line">    <span class="comment">// 更新局部关键帧和局部MapPoints</span></span><br><span class="line">    UpdateLocalKeyFrames();</span><br><span class="line">    UpdateLocalPoints();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="void-Tracking-UpdateLocalKeyFrames"><a href="#void-Tracking-UpdateLocalKeyFrames" class="headerlink" title="void Tracking::UpdateLocalKeyFrames()"></a>void Tracking::UpdateLocalKeyFrames()</h6><p>遍历当前帧的MapPoints，将观测到这些MapPoints的关键帧和相邻的关键帧取出，更新mvpLocalKeyFrames<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新局部关键帧，called by UpdateLocalMap()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 遍历当前帧的MapPoints，将观测到这些MapPoints的关键帧和相邻的关键帧取出，更新mvpLocalKeyFrames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> Tracking::UpdateLocalKeyFrames()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Each map point vote for the keyframes in which it has been observed</span></span><br><span class="line">    <span class="comment">// 步骤1：遍历当前帧的MapPoints，记录所有能观测到当前帧MapPoints的关键帧</span></span><br><span class="line">    <span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">int</span>&gt; keyframeCounter;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">            <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 能观测到当前帧MapPoints的关键帧</span></span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt; observations = pMP-&gt;GetObservations();</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt;::const_iterator it=observations.begin(), itend=observations.end(); it!=itend; it++)</span><br><span class="line">                    keyframeCounter[it-&gt;first]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(keyframeCounter.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    KeyFrame* pKFmax= <span class="keyword">static_cast</span>&lt;KeyFrame*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 步骤2：更新局部关键帧（mvpLocalKeyFrames），添加局部关键帧有三个策略</span></span><br><span class="line">    <span class="comment">// 先清空局部关键帧</span></span><br><span class="line">    mvpLocalKeyFrames.clear();</span><br><span class="line">    mvpLocalKeyFrames.reserve(<span class="number">3</span>*keyframeCounter.size());</span><br><span class="line">    <span class="comment">// All keyframes that observe a map point are included in the local map. Also check which keyframe shares most points</span></span><br><span class="line">    <span class="comment">// V-D K1: shares the map points with current frame</span></span><br><span class="line">    <span class="comment">// 策略1：能观测到当前帧MapPoints的关键帧作为局部关键帧</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">int</span>&gt;::const_iterator it=keyframeCounter.begin(), itEnd=keyframeCounter.end(); it!=itEnd; it++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(pKF-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second&gt;max)</span><br><span class="line">        &#123;</span><br><span class="line">            max=it-&gt;second;</span><br><span class="line">            pKFmax=pKF;</span><br><span class="line">        &#125;</span><br><span class="line">        mvpLocalKeyFrames.push_back(it-&gt;first);</span><br><span class="line">        <span class="comment">// mnTrackReferenceForFrame防止重复添加局部关键帧</span></span><br><span class="line">        pKF-&gt;mnTrackReferenceForFrame = mCurrentFrame.mnId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Include also some not-already-included keyframes that are neighbors to already-included keyframes</span></span><br><span class="line">    <span class="comment">// V-D K2: neighbors to K1 in the covisibility graph</span></span><br><span class="line">    <span class="comment">// 策略2：与策略1得到的局部关键帧共视程度很高的关键帧作为局部关键帧</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator itKF=mvpLocalKeyFrames.begin(), itEndKF=mvpLocalKeyFrames.end(); itKF!=itEndKF; itKF++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Limit the number of keyframes</span></span><br><span class="line">        <span class="keyword">if</span>(mvpLocalKeyFrames.size()&gt;<span class="number">80</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        KeyFrame* pKF = *itKF;</span><br><span class="line">        <span class="comment">// 策略2.1:最佳共视的10帧</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyFrame*&gt; vNeighs = pKF-&gt;GetBestCovisibilityKeyFrames(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator itNeighKF=vNeighs.begin(), itEndNeighKF=vNeighs.end(); itNeighKF!=itEndNeighKF; itNeighKF++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pNeighKF = *itNeighKF;</span><br><span class="line">            <span class="keyword">if</span>(!pNeighKF-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// mnTrackReferenceForFrame防止重复添加局部关键帧</span></span><br><span class="line">                <span class="keyword">if</span>(pNeighKF-&gt;mnTrackReferenceForFrame!=mCurrentFrame.mnId)</span><br><span class="line">                &#123;</span><br><span class="line">                    mvpLocalKeyFrames.push_back(pNeighKF);</span><br><span class="line">                    pNeighKF-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 策略2.2:自己的子关键帧</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;KeyFrame*&gt; spChilds = pKF-&gt;GetChilds();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;KeyFrame*&gt;::const_iterator sit=spChilds.begin(), send=spChilds.end(); sit!=send; sit++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pChildKF = *sit;</span><br><span class="line">            <span class="keyword">if</span>(!pChildKF-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pChildKF-&gt;mnTrackReferenceForFrame!=mCurrentFrame.mnId)</span><br><span class="line">                &#123;</span><br><span class="line">                    mvpLocalKeyFrames.push_back(pChildKF);</span><br><span class="line">                    pChildKF-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 策略2.3:自己的父关键帧</span></span><br><span class="line">        KeyFrame* pParent = pKF-&gt;GetParent();</span><br><span class="line">        <span class="keyword">if</span>(pParent)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// mnTrackReferenceForFrame防止重复添加局部关键帧</span></span><br><span class="line">           <span class="keyword">if</span>(pParent-&gt;mnTrackReferenceForFrame!=mCurrentFrame.mnId)</span><br><span class="line">           &#123;</span><br><span class="line">                mvpLocalKeyFrames.push_back(pParent);</span><br><span class="line">                pParent-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// V-D Kref： shares the most map points with current frame</span></span><br><span class="line">    <span class="comment">// 步骤3：更新当前帧的参考关键帧，与自己共视程度最高的关键帧作为参考关键帧</span></span><br><span class="line">    <span class="keyword">if</span>(pKFmax)</span><br><span class="line">    &#123;</span><br><span class="line">        mpReferenceKF = pKFmax;</span><br><span class="line">       mCurrentFrame.mpReferenceKF = mpReferenceKF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="void-Tracking-UpdateLocalPoints"><a href="#void-Tracking-UpdateLocalPoints" class="headerlink" title="void Tracking::UpdateLocalPoints()"></a>void Tracking::UpdateLocalPoints()</h6><p>局部关键帧mvpLocalKeyFrames的MapPoints，更新mvpLocalMapPoints<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新局部关键点，called by UpdateLocalMap()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 局部关键帧mvpLocalKeyFrames的MapPoints，更新mvpLocalMapPoints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> Tracking::UpdateLocalPoints()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 步骤1：清空局部MapPoints</span></span><br><span class="line">    mvpLocalMapPoints.clear();</span><br><span class="line">    <span class="comment">// 步骤2：遍历局部关键帧mvpLocalKeyFrames</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator itKF=mvpLocalKeyFrames.begin(), itEndKF=mvpLocalKeyFrames.end(); itKF!=itEndKF; itKF++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = *itKF;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMPs = pKF-&gt;GetMapPointMatches();</span><br><span class="line">        <span class="comment">// 步骤2：将局部关键帧的MapPoints添加到mvpLocalMapPoints</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::const_iterator itMP=vpMPs.begin(), itEndMP=vpMPs.end(); itMP!=itEndMP; itMP++)</span><br><span class="line">        &#123;</span><br><span class="line">           MapPoint* pMP = *itMP;</span><br><span class="line">            <span class="keyword">if</span>(!pMP)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// mnTrackReferenceForFrame防止重复添加局部MapPoint</span></span><br><span class="line">            <span class="keyword">if</span>(pMP-&gt;mnTrackReferenceForFrame==mCurrentFrame.mnId)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                mvpLocalMapPoints.push_back(pMP);</span><br><span class="line">                pMP-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="void-Tracking-SearchLocalPoints"><a href="#void-Tracking-SearchLocalPoints" class="headerlink" title="void Tracking::SearchLocalPoints()"></a>void Tracking::SearchLocalPoints()</h5><p>在局部地图中查找在当前帧视野范围内的点，将视野范围内的点和当前帧的特征点进行投影匹配</p>
<blockquote>
<p>1.遍历当前帧的mvpMapPoints，标记这些MapPoints不参与之后的搜索<br>2.将所有局部MapPoints投影到当前帧，判断是否在视野范围内，然后进行投影匹配<br>3.对于双目或rgbd摄像头，为当前帧生成新的MapPoints</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::SearchLocalPoints()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do not search map points already matched</span></span><br><span class="line">    <span class="comment">// 步骤1：遍历当前帧的mvpMapPoints，标记这些MapPoints不参与之后的搜索</span></span><br><span class="line">    <span class="comment">// 因为当前的mvpMapPoints一定在当前帧的视野中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::iterator vit=mCurrentFrame.mvpMapPoints.begin(), vend=mCurrentFrame.mvpMapPoints.end(); vit!=vend; vit++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = *vit;</span><br><span class="line">        <span class="keyword">if</span>(pMP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                *vit = <span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新能观测到该点的帧数加1</span></span><br><span class="line">                pMP-&gt;IncreaseVisible();</span><br><span class="line">                <span class="comment">// 标记该点被当前帧观测到</span></span><br><span class="line">                pMP-&gt;mnLastFrameSeen = mCurrentFrame.mnId;</span><br><span class="line">                <span class="comment">// 标记该点将来不被投影，因为已经匹配过</span></span><br><span class="line">                pMP-&gt;mbTrackInView = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nToMatch=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Project points in frame and check its visibility</span></span><br><span class="line">    <span class="comment">// 步骤2：将所有局部MapPoints投影到当前帧，判断是否在视野范围内，然后进行投影匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::iterator vit=mvpLocalMapPoints.begin(), vend=mvpLocalMapPoints.end(); vit!=vend; vit++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = *vit;</span><br><span class="line">        <span class="comment">// 已经被当前帧观测到MapPoint不再判断是否能被当前帧观测到</span></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;mnLastFrameSeen == mCurrentFrame.mnId)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// Project (this fills MapPoint variables for matching)</span></span><br><span class="line">        <span class="comment">// 步骤2.1：判断LocalMapPoints中的点是否在在视野内</span></span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.isInFrustum(pMP,<span class="number">0.5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 观测到该点的帧数加1，该MapPoint在某些帧的视野范围内</span></span><br><span class="line">            pMP-&gt;IncreaseVisible();</span><br><span class="line">            <span class="comment">// 只有在视野范围内的MapPoints才参与之后的投影匹配</span></span><br><span class="line">            nToMatch++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nToMatch&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.8</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> th = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mSensor==System::RGBD)</span><br><span class="line">            th=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// If the camera has been relocalised recently, perform a coarser search</span></span><br><span class="line">        <span class="comment">// 如果不久前进行过重定位，那么进行一个更加宽泛的搜索，阈值需要增大</span></span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mnId&lt;mnLastRelocFrameId+<span class="number">2</span>)</span><br><span class="line">            th=<span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 步骤2.2：对视野范围内的MapPoints通过投影进行特征点匹配</span></span><br><span class="line">        matcher.SearchByProjection(mCurrentFrame,mvpLocalMapPoints,th);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-NeedNewKeyFrame"><a href="#bool-Tracking-NeedNewKeyFrame" class="headerlink" title="bool Tracking::NeedNewKeyFrame()"></a>bool Tracking::NeedNewKeyFrame()</h4><p>判断是否需要生成新的关键帧，确定关键帧的标准</p>
<blockquote>
<ul>
<li>1.在上一次进行重定位之后，过了20帧数据，或关键帧数小于20个，不满足不能生成</li>
<li>2.在上一个关键帧插入之后，过了20帧，或局部建图是空闲状态，不满足不能生成。</li>
<li>3.当前帧跟踪到大于若干个点，不满足不能生成</li>
<li>4.当前帧的跟踪点数小于90%的参考关键帧跟踪点数，并且当前帧跟踪点数大于15，不满足不能生成</li>
<li>5.初始化后跟踪失败,重新Reset</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::NeedNewKeyFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 步骤1：如果用户在界面上选择重定位，那么将不插入关键帧</span></span><br><span class="line">    <span class="comment">// 由于插入关键帧过程中会生成MapPoint，因此用户选择重定位后地图上的点云和关键帧都不会再增加</span></span><br><span class="line">    <span class="keyword">if</span>(mbOnlyTracking)<span class="comment">//如果仅跟踪，不选关键帧</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//If Local Mapping is freezed by a Loop Closure do not insert keyframes</span></span><br><span class="line">    <span class="comment">// 如果局部地图被闭环检测使用，则不插入关键帧</span></span><br><span class="line">    <span class="keyword">if</span>(mpLocalMapper-&gt;isStopped() || mpLocalMapper-&gt;stopRequested())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nKFs = mpMap-&gt;KeyFramesInMap();<span class="comment">//关键帧数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Do not insert keyframes if not enough frames have passed from last relocalisation</span></span><br><span class="line">    <span class="comment">// 步骤2：判断是否距离上一次插入关键帧的时间太短</span></span><br><span class="line">    <span class="comment">// mCurrentFrame.mnId是当前帧的ID</span></span><br><span class="line">    <span class="comment">// mnLastRelocFrameId是最近一次重定位帧的ID</span></span><br><span class="line">    <span class="comment">// mMaxFrames等于图像输入的帧率</span></span><br><span class="line">    <span class="comment">// 如果关键帧比较少，则考虑插入关键帧</span></span><br><span class="line">    <span class="comment">// 或距离上一次重定位超过1s，则考虑插入关键帧</span></span><br><span class="line">    <span class="keyword">if</span>(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; nKFs&gt;mMaxFrames)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Tracked MapPoints in the reference keyframe</span></span><br><span class="line">    <span class="comment">// 步骤3：得到参考关键帧跟踪到的MapPoints数量</span></span><br><span class="line">    <span class="comment">// 在UpdateLocalKeyFrames函数中会将与当前关键帧共视程度最高的关键帧设定为当前帧的参考关键帧</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> nMinObs = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(nKFs&lt;=<span class="number">2</span>)</span><br><span class="line">        nMinObs=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> nRefMatches = mpReferenceKF-&gt;TrackedMapPoints(nMinObs);<span class="comment">//获取参考关键帧跟踪到的MapPoints数量</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Local Mapping accept keyframes?</span></span><br><span class="line">    <span class="comment">// 步骤4：查询局部地图管理器是否繁忙</span></span><br><span class="line">    <span class="keyword">bool</span> bLocalMappingIdle = mpLocalMapper-&gt;AcceptKeyFrames();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Stereo &amp; RGB-D: Ratio of close "matches to map"/"total matches"</span></span><br><span class="line">    <span class="comment">//双目和RGBD：比率接近地图匹配数/总匹配数</span></span><br><span class="line">    <span class="comment">// "total matches = matches to map + visual odometry matches"</span></span><br><span class="line">    <span class="comment">//总匹配数=地图匹配数+视觉里程计匹配数</span></span><br><span class="line">    <span class="comment">// Visual odometry matches will become MapPoints if we insert a keyframe.</span></span><br><span class="line">    <span class="comment">// This ratio measures how many MapPoints we could create if we insert a keyframe.</span></span><br><span class="line">    <span class="comment">//这个比率测量如果我们插入一个关键帧，我们可以创建多少个MapPoints</span></span><br><span class="line">    <span class="comment">// 步骤5：对于双目或RGBD摄像头，统计总的可以添加的MapPoints数量和跟踪到地图中的MapPoints数量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> nMap = <span class="number">0</span>;<span class="comment">//地图匹配数</span></span><br><span class="line">    <span class="keyword">int</span> nTotal= <span class="number">0</span>;<span class="comment">//总匹配数</span></span><br><span class="line">    <span class="keyword">if</span>(mSensor!=System::MONOCULAR)<span class="comment">// 双目或rgbd</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)<span class="comment">//遍历当前帧所有匹配点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mCurrentFrame.mvDepth[i]&gt;<span class="number">0</span> &amp;&amp; mCurrentFrame.mvDepth[i]&lt;mThDepth)<span class="comment">//map点的速度在合理范围内</span></span><br><span class="line">            &#123;</span><br><span class="line">                nTotal++;<span class="comment">// 总的可以添加mappoints数</span></span><br><span class="line">                <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">                    <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)<span class="comment">//mappoint能被观测</span></span><br><span class="line">                        nMap++;<span class="comment">// 被关键帧观测到的mappoints数，即观测到地图中的MapPoints数量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// There are no visual odometry matches in the monocular case</span></span><br><span class="line">        nMap=<span class="number">1</span>;</span><br><span class="line">        nTotal=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ratioMap = (<span class="keyword">float</span>)nMap/(<span class="keyword">float</span>)(<span class="built_in">std</span>::max(<span class="number">1</span>,nTotal));</span><br><span class="line">    <span class="comment">// 步骤6：决策是否需要插入关键帧</span></span><br><span class="line">    <span class="comment">// Thresholds</span></span><br><span class="line">    <span class="comment">// 设定inlier阈值，和之前帧特征点匹配的inlier比例</span></span><br><span class="line">    <span class="keyword">float</span> thRefRatio = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">if</span>(nKFs&lt;<span class="number">2</span>)</span><br><span class="line">        thRefRatio = <span class="number">0.4f</span>;<span class="comment">// 关键帧只有一帧，那么插入关键帧的阈值设置很低</span></span><br><span class="line">    <span class="keyword">if</span>(mSensor==System::MONOCULAR)</span><br><span class="line">        thRefRatio = <span class="number">0.9f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MapPoints中和地图关联的比例阈值</span></span><br><span class="line">    <span class="keyword">float</span> thMapRatio = <span class="number">0.35f</span>;</span><br><span class="line">    <span class="keyword">if</span>(mnMatchesInliers&gt;<span class="number">300</span>)</span><br><span class="line">        thMapRatio = <span class="number">0.20f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Condition 1a: More than "MaxFrames" have passed from last keyframe insertion</span></span><br><span class="line">    <span class="comment">// 很长时间没有插入关键帧</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c1a = mCurrentFrame.mnId&gt;=mnLastKeyFrameId+mMaxFrames;</span><br><span class="line">    <span class="comment">// Condition 1b: More than "MinFrames" have passed and Local Mapping is idle</span></span><br><span class="line">    <span class="comment">// localMapper处于空闲状态</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c1b = (mCurrentFrame.mnId&gt;=mnLastKeyFrameId+mMinFrames &amp;&amp; bLocalMappingIdle);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Condition 1c: tracking is weak</span></span><br><span class="line">    <span class="comment">// 跟踪要跪的节奏，0.25和0.3是一个比较低的阈值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c1c =  mSensor!=System::MONOCULAR &amp;&amp; (mnMatchesInliers&lt;nRefMatches*<span class="number">0.25</span> || ratioMap&lt;<span class="number">0.3f</span>) ;</span><br><span class="line">    <span class="comment">// Condition 2: Few tracked points compared to reference keyframe. Lots of visual odometry compared to map matches.</span></span><br><span class="line">    <span class="comment">// 阈值比c1c要高，与之前参考帧（最近的一个关键帧）重复度不是太高</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c2 = ((mnMatchesInliers&lt;nRefMatches*thRefRatio || ratioMap&lt;thMapRatio) &amp;&amp; mnMatchesInliers&gt;<span class="number">15</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>((c1a||c1b||c1c)&amp;&amp;c2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If the mapping accepts keyframes, insert keyframe.</span></span><br><span class="line">        <span class="comment">// Otherwise send a signal to interrupt BA</span></span><br><span class="line">        <span class="comment">//如果mapping接受关键帧，则插入关键帧，否则发送信号到中断BA</span></span><br><span class="line">        <span class="keyword">if</span>(bLocalMappingIdle)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mpLocalMapper-&gt;InterruptBA();<span class="comment">//中断BA</span></span><br><span class="line">            <span class="keyword">if</span>(mSensor!=System::MONOCULAR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 队列里不能阻塞太多关键帧</span></span><br><span class="line">                <span class="comment">// tracking插入关键帧不是直接插入，而且先插入到mlNewKeyFrames中，</span></span><br><span class="line">                <span class="comment">// 然后localmapper再逐个pop出来插入到mspKeyFrames</span></span><br><span class="line">                <span class="keyword">if</span>(mpLocalMapper-&gt;KeyframesInQueue()&lt;<span class="number">3</span>)<span class="comment">//队列中关键帧小于3</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset if the camera get lost soon after initialization</span></span><br><span class="line"><span class="comment">// 跟踪失败，并且relocation也没有搞定，只能重新Reset</span></span><br><span class="line"><span class="keyword">if</span>(mState==LOST)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mpMap-&gt;KeyFramesInMap()&lt;=<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Track lost soon after initialisation, reseting..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        mpSystem-&gt;Reset();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="void-Tracking-CreateNewKeyFrame"><a href="#void-Tracking-CreateNewKeyFrame" class="headerlink" title="void Tracking::CreateNewKeyFrame()"></a>void Tracking::CreateNewKeyFrame()</h4><p>创建新的关键帧，在这里将关键帧插入了LocalMapper的候选关键帧队列，​​​​​​​这样就进入到了局部构图线程。</p>
<blockquote>
<ul>
<li>1.将当前帧构造成关键帧</li>
<li>2.将当前关键帧设置为当前帧的参考关键帧</li>
<li>3.对于双目或rgbd摄像头，为当前帧生成新的MapPoints</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::CreateNewKeyFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mpLocalMapper-&gt;SetNotStop(<span class="literal">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 步骤1：将当前帧构造成关键帧</span></span><br><span class="line">    KeyFrame* pKF = <span class="keyword">new</span> KeyFrame(mCurrentFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">    <span class="comment">// 步骤2：将当前关键帧设置为当前帧的参考关键帧</span></span><br><span class="line">    <span class="comment">// 在UpdateLocalKeyFrames函数中会将与当前关键帧共视程度最高的关键帧设定为当前帧的参考关键帧</span></span><br><span class="line">    mpReferenceKF = pKF;</span><br><span class="line">    mCurrentFrame.mpReferenceKF = pKF;</span><br><span class="line">    <span class="comment">// 这段代码和UpdateLastFrame中的那一部分代码功能相同</span></span><br><span class="line">    <span class="comment">// 步骤3：对于双目或rgbd摄像头，为当前帧生成新的MapPoints</span></span><br><span class="line">    <span class="keyword">if</span>(mSensor!=System::MONOCULAR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据Tcw计算mRcw、mtcw和mRwc、mOw</span></span><br><span class="line">        mCurrentFrame.UpdatePoseMatrices();</span><br><span class="line">        <span class="comment">// We sort points by the measured depth by the stereo/RGBD sensor.</span></span><br><span class="line">        <span class="comment">// We create all those MapPoints whose depth &lt; mThDepth.</span></span><br><span class="line">        <span class="comment">// If there are less than 100 close points we create the 100 closest.</span></span><br><span class="line">        <span class="comment">// 步骤3.1：得到当前帧深度小于阈值的特征点</span></span><br><span class="line">        <span class="comment">// 创建新的MapPoint, depth &lt; mThDepth</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">float</span>,<span class="keyword">int</span>&gt; &gt; vDepthIdx;</span><br><span class="line">        vDepthIdx.reserve(mCurrentFrame.N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">float</span> z = mCurrentFrame.mvDepth[i];</span><br><span class="line">            <span class="keyword">if</span>(z&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vDepthIdx.push_back(make_pair(z,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!vDepthIdx.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤3.2：按照深度从小到大排序</span></span><br><span class="line">            sort(vDepthIdx.begin(),vDepthIdx.end());</span><br><span class="line">            <span class="comment">// 步骤3.3：将距离比较近的点包装成MapPoints</span></span><br><span class="line">            <span class="keyword">int</span> nPoints = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>; j&lt;vDepthIdx.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">int</span> i = vDepthIdx[j].second;</span><br><span class="line">                <span class="keyword">bool</span> bCreateNew = <span class="literal">false</span>;</span><br><span class="line">                MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">                <span class="keyword">if</span>(!pMP)</span><br><span class="line">                   bCreateNew = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pMP-&gt;Observations()&lt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bCreateNew = <span class="literal">true</span>;</span><br><span class="line">                    mCurrentFrame.mvpMapPoints[i] = <span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(bCreateNew)</span><br><span class="line">                &#123;</span><br><span class="line">                    cv::Mat x3D = mCurrentFrame.UnprojectStereo(i);</span><br><span class="line">                    MapPoint* pNewMP = <span class="keyword">new</span> MapPoint(x3D,pKF,mpMap);</span><br><span class="line">                    <span class="comment">// 这些添加属性的操作是每次创建MapPoint后都要做的</span></span><br><span class="line">                    pNewMP-&gt;AddObservation(pKF,i);</span><br><span class="line">                    pKF-&gt;AddMapPoint(pNewMP,i);</span><br><span class="line">                    pNewMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line">                    pNewMP-&gt;UpdateNormalAndDepth();</span><br><span class="line">                    mpMap-&gt;AddMapPoint(pNewMP);</span><br><span class="line">                    mCurrentFrame.mvpMapPoints[i]=pNewMP;</span><br><span class="line">                    nPoints++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nPoints++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里决定了双目和rgbd摄像头时地图点云的稠密程度</span></span><br><span class="line">                <span class="comment">// 但是仅仅为了让地图稠密直接改这些不太好，</span></span><br><span class="line">                <span class="comment">// 因为这些MapPoints会参与之后整个slam过程</span></span><br><span class="line">                <span class="keyword">if</span>(vDepthIdx[j].first&gt;mThDepth &amp;&amp; nPoints&gt;<span class="number">100</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mpLocalMapper-&gt;InsertKeyFrame(pKF);</span><br><span class="line">    mpLocalMapper-&gt;SetNotStop(<span class="literal">false</span>);</span><br><span class="line">    mnLastKeyFrameId = mCurrentFrame.mnId;</span><br><span class="line">    mpLastKeyFrame = pKF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="Tracking.cc%E7%A8%8B%E5%BA%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89https://blog.csdn.net/qq_20123207/article/details/82587130">ORB-SLAM2从理论到代码实现（六）</a></p>

    </div>
    
    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>


        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>xiaohu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://xiao-hu.com.cn/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94Tracking/" title="ORB-SLAM2——Tracking">https://xiao-hu.com.cn/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94Tracking/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/ORB-SLAM2/" rel="tag"><i class="fa fa-tag"></i> ORB-SLAM2</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E5%85%A5%E5%8F%A3System/" rel="next" title="ORB-SLAM2——系统入口System">
                  <i class="fa fa-chevron-left"></i> ORB-SLAM2——系统入口System
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/11/05/28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="prev" title="28.对称的二叉树">
                  28.对称的二叉树 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  
  

  





  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#整体流程图"><span class="nav-number">1.</span> <span class="nav-text">整体流程图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#System-TrackMonocular"><span class="nav-number">2.</span> <span class="nav-text">System::TrackMonocular</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tracking-GrabImageMonocular"><span class="nav-number">3.</span> <span class="nav-text">Tracking::GrabImageMonocular</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Frame-Frame"><span class="nav-number">3.1.</span> <span class="nav-text">Frame::Frame</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#void-Tracking-Track"><span class="nav-number">4.</span> <span class="nav-text">void Tracking::Track()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化部分"><span class="nav-number">4.1.</span> <span class="nav-text">初始化部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tracking-MonocularInitialization"><span class="nav-number">4.1.1.</span> <span class="nav-text">Tracking::MonocularInitialization()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#void-Tracking-CreateInitialMapMonocular"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">void Tracking::CreateInitialMapMonocular()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跟踪部分"><span class="nav-number">4.2.</span> <span class="nav-text">跟踪部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跟踪步骤1"><span class="nav-number">4.2.1.</span> <span class="nav-text">跟踪步骤1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#void-Tracking-CheckReplacedInLastFrame"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">void Tracking::CheckReplacedInLastFrame()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bool-Tracking-TrackReferenceKeyFrame"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">bool Tracking::TrackReferenceKeyFrame()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bool-Tracking-TrackWithMotionModel"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">bool Tracking::TrackWithMotionModel()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#void-Tracking-UpdateLastFrame"><span class="nav-number">4.2.1.3.1.</span> <span class="nav-text">void Tracking::UpdateLastFrame()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bool-Tracking-Relocalization"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">bool Tracking::Relocalization()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跟踪步骤2"><span class="nav-number">4.2.2.</span> <span class="nav-text">跟踪步骤2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bool-Tracking-TrackLocalMap"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">bool Tracking::TrackLocalMap()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#void-Tracking-UpdateLocalMap"><span class="nav-number">4.2.2.1.1.</span> <span class="nav-text">void Tracking::UpdateLocalMap()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#void-Tracking-UpdateLocalKeyFrames"><span class="nav-number">4.2.2.1.1.1.</span> <span class="nav-text">void Tracking::UpdateLocalKeyFrames()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#void-Tracking-UpdateLocalPoints"><span class="nav-number">4.2.2.1.1.2.</span> <span class="nav-text">void Tracking::UpdateLocalPoints()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#void-Tracking-SearchLocalPoints"><span class="nav-number">4.2.2.1.2.</span> <span class="nav-text">void Tracking::SearchLocalPoints()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bool-Tracking-NeedNewKeyFrame"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">bool Tracking::NeedNewKeyFrame()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-Tracking-CreateNewKeyFrame"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">void Tracking::CreateNewKeyFrame()</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="xiaohu"
    src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">xiaohu</p>
  <div class="site-description" itemprop="description">博观而约取,厚积而薄发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Xiao-Hu-Z" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Xiao-Hu-Z" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:znxxhn@gmail.com" title="E-Mail &amp;rarr; mailto:znxxhn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">554k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script><script src="/js/bookmark.js?v=7.4.2"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>






  <script src="/js/local-search.js?v=7.4.2"></script>













  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

  

  
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

