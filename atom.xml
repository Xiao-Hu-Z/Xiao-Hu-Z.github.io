<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaohu博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiao-hu.com.cn/"/>
  <updated>2019-10-30T03:39:20.567Z</updated>
  <id>https://xiao-hu.com.cn/</id>
  
  <author>
    <name>xiaohu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随机抽样一致RANSAC-Random-Sample-Consensus</title>
    <link href="https://xiao-hu.com.cn/2020/05/07/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4RANSAC-Random-Sample-Consensus/"/>
    <id>https://xiao-hu.com.cn/2020/05/07/随机抽样一致RANSAC-Random-Sample-Consensus/</id>
    <published>2020-05-07T03:12:23.815Z</published>
    <updated>2019-10-30T03:39:20.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h1><p>随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</p><a id="more"></a><h1 id="RANSAC的基本假设："><a href="#RANSAC的基本假设：" class="headerlink" title="RANSAC的基本假设："></a>RANSAC的基本假设：</h1><p>“内群”数据可以通过几组模型的参数来叙述其分布，而“离群”数据则是不适合模型化的数据。<br>数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。<br>RANSAC假定，给定一组（通常很小）的内群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。</p><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><p>这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内群以及离群，其中内群为可以被拟合到线段上的点，而离群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内群的线，因为最小二乘法会受离群影响而影响其结果。而RANSAC，可以只由内群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020160728989.png#pic_center"><br>包含许多离群的一组数据，要找一条最适合的线。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910201607364.png#pic_center"><br>RANSAC找到的线，离群值对结果没影响（蓝色点为内群，红色点为离群）</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RANSAC算法的输入是一组观测数据（往往含有较大的噪声或无效点），一个用于解释观测数据的参数化模型以及一些可信的参数。RANSAC通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证： </p><ol><li>有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出。</li><li>用1中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li><li>如果有足够多的点被归类为假设的局内点，那么估计的模型就足够合理。</li><li>然后，用所有假设的局内点去重新估计模型（譬如使用最小二乘法），因为它仅仅被初始的假设局内点估计过。</li><li>最后，通过估计局内点与模型的错误率来评估模型。</li><li>上述过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为比现有的模型更好而被选用。<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1>伪码形式的算法如下所示：</li></ol><ul><li><p>输入：</p><blockquote><p>data —— 一组观测数据<br>model —— 适应于数据的模型<br>n —— 适用于模型的最少数据个数<br>k —— 算法的迭代次数<br>t —— 用于决定数据是否适应于模型的阀值<br>d —— 判定模型是否适用于数据集的数据数目</p></blockquote></li><li><p>输出：</p><blockquote><p>best_model —— 跟数据最匹配的模型参数（如果没有找到好的模型，返回null）<br>best_consensus_set —— 估计出模型的数据点<br>best_error —— 跟数据相关的估计出的模型错误</p></blockquote><ul><li>iterations = 0<blockquote><p>best_model = null<br>best_consensus_set = null<br>best_error = 无穷大<br>while ( iterations &lt; k )<br>maybe_inliers = 从数据集中随机选择n个点<br>maybe_model = 适合于maybe_inliers的模型参数<br>consensus_set = maybe_inliers</p></blockquote></li></ul></li><li><p>估计的模型就足够合理</p><blockquote><p>for ( 每个数据集中不属于maybe_inliers的点 ）<br>if ( 如果点适合于maybe_model，且错误小于t ）<br>将点添加到consensus_set<br>if （ consensus_set中的元素数目大于d ）<br>已经找到了好的模型，</p></blockquote></li><li><p>现在测试该模型到底有多好</p><blockquote><p>better_model = 适合于consensus_set中所有点的模型参数<br>this_error = better_model究竟如何适合这些点的度量<br>if ( this_error &lt; best_error )<br>我们发现了比以前好的模型，保存该模型直到更好的模型出现<br>best_model =  better_model<br>best_consensus_set = consensus_set<br>best_error =  this_error</p></blockquote></li><li><p>迭代</p><blockquote><p>增加迭代次数<br>返回 best_model, best_consensus_set, best_error</p></blockquote><p> RANSAC算法的可能变化包括以下几种：</p><ol><li><p>如果发现了一种足够好的模型（该模型有足够小的错误率），则跳出主循环。这样可能会节约计算额外参数的时间。</p><ol><li>直接从maybe_model计算this_error，而不从consensus_set重新估计模型。这样可能会节约比较两种模型错误的时间，但可能会对噪声更敏感。</li></ol><p>其实核心就是随机性和假设性。随机性用于减少计算了，那个循环次数就是利用正确数据出现的概率。所谓的假设性，就是说随机抽出来的数据我都认为是正确的，并以此去计算其他点，获得其他满足变换关系的点，然后利用投票机制，选出获票最多的那一个变换。</p></li></ol></li></ul><h1 id="参数决定"><a href="#参数决定" class="headerlink" title="参数决定"></a>参数决定</h1><p>假设每个点是真正内群的几率是w，则：</p><ul><li>w = 真正内群的数目 / 数据总共的数量</li></ul><p>通常我们不知道w 是多少，$w^{n}$是所选择的n 个点都是内群的几率，$1-w^{n}$ 是所选择的 n 个点至少有一个不是内群的几率， ${(1-w^{n})^{k}}$是表示重复k 次都没有全部的 {\displaystyle n} n 个点都是内群的几率，假设算法跑 k 次以后成功的几率是p，那么：</p><script type="math/tex; mode=display">{1-p=(1-w^{n})^{k}}</script><script type="math/tex; mode=display">{p=1-(1-w^{n})^{k}}</script><p>所以如果希望成功几率高， ${\displaystyle p=0.99}$， 当n 不变时，k 越大， {\displaystyle p} p 越大， 当w 不变时，n 越大，所需的k 就越大， 通常w 未知，所以 n 选小一点比较好。</p><h1 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h1><ul><li>RANSAC的优点是它能鲁棒的估计模型参数。例如，它能从包含大量局外点的数据集中估计出高精度的参数。</li><li>RANSAC的缺点是它计算参数的迭代次数没有上限；如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。</li><li>RANSAC只有一定的概率得到可信的模型，概率与迭代次数成正比。RANSAC的另一个缺点是它要求设置跟问题相关的阀值。</li><li>RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</li></ul><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/pi9nc/article/details/26596519" target="_blank" rel="noopener">RANSAC</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E6%8A%BD%E6%A8%A3%E4%B8%80%E8%87%B4" target="_blank" rel="noopener">随机抽样一致</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;算法简介：&quot;&gt;&lt;a href=&quot;#算法简介：&quot; class=&quot;headerlink&quot; title=&quot;算法简介：&quot;&gt;&lt;/a&gt;算法简介：&lt;/h1&gt;&lt;p&gt;随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/VSLAM/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>IMU测量模型、运动模型、误差模型</title>
    <link href="https://xiao-hu.com.cn/2020/05/07/IMU%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B%E3%80%81%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E3%80%81%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiao-hu.com.cn/2020/05/07/IMU测量模型、运动模型、误差模型/</id>
    <published>2020-05-07T03:12:23.763Z</published>
    <updated>2019-10-30T03:38:12.513Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IMU测量模型"><a href="#IMU测量模型" class="headerlink" title="IMU测量模型"></a>IMU测量模型</h1><ul><li><p>MEMS 加速度计工作原理<br>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示<br>加速度计测量值$a_m$为弹簧拉力对应的加速度</p><script type="math/tex; mode=display">a_m=\frac{f}{m}=a-g</script><p>其中m为质量块质量，a为物体在世界（惯性）坐标系下的实际加速度。</p></li><li><p>陀螺仪测量原理<br>陀螺仪的测量值即为IMU在body坐标系下的旋转角速度，要通过运动学模型转换到惯性坐标系下 ，按测量原理分有振动陀螺，光纤陀螺等。</p><p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 Coriolisforce 来间接得到角速度。</p><blockquote><p>在旋转坐标系中，运动的物体受到科氏力作用<br>MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017192448388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h1 id="IMU运动模型"><a href="#IMU运动模型" class="headerlink" title="IMU运动模型"></a>IMU运动模型</h1><h2 id="旋转量求导"><a href="#旋转量求导" class="headerlink" title="旋转量求导"></a>旋转量求导</h2><p>首先，如下图所示，考虑一个从原点出发的向量 r 绕单位轴 u 旋转，角速度大小为 θ˙。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017155511191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>角速度矢量可以表示为${\boldsymbol \omega}=\dot{\theta}u$，易得向量 r 末端点 P 的速度矢量，即 r的时间一阶导为</p><script type="math/tex; mode=display">\frac{d{r}}{dt} = {\boldsymbol \omega} \times {r}</script><p>坐标系 {B} 绕单位轴 u 旋转，如上所述，其三个轴的时间一阶导同样为</p><script type="math/tex; mode=display">\frac{d{\bf i}_B}{dt} = {\boldsymbol \omega} \times {\bf i}_B, \frac{d{\bf j}_B}{dt} = {\boldsymbol \omega} \times {\bf j}_B, \frac{d{\bf k}_B}{dt} = {\boldsymbol \omega} \times {\bf k}_B</script><p>$[ {\bf i}_B \quad {\bf j}_B \quad {\bf k}_B ]$ 实际上就是坐标系 {B} 相对于参考坐标系的旋转矩阵 R，R的时间一阶导为</p><script type="math/tex; mode=display">\dot{\bf R} =  [ {\boldsymbol \omega} \times {\bf i}_B \quad {\boldsymbol \omega} \times {\bf j}_B \quad {\boldsymbol \omega} \times {\bf k}_B ] = {\boldsymbol \omega} \times {\bf R}</script><p>叉乘运算可以转化为负对称矩阵的乘法：</p><script type="math/tex; mode=display">\dot{\bf R} = {\boldsymbol \omega}^{\land} {\bf R}</script><p>其中负对称矩阵${\boldsymbol \omega}^{\land}$为</p><script type="math/tex; mode=display">% <![CDATA[\quad {\boldsymbol \omega}^{\land}= \begin{bmatrix}0 & -\omega_3 & \omega_2\\ \omega_3 & 0 & -\omega_1 \\ -\omega_2 & \omega_1 & 0\end{bmatrix} %]]></script><p>这里的角速度 ω 是在参考坐标系下表达的，角速度也经常表达在体坐标系 {B} 下，记为${}^B{\boldsymbol \omega} = {\bf R}^T{\boldsymbol \omega}$，即${\boldsymbol \omega} = {\bf R}{}^B{\boldsymbol \omega}$<br>上式也可以写作：</p><script type="math/tex; mode=display">\dot{\bf R} =w^{\land}R=(R^Bw)^{\land}R=R{}^{\land}wR^TR= R({}^Bw)^{\land}</script></blockquote></li></ul><a id="more"></a><blockquote><p>证：对任意旋转矩阵 R 和三维向量 v，都有$({\bf R v})^{\land} = {\bf Rv^{\land}R}^T$<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017160718789.png#pic_center"><br>最后一式利用向量叉乘的旋转变换不变性可证，即，对于任意${\bf v,u}\in \mathbb{R}^3$永远有</p><script type="math/tex; mode=display">({\bf Rv})\times({\bf Ru})={\bf R(v\times u)}</script><p>从三维几何的角度来理解：v,u 是任意两个三维向量，(v×u) 是一个和 v,u 都垂直、大小为 |v||u|sin(u,v) 的三维向量；将 v,u,v×u 三个向量都经过同一个旋转，它们的相对位姿和模长都不会改变，所以 (Rv) 和 (Ru) 的叉乘仍是 R(v×u)。</p></blockquote><h2 id="科氏加速度"><a href="#科氏加速度" class="headerlink" title="科氏加速度"></a>科氏加速度</h2><p>这次把绕惯性系 {A} 中固定单位轴 u 旋转的 {B} 作为参考坐标系。考虑下图， 点 P 相对于 {B} 运动，记 ${}^Br$ 分别为 P 在 {B} 下的坐标，r 为 P 的绝对坐标（即 {A} 下坐标）， R 仍为 {B} 相对于 {A} 的旋转矩阵，易知 $r=R{}^Br$。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017163839187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$r=R{}^Br$求一阶时间导</p><script type="math/tex; mode=display">{\bf v} = \dot{\bf r} = \dot{\bf R} {}^B{\bf r} + {\bf R}^B\dot{\bf r} = {\boldsymbol \omega}^{\land}{\bf R}{}^B{\bf r}+ {\bf R}^B\dot{\bf r}</script><p>记P在 {B}下速度为 ${}^Bv$，于是</p><script type="math/tex; mode=display">v = w^{\land}r+ {R}^B{}= w \times r+ v_r</script><p>${\bf v}_r$来表达「相对速度」的概念，准确定义为 P 相对于 {B} 的速度，在惯性系 {A} 下的表达<br>再对求时间导：</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017165037235.png#pic_center"><br>在旋转坐标系下观察，运动的物体（运动方向和旋转轴不为同一个轴时）会受到科氏力的作用。</p><ul><li>第一项中${\boldsymbol \alpha}$为 {B} 的角加速度，所以第一项的物理意义是 {B} 旋转所造成的 P 的切向加速度</li><li>第二项是 {B} 旋转所造成的向心加速度</li><li>第三项比较特殊，为 {B} 的旋转运动与 P 相对 {B} 的平移运动耦合产生的加速度，称为科氏加速度</li><li>第四项为 P 相对于 {B} 的加速度，但在惯性系{A}下表达，类似于${\bf v}_r$</li></ul></blockquote><h1 id="IMU-误差模型"><a href="#IMU-误差模型" class="headerlink" title="IMU 误差模型"></a>IMU 误差模型</h1><p>加速度计和陀螺仪的误差可以分为：确定性误差，随机误差。</p><ul><li>确定性误差可以事先标定确定，包括： bias, scale …</li><li>随机误差通常假设噪声服从高斯分布，包括：高斯白噪声， bias<br>随机游走…<h2 id="确定性误差"><a href="#确定性误差" class="headerlink" title="确定性误差"></a>确定性误差</h2></li></ul><ol><li>Bias ，Scale<br>理论上，当没有外部作用时， IMU 传感器的输出应该为 0，但实际数据存在一个偏置 b。</li></ol><ul><li>加速度计 bias 对位姿估计的影响：<script type="math/tex; mode=display">v_err=b_at，p_err=\frac{1}{2}b_at^2</script></li><li>scale 可以看成是实际数值和传感器输出值之间的比值</li></ul><ol><li>Nonorthogonality/Misalignment Errors(非正交/错位错误）<br><img alt data-src="https://img-blog.csdnimg.cn/20191017182956354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"> </li><li>其他确定性误差<blockquote><ul><li>Run-to-Run Bias/Scale Facto</li><li>In Run (Stability) Bias/Scale Factor</li><li>Temperature-Dependent Bias/Scale Factor</li></ul></blockquote></li></ol><h3 id="确定性误差误差标定"><a href="#确定性误差误差标定" class="headerlink" title="确定性误差误差标定"></a>确定性误差误差标定</h3><h4 id="六面法标定加速度"><a href="#六面法标定加速度" class="headerlink" title="六面法标定加速度"></a>六面法标定加速度</h4><p><strong>bias 和 scale factor</strong></p><blockquote><p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。如果各个轴都是正交的，那很容易得到 bias 和 scale：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017171617729.png#pic_center"><br>其中,$l$为加速度计某个轴的测量值， g为当地的重力加速度</p></blockquote><p><strong>（Nonorthogonality/Misalignment Errors)</strong></p><blockquote><p>多轴 IMU 传感器制作的时候，由于制作工艺的问题，会使得 xyz 轴可能不垂直，如下图所示。</p><p>考虑轴间误差的时候，实际加速度和测量值之间的关系为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172240109.png#pic_center"><br>水平静止放置 6 面的时候，加速度的理论值为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172303634.png#pic_center"><br>对应的测量值矩阵 L ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172326866.png#pic_center"><br>利用最小二乘就能够把12个变量求出来。</p></blockquote><h4 id="六面法标定陀螺仪"><a href="#六面法标定陀螺仪" class="headerlink" title="六面法标定陀螺仪"></a>六面法标定陀螺仪</h4><blockquote><ul><li>六面法标定陀螺仪 bias 和 scale factor<br>和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这<br>里的 6 面是指各个轴顺时针和逆时针旋转。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017182109980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>参考：<a href="https://blog.csdn.net/CSDN_XCS/article/details/90339761" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_XCS/article/details/90339761</a></li></ul></blockquote><h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><ul><li>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</li><li>两种标定方法：<blockquote><p>• soak method: 控制恒温室的温度值，然后读取传感器数值进行标定。<br>• ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</p></blockquote></li></ul><h2 id="随机误差"><a href="#随机误差" class="headerlink" title="随机误差"></a>随机误差</h2><h3 id="高斯白噪声与随机游走"><a href="#高斯白噪声与随机游走" class="headerlink" title="高斯白噪声与随机游走"></a>高斯白噪声与随机游走</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数。故把瞬时值的概率分布服从高斯分布，功率谱密度服从均匀分布的噪声称为高斯白噪声</p><p>IMU 数据连续时间上受到一个均值为 0，方差为 $σ^2$，各时刻之间相互独立的高斯过程 n(t)：</p><script type="math/tex; mode=display">E[n(t)]=0</script><script type="math/tex; mode=display">E[n(t_1​)n(t_2​)]=σ^2δ(t_1​−t_2​)</script><p>自相关函数的数学定义：$R(τ)=∫^{−∞}_∞　x(t)x(t−τ)dt$</p><p>其中 $δ()$ 表示狄拉克函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190929113450104.png#pic_center"><br><strong>白噪声的离散化</strong><br>实际上， IMU 传感器获取的数据为离散采样，离散和连续高斯白噪声的方差之间存在如下转换关系：</p><script type="math/tex; mode=display">n_d[k] \triangleq n(t_0+\Delta t)\simeq\frac{1}{\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)dt</script><script type="math/tex; mode=display"> \begin{aligned}E(n_d[k]^2) & = E(\frac{1}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)n(t)d \tau dt) \\&= E( \frac{\sigma^2}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\&= E(\frac{\sigma^2}{\Delta t})\end{aligned}</script><p>即:</p><script type="math/tex; mode=display">nd[k] = σ_dw[k]</script><p>其中：$w[k] ∼ N(0, 1)$，$\sigma_d=\sigma \frac{1}{\sqrt{\bigtriangleup t}}$<br>也就是说高斯白噪声的连续时间到离散时间之间差一个 $\frac{1}{\sqrt{\bigtriangleup t}}$ ，√∆t 是传感器的采样时间。</p><h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走</p><script type="math/tex; mode=display">\dot{b}_{(t)}=n(t)=\sigma_bw(t)</script><p>其中 w 是方差为 1 的白噪声</p><p>离散和连续之间的转换：</p><script type="math/tex; mode=display">b_d[k] \triangleq b(t_0) + \int_{t_0}^{t_0+\Delta t}n(t)dt$$$$\begin{aligned}E((b_d[k]-b_d[k-1])^2) &=E(\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(t)n(\tau)d \tau dt)\\&= E({\sigma_{b}^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\&= E(\sigma_{b}^2\Delta t)\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">b_d[k] = b_d[k − 1] + σ_{bd}w[k]</script><p>其中：</p><script type="math/tex; mode=display">w[k] ∼ N(0, 1),σ_{bd} = σ_b\sqrt{\bigtriangleup t}</script><p>bias 随机游走的噪声方差从连续时间到离散之间需要乘以 $\sqrt{\bigtriangleup t}$ </p><h3 id="随机误差的标定"><a href="#随机误差的标定" class="headerlink" title="随机误差的标定"></a>随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><p>Allan 方差法是 20 世纪 60 年代由美国国家标准局的 David Allan 提出的，它是一种基于时域的分析方法。</p><blockquote><p>具体的流程如下：</p><ol><li>保持传感器绝对静止获取数据</li><li>对数据进行分段，设定时间段的时长，如下图所示<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204504508.png#pic_center"></li><li>将传感器数据按照时间段进行平均</li><li>计算方差，绘制艾伦曲线，得到的艾伦曲线如下图所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204557636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">Allan方差法可用于5种随机误差的标定：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017212131103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/YunLaowang/article/details/95608107" target="_blank" rel="noopener">VIO标定IMU随机误差：Allan方差法</a><br><a href="https://blog.csdn.net/lei1105034103/article/details/89159459" target="_blank" rel="noopener">陀螺 Allan 方差分析</a></li></ol></blockquote><h2 id="IMU-数学模型"><a href="#IMU-数学模型" class="headerlink" title="IMU 数学模型"></a>IMU 数学模型</h2><p>以 ECI 为参考坐标系（由于 ECI 为惯性系，不需要考虑地球自转）：<br>忽略 scale 的影响，只考虑白噪声和 bias 随机游走：<br>IMU的真实值：$w^b,a^b$<br>IMU的测量值：$\widetilde{w},\widetilde{a}^b$<br>IMU机体系即b系，w系表示世界坐标系。</p><script type="math/tex; mode=display">\begin{aligned} \widetilde{w}&=w^b +b^g+n^g\\ \widetilde{a}^b&=a^b+b^a+n^a\\&=q_{bw}(a^w+g^w)+b^a+n^a \end{aligned}</script><p>考虑高斯白噪声项，有：</p><script type="math/tex; mode=display">\begin{aligned} &w^b=\widetilde{w} -b^g-n^g\\ &a^w=q_{wb}(\widetilde{a}^b-b^a-n^a)-g^w \end{aligned}</script><p>不考虑高斯白噪声项，有：</p><script type="math/tex; mode=display">\begin{aligned} &w^b=\widetilde{w} -b^g\\ &a^w=q_{wb}(\widetilde{a}^b-b^a)-g^w \end{aligned}</script><p>参考：<a href="https://fzheng.me/2016/11/20/imu_model_eq/#1-2-%E5%89%8D%E7%BD%AE2-%E5%9B%9B%E5%85%83%E6%95%B0" target="_blank" rel="noopener">从零开始的 IMU 状态模型推导</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;IMU测量模型&quot;&gt;&lt;a href=&quot;#IMU测量模型&quot; class=&quot;headerlink&quot; title=&quot;IMU测量模型&quot;&gt;&lt;/a&gt;IMU测量模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MEMS 加速度计工作原理&lt;br&gt;测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示&lt;br&gt;加速度计测量值$a_m$为弹簧拉力对应的加速度&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;a_m=\frac{f}{m}=a-g&lt;/script&gt;&lt;p&gt;其中m为质量块质量，a为物体在世界（惯性）坐标系下的实际加速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;陀螺仪测量原理&lt;br&gt;陀螺仪的测量值即为IMU在body坐标系下的旋转角速度，要通过运动学模型转换到惯性坐标系下 ，按测量原理分有振动陀螺，光纤陀螺等。&lt;/p&gt;
&lt;p&gt;低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 Coriolisforce 来间接得到角速度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在旋转坐标系中，运动的物体受到科氏力作用&lt;br&gt;MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191017192448388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;IMU运动模型&quot;&gt;&lt;a href=&quot;#IMU运动模型&quot; class=&quot;headerlink&quot; title=&quot;IMU运动模型&quot;&gt;&lt;/a&gt;IMU运动模型&lt;/h1&gt;&lt;h2 id=&quot;旋转量求导&quot;&gt;&lt;a href=&quot;#旋转量求导&quot; class=&quot;headerlink&quot; title=&quot;旋转量求导&quot;&gt;&lt;/a&gt;旋转量求导&lt;/h2&gt;&lt;p&gt;首先，如下图所示，考虑一个从原点出发的向量 r 绕单位轴 u 旋转，角速度大小为 θ˙。&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191017155511191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70&quot;&gt;&lt;br&gt;角速度矢量可以表示为${\boldsymbol \omega}=\dot{\theta}u$，易得向量 r 末端点 P 的速度矢量，即 r的时间一阶导为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{d{r}}{dt} = {\boldsymbol \omega} \times {r}&lt;/script&gt;&lt;p&gt;坐标系 {B} 绕单位轴 u 旋转，如上所述，其三个轴的时间一阶导同样为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{d{\bf i}_B}{dt} = {\boldsymbol \omega} \times {\bf i}_B, \frac{d{\bf j}_B}{dt} = {\boldsymbol \omega} \times {\bf j}_B, \frac{d{\bf k}_B}{dt} = {\boldsymbol \omega} \times {\bf k}_B&lt;/script&gt;&lt;p&gt;$[ {\bf i}_B \quad {\bf j}_B \quad {\bf k}_B ]$ 实际上就是坐标系 {B} 相对于参考坐标系的旋转矩阵 R，R的时间一阶导为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot{\bf R} =  [ {\boldsymbol \omega} \times {\bf i}_B \quad {\boldsymbol \omega} \times {\bf j}_B \quad {\boldsymbol \omega} \times {\bf k}_B ] = {\boldsymbol \omega} \times {\bf R}&lt;/script&gt;&lt;p&gt;叉乘运算可以转化为负对称矩阵的乘法：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot{\bf R} = {\boldsymbol \omega}^{\land} {\bf R}&lt;/script&gt;&lt;p&gt;其中负对称矩阵${\boldsymbol \omega}^{\land}$为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\quad {\boldsymbol \omega}^{\land}= \begin{bmatrix}0 &amp; -\omega_3 &amp; \omega_2\\ \omega_3 &amp; 0 &amp; -\omega_1 \\ -\omega_2 &amp; \omega_1 &amp; 0\end{bmatrix} %]]&gt;&lt;/script&gt;&lt;p&gt;这里的角速度 ω 是在参考坐标系下表达的，角速度也经常表达在体坐标系 {B} 下，记为${}^B{\boldsymbol \omega} = {\bf R}^T{\boldsymbol \omega}$，即${\boldsymbol \omega} = {\bf R}{}^B{\boldsymbol \omega}$&lt;br&gt;上式也可以写作：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot{\bf R} =w^{\land}R=(R^Bw)^{\land}R=R{}^{\land}wR^TR= R({}^Bw)^{\land}&lt;/script&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
      <category term="VIO" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/VIO/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
      <category term="VIO" scheme="https://xiao-hu.com.cn/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>C ++ 学习（11）文件输入和输出</title>
    <link href="https://xiao-hu.com.cn/2019/11/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%8811%EF%BC%89%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/"/>
    <id>https://xiao-hu.com.cn/2019/11/19/C-学习（11）文件输入和输出/</id>
    <published>2019-11-19T09:30:24.000Z</published>
    <updated>2019-11-19T09:30:41.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019062610063696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在头文件iostream中定义有两个流类：输入流类istream和输出流类ostream,且用这两个类定义了流对象cin和cout:</p><p>Istream cin;      ostream cout;</p><p>C++的iostream与C的printf/scanf的区别</p><ol><li><p>类型处理更安全、智能，printf中对付int、float等说明符比较麻烦</p></li><li><p>扩展性更强，iostream使用的&lt;&lt;、&gt;&gt;操作符都是可重载，只要重载相关的运算符就可以；</p><ol><li>流风格的写法也比较自然简洁</li></ol></li><li><p>printf/scanf的速度比cin/cout快</p></li></ol><a id="more"></a><p>几个输入函数介绍：</p><p>1.. cin.get()</p><pre><code>  cin.get(字符变量名)可以用来接收字符  cin.get(字符数组名,接收字符数目)用来接收一行字符串,可以接收空格</code></pre><ol><li><p>cin.getline(接收字符串的变量,接收字符个数,结束字符)用法:接收一个字符串，可以接收空格并输出</p></li><li><p>getline()用法：接收一个字符串，可以接收空格并输出，需包含“#include<string>”</string></p></li></ol><p>注意：cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数。</p><h1 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h1><p>文件I/O也称为读文件（输入）和写文件（输出），c++标准库中提供两个类ifstream和ofstream，分别用于文件的输入和输出。</p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><ol><li>创建一个ofstream对象来管理输出流</li><li>讲对象与文件关联起来</li><li>使用cout的方式使用该对象，唯一的区别是输出讲进入文件，而不是屏幕</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream fout;</span><br><span class="line">fout.open('jar.txt‘）;</span><br><span class="line"><span class="comment">//ofstream fout('jar.txt‘）;</span></span><br><span class="line">fout&lt;&lt;<span class="string">"Dull Data"</span>;</span><br><span class="line">fout.close();</span><br></pre></td></tr></table></figure><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><ol><li>创建一个ifstream对象来管理输入流</li><li>讲对象与文件关联起来</li><li>使用cin的方式使用该对象</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin;</span><br><span class="line">fin.open('jar.txt‘）;</span><br><span class="line"><span class="comment">//ifstream fin('jar.txt‘）;in</span></span><br><span class="line">fin.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">fin&gt;&gt;ch;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/2019062610063696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70&quot;&gt;&lt;br&gt;在头文件iostream中定义有两个流类：输入流类istream和输出流类ostream,且用这两个类定义了流对象cin和cout:&lt;/p&gt;&lt;p&gt;Istream cin;      ostream cout;&lt;/p&gt;&lt;p&gt;C++的iostream与C的printf/scanf的区别&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类型处理更安全、智能，printf中对付int、float等说明符比较麻烦&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;扩展性更强，iostream使用的&amp;lt;&amp;lt;、&amp;gt;&amp;gt;操作符都是可重载，只要重载相关的运算符就可以；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流风格的写法也比较自然简洁&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;printf/scanf的速度比cin/cout快&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C ++ 学习（10）C++11 智能指针的使用</title>
    <link href="https://xiao-hu.com.cn/2019/11/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%8810%EF%BC%89C-11-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xiao-hu.com.cn/2019/11/19/C-学习（10）C-11-智能指针的使用/</id>
    <published>2019-11-19T09:29:03.000Z</published>
    <updated>2019-11-19T09:29:27.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>C++程序设计中使用new从堆（自由存储区）分配内存，等不需要时，应使用delete将其释放。C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。<br>智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr</memory></p><a id="more"></a><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><ul><li>初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的<ul><li>拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。</li><li>get函数获取原始指针</li><li>注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存</li><li><strong>注意避免循环引用</strong>，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍。</li></ul></int></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra2(ptra); <span class="comment">//copy</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> *pb = &amp;a;</span><br><span class="line">        <span class="comment">//std::shared_ptr&lt;int&gt; ptrb = pb;  //error</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptrb = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(b);</span><br><span class="line">        ptra2 = ptrb; <span class="comment">//assign</span></span><br><span class="line">        pb = ptrb.get(); <span class="comment">//获取原始指针</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>　　unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));  <span class="comment">//绑定动态对象</span></span><br><span class="line">        <span class="comment">//std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能賦值</span></span><br><span class="line">        <span class="comment">//std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷貝</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr2 = <span class="built_in">std</span>::move(uptr); <span class="comment">//轉換所有權</span></span><br><span class="line">        uptr2.release(); <span class="comment">//释放所有权</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超過uptr的作用域，內存釋放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr的使用"><a href="#weak-ptr的使用" class="headerlink" title="weak_ptr的使用"></a>weak_ptr的使用</h2><p>　　weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。　　</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sh_ptr.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sh_ptr);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!wp.expired())&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr2 = wp.lock(); <span class="comment">//get another shared_ptr</span></span><br><span class="line">            *sh_ptr = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete memory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h1&gt;&lt;p&gt;C++程序设计中使用new从堆（自由存储区）分配内存，等不需要时，应使用delete将其释放。C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。&lt;br&gt;智能指针在C++11版本之后提供，包含在头文件&lt;memory&gt;中，shared_ptr、unique_ptr、weak_ptr&lt;/memory&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 学习（9）——string</title>
    <link href="https://xiao-hu.com.cn/2019/11/18/C-%E5%AD%A6%E4%B9%A0%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94string/"/>
    <id>https://xiao-hu.com.cn/2019/11/18/C-学习（9）——string/</id>
    <published>2019-11-18T02:17:02.000Z</published>
    <updated>2019-11-18T06:42:38.017Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++处理字符串的方式有两种</p><ul><li><p>来自c语言，常称为C-风格字符串<br>可以将字符串存储在char数组中，C-风格字符串特殊性质：以空字符（\0)结尾，用来标记字符串的结尾</p></li><li><p>基于string类型库的方法</p></li></ul><p>strin类使用简单， 提供了将字符串作为一种数据类型的表示方法</p><p>  为了在我们的程序中使用string类型，我们必须包含头文件 &lt; string&gt;</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //注意这里不是string.h string.h是C字符串头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h1 id="声明一个C-字符串"><a href="#声明一个C-字符串" class="headerlink" title="声明一个C++字符串"></a>声明一个C++字符串</h1><p>声明一个字符串变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> Str;</span><br></pre></td></tr></table></figure><p>string是一个类，有构造函数和析构函数，上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。</p><ul><li>String类的构造函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str   <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span> <span class="comment">//生成字符串为str的复制品</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, strbegin,<span class="built_in">strlen</span>)</span> <span class="comment">//将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//将C字符串作为s的初值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr, char_len)</span><span class="comment">//以C_string类型cstr的前char_len个字符串作为字符串s的初值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(num ,c)</span><span class="comment">//生成num个c字符的字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx)</span><span class="comment">//将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</span></span></span><br></pre></td></tr></table></figure><ul><li>String类的析构函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">string</span>() <span class="comment">//销毁所有字符，释放内存</span></span><br></pre></td></tr></table></figure><h1 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">=,assign()     <span class="comment">//赋以新值</span></span><br><span class="line"></span><br><span class="line">swap()     <span class="comment">//交换两个字符串的内容</span></span><br><span class="line"></span><br><span class="line">+=,append(),push_back() <span class="comment">//在尾部添加字符</span></span><br><span class="line"></span><br><span class="line">insert() <span class="comment">//插入字符</span></span><br><span class="line"></span><br><span class="line">erase() <span class="comment">//删除字符</span></span><br><span class="line"></span><br><span class="line">clear() <span class="comment">//删除全部字符</span></span><br><span class="line"></span><br><span class="line">replace() <span class="comment">//替换字符</span></span><br><span class="line"></span><br><span class="line">+ <span class="comment">//串联字符串</span></span><br><span class="line"></span><br><span class="line">==,!=,&lt;,&lt;=,&gt;,&gt;=,compare()    <span class="comment">//比较字符串</span></span><br><span class="line"></span><br><span class="line">size(),length()    <span class="comment">//返回字符数量</span></span><br><span class="line"></span><br><span class="line">max_size() <span class="comment">//返回字符的可能最大个数</span></span><br><span class="line"></span><br><span class="line">empty()    <span class="comment">//判断字符串是否为空</span></span><br><span class="line"></span><br><span class="line">capacity() <span class="comment">//返回重新分配之前的字符容量</span></span><br><span class="line"></span><br><span class="line">reserve() <span class="comment">//保留一定量内存以容纳一定数量的字符</span></span><br><span class="line"></span><br><span class="line">[ ], at() <span class="comment">//存取单一字符</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;,getline() <span class="comment">//从stream读取某值</span></span><br><span class="line"></span><br><span class="line">&lt;&lt;    <span class="comment">//将谋值写入stream</span></span><br><span class="line"></span><br><span class="line">copy() <span class="comment">//将某值赋值为一个C_string</span></span><br><span class="line"></span><br><span class="line">c_str() <span class="comment">//将内容以C_string返回</span></span><br><span class="line"></span><br><span class="line">data() <span class="comment">//将内容以字符数组形式返回</span></span><br><span class="line"></span><br><span class="line">substr() <span class="comment">//返回某个子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找函数</span></span><br><span class="line">begin() end() <span class="comment">//提供类似STL的迭代器支持</span></span><br><span class="line">rbegin() rend() <span class="comment">//逆向迭代器</span></span><br><span class="line">get_allocator() <span class="comment">//返回配置器</span></span><br></pre></td></tr></table></figure><h2 id="C-字符串和C字符串的转换"><a href="#C-字符串和C字符串的转换" class="headerlink" title="C++字符串和C字符串的转换"></a>C++字符串和C字符串的转换</h2><p>C ++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，</p><blockquote><ul><li>data()以字符数组的形式返回字符串内容，但并不添加’/0’。</li><li>c_str()返回一个以‘/0’结尾的字符数组</li><li>copy()则把字符串的内容复制或写入既有的c_string或 字符数组内。</li></ul></blockquote><p>C++字符串并不以’/0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。  </p><h2 id="string的大小和容量"><a href="#string的大小和容量" class="headerlink" title="string的大小和容量"></a>string的大小和容量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">empty() <span class="comment">//判断字符串是否为空</span></span><br><span class="line">    </span><br><span class="line">size()、length()<span class="comment">//返回string对象的字符个数，他们执行效果相同。</span></span><br><span class="line"></span><br><span class="line">max_size()     <span class="comment">//返回string对象最多包含的字符数，超出会抛出length_error异常</span></span><br><span class="line"></span><br><span class="line">capacity()     <span class="comment">//重新分配内存之前，string对象能包含的最大字符数</span></span><br></pre></td></tr></table></figure><h2 id="string的字符串比较"><a href="#string的字符串比较" class="headerlink" title="string的字符串比较"></a>string的字符串比较</h2><p>C ++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。</p><p>另一个功能强大的比较函数是成员函数compare()，他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (A的ASCII码是65，a的ASCII码是97)</span></span><br><span class="line">    <span class="comment">// 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">A</span><span class="params">(<span class="string">"aBcd"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">B</span><span class="params">(<span class="string">"Abcd"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">C</span><span class="params">(<span class="string">"123456"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">D</span><span class="params">(<span class="string">"123dfg"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "aBcd" 和 "Abcd"比较------ a &gt; A</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A.compare(B)："</span> &lt;&lt; A.compare(B)&lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// "cd" 和 "Abcd"比较------- c &gt; A</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A.compare(2, 3, B):"</span> &lt;&lt;A.compare(<span class="number">2</span>, <span class="number">3</span>, B)&lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// "cd" 和 "cd"比较 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A.compare(2, 3, B, 2, 3):"</span> &lt;&lt; A.compare(<span class="number">2</span>, <span class="number">3</span>, B, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由结果看出来：0表示下标，3表示长度</span></span><br><span class="line">    <span class="comment">// "123" 和 "123"比较 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C.compare(0, 3, D, 0, 3)"</span> &lt;&lt;C.compare(<span class="number">0</span>, <span class="number">3</span>, D, <span class="number">0</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string的插入与删除"><a href="#string的插入与删除" class="headerlink" title="string的插入与删除"></a>string的插入与删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator p)</span></span>;<span class="comment">//删除字符串中p所指的字符</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;<span class="comment">//删除字符串中迭代器区间[first,last)上所有字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span></span>;<span class="comment">//删除字符串中从索引位置pos开始的len个字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//删除字符串中所有字符</span></span><br></pre></td></tr></table></figure><h2 id="string拼接字符串：append-amp-操作符"><a href="#string拼接字符串：append-amp-操作符" class="headerlink" title="string拼接字符串：append() &amp; + 操作符"></a>string拼接字符串：append() &amp; + 操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s+=str;<span class="comment">//加个字符串</span></span><br><span class="line">s+=”my name is jiayp”;<span class="comment">//加个C字符串</span></span><br><span class="line">s+=<span class="string">'a'</span>;<span class="comment">//加个字符</span></span><br><span class="line">s.append(str);</span><br><span class="line">s.append(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//不解释了 同前面的函数参数assign的解释</span></span><br><span class="line">s.append(str,<span class="number">2</span>,<span class="built_in">string</span>::npos)<span class="comment">//把字符串str从索引值2开始到结尾拼接到s尾</span></span><br><span class="line">s.append(“my name is jiayp”);</span><br><span class="line">s.append(“nico”,<span class="number">5</span>)<span class="comment">//把'n' ‘I' ‘c' ‘o' ‘/0'拼接到s尾</span></span><br><span class="line">s.append(<span class="number">5</span>,<span class="string">'x'</span>)<span class="comment">//把五个x拼接到s尾</span></span><br><span class="line">s.push_back(‘a');<span class="comment">//这个函数只能增加单个字符</span></span><br></pre></td></tr></table></figure><h2 id="string的字符替换"><a href="#string的字符替换" class="headerlink" title="string的字符替换"></a>string的字符替换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//将当前字符串从pos索引开始的n个字符，替换成字符串s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n, <span class="keyword">size_t</span> n1, <span class="keyword">char</span> c)</span></span>; <span class="comment">//将当前字符串从pos索引开始的n个字符，替换成n1个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>;<span class="comment">//将当前字符串[i1,i2)区间中的字符串替换为字符串s</span></span><br></pre></td></tr></table></figure><h2 id="string查找：find"><a href="#string查找：find" class="headerlink" title="string查找：find"></a>string查找：find</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符c在当前字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s在当前串中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s中前n个字符在当前串中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s在当前串中的位置</span></span><br><span class="line"><span class="comment">//查找成功时返回所在位置，失败返回string::npos的值</span></span><br></pre></td></tr></table></figure><h2 id="string的排序：sort-s-begin-s-end"><a href="#string的排序：sort-s-begin-s-end" class="headerlink" title="string的排序：sort(s.begin(),s.end())"></a>string的排序：sort(s.begin(),s.end())</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"cdefba"</span>;</span><br><span class="line">    sort(s.begin(),s.end());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"s:"</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">// 结果：abcdef</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string类的迭代器处理"><a href="#string类的迭代器处理" class="headerlink" title="string类的迭代器处理"></a>string类的迭代器处理</h2><p>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。</p><p>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;                <span class="comment">//返回string的起始位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;                    <span class="comment">//返回string的最后一个字符后面的位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">rbegin</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">rbegin</span><span class="params">()</span></span>;                <span class="comment">//返回string的最后一个字符的位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">rend</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">rend</span><span class="params">()</span></span>;                    <span class="comment">//返回string第一个字符位置的前面</span></span><br><span class="line">rbegin和rend用于从后向前的迭代访问，通过设置迭代器<span class="built_in">string</span>::reverse_iterator,<span class="built_in">string</span>::const_reverse_iterator实现</span><br></pre></td></tr></table></figure><h2 id="字符串流处理"><a href="#字符串流处理" class="headerlink" title="字符串流处理"></a>字符串流处理</h2><p>通过定义ostringstream和istringstream变量实现，&lt; sstream&gt;头文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">input</span><span class="params">(<span class="string">"hello,this is a test"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(input)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3,s4;</span><br><span class="line">is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;<span class="comment">//s1="hello,this",s2="is",s3="a",s4="test"</span></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line">os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;os.str();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;C++处理字符串的方式有两种&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;来自c语言，常称为C-风格字符串&lt;br&gt;可以将字符串存储在char数组中，C-风格字符串特殊性质：以空字符（\0)结尾，用来标记字符串的结尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于string类型库的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;strin类使用简单， 提供了将字符串作为一种数据类型的表示方法&lt;/p&gt;&lt;p&gt;  为了在我们的程序中使用string类型，我们必须包含头文件 &amp;lt; string&amp;gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>50.第一次只出现一次的字符</title>
    <link href="https://xiao-hu.com.cn/2019/11/17/50-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>https://xiao-hu.com.cn/2019/11/17/50-第一次只出现一次的字符/</id>
    <published>2019-11-17T12:23:33.000Z</published>
    <updated>2019-11-17T12:25:03.320Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>49.丑数</title>
    <link href="https://xiao-hu.com.cn/2019/11/17/49-%E4%B8%91%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/11/17/49-丑数/</id>
    <published>2019-11-17T11:20:10.000Z</published>
    <updated>2019-11-17T12:22:09.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>法1：</p><p>超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;index&gt;<span class="number">0</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j=i;</span><br><span class="line">            <span class="keyword">while</span>(j%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                j/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(j%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                j/=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span>(j%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">                j/=<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)</span><br><span class="line">                index--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>法2：</p><p>创建数组保存已经找到的丑数，用空间换时间，不需要在非丑数的整数上计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(index);</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> UglyNumber_2=<span class="number">0</span>,UglyNumber_3=<span class="number">0</span>,UglyNumber_5=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//res[i]=Min(res[UglyNumber_2]*2,res[UglyNumber_3]*3,res[UglyNumber_5]*5);</span></span><br><span class="line">            res[i]=min(min(res[UglyNumber_2]*<span class="number">2</span>,res[UglyNumber_3]*<span class="number">3</span>),min(res[UglyNumber_3]*<span class="number">3</span>,res[UglyNumber_5]*<span class="number">5</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(res[i]==res[UglyNumber_2]*<span class="number">2</span>)</span><br><span class="line">                UglyNumber_2++;</span><br><span class="line">            <span class="keyword">if</span>(res[i]==res[UglyNumber_3]*<span class="number">3</span>)</span><br><span class="line">                UglyNumber_3++;</span><br><span class="line">            <span class="keyword">if</span>(res[i]==res[UglyNumber_5]*<span class="number">5</span>)</span><br><span class="line">                UglyNumber_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[index<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    int Min(int number1,int number2,int number3)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        int min=(number1&lt;number2)?number1:number2;</span></span><br><span class="line"><span class="comment">//        min=(min&lt;number3)?min:number3;</span></span><br><span class="line"><span class="comment">//        return min;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。&lt;/p&gt;&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;p&gt;法1：&lt;/p&gt;&lt;p&gt;超时&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetUglyNumber_Solution&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(index&amp;lt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i,j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;index&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(j%&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j/=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(j%&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j/=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(j%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j/=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(j==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                index--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 学习（8）——数字转字符串</title>
    <link href="https://xiao-hu.com.cn/2019/11/17/C-%E5%AD%A6%E4%B9%A0%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://xiao-hu.com.cn/2019/11/17/C-学习（8）——数字转字符串/</id>
    <published>2019-11-17T11:09:19.000Z</published>
    <updated>2019-11-17T11:09:49.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="std-stringstream"><a href="#std-stringstream" class="headerlink" title="std::stringstream"></a>std::stringstream</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; <span class="number">1.23</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> aaa = ss.str();</span><br></pre></td></tr></table></figure><h1 id="std-to-string"><a href="#std-to-string" class="headerlink" title="std::to_string"></a>std::to_string</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> aaa = <span class="built_in">std</span>::to_string(<span class="number">1.23</span>);</span><br></pre></td></tr></table></figure><h1 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h1><p>头文件：stdio.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [argument]…)</span></span></span><br></pre></td></tr></table></figure></p><a id="more"></a><ul><li><p>参数：</p><p>1.buffer：是char类型的指针，指向写入的字符串指针；<br>2.format：格式化字符串，即在程序中想要的格式；<br>3.argument：可选参数，可以为任意类型的数据；</p></li><li>函数返回值：buffer指向的字符串的长度</li></ul><p>eg:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d"</span>,<span class="number">1.23</span>);</span><br></pre></td></tr></table></figure><br>效率方面：C风格的sprintf因为没有动态内存分配，效率最高。std::to_string其次，最差的是std::stringstream。</p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;std-stringstream&quot;&gt;&lt;a href=&quot;#std-stringstream&quot; class=&quot;headerlink&quot; title=&quot;std::stringstream&quot;&gt;&lt;/a&gt;std::stringstream&lt;/h1&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;stringstream&lt;/span&gt; ss;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ss &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1.23&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; aaa = ss.str();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&quot;std-to-string&quot;&gt;&lt;a href=&quot;#std-to-string&quot; class=&quot;headerlink&quot; title=&quot;std::to_string&quot;&gt;&lt;/a&gt;std::to_string&lt;/h1&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; aaa = &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::to_string(&lt;span class=&quot;number&quot;&gt;1.23&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&quot;sprintf&quot;&gt;&lt;a href=&quot;#sprintf&quot; class=&quot;headerlink&quot; title=&quot;sprintf&quot;&gt;&lt;/a&gt;sprintf&lt;/h1&gt;&lt;p&gt;头文件：stdio.h&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *buffer, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, [argument]…)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 学习（7）——char * ,char ** ,char a[ ] ,char *a[] 的区别</title>
    <link href="https://xiao-hu.com.cn/2019/11/17/C-%E5%AD%A6%E4%B9%A0%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94char-char-char-a-char-a-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://xiao-hu.com.cn/2019/11/17/C-学习（7）——char-char-char-a-char-a-的区别/</id>
    <published>2019-11-17T07:44:43.000Z</published>
    <updated>2019-11-17T08:11:38.041Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑，因此，刻意再次深入探究了指针和数组这玩意儿，其他类型的数组比较简单，容易混淆的是字符数组和字符指针这两个。</p><h1 id="1-数组的本质"><a href="#1-数组的本质" class="headerlink" title="1.数组的本质"></a>1.数组的本质</h1><p>数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。。</p><a id="more"></a><h1 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h1><p>指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址。。由于地址也是整数，在64位平台下，指针默认为8位。(32位平台下，指针默认为4位)</p><h1 id="3-指针的指向"><a href="#3-指针的指向" class="headerlink" title="3.指针的指向"></a>3.指针的指向</h1><p>指向的直接意思就是指针变量所保存的其他的地址单元中所存放的数据类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  * p ;<span class="comment">//p 变量保存的地址所在内存单元中的数据类型为整型</span></span><br><span class="line"><span class="keyword">float</span> *q;<span class="comment">// q变量保存的地址所在内存单元中的数据类型为浮点型</span></span><br></pre></td></tr></table></figure><p>不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的地址。</p><p><strong>字符串赋给一个指针变量</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>  *s ;</span><br><span class="line">s = <span class="string">"China"</span>;</span><br></pre></td></tr></table></figure></p><h1 id="4-字符数组"><a href="#4-字符数组" class="headerlink" title="4.字符数组"></a>4.字符数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>  str[<span class="number">10</span>]; <span class="comment">//定义了一个有十个元素的数组，元素类型为字符</span></span><br><span class="line"><span class="keyword">char</span>  str[<span class="number">10</span>] = &#123;<span class="string">"hello world"</span>&#125;;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><p>C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了。<br>C语言中字符串常量的本质表示其实是一个地址，规定数组代表数组所在内存位置的首地址，也是 str[0]的地址，即str = &amp;str[0];</p><h1 id="5-char-与-char-a"><a href="#5-char-与-char-a" class="headerlink" title="5.char *  与 char  a[ ]"></a>5.char *  与 char  a[ ]</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>  *s;</span><br><span class="line"><span class="keyword">char</span>  a[ ] ;</span><br></pre></td></tr></table></figure><p>a代表字符串的首地址，而s 这个指针也保存字符串的地址（其实首地址），即第一个字符的地址，这个地址单元中的数据是一个字符，</p><p>可以 s = a;但不能 a = s;</p><p>C语言中数组名可以复制给指针表示地址， 但是却不能赋给给数组名，它是一个常量类型，所以不能修改。。</p><pre><code>   当然也可以这样:</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>  a [ ] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *s =a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a) ; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i]);</span><br><span class="line"><span class="comment">//  printf("%c",*s++)</span></span><br></pre></td></tr></table></figure><p>字符指针可以用间接操作符$<em>$取其内容，也可以用数组的下标形式 [ ]，数组名也可以用 </em>操作，因为它本身表示一个地址 。。<br>比如 printf(“%c”,*a);  将会打印出 ‘h’</p><p><strong>char * 与 char a[ ] 的本质区别：</strong></p><blockquote><p>当定义 char a[10 ]  时，编译器会给数组分配十个单元，每个单元的数据类型为字符。。<br>定义 char *s 时，  这是个指针变量，只占四个字节，32位，用来保存一个地址。。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">10</span> ；</span><br><span class="line"><span class="keyword">sizeof</span>(s)  = <span class="number">4</span>；<span class="comment">//编译器分配4个字节32位的空间，这个空间中将要保存地址</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>,s);<span class="comment">//表示 s 的单元中所保存的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>,&amp;s);<span class="comment">//表示变量本身所在内存单元地址</span></span><br></pre></td></tr></table></figure><p>一句话来概括，就是 $char <em>s$ 只是一个保存字符串首地址的指针变量， char a[ ] 是许多连续的内存单元，单元中的元素为char ，<br>之所以用 $char </em>$能达到char a  [ ] 的效果，还是字符串的本质，地址，即给你一个字符串地址，便可以随心所欲的操所他。但是，char* 和 char a[ ] 的本质属性是不一样的。。</p><p>​    </p><h1 id="6-char-与char-a"><a href="#6-char-与char-a" class="headerlink" title="6.char *  与char   a[ ] ;"></a>6.char <em>*  与char  </em> a[ ] ;</h1><ul><li>char  *a [ ]</li></ul><p>由于[ ] 的优先级高于<em> 所以a先和 [ ]结合，他还是一个数组，数组中的元素才是char </em> ，前面讲到char * 是一个变量，保存的地址。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a[ ] = &#123;<span class="string">"China"</span>,<span class="string">"French"</span>,<span class="string">"America"</span>,<span class="string">"German"</span>&#125;；</span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">32</span>；</span><br></pre></td></tr></table></figure><p>字符串常量的本质是地址，a 数组中的元素为char * 指针，指针变量占四个字节，那么四个元素就是32个字节了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *a [ ] = &#123;<span class="string">"China"</span>,<span class="string">"French"</span>,<span class="string">"America"</span>,<span class="string">"German"</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p %p %p %p\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191117152702126.png#pic_center"><br>可以看到数组中的四个元素保存了四个内存地址，这四个地址中就代表了四个字符串的首地址，而不是字符串本身。四个地址不是连续的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a [ ] = &#123;<span class="string">"China"</span>,<span class="string">"French"</span>,<span class="string">"America"</span>,<span class="string">"German"</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p %p %p %p\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]); <span class="comment">//数组元素中保存的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p %p %p %p\n"</span>,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>],&amp;a[<span class="number">3</span>]);<span class="comment">//数组元素单元本身的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191117153403458.png#pic_center"><br>0x7fff2258ff70 0x7fff2258ff78 0x7fff2258ff80 0x7fff2258ff88，这四个是元素单元所在的地址，每个地址相差8个字节，这是由于每个元素是一个指针变量占8个字节</p><ul><li>char s**</li></ul><blockquote><p>二级指针保存的是一级指针的地址，它的类型是指针变量，而一级指针保存的是指向数据所在的内存单元的地址，虽然都是地址，但是类型是不一样的</p></blockquote><p>在 char<em>* s 中，s 是一个指针，这个指针（s）指向一块内存地址，该内存地址中存储的是 char</em> 类型的数据。指针的加减运算在这里的体现为：a + 1 表示地址加8字节（在32位系统中，地址加4字节）。</p><p>char<em> 也是一个指针，用 </em>s 表示，这个指针（<em>s）指向一块内存地址，该内存地址中存储的是 char 类型的数据。指针的加减运算在这里的体现为：(</em>a) + 1 表示地址加1字节。</p><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/liitdar/article/details/80972088" target="_blank" rel="noopener">char<em>* a 和 char</em> a[] 介绍</a><br><a href="http://www.imooc.com/article/30475" target="_blank" rel="noopener">http://www.imooc.com/article/30475</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;C语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑，因此，刻意再次深入探究了指针和数组这玩意儿，其他类型的数组比较简单，容易混淆的是字符数组和字符指针这两个。&lt;/p&gt;&lt;h1 id=&quot;1-数组的本质&quot;&gt;&lt;a href=&quot;#1-数组的本质&quot; class=&quot;headerlink&quot; title=&quot;1.数组的本质&quot;&gt;&lt;/a&gt;1.数组的本质&lt;/h1&gt;&lt;p&gt;数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 学习（6）——new和malloc的区别</title>
    <link href="https://xiao-hu.com.cn/2019/11/17/C-%E5%AD%A6%E4%B9%A0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://xiao-hu.com.cn/2019/11/17/C-学习（6）——new和malloc的区别/</id>
    <published>2019-11-17T03:40:41.000Z</published>
    <updated>2019-11-17T06:30:36.938Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="new、malloc区分"><a href="#new、malloc区分" class="headerlink" title="new、malloc区分"></a>new、malloc区分</h1><ul><li><p>属性</p><p> new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。</p></li><li><p>参数</p><p> 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p></li><li><p>返回类型</p><p> new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void <em> ，需要通过强制类型转换将void</em>指针转换成我们需要的类型。</p></li><li><p>自定义类型</p><p> new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。<br>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>重载</p><p> C++允许重载new/delete操作符，malloc不允许重载。</p></li><li><p>内存区域</p><p>  new做两件事：分配内存和调用类的构造函数，delete是：调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。</p><p>  new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p><blockquote><p>堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，用完了要还给操作系统，要不然就是内存泄漏。<br>栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p></blockquote></li><li><p>分配失败</p><p>  new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p></li><li><p>内存泄漏</p><p>  内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。</p></li></ul><a id="more"></a><h1 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a>malloc和free</h1><ul><li><strong>malloc:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure><p>malloc 向系统申请分配指定size个字节的内存空间，返回类型是 void<em> 类型。void</em> 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。如果开辟失败，则返回NULL指针。</p><ul><li><strong>free</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>free函数是来释放动态开辟的内存的。malloc和free要配套使用，如果没有free则会造成内存泄漏。</p><h1 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h1><ul><li>规则<blockquote><p>1.new/delete是关键字，效率高于malloc和free。<br>2.配对使用，避免内存泄漏和多重释放。<br>3.避免交叉使用，比如malloc申请空间delete释放，new出的空间被free。<br>4.new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理</p></blockquote></li></ul><ul><li>new/new[] 用法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开辟单地址空间</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//开辟大小为sizeof(int)空间</span></span><br><span class="line"><span class="keyword">int</span> *q = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>); <span class="comment">//开辟大小为sizeof(int)的空间，并初始化为5。</span></span><br><span class="line"><span class="comment">//开辟数组空间</span></span><br><span class="line"><span class="comment">//一维</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]&#123;<span class="number">0</span>&#125;;<span class="comment">//开辟大小为100的整型数组空间，并初始化为0。</span></span><br><span class="line"><span class="comment">//二维</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"><span class="comment">//三维</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">5</span>][<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"><span class="comment">//四维及以上以此类推。</span></span><br></pre></td></tr></table></figure><ul><li>delete/delete[] 用法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放单个int空间</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="comment">//释放int数组空间</span></span><br><span class="line"><span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> []b;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;new、malloc区分&quot;&gt;&lt;a href=&quot;#new、malloc区分&quot; class=&quot;headerlink&quot; title=&quot;new、malloc区分&quot;&gt;&lt;/a&gt;new、malloc区分&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;属性&lt;/p&gt;
&lt;p&gt; new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt; 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回类型&lt;/p&gt;
&lt;p&gt; new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void &lt;em&gt; ，需要通过强制类型转换将void&lt;/em&gt;指针转换成我们需要的类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义类型&lt;/p&gt;
&lt;p&gt; new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。&lt;br&gt;malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重载&lt;/p&gt;
&lt;p&gt; C++允许重载new/delete操作符，malloc不允许重载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存区域&lt;/p&gt;
&lt;p&gt;  new做两件事：分配内存和调用类的构造函数，delete是：调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。&lt;/p&gt;
&lt;p&gt;  new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，用完了要还给操作系统，要不然就是内存泄漏。&lt;br&gt;栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分配失败&lt;/p&gt;
&lt;p&gt;  new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存泄漏&lt;/p&gt;
&lt;p&gt;  内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>45.把数组排成最小的数</title>
    <link href="https://xiao-hu.com.cn/2019/11/17/45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/11/17/45-把数组排成最小的数/</id>
    <published>2019-11-17T02:15:54.000Z</published>
    <updated>2019-11-17T11:15:51.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>把数字转换成字符串</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><a id="more"></a><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><p>把数字转换成字符串</p><h1 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h1><h2 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h2><p><strong>sort()函数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(begin, end, cmp)</span><br></pre></td></tr></table></figure></p><ul><li>参数<br>第一个是要排序的数组的起始地址。<br>第二个是结束的地址（最后一位要排序的地址）<br>第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            res += to_string(numbers[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A = to_string(a)+to_string(b);</span><br><span class="line">        <span class="built_in">string</span> B = to_string(b)+to_string(a);</span><br><span class="line">        <span class="keyword">return</span> A&lt;B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h2><p>c写的<br><strong>sprintf()函数</strong></p><ul><li><p>头文件：stdio.h</p></li><li><p>函数功能：格式化字符串，将格式化的数据写入字符串中。</p></li><li>函数原型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [argument]…)</span></span></span><br></pre></td></tr></table></figure></li><li><p>参数：</p><p>1.buffer：是char类型的指针，指向写入的字符串指针；<br>2.format：格式化字符串，即在程序中想要的格式；<br>3.argument：可选参数，可以为任意类型的数据；</p></li><li>函数返回值：buffer指向的字符串的长度</li><li><p>用处：<br>1.格式化数字字符串：在这点上sprintf和printf的用法一样，只是打印到的位置不同而已，前者打印给buffer字符串，后者打印给标准输出，所以sprintf也可以用来将整型转化为字符串，比itoa效率高且如此地简便~比如：sprintf(buffer, “%d”, 123456);执行后buffer即指向字符串“123456”~</p><p>2.连接字符</p></li></ul><p><strong>qsort()函数</strong><br>qsort函数(全称quicksort)，它是ANSIC标准中提供的，其声明在stdlib.h文件中，是根据二分法写的，其时间复杂度为$nlog(n)$<br>qsort要求提供一个自己定义的比较函数。比较函数使得qsort通用性更好，有了比较函数qsort可以实现对数组、字符串、结构体等结构进行升序或降序排序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nitems, <span class="keyword">size_t</span> size, <span class="keyword">int</span> (*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span>*))</span></span></span><br></pre></td></tr></table></figure></p><ul><li><p>参数</p><p>  base — 指向要排序的数组的第一个元素的指针。<br>  nitems — 由 base 指向的数组中元素的个数。<br>  size — 数组中每个元素的大小，以字节为单位。<br>  compar — 用来比较两个元素的函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNumber1, <span class="keyword">const</span> <span class="keyword">void</span>* strNumber2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int型整数用十进制表示最多只有10位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_MaxNumberLength = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span>* g_StrCombine1 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* g_StrCombine2 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span>** strNumbers = (<span class="keyword">char</span>**)(<span class="keyword">new</span> <span class="keyword">int</span>[length]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        strNumbers[i] = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(strNumbers[i], <span class="string">"%d"</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    qsort(strNumbers, length, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*), compare);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strNumbers[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] strNumbers[i];</span><br><span class="line">    <span class="keyword">delete</span>[] strNumbers;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &gt; [strNumber2][strNumber1], 返回值大于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &lt; [strNumber2][strNumber1], 返回值小于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNumber1, <span class="keyword">const</span> <span class="keyword">void</span>* strNumber2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [strNumber1][strNumber2]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// [strNumber2][strNumber1]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(g_StrCombine1, g_StrCombine2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;把数字转换成字符串&lt;/p&gt;&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;h1 id=&quot;题目描述-1&quot;&gt;&lt;a href=&quot;#题目描述-1&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>43.1~n整数中1出现的次数</title>
    <link href="https://xiao-hu.com.cn/2019/11/16/43-1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/11/16/43-1-n整数中1出现的次数/</id>
    <published>2019-11-16T02:12:17.000Z</published>
    <updated>2019-11-16T03:20:49.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>法1：</p><p>时间复杂度：$O(nlog n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            i=j;</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i/=<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">                    count+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法2：</p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>42.连续子数组的最大和</title>
    <link href="https://xiao-hu.com.cn/2019/11/16/42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>https://xiao-hu.com.cn/2019/11/16/42-连续子数组的最大和/</id>
    <published>2019-11-16T01:31:03.000Z</published>
    <updated>2019-11-16T02:11:22.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>法1：</strong></p><p>时间复杂度：$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> thisSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&gt;maxSum)</span><br><span class="line">                maxSum=<span class="built_in">array</span>[i];<span class="comment">//考虑都为负数</span></span><br><span class="line">                </span><br><span class="line">            thisSum+=<span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(thisSum&gt;maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum=thisSum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(thisSum&lt;<span class="number">0</span>)</span><br><span class="line">                thisSum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法2：</strong></p><p><strong>动态规划</strong></p><ul><li><p>1：令状态 dp[i] 表示以 A[i] 作为末尾的连续序列的最大和（这里是说 A[i] 必须作为连续序列的末尾）。</p></li><li><p>2：做如下考虑：因为 dp[i] 要求是必须以 A[i] 结尾的连续序列，那么只有两种情况：</p><blockquote><p>这个最大和的连续序列只有一个元素，即以 A[i] 开始，以 A[i] 结尾，最大和就是 A[i] 本身。</p><p>这个最大和的连续序列有多个元素，即从前面某处 A[p] 开始 (p&lt;i)，一直到 A[i] 结尾，最大和是 dp[i-1]+A[i]。<br>得到<strong>状态转移方程</strong>：</p></blockquote></li></ul><p>　　　　　　　　<script type="math/tex">dp[i] = max(A[i], dp[i-1]+A[i])</script></p><p>时间复杂度：$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">int</span> maxSum;</span><br><span class="line">        dp.push_back(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i])&gt;<span class="built_in">array</span>[i])</span><br><span class="line">                dp.push_back(dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        maxSum=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;maxSum)</span><br><span class="line">                maxSum=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法c++(vector)实现</title>
    <link href="https://xiao-hu.com.cn/2019/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95c-vector-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xiao-hu.com.cn/2019/11/15/排序算法c-vector-实现/</id>
    <published>2019-11-15T02:40:41.000Z</published>
    <updated>2019-11-19T11:54:48.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115190306423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115190315308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>依次比较相邻两元素，若前一元素大于后一元素则交换之，直至最后一个元素即为最大；然后重新从首元素开始重复同样的操作，直至倒数第二个元素即为次大元素；依次类推。如同水中的气泡，依次将最大或最小元素气泡浮出水面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若flag为true说明有过数据交换，否则停止循环</span></span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size() &amp;&amp; flag;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v.size()<span class="number">-2</span>;j&gt;=i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j]&gt;v[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(v[j],v[j+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115111755847.png#pic_center"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想：任取一个数据元素作为基准，做一次划分，讲所有数据元素集合分成3部分；中间部分值包含一个基准元素，它的前面包含所有关键字小于基准的数据元素，它的后面包含所有关键字大于基础的数据元素，然后分别对前后两部分进行划分。</p><p>对数据元素$v_1~v_n$做一趟划分，不失一般性，选择第一个元素作为基准元素，用t代表基准。设i=1，j=n,划分过程如下：</p><ul><li>1.比较基准元素与第j个元素$a_j$，如果$a_j$&gt;t，则j-  -；继续步骤1；如果$a_j&lt;t$，则将$a_j$移到i的位置，i=i+1转步骤2。</li><li>2.比较基准元素与第i个元素$a_i$，如果$a_j$<t，则i++；继续步骤2；如果$a_i>t$，则将$a_i$移到j的位置，j=j+1转步骤3。</t，则i++；继续步骤2；如果$a_i></li><li>3.重复步骤1和2，直到i=j，将基准元素放到i的位置。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    pivot=v[low];<span class="comment">//用子表的第一个记录作枢轴记录</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; v[high]&gt;=pivot)</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            v[low]=v[high];</span><br><span class="line">            low++;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; v[low]&lt;=pivot)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">            &#123;</span><br><span class="line">                v[high]=v[low];</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    v[low]=pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        i=Partition(v,low,high);</span><br><span class="line">        quickSort(v,low,i<span class="number">-1</span>);</span><br><span class="line">        quickSort(v,i+<span class="number">1</span>,high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=v.size();</span><br><span class="line"></span><br><span class="line">    quickSort(v,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    pivot=v[low];<span class="comment">//用子表的第一个记录作枢轴记录</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; v[high]&gt;=pivot)</span><br><span class="line">            high--;</span><br><span class="line">        swap(v[low],v[high]);<span class="comment">//high指示的值小于pivot，交换</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; v[low]&lt;=pivot)</span><br><span class="line">            low++;</span><br><span class="line">        swap(v[low],v[high]);<span class="comment">//low指示的值大于pivot，交换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        i=Partition(v,low,high);</span><br><span class="line">        quickSort(v,low,i<span class="number">-1</span>);</span><br><span class="line">        quickSort(v,i+<span class="number">1</span>,high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=v.size();</span><br><span class="line"></span><br><span class="line">    quickSort(v,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115183209723.png#pic_center"></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min_index=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;v.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[min_index]&gt;v[j])<span class="comment">//如果有小于当前最小值的关键字</span></span><br><span class="line">                min_index=j;<span class="comment">//将此关键字的下标赋值给min_index</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_index!=i)</span><br><span class="line">            swap(v[min_index],v[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    SelectSort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115112308379.png#pic_center"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap, <span class="keyword">int</span> size, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u, left = u * <span class="number">2</span>, right = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= size &amp;&amp; heap[left] &gt; heap[t])</span><br><span class="line">        t = left;</span><br><span class="line">    <span class="keyword">if</span>(right &lt;= size &amp;&amp; heap[right] &gt; heap[t])</span><br><span class="line">        t = right;</span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        swap(heap[u], heap[t]);</span><br><span class="line">        push_down(heap, size, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; heap[u / <span class="number">2</span>] &lt; heap[u])&#123;</span><br><span class="line">        swap(heap[u / <span class="number">2</span>], heap[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        push_up(q, i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        swap(q[<span class="number">1</span>], q[size]);</span><br><span class="line">        size--;</span><br><span class="line">        push_down(q, size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=v.size();</span><br><span class="line">    heapSort(v, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115185543385.png#pic_center"></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>数列前面部分看为有序，依次将后面的无序数列元素插入到前面的有序数列中，初始状态有序数列仅有一个元素，即首元素。在将无序数列元素插入有序数列的过程中，采用了逆序遍历有序数列，相较于顺序遍历会稍显繁琐，但当数列本身已近排序状态效率会更高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;v.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=v[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;v[j];j--)</span><br><span class="line">            v[j+<span class="number">1</span>]=v[j];<span class="comment">//后移一位</span></span><br><span class="line"></span><br><span class="line">        v[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">    InsertSort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019111515241373.png"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的基本思想如下:选定一个增量$h_1 (h_1&lt;n)$，把序列中的数据元素从第1个开始分组，所有相距$h_1$的数据元素分为一组，一共有$h_1$组， 并在各组内采用直接插入提序，使各组内的数据元素排好序，然后选第个增量$h_2(h_2&lt;h_1)$，以$h_2$为距离对数据元素进行分组及排序；重复该分组及排序过程，知道增量为1。<br>希尔排序的性能取决于增量序列的选择。希尔提出取$h_2=n/2,h_{i-1}=[\frac{h_i}{2}]$。Knuth提出取$h_2=n/2,h_{i-1}=[\frac{h_i}{3}]$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> increment=v.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(increment)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=increment;i&lt;v.size();i+=<span class="number">1</span>)<span class="comment">//对各子表做直接插入排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=v[i], j;</span><br><span class="line">            <span class="keyword">for</span>(j=i-increment;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;v[j];j-=increment)</span><br><span class="line">            &#123;</span><br><span class="line">                v[j+increment]=v[j];</span><br><span class="line">            &#125;</span><br><span class="line">            v[j+increment]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        increment/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ShellSort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019111518311827.png#pic_center"></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(q, l, mid);</span><br><span class="line">    mergeSort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w;</span><br><span class="line">    w.clear();</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &gt; q[j])</span><br><span class="line">            w.push_back(q[j++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w.push_back(q[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        w.push_back(q[i++]);</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= mid)</span><br><span class="line">        w.push_back(q[j++]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : w)</span><br><span class="line">        q[l++] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=v.size();</span><br><span class="line">    mergeSort(v, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115190126906.png#pic_center"></p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            cnt[j].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cnt[get(q[j], i)].push_back(q[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : cnt[j])</span><br><span class="line">                q[k++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=v.size();</span><br><span class="line">    radixSort(v, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115185843674.png#pic_center"></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191115190306423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center&quot;&gt;&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191115190315308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center&quot;&gt;&lt;/p&gt;&lt;h1 id=&quot;交换排序&quot;&gt;&lt;a href=&quot;#交换排序&quot; class=&quot;headerlink&quot; title=&quot;交换排序&quot;&gt;&lt;/a&gt;交换排序&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;依次比较相邻两元素，若前一元素大于后一元素则交换之，直至最后一个元素即为最大；然后重新从首元素开始重复同样的操作，直至倒数第二个元素即为次大元素；依次类推。如同水中的气泡，依次将最大或最小元素气泡浮出水面。&lt;/p&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubblesort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;amp;v)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//若flag为true说明有过数据交换，否则停止循环&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; flag=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;v.size() &amp;amp;&amp;amp; flag;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flag=&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=v.size()&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;;j&amp;gt;=i;j--)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(v[j]&amp;gt;v[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                swap(v[j],v[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                flag=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; v&amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;35&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;47&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;36&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;46&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bubblesort(v);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; x:v)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Data Structures and Algorithms" scheme="https://xiao-hu.com.cn/categories/Data-Structures-and-Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>40.最小的K个数</title>
    <link href="https://xiao-hu.com.cn/2019/11/15/40-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/11/15/40-最小的K个数/</id>
    <published>2019-11-15T01:10:27.000Z</published>
    <updated>2019-11-15T01:13:02.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>法1：</p><p>时间复杂度：O(n^2)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 学习(6)——哈希表(unordered_map)</title>
    <link href="https://xiao-hu.com.cn/2019/11/14/C-%E5%AD%A6%E4%B9%A0-6-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8-unordered-map/"/>
    <id>https://xiao-hu.com.cn/2019/11/14/C-学习-6-——哈希表-unordered-map/</id>
    <published>2019-11-14T07:01:01.000Z</published>
    <updated>2019-11-14T07:01:01.293Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>38.字符串的排列</title>
    <link href="https://xiao-hu.com.cn/2019/11/12/38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>https://xiao-hu.com.cn/2019/11/12/38.字符串的排列/</id>
    <published>2019-11-12T07:00:26.000Z</published>
    <updated>2019-11-12T08:01:54.603Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、求得所有可能出现在第一个位置上的字符，将第一个位子上的字符与后面的交换</p><p>2、固定第一个字符，求后面字符的排列，就涉及递归的问题了</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        Permutations(result,str,<span class="number">0</span>,len);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Permutations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result,<span class="built_in">string</span> str,<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==len)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(str);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=index &amp;&amp; str[i]==str[index])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                swap(str[i],str[index]);</span><br><span class="line">                Permutations(result,str,index+<span class="number">1</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;1、求得所有可能出现在第一个位置上的字符，将第一个位子上的字符与后面的交换&lt;/p&gt;&lt;p&gt;2、固定第一个字符，求后面字符的排列，就涉及递归的问题了&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>39-数组中出现次数超过一半的数字</title>
    <link href="https://xiao-hu.com.cn/2019/11/12/39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://xiao-hu.com.cn/2019/11/12/39-数组中出现次数超过一半的数字/</id>
    <published>2019-11-12T07:00:26.000Z</published>
    <updated>2019-11-15T01:11:41.506Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li>法1</li></ul><p>时间复杂度：$O(n^2)$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int <span class="built_in">length</span>=numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="built_in">length</span><span class="number">-2</span>;<span class="built_in">j</span>&gt;=<span class="built_in">i</span>;<span class="built_in">j</span>--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[<span class="built_in">j</span>]&gt;numbers[<span class="built_in">j</span>+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    int temp=numbers[<span class="built_in">j</span>+<span class="number">1</span>];</span><br><span class="line">                    numbers[<span class="built_in">j</span>+<span class="number">1</span>]=numbers[<span class="built_in">j</span>];</span><br><span class="line">                    numbers[<span class="built_in">j</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int times=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[<span class="built_in">i</span>]==numbers[<span class="built_in">length</span>/<span class="number">2</span>])</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&gt;<span class="built_in">length</span>)</span><br><span class="line">            <span class="keyword">return</span>  numbers[<span class="built_in">length</span>/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>法2</li></ul><p>时间复杂度：$O(nlogn)$</p><ul><li>法3</li></ul><p>时间复杂度：$O(n)$</p><p>遍历数组时保存连个值，一个是数组中的数字，一个是出现的次数，遍历到一个数字时，如果该数字和之前保存的数字相同，则次数加一，如果该数字和之前保存的数字不同，则次数减一，如果次数为零，遍历下一个数组元素，并把次数设为一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> length=numbers.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(times==<span class="number">0</span>)<span class="comment">//该数字已经被自减到0 肯定不是所找的数，换下一个数组元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                result=numbers[i];</span><br><span class="line">                times=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i]==result)</span><br><span class="line">                times++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                times--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// verify whether the input is valid</span></span><br><span class="line">        times=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[j]==result)</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&gt;length)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。&lt;/p&gt;&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;法1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;时间复杂度：$O(n^2)$&lt;/p&gt;&lt;figure class=&quot;highlight matlab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int MoreThanHalfNum_Solution(vector&amp;lt;int&amp;gt; numbers) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(numbers.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int &lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;=numbers.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(int &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;;&lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(int &lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;=&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;;&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;&amp;gt;=&lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;;&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;--)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(numbers[&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;]&amp;gt;numbers[&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    int temp=numbers[&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    numbers[&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=numbers[&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    numbers[&lt;span class=&quot;built_in&quot;&gt;j&lt;/span&gt;]=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int times=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(int &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;;&lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(numbers[&lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;]==numbers[&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                times++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(times*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;gt;&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;  numbers[&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 学习（5）——多线程</title>
    <link href="https://xiao-hu.com.cn/2019/11/10/C-%E5%AD%A6%E4%B9%A0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xiao-hu.com.cn/2019/11/10/C-学习（5）——多线程/</id>
    <published>2019-11-10T02:43:09.000Z</published>
    <updated>2019-11-10T08:09:13.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h1><p>mutex是多线程编程时经常用到的，在C++11中需要包含<mutex>模块。而在该文件中还有其他和mutex协作的类和函数，使得多线程编程时非常方便。</mutex></p><h2 id="mutex类"><a href="#mutex类" class="headerlink" title="mutex类"></a>mutex类</h2><p>mutex对象是一个lockable的对象，当关键区域需要被互斥访问的时候被用来当作信号。mutex对象提供互斥的拥有权限，并且不支持递归。</p><p>实际就是mutex是用来进行线程同步的。常用的成员函数有lock()和unlock()</p><a id="more"></a><p><strong>lcok()</strong></p><p>调用该函数后，调用函数会锁定mutex，在有些情况下调用函数会阻塞。<br>1、如果mutex当前没有被任何其他线程locked，则调用线程lock这个mutex对象（从此刻到直到其成员函数unlock被调用，当前线程拥有mutex对象）。<br>2、如果mutex目前被其他线程locked，则当前线程阻塞直到mutex被其他线程unlock。<br>3、如果mutex目前被当前线程lock，则会产生死锁错误。大部分情况会崩溃，因为mutex不支持递归。</p><p><strong>unlock()</strong></p><p>unlock mutex对象，释放mutex对象的所有权。通常和lock成对使用。<br>调用该函数后，如果有其他线程因为lock同一个mutex对象而阻塞，则他们中的一个会获得mutex的所有权，从而继续执行。</p><p>不使用mutex同步的情况下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread1 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread2 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">t1.detach();</span><br><span class="line">t2.detach();</span><br><span class="line"></span><br><span class="line">this_thread::sleep_for(chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cout是标准输出的接口，所以两个线程同时输出的时候会对cout进行抢占，而两个线程并没有对cout进行同步，所以可能会出现输出错乱的情况。输出结果如下：</strong></p><p><img alt="1573373150246" data-src="/home/xiaohu/.config/Typora/typora-user-images/1573373150246.png"></p><p>使用mutex对cout进行互斥访问，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread1 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread2 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">    t1.detach();</span><br><span class="line">    t2.detach();</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出比较工整了，因为我们对cout作了访问保护，当一个线程输出的时候，另一个线程是不能输出的，只有当一个线程输出完毕了，另一个线程才能输出。而这一切是通过mutex来实现的。</p><p><img alt="1573373275431" data-src="/home/xiaohu/.config/Typora/typora-user-images/1573373275431.png"></p><p><a href="https://blog.csdn.net/coolwriter/article/details/79883253" target="_blank" rel="noopener">C++多线程（一）thread类</a></p><p><a href="https://blog.csdn.net/coolwriter/article/details/79884298" target="_blank" rel="noopener">c++ 多线线程（二）-mutex</a></p><p><a href="https://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="noopener">C++11 并发指南系列</a></p><p><a href="https://www.cnblogs.com/haippy/p/3236136.html" target="_blank" rel="noopener">C++11 并发指南二(std::thread 详解)</a></p><p><a href="https://www.cnblogs.com/haippy/p/3237213.html" target="_blank" rel="noopener">C++11 并发指南三(std::mutex 详解)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;mutex&quot;&gt;&lt;a href=&quot;#mutex&quot; class=&quot;headerlink&quot; title=&quot;mutex&quot;&gt;&lt;/a&gt;mutex&lt;/h1&gt;&lt;p&gt;mutex是多线程编程时经常用到的，在C++11中需要包含&lt;mutex&gt;模块。而在该文件中还有其他和mutex协作的类和函数，使得多线程编程时非常方便。&lt;/mutex&gt;&lt;/p&gt;&lt;h2 id=&quot;mutex类&quot;&gt;&lt;a href=&quot;#mutex类&quot; class=&quot;headerlink&quot; title=&quot;mutex类&quot;&gt;&lt;/a&gt;mutex类&lt;/h2&gt;&lt;p&gt;mutex对象是一个lockable的对象，当关键区域需要被互斥访问的时候被用来当作信号。mutex对象提供互斥的拥有权限，并且不支持递归。&lt;/p&gt;&lt;p&gt;实际就是mutex是用来进行线程同步的。常用的成员函数有lock()和unlock()&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>36.二叉搜索树与双向链表</title>
    <link href="https://xiao-hu.com.cn/2019/11/09/36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://xiao-hu.com.cn/2019/11/09/36-二叉搜索树与双向链表/</id>
    <published>2019-11-09T03:41:44.000Z</published>
    <updated>2019-11-12T07:00:06.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、将左子树构成双链表，并返回该链表的头节点(左子树最左边的节点)</p><p>2、定位到左链表的最后一个节点(左子树最右边的节点)</p><p>3、如果左子树链表不为空，则将当前root追加到左子树链表后</p><a id="more"></a><p>4、将右子树构造成双向链表，并返回链表头结点(右子树最左边的节点)</p><p>5、如果右子树链表不为空，将右子树链表追加到当前root后</p><p>6、根据左子树链表是否为空返回的整体双向链表的头节点</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>待写！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;1、将左子树构成双链表，并返回该链表的头节点(左子树最左边的节点)&lt;/p&gt;&lt;p&gt;2、定位到左链表的最后一个节点(左子树最右边的节点)&lt;/p&gt;&lt;p&gt;3、如果左子树链表不为空，则将当前root追加到左子树链表后&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
