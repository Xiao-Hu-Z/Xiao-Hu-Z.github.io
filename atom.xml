<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaohu博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiao-hu.com.cn/"/>
  <updated>2019-11-04T11:10:07.423Z</updated>
  <id>https://xiao-hu.com.cn/</id>
  
  <author>
    <name>xiaohu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ORB-SLAM2——整体框架</title>
    <link href="https://xiao-hu.com.cn/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/"/>
    <id>https://xiao-hu.com.cn/2019/11/04/ORB-SLAM2——整体框架/</id>
    <published>2019-11-04T11:08:34.000Z</published>
    <updated>2019-11-04T11:10:07.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191104184711727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p> ORB_SLAM2由3+1个平行线程组成，包括跟踪、局部建图、回环检测以及在回环检测后的全局BA优化。之所以说是3+1，因为第四个线程仅在回环检测并确认后才执行。</p><p>三个主要并行线程：<br>Tracking：寻找局部地图特征点并进行匹配，运用纯运动BA最小化重投影误差，定位每帧相机位姿。<br>Local Mapping：运用局部BA算法优化相机位姿和特征点云。<br>Loop Closing：检测回环并通过位姿图优化消除累计漂移误差。在位姿图优化后会启动第4个线程执行全局BA算法，计算整个系统最优结构和运动结果。</p><a id="more"></a><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>以双目stereo_kitti.cc这个主程序来看整个代码：</p><ol><li>首先使用LoadImages读取图片目录和时间戳文件 </li><li>创建ORB_SLAM2::System对象 </li><li>循环读取数据<br>3.1 读取图片<br>3.2 读取时间戳<br>3.3 将图片传给SLAM系统 </li><li>将相机轨线保存到硬盘中<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Usage: ./stereo_kitti path_to_vocabulary path_to_settings path_to_sequence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve paths to images</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstrImageLeft;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstrImageRight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vTimestamps;</span><br><span class="line">    LoadImages(<span class="built_in">string</span>(argv[<span class="number">3</span>]), vstrImageLeft, vstrImageRight, vTimestamps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nImages = vstrImageLeft.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create SLAM system. It initializes all system threads and gets ready to process frames.</span></span><br><span class="line">    ORB_SLAM2::<span class="function">System <span class="title">SLAM</span><span class="params">(argv[<span class="number">1</span>],argv[<span class="number">2</span>],ORB_SLAM2::System::STEREO,<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vector for tracking time statistics</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; vTimesTrack;</span><br><span class="line">    vTimesTrack.resize(nImages);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"-------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Start processing sequence ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Images in the sequence: "</span> &lt;&lt; nImages &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    cv::Mat imLeft, imRight;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ni=<span class="number">0</span>; ni&lt;nImages; ni++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Read left and right images from file</span></span><br><span class="line">        imLeft = cv::imread(vstrImageLeft[ni],CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">        imRight = cv::imread(vstrImageRight[ni],CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">        <span class="keyword">double</span> tframe = vTimestamps[ni];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(imLeft.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Failed to load image at: "</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">string</span>(vstrImageLeft[ni]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t1 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t1 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass the images to the SLAM system</span></span><br><span class="line">        SLAM.TrackStereo(imLeft,imRight,tframe);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t2 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t2 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ttrack= <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(t2 - t1).count();</span><br><span class="line"></span><br><span class="line">        vTimesTrack[ni]=ttrack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait to load the next frame</span></span><br><span class="line">        <span class="keyword">double</span> T=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ni&lt;nImages<span class="number">-1</span>)</span><br><span class="line">            T = vTimestamps[ni+<span class="number">1</span>]-tframe;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ni&gt;<span class="number">0</span>)</span><br><span class="line">            T = tframe-vTimestamps[ni<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ttrack&lt;T)</span><br><span class="line">            usleep((T-ttrack)*<span class="number">1e6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop all threads</span></span><br><span class="line">    SLAM.Shutdown();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracking time statistics</span></span><br><span class="line">    sort(vTimesTrack.begin(),vTimesTrack.end());</span><br><span class="line">    <span class="keyword">float</span> totaltime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ni=<span class="number">0</span>; ni&lt;nImages; ni++)</span><br><span class="line">    &#123;</span><br><span class="line">        totaltime+=vTimesTrack[ni];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"median tracking time: "</span> &lt;&lt; vTimesTrack[nImages/<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mean tracking time: "</span> &lt;&lt; totaltime/nImages &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save camera trajectory</span></span><br><span class="line">    SLAM.SaveTrajectoryKITTI(<span class="string">"CameraTrajectory.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>LoadImages()函数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadImages</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strPathToSequence, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vstrImageLeft,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vstrImageRight, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;vTimestamps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fTimes;</span><br><span class="line">    <span class="built_in">string</span> strPathTimeFile = strPathToSequence + <span class="string">"/times.txt"</span>;</span><br><span class="line">    fTimes.open(strPathTimeFile.c_str());</span><br><span class="line">    <span class="keyword">while</span>(!fTimes.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//strstream类同时可以支持C风格的串流的输入输出操作</span></span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        getline(fTimes,s);</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; s;<span class="comment">//输入</span></span><br><span class="line">            <span class="keyword">double</span> t;</span><br><span class="line">            ss &gt;&gt; t;<span class="comment">//输出</span></span><br><span class="line">            vTimestamps.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> strPrefixLeft = strPathToSequence + <span class="string">"/image_0/"</span>;</span><br><span class="line">    <span class="built_in">string</span> strPrefixRight = strPathToSequence + <span class="string">"/image_1/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nTimes = vTimestamps.size();</span><br><span class="line">    vstrImageLeft.resize(nTimes);<span class="comment">//改变当前使用数据的大小</span></span><br><span class="line">    vstrImageRight.resize(nTimes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; i;</span><br><span class="line">        vstrImageLeft[i] = strPrefixLeft + ss.str() + <span class="string">".png"</span>;</span><br><span class="line">        vstrImageRight[i] = strPrefixRight + ss.str() + <span class="string">".png"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://blog.csdn.net/hzy925/article/details/85488031" target="_blank" rel="noopener">ORB-SLAM2 程序解读</a><br><a href="https://blog.csdn.net/zxcqlf/article/details/80198298" target="_blank" rel="noopener">ORB-SLAM2论文解读与总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;整体框架&quot;&gt;&lt;a href=&quot;#整体框架&quot; class=&quot;headerlink&quot; title=&quot;整体框架&quot;&gt;&lt;/a&gt;整体框架&lt;/h1&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191104184711727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70&quot;&gt;&lt;/p&gt;&lt;p&gt; ORB_SLAM2由3+1个平行线程组成，包括跟踪、局部建图、回环检测以及在回环检测后的全局BA优化。之所以说是3+1，因为第四个线程仅在回环检测并确认后才执行。&lt;/p&gt;&lt;p&gt;三个主要并行线程：&lt;br&gt;Tracking：寻找局部地图特征点并进行匹配，运用纯运动BA最小化重投影误差，定位每帧相机位姿。&lt;br&gt;Local Mapping：运用局部BA算法优化相机位姿和特征点云。&lt;br&gt;Loop Closing：检测回环并通过位姿图优化消除累计漂移误差。在位姿图优化后会启动第4个线程执行全局BA算法，计算整个系统最优结构和运动结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ORB-SLAM2" scheme="https://xiao-hu.com.cn/categories/ORB-SLAM2/"/>
    
    
      <category term="ORB-SLAM2" scheme="https://xiao-hu.com.cn/tags/ORB-SLAM2/"/>
    
  </entry>
  
  <entry>
    <title>C ++ 学习（1）——vector</title>
    <link href="https://xiao-hu.com.cn/2019/11/04/C-%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94vector/"/>
    <id>https://xiao-hu.com.cn/2019/11/04/C-学习（1）——vector/</id>
    <published>2019-11-04T10:18:28.000Z</published>
    <updated>2019-11-04T10:21:20.909Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是vector？"><a href="#一、什么是vector？" class="headerlink" title="一、什么是vector？"></a>一、什么是vector？</h1><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 </p><h1 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h1><ol><li><p>顺序序列</p><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p></li></ol><a id="more"></a><ol><li><p>动态数组</p><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p></li><li><p>能够感知内存分配器的（Allocator-aware）</p><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p></li></ol><h1 id="三、基本函数实现"><a href="#三、基本函数实现" class="headerlink" title="三、基本函数实现"></a>三、基本函数实现</h1><p>1.构造函数</p><blockquote><p>vector():创建一个空vector<br>   vector(int nSize):创建一个vector,元素个数为nSize<br>   vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>   vector(const vector&amp;):复制构造函数<br>   vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p></blockquote><p>2.增加函数</p><blockquote><p> void push_back(const T&amp; x):向量尾部增加一个元素X<br> iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>     iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>     iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p></blockquote><p>3.删除函数</p><blockquote><p>  iterator erase(iterator it):删除向量中迭代器指向元素<br>      iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>      void pop_back():删除向量中最后一个元素<br>      void clear():清空向量中所有元素</p></blockquote><p>4.遍历函数</p><blockquote><p>   reference at(int pos):返回pos位置元素的引用<br>       reference front():返回首元素的引用<br>       reference back():返回尾元素的引用<br>       iterator begin():返回向量头指针，指向第一个元素<br>       iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>       reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>       reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</p></blockquote><p>5.判断函数</p><blockquote><p>bool empty() const:判断向量是否为空，若为空，则向量中无元素</p></blockquote><p>6.大小函数</p><blockquote><p>  int size() const:返回向量中元素的个数<br>      int capacity() const:返回当前向量张红所能容纳的最大元素值<br>      int max_size() const:返回最大可允许的vector元素数量值</p></blockquote><p>7.其他函数</p><blockquote><p>  void swap(vector&amp;):交换两个同类型向量的数据<br>      void assign(int n,const T&amp; x):设置向量中第n个元素的值为x<br>      void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p></blockquote><p>8.看着清楚</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>push_back 在数组的最后添加一个数据</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>pop_back 去掉数组的最后一个数据</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>at 得到编号位置的数据</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>begin 得到数组头的指针</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>end 得到数组的最后一个单元+<span class="number">1</span>的指针</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>．front 得到数组头的引用</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>back 得到数组的最后一个单元的引用</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>max_size 得到<span class="type">vector</span>最大可以是多大</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>capacity 当前<span class="type">vector</span>分配的大小</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>size 当前使用数据的大小</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span>resize 改变当前使用数据的大小</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span>reserve 改变当前vecotr所分配空间的大小</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span>erase 删除指针指向的数据项</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span>clear 清空当前的<span class="type">vector</span></span><br><span class="line"></span><br><span class="line"><span class="number">15.</span>rbegin 将<span class="type">vector</span>反转后的开始指针返回(其实就是原来的end<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span>rend 将<span class="type">vector</span>反转构的结束指针返回(其实就是原来的begin<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span>empty 判断<span class="type">vector</span>是否为空</span><br><span class="line"></span><br><span class="line"><span class="number">18.</span>swap 与另一个<span class="type">vector</span>交换数据</span><br></pre></td></tr></table></figure><h1 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p><strong>eg：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; veci;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">veci.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (it = veci.begin(); it != veci.end(); )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">it = veci.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; veci.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========将vector值传递给其他参数，同时判断是否满足删除要求========"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itc = veci.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecTemp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size(),itc!=veci.end();i++)</span><br><span class="line">&#123;</span><br><span class="line">vecTemp.push_back(veci.at(i));</span><br><span class="line"><span class="keyword">if</span> (*itc % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">itc = veci.erase(itc);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++itc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; veci.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTemp.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; vecTemp.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190903112647360.png"><br><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">参考：https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;一、什么是vector？&quot;&gt;&lt;a href=&quot;#一、什么是vector？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是vector？&quot;&gt;&lt;/a&gt;一、什么是vector？&lt;/h1&gt;&lt;p&gt;向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 &lt;/p&gt;&lt;h1 id=&quot;二、容器特性&quot;&gt;&lt;a href=&quot;#二、容器特性&quot; class=&quot;headerlink&quot; title=&quot;二、容器特性&quot;&gt;&lt;/a&gt;二、容器特性&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;顺序序列&lt;/p&gt;
&lt;p&gt;顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>27.二叉树的镜像</title>
    <link href="https://xiao-hu.com.cn/2019/11/04/27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>https://xiao-hu.com.cn/2019/11/04/27-二叉树的镜像/</id>
    <published>2019-11-04T07:02:06.000Z</published>
    <updated>2019-11-04T07:02:06.164Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>26.树的子结构</title>
    <link href="https://xiao-hu.com.cn/2019/11/04/26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>https://xiao-hu.com.cn/2019/11/04/26-树的子结构/</id>
    <published>2019-11-04T06:58:09.000Z</published>
    <updated>2019-11-04T07:00:08.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>注意检测空指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1!=<span class="literal">NULL</span>&amp;&amp; pRoot2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(pRoot1-&gt;val-pRoot2-&gt;val)&lt;<span class="number">1e-8</span>)</span><br><span class="line">                result=Tree1HaveTree2(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Tree1HaveTree2</span><span class="params">(TreeNode* pRoot1,TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(pRoot1-&gt;val-pRoot2-&gt;val)&gt;=<span class="number">1e-8</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Tree1HaveTree2(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>25.合并两个排序的链表表</title>
    <link href="https://xiao-hu.com.cn/2019/11/03/25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E8%A1%A8/"/>
    <id>https://xiao-hu.com.cn/2019/11/03/25-合并两个排序的链表表/</id>
    <published>2019-11-03T02:31:44.000Z</published>
    <updated>2019-11-03T04:59:11.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果有一个链表为空，则直接返回另外一个链表；否则就对两个链表的每个元素进行大小判断，建立一个新的合并链表，把元素依次放进去，直到一个链表为空，这时把另外一个链表的剩余部分添加到合并链表的尾部即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><a id="more"></a><p><strong>法1：循环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* pHead3=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//利用了构造方法创建一个链表</span></span><br><span class="line">        ListNode* root=pHead3;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">NULL</span> &amp;&amp; pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead1;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead1=pHead1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead2;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead2=pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pHead3=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个链表中哪个头结点的值小，就以此作为新链表的头结点</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;=pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead1;</span><br><span class="line">            pHead1=pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead2;</span><br><span class="line">            pHead2=pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* head=pHead3;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">NULL</span> &amp;&amp; pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead1;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead1=pHead1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead2;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead2=pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pHead3-&gt;next=pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><p><strong>法2：递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pHead3=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead1;</span><br><span class="line">            pHead3-&gt;next=Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead2;</span><br><span class="line">            pHead3-&gt;next=Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pHead3;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;如果有一个链表为空，则直接返回另外一个链表；否则就对两个链表的每个元素进行大小判断，建立一个新的合并链表，把元素依次放进去，直到一个链表为空，这时把另外一个链表的剩余部分添加到合并链表的尾部即可。&lt;/p&gt;&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>24.反转链表</title>
    <link href="https://xiao-hu.com.cn/2019/11/03/24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://xiao-hu.com.cn/2019/11/03/24-反转链表/</id>
    <published>2019-11-03T02:30:22.000Z</published>
    <updated>2019-11-03T02:31:22.751Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191103101356721.png#pic_center"><br>在调整节点i的next指针，需要知道节点i的前一个节点h，事先还要保存i的下一个节点j，以防止链表断开。需要定定义三个指针</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* pRversedHead=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pNode=pHead;</span><br><span class="line">        ListNode* pPrev=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* pNext=pNode-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pNext==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pRversedHead=pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pNode-&gt;next=pPrev;</span><br><span class="line">            pPrev=pNode;</span><br><span class="line">            pNode=pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRversedHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>22.链表中倒数第k个结点</title>
    <link href="https://xiao-hu.com.cn/2019/11/02/22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://xiao-hu.com.cn/2019/11/02/22-链表中倒数第k个结点/</id>
    <published>2019-11-02T12:15:40.000Z</published>
    <updated>2019-11-02T13:11:55.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>先统计链表节点的个数n，再从头遍历到第n-k+1个节点</li><li>为了实现只遍历一次，可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动，从第k步开始，第二个指针也开始从链表的头指针开始遍历</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>思维全面，注意代码的鲁棒性 。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* Ahead=pListHead;</span><br><span class="line">        ListNode* Behind=pListHead;</span><br><span class="line">        <span class="keyword">if</span>(pListHead==<span class="literal">NULL</span> || k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Ahead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">                Ahead=Ahead-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Ahead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ahead=Ahead-&gt;next;</span><br><span class="line">            Behind=Behind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Behind;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>题目：求链表的中间节点，如果节点的总数为奇数，则返回中间节点，若节点的总数为偶数，返回中间两个节点的任意一个。</p><p>思路：定义两个指针，一个指针一次走一步，一个指针一次走两部</p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;先统计链表节点的个数n，再从头遍历到第n-k+1个节点&lt;/li&gt;
&lt;li&gt;为了实现只遍历一次，可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动，从第k步开始，第二个指针也开始从链表的头指针开始遍历&lt;/li&gt;
&lt;/ol&gt;&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;p&gt;思维全面，注意代码的鲁棒性 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>C ++ 学习（16）——&amp;的用法</title>
    <link href="https://xiao-hu.com.cn/2019/11/02/C-%E5%AD%A6%E4%B9%A0%EF%BC%8816%EF%BC%89%E2%80%94%E2%80%94-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://xiao-hu.com.cn/2019/11/02/C-学习（16）——-的用法/</id>
    <published>2019-11-02T08:38:52.000Z</published>
    <updated>2019-11-04T10:20:03.207Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二进制的位与运算。"><a href="#二进制的位与运算。" class="headerlink" title="二进制的位与运算。"></a>二进制的位与运算。</h1><p>例如 二进制数字 100 &amp; 111 = 100；</p><h1 id="表示取地址。"><a href="#表示取地址。" class="headerlink" title="表示取地址。"></a>表示取地址。</h1><p>eg:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用，顾名思义是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价</p><a id="more"></a><p>   <strong>注意：</strong></p><p> ==引用的类型必须和其所绑定的变量的类型相同==</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=<span class="number">10.3</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b=a;<span class="comment">//错误，引用的类型必须和其所绑定的变量的类型相同</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  ==声明引用的同时必须对其初始化==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;a;<span class="comment">//错误，声明引用的同时必须对其初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==引用相当于变量或对象的别名，因此不能再将已有的引用名作为其他变量或对象的名字或别名==<br>==引用不是定义一个新的变量或对象，因此内存不会为引用开辟新的空间存储这个引用==</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;new_value=value;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"value在内存中的地址:"</span>&lt;&lt;&amp;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"new_value在内存中的地址:"</span>&lt;&lt;&amp;new_value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190927105109522.png#pic_center"></p><p><strong>引用作为函数的参数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a ,<span class="keyword">int</span> &amp;b)</span></span>&#123;<span class="comment">//引用作为函数的形参</span></span><br><span class="line">    <span class="keyword">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>当用引用作为函数的参数时，其==效果和用指针作为函数参数的效果相当==。当调用函数时，==函数中的形参就会被当成实参变量或对象的一个别名来使用==，也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参。</li><li>通常函数调用时，系统采用值传递的方式将实参变量的值传递给函数的形参变量。此时，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，也就是说形参变量只是实参变量的副本而已；并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象。而使用引用作为函数的形参时，由于此时==形参只是要传递给函数的实参变量或对象的别名而非副本==，故==系统不会耗费时间来在内存中开辟空间来存储形参==。因此如果参数传递的数据较大时，==建议使用引用作为函数的形参，这样会提高函数的时间效率，并节省内存空间==。</li><li>使用指针作为函数的形参虽然达到的效果和使用引用一样，但==当调用函数时仍需要为形参指针变量在内存中分配空间，而引用则不需要这样==，故在C++中推荐使用引用而非指针作为函数的参数</li><li><p>如果在编程过程中既希望通过让引用作为函数的参数来提高函数的编程效率，又希望保护传递的参数使其在函数中不被改变，则此时应当使用对常量的引用作为函数的参数。</p></li><li><p>数组的引用作为函数的参数：C++的数组类型是带有长度信息的，==引用传递时如果指明的是数组则必须指定数组的长度==</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(&amp;a) [<span class="number">5</span>])</span></span>&#123;<span class="comment">//数组引用作为函数的参数，必须制定数组的长度</span></span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常引用</strong><br>语法：const 类型 &amp;引用名=目标变量名；<br>==常引用不允许通过该引用对其所绑定的变量或对象进行修改==</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;new_a=a;</span><br><span class="line">new_a=<span class="number">11</span>;<span class="comment">//错误，不允许通过常引用对其所绑定的变量或对象进行修改</span></span><br></pre></td></tr></table></figure><p><strong>引用作为函数的返回值</strong><br>语法：类型 &amp;函数名（形参列表）{ 函数体 }</p><p>注意：<br>==引用作为函数的返回值时，必须在定义函数时在函数名前将&amp;==</p><p>==用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本==</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">fn1</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123;</span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">float</span> &amp;<span class="title">fn2</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123; <span class="comment">//&amp;说明返回的是temp的引用，换句话说就是返回temp本身</span></span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a=fn1(<span class="number">5.0</span>); <span class="comment">//case 1：返回值</span></span><br><span class="line">    <span class="comment">//float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type 'float&amp;' from an rvalue of type 'float'</span></span><br><span class="line">                           <span class="comment">//（有些编译器可以成功编译该语句，但会给出一个warning） </span></span><br><span class="line">   <span class="keyword">float</span> c=fn2(<span class="number">5.0</span>);<span class="comment">//case 3：返回引用</span></span><br><span class="line">   <span class="keyword">float</span> &amp;d=fn2(<span class="number">5.0</span>);<span class="comment">//case 4：用函数返回的引用作为新引用的初始化值</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;b&lt;&lt;endl;//78.5</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用引用实现多态</strong><br>在C++中，引用是除了指针外另一个可以产生多态效果的手段。也就是说一个基类的引用可以用来绑定其派生类的实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>;</span><span class="comment">//基类（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>：<span class="title">public</span> <span class="title">Father</span>&#123;</span>.....&#125;<span class="comment">//Son是Father的派生类</span></span><br><span class="line">Son son;<span class="comment">//son是类Son的一个实例</span></span><br><span class="line">Father &amp;ptr=son;<span class="comment">//用派生类的对象初始化基类对象的使用</span></span><br></pre></td></tr></table></figure><p>ptr只能用来访问派生类对象中从基类继承下来的成员。如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li><p>在引用的使用中，单纯给某个变量去别名是毫无意义的，引用的目的主要用于在函数参数的传递中，解决大块数据或对象的传递效率和空间不如意的问题</p></li><li><p>用引用传递函数的参数，能保证参数在传递的过程中不产生副本，从而提高传递效率，同时通过const的使用，还可以保证参数在传递过程中的安全性</p></li><li><p>引用本身是目标变量或对象的别名，对引用的操作本质上就是对目标变量或对象的操作。因此能使用引用时尽量使用引用而非指针</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;二进制的位与运算。&quot;&gt;&lt;a href=&quot;#二进制的位与运算。&quot; class=&quot;headerlink&quot; title=&quot;二进制的位与运算。&quot;&gt;&lt;/a&gt;二进制的位与运算。&lt;/h1&gt;&lt;p&gt;例如 二进制数字 100 &amp;amp; 111 = 100；&lt;/p&gt;&lt;h1 id=&quot;表示取地址。&quot;&gt;&lt;a href=&quot;#表示取地址。&quot; class=&quot;headerlink&quot; title=&quot;表示取地址。&quot;&gt;&lt;/a&gt;表示取地址。&lt;/h1&gt;&lt;p&gt;eg:&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p = &amp;amp;a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;p&gt;引用，顾名思义是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://xiao-hu.com.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>21.调整数组顺序使奇数位于偶数前面</title>
    <link href="https://xiao-hu.com.cn/2019/11/02/21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>https://xiao-hu.com.cn/2019/11/02/21-调整数组顺序使奇数位于偶数前面/</id>
    <published>2019-11-02T08:16:56.000Z</published>
    <updated>2019-11-02T13:09:00.637Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul><li>最简单从头遍历，每碰到一个偶数，拿出这个数字，把位于这个偶数后面的所有数字往前移一位，再把这个数字放在数组末尾，时间复杂度$O(n^2)$</li><li><p>需要两个指针分别指向数组的头和尾，依次比较。</p><ol><li>如果头指针指向的数组位置为奇数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则头指针后移一个位置，如果是偶数，则尾指针前移一个位置。</li><li>如果头指针指向的数组位置为偶数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则交换头尾指针指向的数组元素，如果是偶数，则尾指针前移一个位置。</li></ol></li></ul><a id="more"></a><p>法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_1</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin，直到它指向偶数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; <span class="number">0x1</span>) != <span class="number">0</span>)</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd，直到它指向奇数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_2</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reorder(pData, length, isEven);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; !func(*pBegin))</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; func(*pEnd))</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector表示</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> reOrderArray(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> j=<span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">array</span>[i]&amp;<span class="number">0x1</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>((<span class="built_in">array</span>[j]&amp;<span class="number">0x1</span>)==<span class="number">0</span>)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp=<span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i]=<span class="built_in">array</span>[j];</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并==保证奇数和奇数，偶数和偶数之间的相对位置不变==。</p><p>时间复杂度$O(n)$,空间复杂度$O(n)$</p><p>法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时间：3ms,占用内存：492k</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1,vec2 ;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&amp; <span class="number">0x1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vec1.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vec2.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">array</span>.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">            <span class="built_in">array</span>.push_back(vec1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="built_in">array</span>.push_back(vec2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时间：3ms,占用内存：484k</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录第一个为奇数的位置</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&amp;<span class="number">0x1</span>)<span class="comment">//找到第一个奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="built_in">array</span>[i];<span class="comment">//记录第一个奇数</span></span><br><span class="line">                <span class="keyword">int</span> k=i;</span><br><span class="line">                <span class="keyword">for</span>(;k&gt;j;k--)<span class="comment">//将奇数之前的所有元素往后移一个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">array</span>[k]=<span class="built_in">array</span>[k<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分&lt;/p&gt;&lt;h1 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;最简单从头遍历，每碰到一个偶数，拿出这个数字，把位于这个偶数后面的所有数字往前移一位，再把这个数字放在数组末尾，时间复杂度$O(n^2)$&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要两个指针分别指向数组的头和尾，依次比较。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果头指针指向的数组位置为奇数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则头指针后移一个位置，如果是偶数，则尾指针前移一个位置。&lt;/li&gt;
&lt;li&gt;如果头指针指向的数组位置为偶数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则交换头尾指针指向的数组元素，如果是偶数，则尾指针前移一个位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>ORB-SLAM——论文翻译（ORB-SLAM:a Versatile and Accurate Monocular SLAM System）</title>
    <link href="https://xiao-hu.com.cn/2019/11/01/ORB-SLAM%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88ORB-SLAM-a-Versatile-and-Accurate-Monocular-SLAM-System%EF%BC%89/"/>
    <id>https://xiao-hu.com.cn/2019/11/01/ORB-SLAM——论文翻译（ORB-SLAM-a-Versatile-and-Accurate-Monocular-SLAM-System）/</id>
    <published>2019-11-01T09:15:37.000Z</published>
    <updated>2019-11-04T10:16:53.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><center>ORB-SLAM：一种通用的(全能的)精确的单目SLAM系统<center></center></center></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文提出了ORB-SLAM，在大小场景、室内室外环境下都可以实时操作的一种基于特征的单目SLAM系统。系统对复杂的剧烈运动具有鲁棒性，允许宽基线的闭环和重定位，且包含完整的自动初始化。基于最近几年的优秀算法之上，我们从头开始设计了一种新颖的系统，它对所有SLAM任务使用相同的特征：追踪、建图、重定位和闭环。合适策略的存在使得选择的重建点和关键帧具有很好的鲁棒性，并能够生成紧凑的可追踪的地图，只有当场景内容发生变化地图才改变，从而允许长时间操作。本文从最受欢迎的数据集中提供了27个序列的详尽评估。相对于其他最先进的单目SLAM方法，ORB-SLAM实现了前所未有的性能。为了社会的利益，我们将源代码公开。</p><a id="more"></a><p>关键字：持续建图，定位，单目视觉，识别，同时定位和制图（SLAM）。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>BA提供相机定位的精确估计以及稀疏几何重建[1,2]，并且提供了强烈的匹配网络和良好的初始猜测。一段长的时间，这种方法被认为不符合实时性的应用，如视觉VSLAM。VSLAM系统在构建环境的同时需要估计相机的轨迹。现在，我们为了不以过高的计算成本获得准确的结果，实时SLAM算法必须向BA提供以下信息。</p><ul><li>在候选图像帧子集中（关键帧）匹配观测的场景特征（地图云点）</li><li>由于关键帧数量的增长，需要做筛选避免冗余</li><li>关键帧和云点的网络配置可以产生精确的结果，也就是，分布良好的关键帧集合和有明显视差、大量回环匹配的观测云点</li><li>关键帧和云点位置的初始估计，采用非线性优化的方法</li><li>在构建局部地图的过程中，优化的关键是获得良好的稳定性</li><li>本系统可以实时执行快速全局优化（比如位姿图）以实现闭环回路</li></ul><p>BA第一次实时应用是在Mouragon等人[13]提出的视觉里程计算法中，其次是在Klein和Murray的突破性工作PTAM[4]算法中。尽管受制于小场景的应用，PTAM算法对关键帧的选择，特征匹配，点的三角化，相机位姿估计，追踪失败后的重定位非常有效。然而，由于缺少闭环检测和对遮挡场景的处理，再加上其视图不变性差，在地图初始化时需要人工干预等多个因素，使得PTAM算法的应用收到了严重的限制。</p><p>在本文中，我们基于PTAM算法的主要框架，采用Gálvez-López和Tardós提出的place recognition（场景/位置识别）算法，Strasdat等人提出的scale-aware loop closing（具备尺度感知的闭环检测）算法以及文献[7][8]中的大尺度操作中Covisibility信息的使用，重新设计了一种新的单目SLAM系统ORB-SLAM，本文的贡献主要包括：</p><ul><li>对所有的任务采用相同的特征：追踪、地图构建、重定位和闭环检测。这使得我们的系统更有效率、简单可靠。采用的ORB特征[9]在没有GPU的情况下也有很好的实时性，且具有旋转不变性和光照不变性。</li><li>算法支持在宽阔环境中实时操作。由于covisibility graph的使用，特征点的跟踪与构图主要集中在局部共视区域，而与全局地图的大小无关。</li><li>使用Essential Graph来优化位姿实现回环检测。构建生成树，并由系统、闭环检测链接和covisibility graph的强边缘进行维护。</li><li>算法的实时相机重定位具有明显的旋转不变特性和光照不变性。这就使得点跟踪丢失后可以恢复，增强了地图的重用性。</li><li>提出了一种合适的方法来选择地图点云和关键帧，通过严格删选关键帧和地图点，剔除冗余信息，使得特征点的跟踪具备了更好的稳定性，从而增强算法的可持续操作性。好的挑选方法可以增强追踪的鲁棒性，同时舍弃多余的关键帧加强系统长时间操作性</li></ul><p>我们在公共数据集上对算法的性能在室内和室外环境下进行了评估，包括手持设备、汽车和机器人。值得一提的是，与目前最新的直接SLAM算法[10]相比——直接SLAM方法通过直接对像素点的灰度进行优化而不是最小化特征重投影误差，我们的方法能够实现更精确的摄像头定位精度。我们在文章的第IX-B部分还讨论了基于特征的SLAM方法定位比直接法更准确的原因。</p><p>闭环检测和重定位的方法是基于我们之前的论文[11]。系统最初的版本是论文[12]。本文中我们添加了初始化的方法，Essential graph ，并完善其他模块。我们详细了描述了系统的各个板块，并且开展了实验验证。<br>据我们所知，这是目前最完整最可靠的单目SLAM系统，为了使更多人获益，我们将源代码开放。视频演示和源代码放在我们的项目网站上。</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h2 id="A、位置识别"><a href="#A、位置识别" class="headerlink" title="A、位置识别"></a>A、位置识别</h2><p>Williams等人在综述[13]中比较了几种基于景象的位置识别方法，即图像到图像的匹配，这种方法在大环境下比地图到地图或图像到地图的方法更准确。在景象匹配方法中，bags of words（词袋）[14]的使用以其效率很高而脱颖而出，比如概率方法FAB-MAP[15]算法,。DBoW2方法[5]则首次使用了BRIEF描述子[16]生成的二进制词袋和非常高效的FAST特征检测算法[17]与SURF和SIFT相比，FAST算法的运时间减小了至少一个数量级。然而，尽管系统运行效率高、鲁棒性好，采用BRIEF描述子不具有旋转不变性和尺度不变性，系统只能运行在同一平面内（否则会造成尺度变化）  ，闭环检测也只能从相似的视角中进行。在我们之前的工作[11]中，我们提出了一个使用ORB特征检测子的DBoW2位置识别器。ORB特征是具有旋转不变和尺度不变特性的二进制特征，因此，用它生成的快速识别器具有较好的视角不变性。我们在4组不同的数据集上演示了位置识别功能，从10K图像数据库中提取一个候选闭合回路的运算时间少于39毫秒。在本文的工作中，我们提出了一种改进版本的位置识别方法，采用covisibility信息，在检索数据库时返回几个假设情况而不是最好的匹配。</p><h2 id="B、地图初始化"><a href="#B、地图初始化" class="headerlink" title="B、地图初始化"></a>B、地图初始化</h2><p>单目SLAM系统需要设计专门的策略来生成初始化地图，因为单幅图像不具备深度信息。解决这个问题的一种方法是一开始跟踪一个已知结构的对象，正如文献[20]。另一个方法是用一个具有高不确定度的逆深度参数[21]来初始化点的深度信息，理想情况下，该参数会在后期逐渐收敛到真值。最近Engel提出的半稠密方法[10]中就采用类似的方法将像素的深度信息初始化为一个随机数值。</p><p>如果是从两个视角来初始化特征，就可以采用以下方法：一种是假设局部场景在同一平面内[4]，[22]，然后利用Faugeras等人论文[23]中的单应性来重构摄像头相对位姿。第二种是将场景建模为通用情况（不一定为平面），通过Nister提出的五点算法[26]来计算本征矩阵[24],[25]，但该方法存在多解的问题。这两种摄像头位姿重构方法在低视差下都没有很好的约束，如果平面场景内的所有点都靠近摄像机的中心，则结果会出现双重歧义[27]。另一方面，非平面场景可以通过线性8点算法[2]来计算基础矩阵，相机的相对位姿就可以无歧义的重构出来。</p><p>针对这一问题，我们在本文的第四部分提出了一个新的基于模型选择的自动初始化方法，对平面场景算法选择单应性矩阵，而对于非平面场景，算法选择基础矩阵。模型选择的综述方法可参见Torr等人的论文[28]。基于类似的理论，我们设计了一种启发式初始化算法，算法考虑到在接近退化情况（比如：平面，近平面，或是低视差）下选择基础矩阵进行位姿估计可能存在的问题，则选择单应性计算。在平面的情况下，为了保险起见，如果最终存在双重歧义，则算法避免进行初始化，因为可能会因为错误选择而导致算法崩溃。因此，我们会延迟初始化过程，直到所选的模型在明显的视差下产生唯一的解。</p><h2 id="C、单目SLAM"><a href="#C、单目SLAM" class="headerlink" title="C、单目SLAM"></a>C、单目SLAM</h2><p>单目SLAM最初采用滤波框架[20],[21],[29],[30]来建模。在该类方法中，每一帧都通过滤波器联合估计地图特征位置和相机位姿。这样做带来的问题是在处理连续帧图像上对计算资源的浪费和线性误差的累积。而另外一种SLAM框架是基于关键帧的，即采用少数筛选过的图像（关键帧）来构建地图，因为构图不再与帧率相关联，因此基于关键帧的SLAM方法不但节省了计算资源，还可以进行高精度的BA优化。Strasdar等人在论文[31]中证明了基于关键帧的单目SLAM方法比滤波器方法在相同的运算代价上定位结果更精确。</p><p>基于关键帧的SLAM系统最具代表性可能是由Klein和Murray等人提出的PTAM算法[4]。它第一次将相机追踪和地图构建拆分成两个并行的线程运行，并成功用于小环境的实时增强现实中。后来文献[32]引入边缘特征对PTAM算法进行了改进，在跟踪过程中增加了旋转估计步骤，实现了更好的重定位效果。由于PTAM中的地图云点通过图像区块与FAST角点匹配，因此仅适合于特征跟踪并不适合用于后期的位置识别。而实际上，PTAM算法并没有进行大闭环检测，其重定位也仅是基于关键帧低分辨率缩略图的相关性进行的，因此视角不变性较差。</p><p>Strasdat等人在文献[6]中提出了一个基于GPU实现的大尺度单目SLAM系统，该系统前端采用光流算法，其次用FAST特征匹配和运动BA；后端是基于滑动窗口的BA。闭环检测通过具有相似性约束（7自由度）的位姿图优化来进行，该方法可以矫正在单目SLAM系统中出现的尺度偏移问题。在本文中，我们也将采用这种7自由度的位姿图优化方法，并将其应用到我们的Essential Graph中，更多细节将在第三部分D节里面描述。</p><p>Strasdat等人在文献[7]中采用了PTAM的前端，但其跟踪部分仅在一个从covisibility graph提取的局部图中进行。他们提出了一个双窗口优化后端，在内部窗口中连续进行BA，在有限大小的外部窗口中构建位姿图。然而， 只有当外部窗口尺寸足够大到可以包含整个闭环回路的情况下，闭环检测才能起作用。在我们的算法中，我们利用了Strasdat等人提出的基于covisibility的局部地图的优势，并且通过covisibility map来构建位姿图，同时重新设计前端和后端。另一个区别是，我们并没有用特别的特征提取方法做闭合回路检测（比如SURF方法），而是基于相同的追踪和建图的特征进行位置识别，获得具有鲁棒性的重定位和闭环检测。</p><p>在Pirker等人的论文[33]中作者提出了CD-SLAM方法，一个非常复杂的系统，包括闭环检测，重定位，大尺度操作以及对算法在动态环境运行所做的改进。但文中并没有提及地图初始化。因此不利于后期读者对算法的复现，也致使我们没法对其进行精确性、鲁棒性和大场景下的测试对比。</p><p>Song等人在论文[34]提出的视觉里程计方法中使用了ORB特征做追踪和处理BA后端滑动窗口。相比之下，我们的方法更加全面，因为他们的算法中没有涉及全局重定位，闭环回路检测，而且地图也不能重用。他们也使用了相机到地面的真实距离来限制单目SLAM算法的尺度漂移。Lim等人在我们提交本文最初的版本[12]之后发表了论文[25]，他们也采用相同的特征进行跟踪，地图构建和闭环检测。但是，由于Lim等人的算法选择的BRIEF描述子不具备尺度不变性，因此其算法运行受限在平面轨迹上。他们的算法仅从上一帧关键帧开始跟踪特征点，因此访问过的地图不能重用，这样的处理方式与视觉里程计很像，存在系统无限增长的问题。我们在第三部分E小节里面与该算法进行了定性比较。</p><p>Engel等人在最近的论文[10]里提出了LSD-SLAM算法，其可以构建大场景的半稠密地图。算法并没有采用特征提取和BA方法，而是选择直接法（优化也是直接通过图像像素灰度进行）。算法的结果让人印象深刻，其在没有GPU加速的情况下实时构建了一个半稠密地图，相比基于特征的稀疏地图SLAM系统而言，LSD-SLAM方法在机器人领域有更大的应用潜力。然而，该算法的运行仍然需要基于特征做闭环检测，且相机定位的精度也明显低于PTAM和我们的算法，相关实验结果我们将在第8部分的B小节中展示，对该结果的讨论在文章IX部分B小节进行。</p><p>Forster等人在论文[22]中提出了介于直接方式和基于特征的方法之间的半直接视觉里程计算法SVO方法。该方法不需要对每帧图像都提取特征点，且可以以很高的帧率运行，在四轴飞行器上取得了令人惊叹的定位效果。然而，SVO算法没有进行闭环检测，且目前主要基于下视摄像头运行。</p><p>最后，我们想讨论一下目前关键帧的选择方法。由于所有的视觉SLAM算法选择所有的云点和图像帧运行BA是不可行的。因此，在论文[31]中，Strasdat等人证明最合理的选择是保留尽可能多地点云和非冗余关键帧。PTAM方法非常谨慎插入关键帧避免运算量增长过大。然而，这种严格限制关键帧插入的策略在算法运行困难的情况下可能会导致追踪失败。在本文中，为了达到更好的稳定性，我们选择一种更为合适的关键帧插入策略，当算法运行困难的时候算法选择尽快的插入关键帧，然后在后期将冗余的关键帧删除以避免额外的计算成本。</p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="A、特征选择"><a href="#A、特征选择" class="headerlink" title="A、特征选择"></a>A、特征选择</h2><p>我们系统设计的中心思想是对SLAM系统的构图、跟踪、重定位以及闭环检测等模块都采用相同的特征，这将使得我们的系统更有效率，避免了像以往文章[6],[7]一样还需要额外插入一些额外的识别性强的特征以用于后期的闭环检测。我们每张图像的特征提取远少于33毫秒，远小于目前的SIFT算法（~300ms）,SURF算法(~300ms)，或最近提出的A-KAZE（~100ms）算法。为了使算法的位置识别能力能更加通用化，我们需要提取的特征具备旋转不变性，而BRIEF和LDB不具备这样的特性。</p><p>为此，我们选择了ORB[9]特征，其是具有256位描述符的带方向的多尺度FAST角点。他们计算和匹配的速度非常快，同时对视角具有旋转不变的特性。这样可以在更宽的基准线上匹配他们，增强了BA的精度。我们已经在论文[11]中演示了基于ORB特征的位置识别性能。需要申明的是，虽然本文的方案中采用ORB算法，但所提出的技术并不仅限于该特征。</p><h2 id="B、三个线程：追踪、局部地图构建和闭环检测"><a href="#B、三个线程：追踪、局部地图构建和闭环检测" class="headerlink" title="B、三个线程：追踪、局部地图构建和闭环检测"></a>B、三个线程：追踪、局部地图构建和闭环检测</h2><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101155613105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">&gt;图1 ORB-SLAM系统框架，图中显示了算法的三个线程——跟踪、局部构图与闭环检测的所有步骤。另外还有场景识别和地图的主要组成部分。</p></blockquote><p>我们的系统框架如图1所示，包括三个并行的线程：跟踪、局部地图构建和闭环回路检测。跟踪线程负责对每帧图像的相机位置进行定位，并决定什么时候插入新的关键帧。我们首先通过与前一帧图像匹配得到初始特征点，然后采用运动BA优化摄像头位姿。如果特征跟丢（比如由于遮挡或是突然运动），则由位置识别模块进行全局重定位。一旦获得最初的相机位姿估计和特征匹配，则使用由系统维护的关键帧的covisibility graph提取一个局部可视化地图，如图2(a),图2(b)所示。然后通过重投影方法搜索当前帧与局部地图点对应的匹配点，并利用所有的匹配点优化当前相机位姿。最后，跟踪线程决定是否插入新的关键帧。所有的跟踪步骤将在第5部分详细阐述。创建初始化地图的新方法将在第4部分进行说明。</p><p>局部地图构建模块负责处理新的关键帧，对周围的相机位姿进行局部BA以优化重构。在covisibility graph已连接的关键帧中搜索新的关键帧中ORB特征的匹配点，然后三角化新的地图点。有时尽管已经创建了新的点云，但基于跟踪线程过程中新收集的信息，为了保证点云的高质量，可能会根据点云筛选策略临时删除一些点。局部地图构建模块也负责删除冗余的关键帧。我们将在第6章详细说明局部地图构建的步骤。</p><p>对每个新的关键帧都要进行闭环搜索，以确认是否形成闭环。如果闭环被侦测到，我们就计算相似变换来查看闭环的累积误差。这样闭环的两端就可以对齐，重复的云点就可以被融合。最后，为了确保全局地图的一致性，利用相似性约束[6]对位姿图进行优化。这里值得一提的是，本文主要对Essential Graph进行优化，它是一个covisibility graph中的一个更稀疏的子图，更多细节将在第三部分D小节描述。闭环检测和校验步骤将在第7部分详细描述。</p><p>我们使用g2o[37]库中的Levenverg-Marquardt算法执行所有的优化。我们在附录中描述了每个优化的误差，计算成本和变量。</p><h2 id="C、地图点云、关键帧及其选择标准"><a href="#C、地图点云、关键帧及其选择标准" class="headerlink" title="C、地图点云、关键帧及其选择标准"></a>C、地图点云、关键帧及其选择标准</h2><p>对每个地图点云pi保存以下信息：</p><ul><li>它在世界坐标系中的3D坐标$X_{w.i}$</li><li>视图方向$n_i$，即所有视图方向的平均单位向量（该方向是指连接该点云和其对应观测关键帧光心的射线方向）</li><li>ORB特征描述子$D_i$，与其他所有能观测到该点云的关键帧中ORB描述子相比，该描述子的汉明距离最小</li><li>根据ORB特征尺度不变性约束，可观测的点云的最大距离$d_{max}$和最小距离$d_{min}$</li></ul><p>对每个关键帧$K_i$保存以下信息：</p><ul><li>相机位姿$T_(i,w)$，从世界坐标系转换到相机坐标系下的变换矩阵</li><li>相机内参，包括主点和焦距</li><li>从图像帧提取的所有ORB特征，不管其是否已经关联了地图云点， 这些ORB特征点都经过畸变模型矫正过</li></ul><p>地图点云和关键帧的创建条件较为宽松，但是之后则会通过一个非常严格苛刻的删选机制进行挑选，该机制会检测出冗余的关键帧和匹配错误的或不可跟踪的云点进行删除。这样做的好处在于地图在构建过程中具有一定的弹性，在外界条件比较困难的情况下（比如：旋转，相机快速运动），算法仍然可以实现鲁棒的跟踪，而与此同时，当相机对同一个环境重访问时，地图的尺度大小是可控的，这就利于该系统的长期工作。另外，与PTAM算法相比，我们构建的地图中基本不包含局外点，因为秉持的原则是很苛刻的，宁缺毋滥。地图云点和关键帧的筛选过程将在第6部分B节和E节分别解释。</p><h2 id="D、Covisibility-Graph和Essential-Graph"><a href="#D、Covisibility-Graph和Essential-Graph" class="headerlink" title="D、Covisibility Graph和Essential Graph"></a>D、Covisibility Graph和Essential Graph</h2><p>关键帧之间的Covisibility信息在本文的SLAM系统中几个模块上都非常有用，像论文[7]一样，我们将其表示成一个间接的权重图。图中每个节点代表一个关键帧，如果两个关键帧都能同时观测到地图云点中至少15个点，则这两个关键帧之间用一条边线相连，我们用权重θ表示两个关键帧能共同观测到的云点数量</p><p>为了矫正闭环回路，我们像论文[6]那样做位姿图优化，优化方法延着位姿图将闭环回路的误差进行分散。考虑到covisibility graph可能非常密集的边缘，我们提出构建一个（Essential Graph），该图中保留了covisibility graph的所有节点（关键帧），但是边缘更少，仍旧保持一个强大的网络以获得精确的结果。系统从初始关键帧开始增量式地构建一个生成树，它是一个边缘数量最少的covisibility graph的子图像。当插入新的关键帧时，则判断其与树上的关键帧能共同观测到多少云点，然后将其与共同观测点最多的关键帧相连反之，当一个关键帧通过筛选策略被删除时，系统会重新更新与其相关的连接。Essential Graph包含了一个生成树，一个高covisibility（θmin=100）的covisibility graph边缘子集，以及闭环回路的边缘，这样的组合共同构建了一个强大的相机网络。图2展示了一个covisibility graph，生成树和相关的essential graph的例子。在本文第8部分第E节的实验里，当算法运行位姿图优化时，结果可以达到非常高的精度以至于即便是全局BA优化都很难达到。。essential graph的效用和θmin对算法的影响将在第8部分E节的最后讨论。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160115593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">&gt;图2 对TUM RGB-D标准库[38]中fr3_long_office_household图像序列进行重构以及本文用到的各种姿态图的例子</p></blockquote><h2 id="E、基于图像词袋模型的位置识别"><a href="#E、基于图像词袋模型的位置识别" class="headerlink" title="E、基于图像词袋模型的位置识别"></a>E、基于图像词袋模型的位置识别</h2><p>为了实现闭环检测与重定位，系统嵌入了基于DBoW2[5]算法来执行闭环检测和重定位。视觉词汇（Visual words）是一个离散化的特征描述子空间，被称为视觉词典。这部视觉词典是通过从大量图像中提取ORB描述子离线创建的。如果图像的通用性强，则同一部视觉词典在不同的环境下也能获得很好的性能，正如我们之前的论文[11]那样。SLAM系统增量式地构建一个数据库，该数据库中包含了一个反向指针，用于存储每个视觉词典里的视觉单词，关键帧可以通过这个数据库查询视觉词典，从而实现高效检索。当一个关键帧通过筛选程序删除时，数据库也会相应更新。</p><p>由于关键帧之间可能会存在视图上的重叠，因此检索数据库时，可能返回的结果不止一个高分值的关键帧。原版的DBoW2认为是图像重叠的问题，就将时间上接近的图像的分值相加。但这并没有包括观测同一地点但在不同时间插入的关键帧。为了解决这一问题，我们将这些与covisibility graph相连的关键帧进行分类。另外，我们的数据库返回的是分值高于最好分值75%的所有关键帧。<br>用词袋模型来表示特征匹配的另外一个优势在论文[5]里有详细介绍。如果我们想计算两个ORB特征的对应关系，我们可以强制匹配视觉字典树上某一层（我们在6层里面选第2层）的相同节点（关键帧）里的特征，这可以加快搜索速度。在本文中，我们就利用这个小技巧来搜索匹配的特征点，用于三角化新的点云，闭环检测和重定位。我们还引入一个方向一致性测试来改进匹配点，具体如论文[11]，这可以去掉无效数据，保证所有对应匹配点的旋转方向一致。</p><h1 id="IV-地图自动初始化"><a href="#IV-地图自动初始化" class="headerlink" title="IV. 地图自动初始化"></a>IV. 地图自动初始化</h1><p>地图初始化的目的是计算两帧图像之间的相对位姿来三角化一组初始的地图云点。这个方法应该与场景无关（平面的或一般的）而且不需要人工干预去选择良好的双视图配置，比如两幅图应具有明显的视差。本文算法提出并行计算两个几何模型，一个是面向平面视图的单映矩阵，另一个是面向非平面视图的基础矩阵。然后，采用启发式的方法选择模型，并使用所选的模型从两图像的相对位姿中对地图点云进行重构。本文算法只有当两个视图之间的视差达到安全阈值时，才进行地图初始化。如果检测到低视差的情况或已知两视图模糊的情况（如论文[27]所示），则为了避免生成一个有缺陷的地图而推迟初始化。算法的步骤是：</p><ul><li>1.查找初始的匹配点对：<br>从当前帧中提取ORB特征$F_c$（只在最好的尺度上），与在参考帧$Ｆ_r$搜索匹配点对 $x_c\leftrightarrow x_r$。如果找不到足够的匹配点对，就重置参考帧。</li><li>2.并行计算两个模型：<br>在两个线程上并行计算单应矩阵$H_{cr}$和基础矩阵$F_{cr}$ ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160909286.png#pic_center"><br>在文献[2]中详细解释了基于RANSAC的归一化DLT算法和8点算法计算原理。为了使两个模型的计算流程尽量一样，将两个模型的迭代循环次数预先设置成一样，每次迭代的特征点数目也预先设置好，基础矩阵是8个特征点对，单映矩阵是4个特征点对。每次迭代中，我们给每个模型M（H表示单映射，F表示基本矩阵）计算一个分值SM：</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160949854.png#pic_center"></p><p>其中，$d_{cr}^2$和$d_{rc}^2$是帧到帧之间的对称传递误差，其计算方法参见文献[2]。$T_M$是无效数据的排除阈值，它的依据是$\chi ^2$测试的95%（$T_H=5.99, T_F=3.84$，假设在测量误差上有1个像素的标准偏差）。 等于$T_H$，这样两个模型在有效数据上对于同一误差d的分值相同，同样使得运算流程保持一致。<br>我们从单应矩阵和基本矩阵的计算中选择分值最高的，但如果两个模型分值都不高（没有足够的局内点），则算法流程重启，从step1开始重新计算。</p><ul><li><p>3.模型选择：</p><p>如果场景是平面，近平面或存在低视差的情况，则可以通过单映矩阵来求解。同样地，我们也可以找到一个基础矩阵，但问题是基础矩阵不能够很好的约束该问题[2]，而且从基础矩阵中计算得到的运动结果是错误的。在这种情况下，我们应该选择单映矩阵才能保证地图初始的正确性，或者如果检测到低视差的情况则不进行初始化工作。另一方面，对于非平面场景且有足够的视差的情况则可以通过基础矩阵来计算，而在这种情况下单映矩阵只有基于平面点或者低视差的匹配点才能找到。因此，在这种情况下我们应该选择基础矩阵。我们利用如下强大的启发式进行计算：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161616755.png#pic_center"><br>如果$R_H&gt;0.45$ , 这表示二维平面和低视差的情况，我们将选择计算单应矩阵。其他的情况，我们选择基础矩阵。</p></li><li>4.运动和从运动到结构的重构</li><li>一旦选择好模型，我们就可以获得相应的运动状态。如果选择单映矩阵，我们按照Faugeras等人发表的论文[23]中提到的方法，提取8种运动假设，该方法提出用cheriality测试来选择有效解。然而，如果在低视差的情况下，这些测试就会失效，因为云点很容易在相机的前面或后面移动，会导致选解错误。我们提出的方法是直接按这8种解将二维点三角化，然后检查是否有一种解可以使得所有的云点都位于两个相机的前面，且重投影误差较小。如果没有一个明确的解胜出，我们就不执行初始化，重新从第一步开始。这种方法使初始化程序在低视差和两个交叉的视图情况下更具鲁棒性，这也是我们整个算法体现鲁棒性的关键所在。<br>在基本矩阵的情况下，我们使用标定矩阵K用下式将其转换为本质矩阵：．<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161803488.png#pic_center"><br>然后用文献[2]中的奇异值分解方法计算4个运动解，然后就像上文中叙述的一样，我们将四个解用于三角化特征点，以选择正解。</li><li>C5.Bundle adjustment<br>最后我们执行一个全局BA，详细优化过程参见附录，以优化初始重构得到的点云地图。<br>如图3所示是对论文[39]中的室外NewCollege机器人图像序列进行地图初始化的例子，室外环境下初始化工作具有很大挑战性。从图中可以看出，PTAM算法和LSD-SLAM算法对位于同一平面上的所有点都进行了初始化，而我们的方法是当两幅图像有足够视差之后才进行初始化，并基于基础矩阵得到了正确的结果。<blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161919724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图3 基于NewCollege图像序列[39]进行地图初始化，最上面一行：PTAM算法,中间一行：LSD-SLAM算法，底下一行：ORB-SLAM算法。其中，PTAM算法和LSD-SLAM算法初始化了一个错误的平面地图，而我们的方法自动选择在两帧图像存在足够视差的情况下再利用基础矩阵初始化。如果人工选择关键帧，则PTAM算法也能够初始化得很好。</p><h1 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h1><p>在这一部分，我们将详细介绍跟踪线程在相机每帧图像上执行的步骤。在几个步骤中都提到的相机位姿优化，包括运动BA，将在附录部分进行阐述。</p><h2 id="A、ORB特征提取"><a href="#A、ORB特征提取" class="headerlink" title="A、ORB特征提取"></a>A、ORB特征提取</h2><p>我们在8层图像金字塔上提取FAST角点，金字塔图像尺度因子为1.2。如果图像分辨率从512<em>384到752</em>480，我们发现提取1000个角点比较合适，如果分辨率提高，如KITTI数据集[40]，则提取2000个角点。为了确保特征点均匀分布，我们将每层图像分成网格，每格提取至少5个角点。然后检测每格角点，如果角点数量不够，就调整阈值。如果某些单元格内检测不出角点，则其对应提取的角点数量也相应减少。最后，根据保留的FAST的角点计算方向和ORB特征描述子。ORB特征描述子将用于算法后续所有的特征匹配，而不是像PTAM算法中那样根据图像区块的相关性进行搜索。</p><h2 id="B、通过前一图像帧估计相机的初始位姿"><a href="#B、通过前一图像帧估计相机的初始位姿" class="headerlink" title="B、通过前一图像帧估计相机的初始位姿"></a>B、通过前一图像帧估计相机的初始位姿</h2><p>如果上一帧图像跟踪成功，我们就用运动速率恒定模型来预测当前相机的位置（即认为摄像头处于匀速运动），然后搜索上一帧图像中的特征点在地图中的对应云点与当前帧图像的匹配点，最后利用搜索到的匹配点对当前相机的位姿进一步优化。但是，如果没有找到足够的匹配点（比如，运动模型失效，非匀速运动），我们就加大搜索范围，搜索地图云点附近的点在当前帧图像中是否有匹配点，然后通过寻找到的对应匹配点对来优化当前时刻的相机位姿。</p></blockquote></li></ul><h2 id="C、通过全局重定位来初始化位姿"><a href="#C、通过全局重定位来初始化位姿" class="headerlink" title="C、通过全局重定位来初始化位姿"></a>C、通过全局重定位来初始化位姿</h2><p>如果扩大了搜索范围还是跟踪不到特征点，（那么运动模型已经失效），则计算当前帧图像的词袋（BoW）向量,并利用BoW词典选取若干关键帧作为备选匹配帧（这样可以加快匹配速度）；然后，在每个备选关键帧中计算与地图云点相对应的ORB特征，就如第三部分E节所描述的。接着，对每个备选关键帧轮流执行PnP算法[41]计算当前帧的位姿（RANSAC迭代求解）。如果我们找到一个姿态能涵盖足够多的有效点，则搜索该关键帧对应的更多匹配云点。最后，基于找到的所有匹配点对相机位置进一步优化，如果有效数据足够多，则跟踪程序将持续执行。</p><h2 id="D、跟踪局部地图"><a href="#D、跟踪局部地图" class="headerlink" title="D、跟踪局部地图"></a>D、跟踪局部地图</h2><p>一旦我们获得了初始相机位姿和一组初始特征匹配点，我们就可以将更多的地图云点投影到图像上以寻找更多的匹配点。为了降低大地图的复杂性，我们只映射局部地图。该局部地图包含一组关键帧K1，它们和当前关键帧有共同的地图云点，还包括与关键帧K1在covisibility graph中相邻的一组关键帧K2。这个局部地图中有一个参考关键帧$K_{ref}∈K1$，它与当前帧具有最多共同的地图云点。现在对K1, K2中可见的每个地图云点，在当前帧中进行如下搜索：</p><ul><li>1.计算地图云点在当前帧图像中的投影点x。如果投影位置超出图像边缘，就将对应的地图云点删除</li><li>2.计算当前视图射线v和地图云点平均视图方向n的夹角。如果n&lt;cos(60o)，就删除对应云点</li><li>3.计算地图云点到相机中心的距离d。如果它不在地图云点的尺度不变区间内，即d∉[dmin,dmax]，就删除该云点</li><li>4.计算每帧图像的尺度比d/dmin</li><li>5.对比地图云点的特征描述子D和当前帧中还未匹配的ORB特征，在预测的尺度层和靠近x的云点作最优匹配</li></ul><p>相机位姿最后通过当前帧中获得所有的地图云点进行优化。（这个环节的目的是在当前帧和局部地图之间找到更多的匹配点对，来优化当前帧的位姿）。</p><h2 id="新关键帧的判断"><a href="#新关键帧的判断" class="headerlink" title="新关键帧的判断"></a>新关键帧的判断</h2><p>最后一步是决定当前帧是否可以作为关键帧。由于局部地图构建的过程中有一个机制去筛选冗余的关键帧，所以我们需要尽快地插入新的关键帧以保证跟踪线程对相机的运动更具鲁棒性，尤其是对旋转运动。我们根据以下要求插入新的关键帧：</p><ul><li>1.距离上一次全局重定位后需要超过20帧图像。</li><li>2.局部地图构建处于空闲状态，或距上一个关键帧插入后，已经有超过20帧图像。</li><li>3.当前帧跟踪少于50个地图云点。</li><li>4.当前帧跟踪少于参考关键帧K_ref云点的90%。</li></ul><p>与PTAM中用关键帧之间的距离作为判断标准不同，我们加入一个最小的视图变换，如条件4。条件1 确保一个好的重定位，条件3保证好的跟踪。如果局部地图构建处于忙状态（条件2的后半部分）的时候插入关键帧，就会发信号去暂停局部BA，这样就可以尽可能快地去处理新的关键帧。</p><h1 id="局部建图"><a href="#局部建图" class="headerlink" title="局部建图"></a>局部建图</h1><p>这章我们将描述根据每个新的关键帧$K_i$构建局部地图的步骤。</p><h2 id="A、关键帧插入"><a href="#A、关键帧插入" class="headerlink" title="A、关键帧插入"></a>A、关键帧插入</h2><p>首先更新covisibility graph，具体包括：添加一个关键帧节点$K_i$，检查与$K_i$有共同云点的其他关键帧，用边线连接。然后，更新生成树上与$K_i$有最多共享点的其他关键帧的链接。计算表示该关键帧的词袋，并利用三角法生成新的地图云点。</p><h2 id="地图点云筛选"><a href="#地图点云筛选" class="headerlink" title="地图点云筛选"></a>地图点云筛选</h2><p>三角化的云点为了已知保留在地图中，必须在其创建后的头三个关键帧中通过一个严格的测试，该测试确保留下的云点都是能被跟踪的，不是由于错误的数据而被三角化的。一个云点必须满足如下条件：</p><ul><li>1.跟踪线程必须在超过25%的图像中找到该特征点。</li><li>2.如果创建地图云点经过了多个关键帧，那么它必须至少是能够被其他3个关键帧观测到。</li></ul><p>一旦一个地图云点通过测试，它只能在被少于3个关键帧观测到的情况下移除。这样的情况在关键帧被删除以及局部BA排除异值点的情况下发生。这个策略使得我们的地图包含很少的无效数据。</p><h2 id="C、新地图点云创建"><a href="#C、新地图点云创建" class="headerlink" title="C、新地图点云创建"></a>C、新地图点云创建</h2><p>新的地图云点的创建是通过对covisibility graph中连接的关键帧Kc中的ORB特征点进行三角化实现的。对Ki中每个未匹配的ORB特征，我们在其他关键帧的未匹配云点中进行查找，看是否有匹配上的特征点。这个匹配过程在第三部分第E节中有详细阐述，然后将那些不满足对级约束的匹配点删除。ORB特征点对三角化后，需要对其在摄像头坐标系中的深度信息，视差，重投影误差和尺度一致性进行审查，通过后则将其作为新点插入地图。起初，一个地图云点通过2个关键帧观测，但它在其他关键帧中也有对应匹配点，所以它可以映射到其他相连的关键帧中，搜索算法的细则在本文第5部分D节中有讲述。</p><h2 id="D、局部BA"><a href="#D、局部BA" class="headerlink" title="D、局部BA"></a>D、局部BA</h2><p>局部BA主要对当前处理的关键帧$K_i$,以及在covisibility graph中与$K_i$连接的其他关键帧$K_c$，以及这些关键帧观测到的地图云点进行优化所有其他能够观测到这些云点的关键帧但没有连接$K_i$的会被保留在优化线程中，但保持不变。优化期间以及优化后，所有被标记为无效的观测数据都会被丢弃，附录有详细的优化细节。</p><h2 id="E、局部关键帧筛选"><a href="#E、局部关键帧筛选" class="headerlink" title="E、局部关键帧筛选"></a>E、局部关键帧筛选</h2><p>为了使重构保持简洁，局部地图构建尽量检测冗余的关键帧，删除它们。这样对BA过程会有很大帮助，因为随着关键帧数量的增加，BA优化的复杂度也随之增加。当算法在同一场景下运行时，关键帧的数量则会控制在一个有限的情况下，只有当场景内容改变了，关键帧的数量才会增加，这样一来，就增加了系统的可持续操作性。如果关键帧Kc中90%的点都可以被其他至少三个关键帧同时观测到，那认为Kc的存在是冗余的，我们则将其删除。尺度条件保证了地图点以最准确的方式保持它们对应的关键帧（这句翻译没理解透：The scale condition ensures that map points maintain keyframes from which they are measured with most accuracy.）这个策略受Tan等人的工作[24]的启发，在这项工作中，作者在经过一系列变化检测后即将关键帧删除。</p><h1 id="闭环检测"><a href="#闭环检测" class="headerlink" title="闭环检测"></a>闭环检测</h1><p>闭环检测线程抽取$K_i$——最后一帧局部地图关键帧，用于检测和闭合回环。具体步骤如下：</p><h2 id="A、候选关键帧"><a href="#A、候选关键帧" class="headerlink" title="A、候选关键帧"></a>A、候选关键帧</h2><p>我们先计算Ki的词袋向量和它在covisibility graph中相邻图像（θmin=30）的相似度，保留最低分值Smin。然后，我们检索图像识别数据库，丢掉那些分值低于Smin的关键帧。这和DBoW2中均值化分值的操作类似，可以获得好的鲁棒性，DBoW2中计算的是前一帧图像，而我们是使用的covisibility信息。另外，所有连接到Ki的关键帧都会从结果中删除。为了获得候选回环，我们必须检测3个一致的候选回环（covisibility graph中相连的关键帧）。如果对Ki来说环境样子都差不多，就可能有几个候选回环。</p><h2 id="B、计算相似变换"><a href="#B、计算相似变换" class="headerlink" title="B、计算相似变换"></a>B、计算相似变换</h2><p>单目SLAM系统有7个自由度，3个平移，3个旋转，1个尺度因子 [6]。因此，闭合回环，我们需要计算从当前关键帧Ki到回环关键帧Kl的相似变换，以获得回环的累积误差。计算相似变换也可以作为回环的几何验证。</p><p>我们先计算ORB特征关联的当前关键帧的地图云点和回环候选关键帧的对应关系，具体步骤如第3部分E节所示。此时，对每个候选回环，我们有了一个3D到3D的对应关系。我们对每个候选回环执行RANSAC迭代，通过Horn方法（如论文[42]）找到相似变换。如果我们用足够的有效数据找到相似变换Sil，我们就可以优化它，并搜索更多的对应关系。如果Sil有足够的有效数据，我们再优化它，直到Kl回环被接受。</p><h2 id="C、回环融合"><a href="#C、回环融合" class="headerlink" title="C、回环融合"></a>C、回环融合</h2><p>回环矫正的第一步是融合重复的地图云点，在covisibility graph中插入与回环相关的的新边缘。先通过相似变换Sil矫正当前关键帧位姿Tiw，这种矫正方法应用于所有与Ki相邻的关键帧，这样回环两端就可以对齐。然后，回环关键帧及其近邻能观测到的所有地图云点都映射到Ki及其近邻中，并在映射的区域附近小范围内搜索它的对应匹配点，如第5部分D节所述。所有匹配的地图云点和计算Sil过程中的有效数据进行融合。融合过程中所有的关键帧将会更新它们在covisibility graph中的边缘，创建的新边缘将用于回环检测。</p><h2 id="D、Essential-Graph优化"><a href="#D、Essential-Graph优化" class="headerlink" title="D、Essential Graph优化"></a>D、Essential Graph优化</h2><p>为了有效地闭合回环，我们通过Essential Graph优化位姿图，如第三部分D节所示，这样可以将回环闭合的误差分散到图像中去。优化程序通过相似变换校正尺度偏移，如论文[6]。误差和成本计算如附录所示。优化过后，每一个地图云点都根据关键帧的校正进行变换。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>我们采用NewCollege[39]的大场景机器人图像序列对本文提出的系统进行了较全面的实验评估，首先采用TUM的室内16个手持RGB-D数据集[38]对系统的总体性能进行了评估，包括算法的定位精度，重定位和程序运行能力；然后，用KITTI的10个汽车户外图像数据集[40]，评估算法在实时大场景下的操作及其定位精度和位姿图的优化效率。</p><p>算法运行在Intel Core i7-4700MQ （4核@2.40GHz）和8GB RAM的实验平台上，运算速率可达到实时，且以帧率对图像进行准确处理。ORB-SLAM有3个主线程，它们和其他ROS线程并行运行，由于引入了ROS操作系统，因此算法结果具有一定的随机性，针对这个原因，我们在一些实验中公布了算法运行的中间结果。</p><h2 id="A、基于Newcollege数据集测试系统性能"><a href="#A、基于Newcollege数据集测试系统性能" class="headerlink" title="A、基于Newcollege数据集测试系统性能"></a>A、基于Newcollege数据集测试系统性能</h2><p>NewCollege数据集[39]包含了一个2.2公里的校园的机器人图像序列。它是由双目相机拍摄，帧率为20fps，分辨率512x38。图像序列中包含几个回环和快速的旋转，这对单目视觉定位非常具有挑战性。据我们所知，目前没有单目系统可以处理整个图像序列。例如论文[7]，尽管其算法可以实现回环检测，也可以应用于大场景环境，但只有小部分序列图像能够显示单目结果。.<br>如图4显示的是我们的算法检测到的闭合回路，从图中可以看出，我们选择的有效数据点都支持相似性变换。图5则对比了回环闭合前后的环境地图重构状况。其中，红色标注的是局部地图，回环检测后可以看到其两端扩展到连接整个运行轨迹。图6是以实时帧率速度运行整个图像序列后的全局地图，从图中可以看出，后边的大回环并没有完全闭合，它从另外一个方向穿过，位置识别程序没能发现闭合回路。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164011644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201911011640368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164055751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><p>我们统计了ORB_SLAM算法每个线程所用的时间。表1显示了算法跟踪和局部构图的时间。可以看出，跟踪的帧率大概在25-30Hz，这是跟踪局部地图所需的最多时间。如果需要的话，这个时间还可以更快，只要减少局部地图中所包含的关键帧数量即可。局部地图构建线程中需时最高的是局部BA优化。局部BA的时间根据机器人探索环境的状态变动，即在未探索环境下所需时间多，在已经探索过的环境下运行所需时间少，因为在未知环境中如果跟踪线程插入一个新的关键帧，BA优化会被中断，如第5部分E节所示。如果不需要插入新的关键帧，局部BA优化则会执行大量已经设置的迭代程序。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164133928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><p>表2显示了6个闭合回路的结果。可以看到回环检测是如何亚线性地随关键帧数量的增多而增加。这主要是由于高效的数据库检索，表2中只比较了具有相同图像单词的图像子集，由此可见用于位置识别词袋模型的潜力。我们的Essential Graoh中包含的边缘是关键帧数量的5倍，它是一个稀疏图。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164204706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h2 id="B、基于TUM-RGB-D标准库的定位精度"><a href="#B、基于TUM-RGB-D标准库的定位精度" class="headerlink" title="B、基于TUM RGB-D标准库的定位精度"></a>B、基于TUM RGB-D标准库的定位精度</h2><p>TUM RGB-D数据集[38]是一个用于估计摄像头定位精度的优秀数据库，它提供了许多图像序列，还包括外部运动捕捉系统提供的对应轨迹真值。我们去掉那些不适合纯单目SLAM系统的图像序列，这些序列包含强烈的旋转，没有纹理或没有运动。</p></blockquote><p>为了验证算法性能，我们选择了最近提出的直接法半稠密LSD-SLAM（论文[10]）和经典算法PTAM（论文[4]）作为对比。除此之外，我们还比较了由RGBD-SLAM（论文[43]）算法生成的轨迹。为了在相同的基准下比较ORB-SLAM，LSD-SLAM和PTAM，我们用相似变换对齐关键帧轨迹，在尺度未知的情况下，检测轨迹的绝对误差（论文[38]）。对RGBD-SLAM算法，我们通过相机坐标变换来对齐轨迹，也采用同样的方法检测尺度是否重构良好。LSD-SLAM从随机深度值开始初始化，然后随机值逐渐收敛，因此与基准对比的时候，我们会丢掉前10个关键帧。对于PTAM算法，我们从一个好的初始化中，手动选择两个关键帧。表3 是对我们选择的16个图像序列运行5次的中间结果。<br>TUM RGB-D数据集[38]是一个用于估计摄像头定位精度的优秀数据库，它提供了许多图像序列，还包括外部运动捕捉系统提供的对应轨迹真值。我们去掉那些不适合纯单目SLAM系统的图像序列，这些序列包含强烈的旋转，没有纹理或没有运动。</p><p>为了验证算法性能，我们选择了最近提出的直接法半稠密LSD-SLAM（论文[10]）和经典算法PTAM（论文[4]）作为对比。除此之外，我们还比较了由RGBD-SLAM（论文[43]）算法生成的轨迹。为了在相同的基准下比较ORB-SLAM，LSD-SLAM和PTAM，我们用相似变换对齐关键帧轨迹，在尺度未知的情况下，检测轨迹的绝对误差（论文[38]）。对RGBD-SLAM算法，我们通过相机坐标变换来对齐轨迹，也采用同样的方法检测尺度是否重构良好。LSD-SLAM从随机深度值开始初始化，然后随机值逐渐收敛，因此与基准对比的时候，我们会丢掉前10个关键帧。对于PTAM算法，我们从一个好的初始化中，手动选择两个关键帧。表3 是对我们选择的16个图像序列运行5次的中间结果。</p><p>从表中可以看出，ORB-SLAM可以处理所有的图像序列，除了fr3 nostructure texture far (fr3 nstr tex far)以外。这是一个平面的场景，相机的轨迹在这种情况下有两种可能，正如论文[27]中的描述的。我们的初始化方法检测到这种模棱两可的情况，为了保证算法的安全运行选择不进行初始化。PTAM初始化有时会选择对的方案，有些可能会选择错的方案，且导致的错误可能不能接受。我们没有注意到LSD-SLAM的2种不同的重构方案，但在这个图像序列出现的错误非常多。针对其他的图像序列，PTAM和LSD-SLAM算法的鲁棒性都比我们的方法差，且分别有八组序列和三组序列中地图点容易跟踪丢失。</p><p>关于精度问题，没有回环检测期间，ORB-SLAM和PTAM算法的定位精度相当，但回环检测成功后，ORB-SLAM算法将达到更高的定位精度，正如在图像序列fr3 nostructure texture near withloop (fr3 nstr tex near)中表现的。非常意外的一个结果是PTAM和ORB-SLAM都非常明显地表现出精度高于LSD-SLAM和RGBD-SLAM。一个可能的原因是它们将地图的优化过程简化为一个单纯的姿态图优化过程，这样就造成了传感器测量信息的丢失，但在我们的算法中，采用BA优化，同时通过传感器测量优化相机的姿态和地图的云点位置，这是解决运动到结构[2]的经典标准算法。。我们将在第9部分B节进一步讨论了这个结果。另一个有趣的结果是在图像序列fr2 desk with person 和 fr3 walking xyz中，LSD-SLAM对动态物体的鲁棒性相比ORB-SLAM差一些。</p><p>我们注意到RGBD-SLAM在图像序列fr2上尺度上有一个偏差，用7自由度对齐轨迹则误差明显减少。最后我们注意到Engle等人在论文[10]中提出在f2_xyz上PTAM的精度比LSD-SLAM算法低，RMSE是24.28cm。然而，论文没有给出足够的细节说明如何获得这些结果的，因此我们没有办法复现它。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164359174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h2 id="C、基于TUM-RGB-D标准数据库的重定位"><a href="#C、基于TUM-RGB-D标准数据库的重定位" class="headerlink" title="C、基于TUM RGB-D标准数据库的重定位"></a>C、基于TUM RGB-D标准数据库的重定位</h2><p>我们在TUM RGB-D数据集上进行了两组重定位实验。在第一个实验中，我们选择fr2_xyz图像序列，通过前30秒构建了一个地图，然后对后来的每一帧图像都进行全局重定位，并评估重构出来的相机位姿精度。我们对PTAM算法进行了相同的实验。如图7所示是创建初始地图的关键帧，重定位的图像帧位姿和这些帧对应的真值。从图中可以看出PTAM算法只能够对重定位关键帧附近的图像帧，这是因为其算法中重定位方法并不具备不变形导致的。表4显示了PTAM算法和ORB_SLAM算法相对地面真值的误差。从表中数据可以看出，ORB-SLAM比PTAM可以更精准地多定位2倍的图像帧。在第2个实验中，我们采用fr3_sitting_xyz图像序列来初始化地图，然后用fr3_walking_xyz图像序列重定位所有的图像帧。这是一个颇具挑战性的实验，由于图像中有人移动，会造成图像局部区域的遮挡。在该试验中，PTAM并没有实现重定位，而ORB-SLAM重定位了78%的图像帧，如表4所示。图8显示了ORB-SLAM重定位的一些实验图例。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164542153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164634243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164649369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h2 id="D、基于TUM-RGB-D标准数据集测试算法的运行生命"><a href="#D、基于TUM-RGB-D标准数据集测试算法的运行生命" class="headerlink" title="D、基于TUM RGB-D标准数据集测试算法的运行生命"></a>D、基于TUM RGB-D标准数据集测试算法的运行生命</h2></blockquote><p>之前的重定位实验表明我们的系统可以从非常不同的视角定位地图，在中等动态环境中的鲁棒性也较好。这个特性和关键帧筛选程序使得算法在不同的视角和局部动态环境中能够一直运行到图像结束。</p><p>在全静态场景情况下，即使相机从不同视角观测场景，ORB-SLAM也可以使关键帧数量保持在一个有限的水平内。我们在一个自定义的图像序列中验证了这一点，手持相机在93秒以内都拍摄同一张桌子，但视角一直变换，形成一个轨迹。我们对比了我们地图的关键帧数量和PTAM生成的关键帧，如图9所示。可以看到PTAM一直都在插入关键帧，而ORB-SLAM会删除冗余的关键帧，将其总数保持在一个稳定的范围内。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164757407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><p>当然，在整个程序运行过程中，静态环境下的正常操作是任何SLAM系统的一个基本要求，更引人关注的是动态环境下的状况。我们在几个fr3的图像序列中分析了ORB-SLAM系统的状况，图像序列有：sitting xyz, sitting halfsphere, sitting rpy, walking xyz, walking halfspehere 和walking rpy。所有的视频中，相机都对着桌子，但运动轨迹不同，拍摄场景中有人在移动，椅子也被移动了。如图10（a）所示是ORB_SLAM算法生成的地图中所有关键帧的总数量，图10（b）显示从图像帧中创建或删除关键帧，从中可以看出从关键帧到地图构建需要多久时间。可以看到前2个图像序列中新看到（增加）场景时地图的大小一直在增加。图10（b）是前2个视频中创建的关键帧。在视频sitting_rpy和walking_xyz中，地图没有增加，地图是通过已有场景创建。相反，在最后两个视频中，有更多的关键帧插入但没有在场景中表示出来，可能由于场景的动态变化。图10（C）是关键帧的柱状图，它们是从视频中挑选出来的。大部分的关键帧被筛选程序删除了，只有一小部分留下来了。ORB-SLAM有大量关键帧的生成策略，在未知环境下非常有用；后面系统会生成一个小的子集来代表这些关键帧。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164845644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><p>在整个实验中，我们系统的地图根据场景上内容来增加，而不是根据时间，它可以存储场景的动态变化，对场景的理解非常有用。</p><h2 id="E、基于KITTI数据集测试算法在大场景大回环下的性能对比"><a href="#E、基于KITTI数据集测试算法在大场景大回环下的性能对比" class="headerlink" title="E、基于KITTI数据集测试算法在大场景大回环下的性能对比"></a>E、基于KITTI数据集测试算法在大场景大回环下的性能对比</h2><p>KITTI数据集中里程计的数据包括11个视频，它的获取是在一个住宅区驾驶汽车，基准精度非常高，有一个GPS和一个Velodyne Laser Scanner。这个数据集对单目系统非常有挑战性，因为视频中有快速旋转，区域内有大量树叶，这使数据关联变得更困难，而且车速相对较快，视频记录的频率为10fps。除了视频01外，ORB-SLAM可以处理其他所有的视频，01是高速路上的视频，可追踪的物体非常少。视频00,02,05,06,07,09，有闭环回路，系统可以检测到，并使它闭合。其中视频09的闭环只能在视频的最后几个图像帧里检测到，并不是每次都能成功检测到（结果显示的是针对其被检测到的运行情况）。<br>对于轨迹与基准的定性比较如图11和12所示。在TUM RGB-D数据集中，我们可以通过相似变换对齐轨迹的关键帧和基准。图11是定性比较的结果，图12是论文[25]中的最新单目SLAM在视频00,05,06,07和08上执行的结果。除了08有一些偏移以外，ORB-SLAM在这些视频上的轨迹都很精准。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165216473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165258286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><p>表5显示了每个视频的关键帧轨迹中间的RMSE误差。我们基于地图尺寸提供了轨迹的误差。结果表明我们的轨迹误差是地图尺寸的1%左右。大致范围低的是视频03的0.3%高的是视频08的5%。视频08中没有闭环，漂移也没办法纠正，因为闭环控制需要获得更精确的重构。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165353994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><p>在本次实验中，我们还确认了到底全局BA的20层迭代最终能优化多少地图重构，相关细节如附录所示。我们还注意到全局BA优化可以稍微增加闭环轨迹的精度，但这对开环轨迹有负面影响，这意味着我们的系统已经非常精确了。在有些应用中，如果需要非常精确的结果我们的算法会提供一组匹配，需要定义一个比较强的相机网络，一个初始估计，这样全局BA优化迭代次数就会变少。</p><p>最后讲一下我们算法的闭环检测和用于essential graph边缘的θmin的效率。我们选择视频09（一段非常长的图像序列，在最后有一个闭环），然后评估不同的闭环检测算法。表6是关键帧轨迹RMSE和不同情况下没有闭环检测优化所用的时间，表中的相关内容包括：如果直接采用全局BA优化（20层或100层迭代）的情况，如果只用位姿图优化（10层迭代不同数量的边缘）的情况，如果先用位姿图优化再执行全局BA优化的情况。结果表明，在闭环检测之前，算法的RMSE误差较大，以至于BA优化没办法收敛，即便是迭代100次之后后误差仍旧非常大。另一方面，essential graph优化收敛速度很快，而且结果也更精确。θmin对精度影响并不大，减少边缘的数量会明显降低精度。位姿图优化后再执行一个BA优化则可以增加精度，但时间也增加了。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019110116552977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h1 id="结论和讨论"><a href="#结论和讨论" class="headerlink" title="结论和讨论"></a>结论和讨论</h1><h2 id="A、结论"><a href="#A、结论" class="headerlink" title="A、结论"></a>A、结论</h2><p>本文中，我们提出了一个新的单目SLAM系统，并详细介绍了其组成模块，最后基于公共数据库对其性能进行了全方位的测试。通过实验得知，我们的系统可以处理室内与室外的图像序列，能够用于汽车、机器人和手持设备上。其定位精度在室内小场景中约为1厘米，室外大场景的应用是几米（前提是我们与真实轨迹尺度对齐的情况下）。</p></blockquote><p>由Klein和Murray[4]提出的PTAM算法被认为是目前最精准的单目实时SLAM方法。PTAM后端是BA优化，这是众所周知的离线SFM（从运动到结构）问题[2]的经典解法。PTAM算法和Mouragnon[3]早期作品的主要贡献是将BA算法引入到机器人SLAM框架下，并具有良好的实时性。而本文的主要贡献是将PTAM算法的适用性进一步扩展，使其可以应用于原来不可应用的场景下。为了实现这一目标，我们整合了前面几年的优秀作品，引入新的想法和算法，从头设计了一种新的单目SALM系统所用到的技术包括Gálvez-López和Tardós提出的论文[5]中的闭环检测，Strasdat等人在论文[6],[7]中提出的的闭环检测程序和covisibility graph，Kuemmerle等人在论文[37]中提出的g2o优化框架以及Rubble等人提出的ORB特征[9]。到目前为止就我们所知，本文提出的ORB_SLAM方法的定位精度最高，也是最可靠最完整的单目SLAM系统。我们提出的新的生成和删除关键帧策略，允许每个几帧就创建一个关键帧，然后当关键帧冗余时则删除。这样的构图方式很灵活，在外界条件很差的情况下可以保证系统正常运行，比如相机作纯旋转运动或快速移动时。当算法在相同场景下运行时，地图在只有拍摄到新内容的情况下才会增长，可以从我们的长期构图结果中看到这个特性。</p><p>最后，我们还展示了ORB特征具有很好的识别能力，可识别剧烈视角变换情况下的场景信息。此外，它们能够被非常快速的提取和匹配（不需要多线程或GPU加速），这就使得跟踪和地图构建更加实时精确。</p><h2 id="B、离散-特征SLAM方法与稠密-直接SLAM方法对比"><a href="#B、离散-特征SLAM方法与稠密-直接SLAM方法对比" class="headerlink" title="B、离散/特征SLAM方法与稠密/直接SLAM方法对比"></a>B、离散/特征SLAM方法与稠密/直接SLAM方法对比</h2><p>最近，DTAM[44]和LSD-SLAM[10]提出了一种实时单目SALM算法，算法直接利用图像像素的亮度信息进行摄像头的定位与优化，并重构稠密或半稠密的环境地图。这类方法即为直接法，直接方法不需要特征提取，可以避免人工匹配。他们对图像模糊，弱纹理环境和像论文[45]这样的高频纹理环境的鲁棒性更好。与由稀疏点构建的地图相比，比如ORB-SLAM或PTAM算法，稠密/直接法SLAM对相机定位之外的其他应用任务可能更有用途。</p><p>部分重译： 然而，直接方法有他们自己的局限。首先，这些方法假设真实场景中的物体的像是由该物体本身的表面反射模型产生的，因此，算法采用的光度一致性寻找匹配点的思路就限制了匹配点之间的基线距离，通常都比特征匹配点的基线要窄。这对重构的精度影响很大，因为重构需要较宽的基线来减少深度的不确定性。如果直接建模不准确，则可能会受到快门，自动增益和自动曝光的影响（如TUM RGB-D 的对比测试）。最后，由于直接方法计算要求较高，因此为了满足计算速度，DTAM算法采用地图增量式扩张的方法，而LSD-SLAM则丢掉传感器测量信息，将地图优化降低为对位姿图的优化。</p><p>相反，基于特征的方法可以在更宽的基线上匹配特征，主要得益于特征匹配算法较好地视图不变特性。BA优化和相机位姿优化，地图云点通过传感器测量进行融合。在运动结构估计中，论文[46]已经指出了基于特征的方法相比直接方法的优势。在我们的实验第8部分B节中也直接提供了证据，，表明基于特征的定位精度更高。未来单目SLAM应该会整合两种最好的方法。</p><h2 id="C、后续"><a href="#C、后续" class="headerlink" title="C、后续"></a>C、后续</h2><p>我们系统的精度可以通过结合无限远点跟踪来进一步增强。这些在视图中看不到的平行线交点，并没有包含在本文算法构建的地图中，但对相机的旋转非常有用[21]。</p><p>另外一种方法是将稀疏地图更新到一个更加稠密的地图。由于我们关键帧的选择机制，关键帧组成了一个紧凑的地图，地图具有非常高精度的位姿信息和丰富的covisibility信息。所以，ORB-SLAM稀疏地图是一个非常优秀的初始估计框架，比稠密地图更好。这个方向的首次尝试在论文[47]中有详细描述。</p><h1 id="附录：非线性优化"><a href="#附录：非线性优化" class="headerlink" title="附录：非线性优化"></a>附录：非线性优化</h1><ul><li><p>Bundle Adjustment (BA)<br>地图云点3D位置 $X_{w,j}∈R^3$，关键帧位姿$T_{iw}∈SE(3)$，w表示世界坐标，通过匹配的关键点$X_{i,j}∈R^2$减少重投影误差。地图云点j在关键帧i中的误差是：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165938350.png#pic_center"><br>其中$π_i$是影射函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101170009868.png#pic_center"><br>其中，$R_{iw}∈SO(3)$，$t_{iw}∈R3$，分别表示$T_{iw}$的旋转和平移部分，$f_{i,u} , f_{i,v}）$，$（c_{i,u} , c_{i,v}）$分别是相机i的焦点距离和主点。<br>代价函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101170602738.png#pic_center"><br>$ρ_h$是Huber鲁棒损失函数，$Ω_{i,j}=δ_{i,j}^2I_{2x2}$是协方差矩阵，与检测关键点的尺度有关。在全局BA中（用于地图初始化，请参见第IV节在第VIII-E节），我们优化了所有点和关键帧。但第一个关键帧除外，这些关键帧保持为原点。在局部BA中（请参见VI-D节），局部区域中包含的所有点均得到优化，而关键帧的子集是固定的。 在姿态优化，或者motion-only BA，（见V）将所有点固定，仅将优化相机姿态。</p></li><li><p>Sim（3）约束下的姿势图优化[6]：给定二进制边的姿势图（请参阅第VII-D节）我们将误差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101171244797.png#pic_center"></p><p>其中，$S_{ij}$是在姿势图优化并将比例因子设置为1之前，从SE（3）姿势计算出的两个关键帧之间的相对Sim（3）变换。在闭环边的情况下，该相对变换通过Horn角[42]的方法。 $log_{Sim3}$ [48]转换为切线空间，因此误差是$R^7$维的向量。 目标是“优化Sim（3）关键帧姿势，以最小化损失”功能：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101171657388.png#pic_center"></p><p>其中$Λ_{i; j}$是边缘的信息矩阵，如[48]所示，我们将其设置为恒等式。 我们修复了回路闭合关键帧，以修复7度规的自由度。 尽管“此方法”是完整BA的粗略近似，但我们在VIII-E节中通过实验证明，它比BA具有显着更快和更好的收敛性。</p></li></ul><ul><li>Relative Sim(3) Optimization<br>给定关键帧1和关键帧2之间的一组n个匹配$i\leftrightarrow j$（关键点及其关联的3D映射点），我们要优化相对Sim（3）变换$S_{12}$（请参见VII-B部分），以最大程度地减小图像间重投影误差：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101172300914.png#pic_center"><br>最小化损失函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101172336172.png#pic_center"><br>其中$Ω_{1; i}$和$Ω_{2; i}$是与比例相关的协方差矩阵，与图像1和图像2中的关键点的方差有关。 在此优化中点是固定的。</li></ul><blockquote><p>参考：<br><a href="http://www.jintiankansha.me/t/SlssOSIu57" target="_blank" rel="noopener">【泡泡机器人翻译专栏】ORB-SLAM：精确多功能单目SLAM系统(一)</a><br><a href="https://www.sohu.com/a/161346283_715754" target="_blank" rel="noopener">【泡泡机器人翻译专栏】ORB-SLAM：精确多功能单目SLAM系统(二)</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;&lt;center&gt;ORB-SLAM：一种通用的(全能的)精确的单目SLAM系统&lt;center&gt;&lt;/center&gt;&lt;/center&gt;&lt;/p&gt;&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文提出了ORB-SLAM，在大小场景、室内室外环境下都可以实时操作的一种基于特征的单目SLAM系统。系统对复杂的剧烈运动具有鲁棒性，允许宽基线的闭环和重定位，且包含完整的自动初始化。基于最近几年的优秀算法之上，我们从头开始设计了一种新颖的系统，它对所有SLAM任务使用相同的特征：追踪、建图、重定位和闭环。合适策略的存在使得选择的重建点和关键帧具有很好的鲁棒性，并能够生成紧凑的可追踪的地图，只有当场景内容发生变化地图才改变，从而允许长时间操作。本文从最受欢迎的数据集中提供了27个序列的详尽评估。相对于其他最先进的单目SLAM方法，ORB-SLAM实现了前所未有的性能。为了社会的利益，我们将源代码公开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ORB-SLAM2" scheme="https://xiao-hu.com.cn/categories/ORB-SLAM2/"/>
    
    
      <category term="ORB-SLAM2" scheme="https://xiao-hu.com.cn/tags/ORB-SLAM2/"/>
    
  </entry>
  
  <entry>
    <title>ORB-SLAMB2——论文翻译（ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras）</title>
    <link href="https://xiao-hu.com.cn/2019/10/31/ORB-SLAMB2%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras%EF%BC%89/"/>
    <id>https://xiao-hu.com.cn/2019/10/31/ORB-SLAMB2——论文翻译（ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras）/</id>
    <published>2019-10-31T09:15:37.000Z</published>
    <updated>2019-11-01T06:39:37.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>ORB-SLAM2是基于单目，双目和RGB-D相机的一套完整的SLAM方案。它能够实现地图重用，回环检测和重新定位的功能。无论是在室内的小型手持设备，还是到工厂环境的无人机和城市里驾驶的汽车，ORB-SLAM2都能够在标准的CPU上进行实时工作。ORB-SLAM2在后端上采用的是基于单目和双目的光束法平差优化（BA）的方式，这个方法允许米制比例尺的轨迹精确度评估。此外，ORB-SLAM2包含一个轻量级的定位模式，该模式能够在允许零点漂移的条件下，利用视觉里程计来追踪未建图的区域并且匹配特征点。我们用29个广泛使用的公共数据测试的结果显示，在大多数情况下，本文方案比此前方案精度更高，此外，我们开源了ORB-SLAM2源代码，不仅仅是为了整个SLAM领域，同时也希望能够为其他领域研究者提供一套SLAM的解决方案。</p><a id="more"></a><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>SLAM（同时定位与地图重建）在过去的20年中，一直是计算机视觉和机器人领域的热门话题，同时也吸引了很多高科技公司的关注。SLAM技术是在未知的环境当中建立一个地图并且能够在地图当中实时的定位。在不同类型的传感器当中，相机十分廉价，并且能够提供丰富的环境信息，受到研究者的青睐。相机提供的图像信息可以用作鲁棒的和精确的位置识别。位置识别是SLAM系统中回环检测的关键模块（例如，当传感器检测到一个已经建好图的位置的时候，可以进行修正在探索过程中的误差）以及，能够修正由于剧烈的震动或者在系统进行初始化的时候在相机跟踪失败后的重新定位。因此以相机为核心的视觉SLAM在过去的一年中得到快速的发展。 </p><p>   视觉SLAM仅仅通过一个单目相机就能够完成。单目相机也是最便宜也是最小巧的传感器设备。然而深度信息无法从单目相机中观测到，地图的尺度和预测轨迹是未知的。此外，由于不能从第一帧当中进行三角测量化，单目视觉SLAM系统的启动往往需要多个视角或者滤波技术才能产生一个初始化的地图。最后，单目SLAM可能会造成尺度漂移,以及在探索的过程中执行纯旋转的时候可能会失败。通过使用一个双目或者RGB-D相机将会解决这些问题，并且能够成为一种更加有效的视觉SLAM的解决方案。</p><p> 在这篇文章当中，我们在单目ORB-SLAM[1]的基础上提出ORB-SLAM2，有以下贡献：</p><pre><code>1. 这是首个基于单目，双目和RGB-D相机的开源SLAM方案，这个方案包括，回环检测，地图重用和重定位。2. 我们的RGB-D结果说明，光速法平差优化（BA）比ICP或者光度和深度误差最小方法的更加精确。3. 通过匹配远处和近处的双目匹配的点和单目观测，我们的双目的结果比直接使用双目系统更加精确。4. 针对无法建图的情况，提出了一个轻量级的定位模式 ，能够更加有效的重用地图。</code></pre><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031172843722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图1中显示的是双目和RGB输入下的ORBSLAM2的输出。双目例子显示的是最后轨迹和稀疏重建的地图。这里的数据集来源于KITTI的Sequence00数据集。这个城市数据集是ORB-SLAM2多次成功提取特征，并且回环检测而来。RGB-D例子是来源于TUM 的RGB-D 数据库中的fr1_room的数据集，并且进行关键帧的位姿评估而来。通过评估关键帧的位姿，映射深度图，最终形成一个稠密的点云图。指的注意的一点是，ORB-SLAM2虽不像Kinect Fusion一样进行数据融合，但是却能够很精确的估计关键帧的位姿。更多的例子在附件视频中展示。<br>在余下的篇章当中，我们将会在第二部分讨论相关的工作。在第三部分谈论ORB-SLAM2系统框架。第四部分评价ORB-SLAM2，第五部分得出结论。</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>在这个章节，我们将会讨论双目和RGB-D SLAM的相关工作。评估部分我们放在第四部分，本章我们主要讨论的是SLAM的方法。</p><h2 id="A-双目SLAM"><a href="#A-双目SLAM" class="headerlink" title="A.双目SLAM"></a>A.双目SLAM</h2><p>最早研究双目SLAM方案的是Paz 等人，基于条件独立分割和扩展SLAM，其显著特点是能够在大场景中运行。更重要的是，这是第一个使用近特征点和远特征点（例如，由于双目相机差异较小，导致点的深度不能准确的估计）的双目SLAM系统，使用一个逆深度参数进行估计。经验值表明如果深度小于40倍双目的基线，那么这个点就能被三角测量化。我们就是跟随的这样思想来处理远近不同的特征点，具体解释放在第三部分。<br>最早研究双目SLAM方案的是Paz 等人[5]，基于条件独立分割和扩SLAM，其显著特点是能够在大场景中运行。更重要的是，这是第一个使用近特征点和远特征点（例如，由于双目相机差异较小，导致点的深度不能准确的估计）的双目SLAM系统，使用一个逆深度参数进行估计。经验值表明如果深度小于40倍双目的基线，那么这个点就能被三角测量化。我们就是跟随的这样思想来处理远近不同的特征点，具体解释放在第三部分。Engel等人[11]提出邻近双目LSD-SLAM方案，采用的是一种直接的半稠密方法，最小化高梯度的图像区域中的光度误差。这种方法希望能够在不依赖特征提取的条件下，能够在纹理不清或者模糊运动的过程中获得更高的鲁棒性。然而，直接法的性能会由于滚动（卷帘）快门，或者非朗伯反射的未建模的因素影响而下降。</p><h1 id="B-RGB-D-SLAM"><a href="#B-RGB-D-SLAM" class="headerlink" title="B.RGB-D SLAM"></a>B.RGB-D SLAM</h1><p>最早和最著名的RGB-DSLAM系统是有Newcombe等人[4]提出的KinectFusion，这种方法将深度数据进行融合，深度数据来源于传感器到深度模型，常常使用ICP算法来跟踪相机的位姿。由于体积的表现形式和缺乏回环检测，这种算法只能工作在小的工作空间。Whelan 等人[12]提出的Kintinuous能够在大环境中运行。它通过使用一个滚动循环缓冲器和包括使用位置定位和位姿优化来达到回环检测的目的。</p><p>或许第一个开源的RGB-DSLAM方案是由Endres[13]提出的，这是一种基于特征点提取的系统，他的前端采用提取和匹配特征点和ICP来计算帧与帧之间的运动。后端采用位姿图优化的方式，回环检测约束条件来源于一个启发式搜索。相似的是，Kerl 等人[14]提出的DVO-SLAM，是在关键帧与关键帧之间的优化位姿图，视觉里程计通过计算最小化光度和深度误差来计算约束条件。DVO-SLAM同时在以前的所有帧当中，搜索回环的候选者，而不依赖于位置识别。</p><p>Whelan等人[15]提出的邻近ElasticFusion算法，是建立在基于确定环境的地图。这是一种以地图为中心的方法。这种方法忽略了非刚性形变地图的位姿和回环检测的性能，也是不是一个标准的位姿图优化。这种方法在重建和定位的精度都是十分优秀的，但是目前的应用十分有限对于一个房间大小的地图，由于在地图当中面元的数量影响计算的复杂程度。</p><p>Strasdat等人[8]提出ORB-SLAM2这种方法，这个方法使用深度信息去合成一个三维坐标，能够精确的提取到一副图像的信息。ORB-SLAM2能够处理来自双目和RGB-D的图像，与上述方法不同的是，我们的后端是用的BA算法，来建立一个全局的稀疏的地图重建，因此我们的方法更加轻量级并且能够在标准的CPU上面运行。我们的目标是长时间并且全局精准定位，而不是建立一个有很多细节的稠密地图。然而，高精度的关键帧的位姿，能够融合深度图像以及在计算中得到精准的重建，或者能够处理所有的关键帧和深度图，以及所有的BA并且得到一个精准的3D模型。</p><h1 id="ORBSLAM2"><a href="#ORBSLAM2" class="headerlink" title="ORBSLAM2"></a>ORBSLAM2</h1><p>针对双目相机和RGB-D相机的ORB-SLAM2建立在单目ORB-SLAM的基础上，它的核心组件，如图2所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031210057222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图2 ORB-SLAM2由三个平行的线程组成，跟踪，局部建图和回环检测。在一次回环检测后，会执行第四个线程，去执行BA优化。跟踪的线程在双目或者RGB-D输入之前进行，因此剩下的系统模块能够跟传感器模块独立运行。单目的ORB-SLAM2工作图也是这幅图。</p><p>这个系统主要有3个并行的线程：</p><blockquote><p>1、通过寻找对局部地图的特征，并且进行匹配，以及只运用BA算法来最小化重投影误差，进行跟踪和定位每帧的相机。<br>2、运用局部的BA算法设置局比地图并且优化。<br>3、回环检测检能够通过执行位姿图的优化来更正累计漂移误差。在位姿优化之后，会启动第四个线程来执行全局BA算法，来计算整个系统最优结构和运动的结果。<br>这个系统是一个基于DBoW2[16]的嵌入式位置识别模型，来达到重定位，防止跟踪失败（如遮挡），或者已知地图的场景重初始化，和回环检测的目的。这个系统产生关联可见的图[8]，连接两个关键帧的共同点，连接所有关键帧的最小生成树方面。这些关键帧的图结构能够得到一个关键帧的局部的窗口，以便于跟踪和局部建图，并且在大型的环境当中的回环检测部分，作为一种图优化的结构。</p></blockquote><p>这个系统使用相同的ORB特征进行跟踪，建图和位置识别的任务。这些特征在旋转不变和尺度不变性上有良好的鲁棒性，同时对相机的自动增益，曝光和光线的变化表现出良好的稳定性。并且能够迅速的提取特征和进行匹配，能够满足实时操作的需求，能够在基于词袋的位置识别过程中，显示出良好的精度[18]。</p><p>在本章的剩下的部分当中，我将会展示双目或者深度信息是如何利用，和到底会影响系统中的那些部分。对每个系统块更详尽的描述，可参见论文[1]</p><h2 id="单目、近处双目和远处双目特征点"><a href="#单目、近处双目和远处双目特征点" class="headerlink" title="单目、近处双目和远处双目特征点"></a>单目、近处双目和远处双目特征点</h2><p>ORB-SLAM2作为一种基于特征提取的方法，在一些关键的位置上的提取进行预处理，如图2b所示，系统的所有运行都是基于输入图像的特征展开，而不依赖于双目或者RGB-D的相机。我们的系统处理单目或者双目的特征点，分成远处特征点和近处特征点两类。</p><p>双目特征点 通过三个坐标$x_s=(u_L,v_L,u_R)$定义，$(u_L,v_L)$是这个左边图像的坐标，$u_R$是右图当中的水平坐标。对于双目相机而言，我们提取两幅图像当中的ORB特征，对于每个左边的ORB特征我们对其匹配到右边的图像中。这对于建设双目图像校正十分有效，因此极线是水平的。之后我们会在左边的图像产生双目的ORB特征点，和一条水平的线向右边的图像进行匹配，通过修补相关性来重新定义亚像素。对于RGB-D相机，正如Strasdat等人[8]所言，我们提取在RGB图像上提取ORB特征点，d对于每个特征坐标$(u_L,v_L)$，我们将其深度值d转换为实际正确的坐标<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031213345404.png#pic_center"><br>这里$f_x$是水平焦距，b是结构光投影器和红外相机的基线<br>我们估计kinect和华硕 Xtion 基线长大约是8cm。深度传感器的不确定性由实际右坐标的不确定性表示，这样，立体声和RGB-D输入的特征由系统的其余部分均等地处理。</p><p>近双目特征点的定义是：匹配的深度值小于40倍双目或者RGB-D的基线，否则的话，是远特征点。近的特征点能够从一帧的深度值能够三角测量化，是精确的估计，并且能够提供尺度，平移和旋转的信息。另外一方面，远的特征点，能够提供精确的旋转信息，但是很少的尺度和平移信息。当提供多视图的时候，我们才能三角化那些远的点。</p><p>单目的特征点通过右边图像的两个坐标$x_m=(u_L,v_L)$定义，必须保证所有的ORB特征是一致的，否则双目特征点的提取将不能够完整，或者在RGB-D的情况下，有产生一个无效的深度值。这些点仅能够从多视图中三角测量化并且不能够提供尺度信息，但是可以提供旋转和平移的估计信息。</p><h2 id="系统引导"><a href="#系统引导" class="headerlink" title="系统引导"></a>系统引导</h2><p>使用双目和RGB-D相机的主要优势在于，我们可以直接获得深度信息，我们不需要像单目情况中那样做一个特定的SFM初始化。在系统初始化的时候，我们就创造了一个关键帧（也就是第一帧），将他的位姿进行初始化，从所有的立体点中创造一个初始化地图。</p><p>3.3 使用单目或者双目光束优化法</p><p>我们的系统采用光束优化法（BA），优化在跟踪过程（纯运动BA）中相机的位姿，优化本地窗口的关键帧和局部地图的特征点（局部BA），并且在回环检测之后优化所有的关键帧和特征点（全局BA）。我们在g2o当中使用Levenberg-Marquadt方法[19]。</p><p>纯运动BA，优化相机旋转矩阵R和位置t，最小化世界坐标系下匹配3D点云$X^i$和特征点$x^i$（单目的或双目的，其中）的重投影误差,要么<br>单目m∈R2或双目xi s∈R3，其中i∈X是所有匹配集合</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031214735118.png#pic_center"><br>在这个式子当中，$\rho$是强健的Huber的cost函数，$\sum$是协方差矩阵，与关键点的规模有关。投影函数$\pi(.)$，单目的时候使用$\pi_m$，修正双目的时候用$\pi_s$，他们的定义如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101092309550.png#pic_center"><br>在这个式子$(f_x,f_y)$是焦距，$(c_x,c_y)$是主点，b是基线，所有的这些参数都是通过标定获得。<br>局部BA优化一系列可见的关键帧$\K_L$和所有在这些关键帧$P_L$的可见点，所有的其他关键帧$K_F$是，不在$K_L$，$P_L$观测点用于代价函数，但是在优化中是固定的。 将$X_k$定义为点之间的匹配集，这些点在$P_L$和关键帧k中的关键点上，优化问题如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101093927765.png#pic_center"><br>全局BA是局部光束法的一个特例，这个方法除了固定的来消除随机化的初始帧，所有的关键帧和地图中的点都会被优化</p><h2 id="闭环检测和全局BA"><a href="#闭环检测和全局BA" class="headerlink" title="闭环检测和全局BA"></a>闭环检测和全局BA</h2><p>回环检测有两步：首先，一个回环信息被确定检测到，然后利用这个回环纠正和优化位姿图。相比于单目的ORB-SLAM中可能出现尺度漂移的地方[20]，这个双目或者深度的信息将会使得尺度信息可观测。并且，几何校验和位姿图优化将不再需要处理尺度漂移，而且是基于刚体变换的，而不是基于相似性。<br>在ORB-SLAM2的位姿优化后，我们包含一个全局的BA优化，为了实现一个优化方案，我们必须采用一个独立的线程，允许系统能够持续的建图，并且检测到回环信息。但是这将会再次触发全局BA优化与当前地图的合成。如果在优化运行时检测到新的回环，我们将中止优化并继续关闭循环，这将再次启动全局的BA优化。当完整的BA结束时，我们需要将更新的关键帧子集和由完整BA优化的点与未更新的关键帧和在优化运行时插入的点合并。最后通过更新更新关键帧校正（例如，这个变换从未优化到已优化）到一个未更新关键帧通过生成树当中。根据校正参考帧来改造呢些未更新的特征点。</p><h2 id="关键帧的插入"><a href="#关键帧的插入" class="headerlink" title="关键帧的插入"></a>关键帧的插入</h2><p>ORB-SLAM2遵循在单目ORB-SLAM中提的法则，即经常插入关键帧并且剔除上一帧的冗余。在远近特征点的差异为我们插入一个新的关键帧提供了条件，这在大场景的条件下是至关重要的，如图3所示。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101095206294.png#pic_center"><br>图3 ＫITTI 01数据集的跟踪点。绿色的特征点深度小于40倍双目的基线，蓝色特征点大于40倍双目的基线，在这种数据集当中，需要插入大量的关键帧，以便于能够让近处的特征点更加精确的估计平移和尺度，远处的特征点来估计方向，但是不能够计算平移和尺度。</p></blockquote><p>在这样的环境中，我们需要一个大量的近点用以精确估计平移，因而如果这个被跟踪近点小于$\tau _t$并且这个帧将会创造$\tau _c$个新邻近特征点，这个系统将会插入一个新的关键帧，我们经验值认为，当$\tau _t=100$和$\tau _c=70$的条件下我们效果最好。</p><h2 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h2><p>ORB-SLAM2包括一个定位模式，该模式适用于轻量级以及在地图已知情况下长期运行，只要那个环境没有发生剧烈变化。在该模式中，局部建图和回环检测的线程中是停用的，并且这个相机始终都是在通过追踪进行重定位。在这个模式下，追踪模块使用视觉里程计进行匹配图像的点云。视觉里程计匹配在当前帧的ORB算子和由双目或者深度相机收集的3D点云。这些匹配使得在没有地图的区域也能够精确重新定位，但是漂移将会被累加。地图点云匹配要确保在一个已经存在的地图当中零漂移定位，这个模型在附带的video当中会显示。</p><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>我们使用三个著名的数据集来评估ORB-SLAM2的算法的性能。我们在一台16G的RAM，Intel Core i7-4790的台式机运行，以低于传感器的帧率，对处理跟踪时间求平均。我们运行数据集5次，取中间值，来消除多线程系统的不确定性。我们开源了在运行这几个系统的数据集的方法包括标定具体操作实现。</p><h2 id="KITTI数据集"><a href="#KITTI数据集" class="headerlink" title="KITTI数据集"></a>KITTI数据集</h2><p>KITTI数据集包含双目数据，这些数据从一个正在高速公路上行驶的车上采集到的。这个双目传感器有约54厘米的基线并且在在1392*512像素上，以10Hz的采样速率进行采样，其中序列00,02,05,06，和09包含回环。我们的ORB-SLAM2能够检测出回环并且能够地图重用，除了09序列以外，09序列的回环只发生在尾端少数的几帧当中。表1显示在11个训练数据的结果，这是一个公开的真实数据，对比于原先的LSD-SLAM算法，我们展示了的双目SLAM系统测试数据结果。我们使用两个不同的米制，均方根误差(RMSE)$t_{abs}$在论文[3]中提到，并且取平均相关平移$t_{rel$和旋转误差$r_{rel}$在论文[2]，我们的系统在数据集大多数序列中都优于双目LSD-SLAM，并且总体而言，相对误差低于1％。序列01（参见图3）是训练集中唯一的高速公路序列，平移误差稍差一些。 由于高速和低帧频，很难追踪到几乎所有的闭合点，因此在数据集这个序列中很难估计平移。。然而这个方向能够被精确的评估，获得的误差是每100米做0.21度。很多较远的点能够被检测，如图4所示，显示了一些评估的例子。</p><blockquote><p>表一 KITTI数据集精度的比较<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101101839858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101102024770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图4 在KITTE数据集01,05,07和08，估计轨迹（黑色线）和以及实际运动（红色线）</p></blockquote><p>与[1]中提出的单目结果相比，提出的双目版本能够处理单目系统处理失败的序列01。 在此高速公路序列中，请参见图3，仅在几帧的情况下才能看到近点。 双目版本有仅从一个双目关键帧创建点的能力，而不是通过在两个关键帧的匹配而导致的单目延迟初始化的能力，在此序列中至关重要，不能丢失跟踪。 而且，双目系统以公制比例尺估计地图和轨迹，并且不会受到比例尺偏移的影响，如图5所示。</p><blockquote><p>在KITTI数据集08估计轨迹（黑色线）和以及实际运动（红色线）左：单目ORB-SLAM [1]，右：ORB-SLAM2（双目）。 单目ORBSLAM在此序列中有严重的标度漂移，尤其是在转弯处。 相比之下，提出的双目版本能够估计轨迹和地图的真实比例，而不会出现比例漂移。<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101103033691.png#pic_center"></p><h2 id="EuRoC-数据集"><a href="#EuRoC-数据集" class="headerlink" title="EuRoC 数据集"></a>EuRoC 数据集</h2><p>EuRoC 数据集包含了11个双目的序列，通过一个微型飞行器（MAV）采集到的数据，飞行在两个不同的房间和大量的工业环境。这个双目传感器有一个约11cm的基线和能够提供20HZ的WVGA格式的图像，这个序列分成，简单、中等、和困难，这取决于MAV（微型飞行器）的速度，照明和场景的纹理。在所有的序列当中，MAV（微型飞行器）再次访问这个环境的时候，ORB-SLAM2能够重用地图，回环检测当有必要时。这个表格2显示的是ORB-SLAM2的最小均方误差(RMSE)的绝对值变换，对于所有序列而言。相比较对双目的LSD-SLAM的结果。ORB-SLAM2能够实现一个厘米级精准的定位，并且比双目的LSD-SLAM更加的精确。由于一些运动模糊，在V2_ 03_ difficul序列中跟踪丢失。在论文[22]]，这个序列在处理过程中是使用IMU信息，如图5所示，显示的一些相比实际运动的估计轨迹的例子。<br>表2 EUROC数据集<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101103818187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104359603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>在EuRoCV1_02_medium, V2_02_medium, MH_03_medium, and MH_05_difficult数据集测试的估计轨迹（黑色线）和以及实际运动（红色线）</p><h2 id="TUM-RGB-D-Dataset"><a href="#TUM-RGB-D-Dataset" class="headerlink" title="TUM RGB-D Dataset"></a>TUM RGB-D Dataset</h2><p>TUM RGB-D数据集包含一些室内的序列，在不同的纹理下，不同的光照和不同的结构条件，从RGB-D传感器采集到的数据中分别去评估物体的重建和SLAM/视觉里程计的性能。和大多数RGB-DSLAM方法一样，我们将实验结果展示在一个序列子集当中，在表格3当中，我们比较我们的精准性和其他方法，例如ElasticFusion，Kintinuous，DVO-SLAM以及RGB-DSLAM，ORB-SLAM2是唯一一种基于光束流差法，并且比其他的方法都更加优秀。我们已经注意到RGB-DSLAM，深度地图对于freiburg2序列有一个4%的尺度误差，误差可能来自错误的标定，我们已经在运行过程中，进行了一定程度的补偿。这能够部分解释我们取得好的结果的原因。图6显示的点云的结果来源于后端映射的传感器深度的地图，从计算关键帧的位姿在四个序列当中。实验的结果显示，ORB-SLAM2很好的展示了桌子和海报的轮廓线，以及高精度的重定位。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104655260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104722466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图6 TUM RGB-D数据的fr3office, fr1 room, fr2 desk and fr3 nst 序列的通过评估关键帧的位姿和深度图进行稠密的点云重建图</p></blockquote><h2 id="时序结果"><a href="#时序结果" class="headerlink" title="时序结果"></a>时序结果</h2><p>为了完成对所提出系统的评估，我们在表IV中列出了三个时序的时序结果，这些时序具有不同的图像分辨率和传感器。显示了每个线程任务的平均值和两个标准偏差范围。由于这些序列包含一个循环，因此全局BA和回环检测线程的某些任务仅执行一次，并且仅报告一次测量。每帧的平均跟踪时间低于每个序列的相机帧频的倒数，这意味着我们的系统能够实时工作。由于将双目图像中的ORB提取并行化，因此可以看出，在V2_02的立体声WVGA图像中提取1000个ORB特征类似于在fr3_office的单个VGA图像通道中提取相同数量的特征。回环中关键帧的数量显示为与回环检测有关的时间的参考。虽然KITTI 07中的回环包含更多关键帧，但为室内fr3_office构建的可见性图更加密集，因此，回环融合，姿态图优化和全局BA任务更加昂贵。可见性图的较高密度使本地地图包含更多关键帧和点，因此，本地地图跟踪和局部BA也更加昂贵。</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019110111103884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p></blockquote><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文呈现了一个基于于单目，双目和RGB-D传感器的完整SLAM框架，在实时和标准的CPU的前提下能够进行重新定位和回环检测，以及地图的重用。在实验当中，我们关心的是在大场景中建立可用的地图和长期的定位。所提出的具有系统重新定位功能的定位模式可为已知环境提供一种非常健壮，零漂移和轻量级的定位方法。此模式对于某些应用程序可能很有用，例如在映射良好的空间中跟踪虚拟现实中的用户视点。与最新技术的比较表明，ORB-SLAM2在大多数情况下都可以达到最高的精度。</p><p> 与最新技术的比较表明，ORB-SLAM2在大多数情况下都可以达到最高的精度。在KITTI视觉里程表测试中，ORB-SLAM2是目前最佳的双目SLAM解决方案。至关重要的是，与近年来兴起的立体视觉测距法相比，ORB-SLAM2在已经构建的地图中实现了零漂移定位。</p><p>出乎意料的是，我们的RGB-D结果表明，如果相机的定位精度更好，则BA性能要优于直接法或ICP，并且具有计算成本更低，不需要GPU处理实时运行的额外优势。</p><p>我们已经发布了系统的源代码，包括示例和说明，以便其他研究人员可以轻松使用。就我们所知，ORB-SLAM2是第一个可与单目，双目和RGB-D使用的开源视觉SLAM系统。此外，我们的源代码包含一个使用单目相机的增强现实应用程序2，以展示我们解决方案的潜力。<br>举例来说，将来的发展可能包括不重叠的多相机，鱼眼镜头或全景相机，大规模稠密融合，协作建图或增强的运动模糊鲁棒性</p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;ORB-SLAM2是基于单目，双目和RGB-D相机的一套完整的SLAM方案。它能够实现地图重用，回环检测和重新定位的功能。无论是在室内的小型手持设备，还是到工厂环境的无人机和城市里驾驶的汽车，ORB-SLAM2都能够在标准的CPU上进行实时工作。ORB-SLAM2在后端上采用的是基于单目和双目的光束法平差优化（BA）的方式，这个方法允许米制比例尺的轨迹精确度评估。此外，ORB-SLAM2包含一个轻量级的定位模式，该模式能够在允许零点漂移的条件下，利用视觉里程计来追踪未建图的区域并且匹配特征点。我们用29个广泛使用的公共数据测试的结果显示，在大多数情况下，本文方案比此前方案精度更高，此外，我们开源了ORB-SLAM2源代码，不仅仅是为了整个SLAM领域，同时也希望能够为其他领域研究者提供一套SLAM的解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ORB-SLAM2" scheme="https://xiao-hu.com.cn/categories/ORB-SLAM2/"/>
    
    
      <category term="ORB-SLAM2" scheme="https://xiao-hu.com.cn/tags/ORB-SLAM2/"/>
    
  </entry>
  
  <entry>
    <title>VINs-Mono——闭环检测</title>
    <link href="https://xiao-hu.com.cn/2019/10/31/VINs-Mono%E2%80%94%E2%80%94%E9%97%AD%E7%8E%AF%E6%A3%80%E6%B5%8B/"/>
    <id>https://xiao-hu.com.cn/2019/10/31/VINs-Mono——闭环检测/</id>
    <published>2019-10-31T09:11:12.000Z</published>
    <updated>2019-10-31T09:12:34.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>18.删除链表中的节点</title>
    <link href="https://xiao-hu.com.cn/2019/10/31/18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://xiao-hu.com.cn/2019/10/31/18-删除链表中的节点/</id>
    <published>2019-10-31T07:22:44.000Z</published>
    <updated>2019-10-31T09:12:19.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在O(1)时间删除链表结点。</p><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表节点与函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>删除一个节点的两种方法：</p><a id="more"></a><p>比如删除链表中的的节点i，j为i的下一个节点</p><ol><li><p>先从链表中的头结点遍历到i前面的一个节点，把h的m_pNext指向i的下一个节点j,再删除节点i，时间复杂度$O(n)$</p></li><li><p>把节点j的内容复制覆盖节点i，接下里再把节点i的m_pNext指向j的下一个节点，再删除节点j（把j移到i)，时间复杂度$O(1)$</p><blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三种情况： </span><br><span class="line"><span class="number">1.</span> 节点是头节点且只有这一个节点                          </span><br><span class="line"><span class="number">2.</span> 节点是尾节点                          </span><br><span class="line"><span class="number">3.</span> 节点是链表中的某个节点</span><br></pre></td></tr></table></figure></blockquote></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">        *pListHead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;            </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">description</span></span><br><span class="line"><span class="string">    题目： 删除链表中的节点</span></span><br><span class="line"><span class="string">    1.在O（1）时间内删除链表节点</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这里我们首先定义一个链表的类</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, next = None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = next</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_node_in_o1_time</span><span class="params">(self, p, head)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param p: linknode</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        这里一共有三种情况： 节点是头节点且只有这一个节点</span></span><br><span class="line"><span class="string">                          节点是尾节点</span></span><br><span class="line"><span class="string">                          节点是链表中的某个节点</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> p == head <span class="keyword">and</span> p.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> p.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            q = head</span><br><span class="line">            <span class="keyword">while</span> q.next <span class="keyword">is</span> <span class="keyword">not</span> p:</span><br><span class="line">                q = q.next</span><br><span class="line">            q.next = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        q = p.next</span><br><span class="line">        p.value = q.value</span><br><span class="line">        p.next = q.next</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_lnode</span><span class="params">(self, lst)</span>:</span></span><br><span class="line">        head = linkNode(lst[<span class="number">0</span>])</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)):</span><br><span class="line">            p.next = linkNode(lst[i])</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_lnode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(p.value)</span><br><span class="line">            p = p.next </span><br><span class="line"> </span><br><span class="line">s = Solution()</span><br><span class="line">head = s.gen_lnode([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">p = head.next.next</span><br><span class="line">s.delete_node_in_o1_time(p, head)</span><br><span class="line">s.print_lnode(head)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在O(1)时间删除链表结点。&lt;/p&gt;&lt;p&gt;给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表节点与函数的定义如下：&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;       m_nValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode* m_pNext;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;删除一个节点的两种方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>高斯分布与边缘化</title>
    <link href="https://xiao-hu.com.cn/2019/10/30/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E8%BE%B9%E7%BC%98%E5%8C%96/"/>
    <id>https://xiao-hu.com.cn/2019/10/30/高斯分布与边缘化/</id>
    <published>2019-10-30T12:14:03.000Z</published>
    <updated>2019-10-30T12:52:33.610Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h1><p>高斯分布有两种表达方式：</p><ul><li>协方差矩阵+均值</li><li>信息矩阵+信息矢量</li></ul><p>协方差矩阵+均值的方式比较常见，如下</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152615298.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152644545.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152656564.png#pic_center"></p><p>左边常数项记为$η$，$p(x)$可以记为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200301827.png"></p><p>其中对称正定矩阵$Σ$为随机变量x的协方差矩阵，μ为x的均值，简记为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200243950.png"></p><p>信息矩阵+信息矢量的形式可以由上式推导而来</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200156360.png"></p><p>现在定义信息矩阵$Ω=Σ^{−1}$ ，信息矢量$ξ=Σ^{−1}μ=Ωμ$，则</p><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200137498.png"></p><h1 id="联合高斯分布的分解"><a href="#联合高斯分布的分解" class="headerlink" title="联合高斯分布的分解"></a>联合高斯分布的分解</h1><p>设随机变量$x_a,x_b$满足联合高斯分布$p(x_a,x_b)$<br>由条件概率公式可知</p><script type="math/tex; mode=display">p(x_a,x_b)=p(x_a)p(x_b∣x_a)</script><p>联合高斯函数的分解就是根据$p(x_a,x_b)$求出上式中的$p(x_a)$和$p(x_b∣x_a)$</p><h2 id="协方差矩阵-均值"><a href="#协方差矩阵-均值" class="headerlink" title="协方差矩阵+均值"></a>协方差矩阵+均值</h2><p>假设多元变量x服从高斯分布，且由两部分组成： $x = [x_a \  x_b]^T$，变量x的概率分布为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204045547.png#pic_center"></p><p>其密度函数可写为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204101961.png#pic_center"></p><p>利用舒尔补对高斯分布进行分解：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204114634.png#pic_center"></p><p>将上式带入$p(x_a,x_b)$的概率密度函数，并注意到对任意矩阵<em>K</em>，有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020412790.png#pic_center"></p><p>可以得到:</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204144966.png#pic_center"></p><p>其中:</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204202528.png#pic_center"></p><p>由此可看出，$p(x_a)$是均值为$μ_a$，协方差矩阵为$Σ_{aa}$的高斯分布，记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204216952.png#pic_center"></p><p>同时，$p(x_b∣x_a)$是均值为$μ_b+Σ_{ba}Σ_{aa}^{−1}(x_a−μ_a)$，协方差矩阵为$Θ_{bb}$的高斯分布，记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204250870.png#pic_center"></p><h2 id="信息矩阵-信息矢量"><a href="#信息矩阵-信息矢量" class="headerlink" title="信息矩阵+信息矢量"></a>信息矩阵+信息矢量</h2><p>$p(x_a,x_b)$以信息矩阵+信息矢量的形式给出，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204311535.png#pic_center"></p><p>通过信息矢量与信息矩阵，可以计算出该分布的均值</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204324848.png#pic_center"></p><p>因此该分布的概率密度函数可写为（注意到信息矩阵与协方差矩阵为互逆关系）</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204348310.png#pic_center"></p><p>为了求出$p(x_a)$和$p(x_b∣x_a)$的表达式，需要再次用到舒尔补（Schur Complement），不过作用对象与之前不同，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204403932.png#pic_center"></p><p>将上式带入$p(x_a,x_b)$的密度函数中，并令$Ω_{aa}−Ω_{ab}Ω_{bb}^−1Ω_{ba}=Λ_{aa}$，可得</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204423266.png#pic_center"></p><ul><li><p>$p(x_a)$是一个均值为$μ_a$，协方差矩阵为$Λ_{aa}^{−1}$的高斯分布</p></li><li><p>$p(x_b∣x_a)$是一个均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，协方差矩阵为$Ω_{bb}^{−1}%$的高斯分布。</p></li></ul><p>$p(x_a)$的均值为$μ_a$，信息矩阵为$Λ_{aa}$，对应的信息矢量为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910302044559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>所以$p(x_a)$完全使用信息矩阵+信息矢量的形式可记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020452532.png#pic_center"></p><p>同理：</p><p>$p(x_b∣x_a)$均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，信息矩阵为$Ω_{bb}$的高斯分布，对应的信息矢量为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204543853.png#pic_center"><br>$p(x_b∣x_a)$完全使用信息矩阵+信息矢量的形式可以记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204557435.png#pic_center"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。表格总结如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204611958.png#pic_center"></p><p>根据协方差矩阵与信息矩阵的互逆关系，从上表还可以得出如下一组关系</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204627632.png#pic_center"></p><h2 id="边缘化与条件化"><a href="#边缘化与条件化" class="headerlink" title="边缘化与条件化"></a>边缘化与条件化</h2><p>所谓边缘化，就是求某个联合概率分布的边缘分布。比如对于联合概率$p(x_a,x_b)$，对$x_b$进行边缘化，就是对$x_b$在整个空间中积分，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204650325.png#pic_center"></p><p>由贝叶斯公式可知</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204702487.png#pic_center"></p><p>伴随着边缘化，$p(x_b∣x_a)$就是$p(x_a,x_b)$对$x_a$的条件化。</p><p>在信息矩阵+信息矢量的表示方式下，边缘化和条件化与最小二乘法有密切关系。在许多基于最小二乘的优化问题中，常有如下形式的优化目标：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204718621.png#pic_center"></p><p>为了寻找上式的最小值，常使用迭代优化的方法，每一次迭代都会寻找一个增量Δx使目标函数减小。为了求增量，往往会将e(x)在当前<em>x</em>x处展开为一阶近似（这种处理方式即Gauss-Newton Method），即<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204730880.png"></p><p>则优化的目标变为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020474264.png#pic_center"></p><p>这是关于Δx的二次函数，对Δx求导，并令导数等于0，有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204755898.png#pic_center"></p><p>即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204808181.png#pic_center"></p><p>令$J(x)^TW^{−1}J(x)=Ω$，表示变量Δ<em>x</em>Δx的信息矩阵，令−$J(x)^TW^{−1}e(x)=ξ$，表示信息矢量，则有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204822240.png#pic_center"></p><p>以上就是非线性优化时，每次都要求解的线性方程。</p><p>在很多优化问题中，待优化的变量有明确意义，比如在SLAM或者SfM问题中，要优化的是所有相机的位姿<em>p</em>p以及地图中所有三维点的坐标<em>m</em>m，设Δ<em>x</em>Δx由这两个分量的增量构成，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204837435.png#pic_center"></p><p>同时设</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204848663.png#pic_center"></p><p>则有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204900849.png"></p><p>为了简化以上方程的求解，往往使用高斯消元法，具体的，对以上方程等式两边左乘</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204917817.png"></p><p>可得</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204930919.png#pic_center"></p><p>于是原方程可以转换为两个独立方程</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204940320.png#pic_center"></p><p>可以发现，Δp的系数矩阵和等号右边的结果，与上文中高斯分布$p(x_a)$的信息矩阵和信息矢量有相同的形式。而Δm的系数矩阵和等号右边的结果，则与高斯分布$p(x_b∣x_a)$的信息矩阵和信息向量有相同形式</p><p>也就是说，这里的高斯消元法，等价于对变量Δx做了边缘化，先将Δm边缘化掉，单独求Δp，然后再在Δp已知的情况下求Δm。</p><p>参考：<a href="https://blog.csdn.net/AIchipmunk/article/details/86185248" target="_blank" rel="noopener">高斯分布与边缘化</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;多元高斯分布&quot;&gt;&lt;a href=&quot;#多元高斯分布&quot; class=&quot;headerlink&quot; title=&quot;多元高斯分布&quot;&gt;&lt;/a&gt;多元高斯分布&lt;/h1&gt;&lt;p&gt;高斯分布有两种表达方式：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;协方差矩阵+均值&lt;/li&gt;
&lt;li&gt;信息矩阵+信息矢量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;协方差矩阵+均值的方式比较常见，如下&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030152615298.png#pic_center&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030152644545.png#pic_center&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030152656564.png#pic_center&quot;&gt;&lt;/p&gt;&lt;p&gt;左边常数项记为$η$，$p(x)$可以记为：&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030200301827.png&quot;&gt;&lt;/p&gt;&lt;p&gt;其中对称正定矩阵$Σ$为随机变量x的协方差矩阵，μ为x的均值，简记为&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030200243950.png&quot;&gt;&lt;/p&gt;&lt;p&gt;信息矩阵+信息矢量的形式可以由上式推导而来&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030200156360.png&quot;&gt;&lt;/p&gt;&lt;p&gt;现在定义信息矩阵$Ω=Σ^{−1}$ ，信息矢量$ξ=Σ^{−1}μ=Ωμ$，则&lt;/p&gt;
    
    </summary>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/categories/VSLAM/"/>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/tags/VSLAM/"/>
    
  </entry>
  
  <entry>
    <title>舒尔补</title>
    <link href="https://xiao-hu.com.cn/2019/10/30/%E8%88%92%E5%B0%94%E8%A1%A5/"/>
    <id>https://xiao-hu.com.cn/2019/10/30/舒尔补/</id>
    <published>2019-10-30T12:10:35.000Z</published>
    <updated>2019-10-30T12:12:44.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>舒尔补定义<br>给定任意的矩阵块 M，如下所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030155959352.png"><ul><li>如果矩阵块 D 是可逆的，则$A − BD^{−1}C$称之为D关于M的舒尔补</li><li>如果矩阵块 A 是可逆的，则$D − CA^{−1}B$称之为A关于 M的舒尔补</li></ul></li></ul><p>将 M 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160209537.png"></p><p>其中：$∆A=D − CA^{−1}B$。联合起来，将 M 变形成对角形：</p><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160250360.png"></p><p>矩阵 M 的逆为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160322364.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;ul&gt;
&lt;li&gt;舒尔补定义&lt;br&gt;给定任意的矩阵块 M，如下所示:&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030155959352.png&quot;&gt;&lt;ul&gt;
&lt;li&gt;如果矩阵块 D 是可逆的，则$A − BD^{−1}C$称之为D关于M的舒尔补&lt;/li&gt;
&lt;li&gt;如果矩阵块 A 是可逆的，则$D − CA^{−1}B$称之为A关于 M的舒尔补&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将 M 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030160209537.png&quot;&gt;&lt;/p&gt;&lt;p&gt;其中：$∆A=D − CA^{−1}B$。联合起来，将 M 变形成对角形：&lt;/p&gt;
    
    </summary>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/categories/VSLAM/"/>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/tags/VSLAM/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono——后端优化</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/VINs-Mono%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/VINs-Mono——后端优化/</id>
    <published>2019-10-29T12:43:40.000Z</published>
    <updated>2019-10-30T12:33:58.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="状态向量"><a href="#状态向量" class="headerlink" title="状态向量"></a>状态向量</h1><p>VIO 紧耦合方案的主要思路就是通过将基于视觉构造的残差项和基于 IMU 构造的残差项放在一起构造成一个联合优化的问题，整个优化问题的最优解即可认为是比较准确的状态估计。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192151582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>为了限制优化变量的数目， VINS-Mono 采用了滑动窗口的形式， 滑动窗口中的全状态量包括滑动窗口内的n+1个关键帧时刻 IMU 坐标系的位置、姿态、姿态（旋转）、加速度计偏置、陀螺仪偏置， Camera 到 IMU 的外参， m +1个 3D 路标点的逆深度：</p><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192802133.png#pic_center"></p><p>优化过程中的误差状态量为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192821349.png#pic_center"></p><h1 id="代价函数（Minimize-residuals-from-all-sensors）"><a href="#代价函数（Minimize-residuals-from-all-sensors）" class="headerlink" title="代价函数（Minimize residuals from all sensors）"></a>代价函数（Minimize residuals from all sensors）</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192917433.png#pic_center"></p><p>其中$P^{b_{k}}_{b_{k+1}}$ 为 IMU 预积分噪声项的协方差矩阵， $P^{c_j}_l$ 为视觉观测噪声的协方差矩阵。<br>三个残差项即误差项分别为边缘化的先验信息、 IMU 测量残差、视觉的重投影残差。三种残差都是用马氏距离表示。<br>根据高斯牛顿法求优化过程中最为核心的增量方程，以 IMU 测量残差为例，先将$r_{b}(\hat z^{b_k}_{b_{k+1}},\chi )$进行一阶泰勒展开</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194020513.png#pic_center"></p><p>其中$H^{b_k}_{b_{k+1}}$是雅可比矩阵</p><p>等号右边关于$\delta x$的导数，并令其为 0，得到增量方程：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194351591.png#pic_center"></p><p>那么可以写出函数对应的增量方程：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195011958.png#pic_center"></p><p>增量方程可进一步简化为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195045773.png#pic_center"></p><p>其中$\wedge _p$，$\wedge _B$，$\wedge _C$为（近似的） Hessian 矩阵，上述方程称之为增量方程。</p><h1 id="IMU-测量约束"><a href="#IMU-测量约束" class="headerlink" title="IMU 测量约束"></a>IMU 测量约束</h1><h2 id="IMU-测量残差"><a href="#IMU-测量残差" class="headerlink" title="IMU 测量残差"></a>IMU 测量残差</h2><p>根据上面的 IMU 预积分，得到 IMU <strong>预积分残差（估计值 - 测量值）</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195522934.png#pic_center"></p><p>其中$[q]_{xyz}$表示提取四元数q的虚部，$[\hat \alpha^{b_k}_{b_{k+1}},\hat \beta ^{b_k}_{b_{k+1}},\hat \gamma ^{b_k}_{b_{k+1}}]^T$为关键帧$b_k$和关键帧$b_{k+1}$时间间隔内，仅仅使用含有噪声的加速度计和陀螺仪数据计算的预积分 IMU 测量项，$\delta \theta^{b_k}_{b_{k+1}}$是四元数误差的三维表示。</p><h2 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h2><p>对于两帧之间的 IMU 测量残差，待优化变量为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029200304722.png#pic_center"></p><h2 id="雅克比矩阵"><a href="#雅克比矩阵" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>高斯迭代优化过程中会用到 IMU 测量残差对状态量的雅克比矩阵，但此处我们是对误差状<br>态量求偏导</p><ul><li>对k时刻$[\delta p^w_{b_k},\delta \theta^w_{b_k}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201345442.png#pic_center"></p><ul><li>对k时刻$[\delta v^w_{b_k},\delta b_{a_k},\delta \theta b_{w_{k}}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201641707.png#pic_center"></p><ul><li>对k时刻$[\delta p^w_{b_{k+1}},\delta \theta^w_{b_{k+1}}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201652448.png#pic_center"></p><ul><li>对k时刻$[\delta v^w_{b_{k+1}},\delta b_{a_{k+1}},\delta \theta b_{w_{k+1}}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201704647.png#pic_center"></p><p>上面公式在代码中对应： class IMUFactor : public ceres::SizedCostFunction<15, 9 7, 9,>对于 Evaluate 输入 double const <em>const </em>parameters, parameters[0], parameters[1], parameters[2],parameters[3]分别对应 4 个输入参数, 它们的长度依次是 7,9,7,9， 分别对应 4 个优化变量的参数块。<br>代码 IMUFactor::Evaluate()中 residual 还乘以一个信息矩阵 sqrt_info， 这是因为真正的优化项其实是 Mahalanobis 距离： $d=r^TP^{−1}r$，P 是协方差，又因为 Ceres 只接受最小二乘优化， 也就是$min(e^Te)$所以把𝑃−1做 LLT 分解， 即$LL^T=P^{-1}$, 则有：</15,></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202424429.png#pic_center"></p><p>令$r’=L^Tr$作为新的优化误差, 这样就能用 Ceres 求解了。 Mahalanobis 距离其实相当于一个残差加权, 协方差大的加权小, 协方差小的加权大, 着重优化那些比较确定的残差。若写成“sqrt_info.setIdentity()”相当于不加权</p><h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>IMU 协方差 P 为前面推导的 IMU 预积分中迭代出来的 IMU 增量误差的协方差。</p><h1 id="视觉测量残差"><a href="#视觉测量残差" class="headerlink" title="视觉测量残差"></a>视觉测量残差</h1><p>视觉测量残差即 特征点的重投影误差，视觉残差和雅克比矩阵计算的对应代码在ProjectionFactor::E<br>函数中。</p><h2 id="重投影误差（视觉测量残差）"><a href="#重投影误差（视觉测量残差）" class="headerlink" title="重投影误差（视觉测量残差）"></a>重投影误差（视觉测量残差）</h2><p>对于第 i 帧中的特征点, 它投影到第 j 帧相机坐标系下的值为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202633785.png#pic_center"></p><p>拆写成三维形式为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202722447.png"></p><p>其中：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202739798.png#pic_center"></p><p>为了后面方便求导Jacobian，对$P_{c_j}$拆解，定义如下变量</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202916771.png"></p><p>视觉测量残差为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203023784.png#pic_center"></p><h2 id="优化变量-1"><a href="#优化变量-1" class="headerlink" title="优化变量"></a>优化变量</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203801125.png#pic_center"></p><h2 id="雅克比矩阵-1"><a href="#雅克比矩阵-1" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>根据视觉残差公式，我们可以得到相对于各优化变量的 Jacobian</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203923600.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203934216.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203946932.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102920400339.png"></p><h2 id="协方差矩阵-1"><a href="#协方差矩阵-1" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>视觉约束的噪声协方差与标定相机内参时的重投影误差，也就是偏离几个像素有关， 代<br>码对应为 ProjectionTdFactor::sqrt_info， 这里取的 1.5 个像素，信息矩阵取根号后为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029204041242.png#pic_center"></p><h1 id="边缘化和FEJ"><a href="#边缘化和FEJ" class="headerlink" title="边缘化和FEJ"></a>边缘化和FEJ</h1><h2 id="Marginalization"><a href="#Marginalization" class="headerlink" title="Marginalization"></a>Marginalization</h2><p>然而，将 pose 移出 windows 时，有些约束会被丢弃掉，这样势必会导致求解的精度下降，而<br>且当 MAV 进行一些退化运动 (如: 匀速运动) 时，没有历史信息做约束的话是无法求解的。所以，<br>在移出位姿或特征的时候，需要将相关联的约束转变成一个约束项作为 prior 放到优化问题中，这<br>就是 marginalization 要做的事情。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029213408596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>边缘化的过程就是将滑窗内的某些较旧或者不满足要求的视觉帧剔除的过程，所以边缘化也被描述为将联合概率分布分解为边缘概率分布和条件概率分布的过程 (就是利用 shur 补减少优化参数的过程)。</p><p>直接进行边缘化而不加入先验条件的后果：</p><blockquote><ol><li>无故地移除这些 pose 和 feature 会丢弃帧间约束，会降低了优化器的精度，所以在移除 pose和 feature 的时候需要将相关联的约束转变为一个先验的约束条件作为 prior 放到优化问题中</li><li>在边缘化的过程中，不加先验的边缘化会导致系统尺度的缺失 (参考 [6])，尤其是系统在进行退化运动时 (如无人机的悬停和恒速运动)。一般来说 只有两个轴向的加速度不为 0 的时候，才能保证尺度可观，而退化运动对于无人机或者机器人来说是不可避免的。所以在系统处于退化运动的时候，要加入先验信息保证尺度的可观</li></ol></blockquote><p>VINS 根据次新帧是否为关键帧，分为两种边缘化策略：</p><blockquote><ol><li>当次新帧为关键帧时，我们将 marg 掉最老帧，及其看到的路标点和相关联的 IMU<br>数据，将其转化为先验信息加到整体的目标函数中；</li><li>当次新帧不是关键帧时，我们将直接扔掉次新帧及它的视觉观测边，而不对次新帧进行 marg， 因为我们认为当前帧和次新帧很相似，也就是说当前帧跟路标点之间的约束和次新帧与路标点的约束很接近，直接丢弃并不会造成整个约束关系丢失过多信息。 但是值得注意的是，我们要保留次新帧的 IMU 数据，从而保证 IMU 预积分的连贯性</li></ol></blockquote><p>VINS 中的先验残差项的构造可以分为以下几个步骤： </p><blockquote><ol><li>把上一次先验项中的残差项传递给当前先验项，并从中去除需要丢弃的状态量</li><li>添加与当前需要丢弃的状态量相关的约束项；</li><li>通过函数 MarginalizationInfo::preMarginalize()得到每个残差项(cost_function)对应<br>的参数块(parameter_blocks)，雅可比矩阵(jacobians)，残差值(residuals)；</li><li>通过函数 MarginalizationInfo::marginalize()将步骤 3 中得到的雅可比矩阵和残差值<br>进行组合，得到整个先验项的参数块，雅可比矩阵和残差值</li></ol></blockquote><p>通过以上四步先验项就算构造完成了，在对滑动窗口内的状态量进行优化时，把它与IMU 残差项和视觉残差项放在一起优化，从而得到不丢失历史信息的最新状态估计的结果。</p><h2 id="边缘化和舒尔补"><a href="#边缘化和舒尔补" class="headerlink" title="边缘化和舒尔补"></a>边缘化和舒尔补</h2><p>根据前面讨论的基于高斯牛顿的非线性优化理论可知， 𝐻𝛿𝑥 = 𝑏可写成如下形式：</p><p><img alt="1572437838552" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437838552.png"></p><p>INS 中则真正需要边缘化掉滑动窗口中的最老帧或者次新帧，目的是希望不再计算这一帧的位姿或者与其相关的路标点，但是希望保留该帧对窗口内其他帧的约束关系。</p><p>上式中的$x_a$是我们要 marg 的变量，比如一个相机的 pose，因此我们更关心如何只去求解我们希望保留的变量$x_b$，而不再求解$x_a$，但是我们也希望直接将$x_a$和与其相关的路标点直接删除，因为这样会减少约束，丢失信息。因此，采用如下 Schur 进行消元：</p><p><img alt="1572437967596" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437967596.png"></p><p>其中，$ Λ^𝑇_𝑏Λ^{-1}_𝑎Λ_𝑏$就称为Λ𝑎在Λ𝑏中的 Schur 项，那么有了上面式子，我们就可以直接计算$𝛿x_b$了：</p><p><img alt="1572438049891" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438049891.png"></p><p>上面的公式即为要保留变量𝑥𝑏的先验信息。</p><h2 id="滑动窗口中的-FEJ-算法"><a href="#滑动窗口中的-FEJ-算法" class="headerlink" title="滑动窗口中的 FEJ 算法"></a>滑动窗口中的 FEJ 算法</h2><p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</p><p>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量</p><p>滑动窗口算法大致流程</p><ol><li>增加新的变量进入最小二乘系统优化</li><li>如果变量数目达到了一定的维度，则移除老的变量。</li><li>SLAM 系统 不断循环前面两步</li></ol><p>利用边际概率移除老的变量</p><p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量。</p><p><strong>example：</strong></p><p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量</p><p><img alt="1572438273296" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438273296.png"></p><p>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</p><p><img alt="1572438402148" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438402148.png"></p><p><img alt="1572438422145" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438422145.png"></p><p>marg 前，变量 $x_m$ 以及对应测量$S_m$ 构建的最小二乘信息矩阵为：</p><p><img alt="1572438479585" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438479585.png"></p><p>marg 后，变量$x_m$的测量信息传递给了变量 $x_r$:</p><p><img alt="1572438555840" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438555840.png"></p><p>下标 p 表示 prior. 即这些信息将构建一个关于$x_r$ 的先验信息。</p><p><img alt="1572438612496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438612496.png"></p><p><strong>新测量信息和旧测量信息构建新的系统</strong></p><p><img alt="1572438683496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438683496.png"></p><p><img alt="1572438702531" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438702531.png"></p><p><img alt="1572438724298" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438724298.png"></p><p><img alt="1572438749984" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438749984.png"></p><p>参考：<br><a href="https://blog.csdn.net/weixin_44580210/article/details/95748091" target="_blank" rel="noopener">VINS-Mono关键知识点总结——边缘化marginalization理论和代码详解</a><br><a href="https://blog.csdn.net/weixin_44580210/article/details/93377806" target="_blank" rel="noopener">VINS-Mono关键知识点总结——预积分和后端优化IMU部分</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;状态向量&quot;&gt;&lt;a href=&quot;#状态向量&quot; class=&quot;headerlink&quot; title=&quot;状态向量&quot;&gt;&lt;/a&gt;状态向量&lt;/h1&gt;&lt;p&gt;VIO 紧耦合方案的主要思路就是通过将基于视觉构造的残差项和基于 IMU 构造的残差项放在一起构造成一个联合优化的问题，整个优化问题的最优解即可认为是比较准确的状态估计。&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191029192151582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center&quot;&gt;&lt;br&gt;为了限制优化变量的数目， VINS-Mono 采用了滑动窗口的形式， 滑动窗口中的全状态量包括滑动窗口内的n+1个关键帧时刻 IMU 坐标系的位置、姿态、姿态（旋转）、加速度计偏置、陀螺仪偏置， Camera 到 IMU 的外参， m +1个 3D 路标点的逆深度：&lt;/p&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono——初始化</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/VINS-Mono%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/VINS-Mono——初始化/</id>
    <published>2019-10-29T09:31:40.000Z</published>
    <updated>2019-10-30T03:37:18.732Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="估计器初始化"><a href="#估计器初始化" class="headerlink" title="估计器初始化"></a>估计器初始化</h1><ul><li>初始化的原因是单目惯性紧耦合系统是一个非线性程度很高的系统，首先单目是无法获得空间中的绝对尺度，而IMU又必然存在偏置，在后面进行求解的时候还需要用到重力加速度（包括大小和方向），对于速度比较敏感的条件下，比如说无人机，又要精确的速度信息，因此，如何有效的在紧耦合系统处理之前计算出这些量，对整个紧耦合系统的鲁棒性有着重大的意义</li><li>初始化要做的事其实说起来很简单，就是计算出绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li><li>VINS-Mono 的初始化采用松组合（loosely coupled）的方式获取初始值。 首先用 SFM求解滑动窗口内所有帧的位姿（以第一帧作为参考坐标系）和所有路标点的 3D 位置。然后将 SFM 的结果与 IMU 预积分的值进行对齐，实现对陀螺仪偏置的校正，再求解每一帧对应的速度，求解重力向量方向，恢复单目相机的尺度因子。</li><li>需要注意的是，在初始化过程中，并没有对加速度计的偏置进行校正，这是因为重力是初始化过程中待求的量，而加速度计偏置与重力耦合，而且系统的加速度相对于重力加速度很小，所以加速度计偏置在初始化过程中很难观测，因此初始化过程中不考虑加速度计偏置的校正。</li></ul><a id="more"></a><h2 id="滑动窗口-Sliding-Window-纯视觉SfM"><a href="#滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="滑动窗口(Sliding Window)纯视觉SfM"></a>滑动窗口(Sliding Window)纯视觉SfM</h2><p>首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，使用五点法恢复这两个帧之间的相对旋转和尺度平移。否则，将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c_0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}_{c_k}，q^{c0}_{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。</p><p>纯视觉初始化时，我们采用第一帧 c0 作为基准坐标系，若要转化为从 body 坐标系到 c0坐标系，可以进行如下变换，其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"></p><p>上式推导如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185549508.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185607797.png#pic_center"></p><h2 id="B-视觉惯性校准（Visual-Inertial-Alignment"><a href="#B-视觉惯性校准（Visual-Inertial-Alignment" class="headerlink" title="B. 视觉惯性校准（Visual-Inertial Alignment)"></a>B. 视觉惯性校准（Visual-Inertial Alignment)</h2><h3 id="陀螺仪偏置标定"><a href="#陀螺仪偏置标定" class="headerlink" title="陀螺仪偏置标定"></a>陀螺仪偏置标定</h3><p>这 一 部 分 的 内 容 对 应 于 VINS-Mono 代 码 initial_aligment.cpp 中 的<br>solveGyroscopeBias()函数。<br>考虑滑动窗口中连续两帧$b_k$和$b_{k+1}$，我们从视觉sfM中得到旋转$q^{c0}_{b_k}$和$q^{c0}_{b_{k+1}}$，从IMU预积分得到的相对约束$γ^{b_k}_{b_{k+1}}$。<br>陀螺仪的误差有两部分测量噪声和陀螺仪偏置，噪声暂时可以忽略（毕竟太小），而视觉的误差就只有观测噪声（也可以忽略不管），因此两者差值的绝对值就是陀螺仪偏置，将整个滑动窗口的所有的旋转做差构成了一个最小化误差模型：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"></p><p>其中B代表窗口的所有帧。<br>$q^{c0}_{b_k}$$q^{c0}_{b_{k+1}}$：相机从$b_k$到$b_{k+1}$下的相对旋转<br>$γ^{b_k}_{b_{k+1}}$：陀螺仪从$b_{k+1}$到$b_k$下的相对旋转<br>第二个式子给出了$γ^{b_k}_{b_{k+1}}$对陀螺仪偏置的一阶近似。</p><p>因为四元数最小值为单位四元数 [1; 0v]T，所以</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171134242.png#pic_center"></p><p>只考虑虚部，则有：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171213618.png#pic_center"></p><p>然后取最小二乘，当然也可以使用SVD分解等方法求解，得到了陀螺仪偏置$b_w$的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}_{b_{k+1}}、\hat β^{b_k}_{b_{k+1}}、\hat γ^{b_k}_{b_{k+1}}$ 。</p><h3 id="速度、重力向量和尺度初始化："><a href="#速度、重力向量和尺度初始化：" class="headerlink" title="速度、重力向量和尺度初始化："></a>速度、重力向量和尺度初始化：</h3><p>这一部分的内容对应于 VINS-Mono 代码 initial_aligment.cpp 中的 LinearAlignment()<br>函数<br>在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"></p><p>其中，$v^{b_k}_{b_k}$是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。<br>在$c_0$坐标系的预积分：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180200742.png#pic_center"></p><p>$p^{c_0}_{b_{k+1}}$和$p^{c_0}_{b_{k}}$可由视觉 SFM 获得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180301129.png#pic_center"></p><p>将此式带入上式得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180458901.png#pic_center"></p><p>将等式中速度都转换到$c_0$ 坐标系下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181635823.png#pic_center"></p><p>将上式转换成$Hx=b$ 的形式，这样便于利用 cholesky 进行求解，由$s\bar p^{c_0}_{b_k}=p^{c_0}_{c_k}-R^{c_0}_{c_k}p_c^b$，带入上式得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181106531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>联力等式：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181609102.png#pic_center"></p><p>即： $H^{6×10}X_I^{\ 10×1} = b^{6×1}$<br>H矩阵一定是一个正定对称矩阵，以采用快速的 Cholosky 分解下面方程求解$X_I$：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028182207166.png#pic_center"></p><p>可以得到滑动窗口中所有关键帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及单目尺度因子 s 。</p><h3 id="修正重力矢量"><a href="#修正重力矢量" class="headerlink" title="修正重力矢量"></a>修正重力矢量</h3><p>这里计算的重力吸收了重力加速度计的偏置，虽然不需要计算重力加速度计的偏置，但重力还是需要优化的，说到优化重力加速度，肯定包含两个量，大小和方向，也就是三个维度，但是一般来说大小是确定已知的（这里设为9.8），因此其实我们要做的就是优化方向，是一个两维的向量，下图是优化重力的方法以及b1,b2单位向量的方向确定模型。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>将重力向量重新参数化：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183144674.png#pic_center"></p><p>其中g是已知的重力大小，$\bar {\hat g}$是表示重力方向的单位向量，b1、 b2为重力向量正切空间的一对<br>正交基 ，如图所示，w1和w2分别是在b1和b2上的对应位移。<br>将上式代入前面式子中，重新整理可得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183424735.png#pic_center"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183439415.png"></p><p>这样，可以用 Cholosky 分解下面方程求解$X_I$：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183526590.png#pic_center"></p><p>完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p><h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028160032562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>直接从estimator.cpp中的 if (solver_flag == INITIAL) 开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (solver_flag == INITIAL) &#123;</span><br><span class="line">    <span class="comment">// 滑窗中的Keyframe达到指定大小的时候，才开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (frame_count == WINDOW_SIZE) &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_EXTRINSIC != <span class="number">2</span> &amp;&amp; (header.stamp.toSec() - initial_timestamp) &gt; <span class="number">0.1</span>) &#123;</span><br><span class="line">            result = initialStructure(); <span class="comment">//! 初始化</span></span><br><span class="line">            initial_timestamp = header.stamp.toSec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            solver_flag = NON_LINEAR;</span><br><span class="line">            solveOdometry();</span><br><span class="line">            slideWindow();</span><br><span class="line">            f_manager.removeFailures();</span><br><span class="line">            ROS_INFO(<span class="string">"Initialization finish!"</span>);</span><br><span class="line">            last_R = Rs[WINDOW_SIZE];</span><br><span class="line">            last_P = Ps[WINDOW_SIZE];</span><br><span class="line">            last_R0 = Rs[<span class="number">0</span>];</span><br><span class="line">            last_P0 = Ps[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            slideWindow();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        frame_count++;</span><br></pre></td></tr></table></figure><h3 id="initialStructure-视觉惯性联合初始化"><a href="#initialStructure-视觉惯性联合初始化" class="headerlink" title="initialStructure() 视觉惯性联合初始化"></a>initialStructure() 视觉惯性联合初始化</h3><ul><li>1.通过计算线加速度的标准差，检测IMU的可观性，以进行初始化<br>注意这里并没有算上all_image_frame的第一帧，所以求均值和标准差的时候要减一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 通过计算预积分加速度的标准差，检测IMU的可观性</span></span><br><span class="line"><span class="comment">//check imu observibility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算均值</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it;</span><br><span class="line">    Vector3d sum_g;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        sum_g += tmp_g;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector3d aver_g = sum_g * <span class="number">1.0</span> / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方差</span></span><br><span class="line">    <span class="keyword">double</span> var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        var += (tmp_g - aver_g).transpose() * (tmp_g - aver_g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算标准差</span></span><br><span class="line">    var = <span class="built_in">sqrt</span>(var / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//ROS_WARN("IMU variation %f!", var);</span></span><br><span class="line">    <span class="keyword">if</span>(var &lt; <span class="number">0.25</span>) <span class="comment">//! 以标准差判断可观性</span></span><br><span class="line">    &#123;</span><br><span class="line">        ROS_INFO(<span class="string">"IMU excitation not enouth!"</span>);</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.将f_manager中的所有feature保存到vector<sfmfeature> sfm_f中，SFMFeature数组中包含了特征点状态（是否被三角化），id，2d点，3d坐标以及深度，将特征管理器中的特征信息保存到SFMFeature对象sfm_f中sfm_f.push_back(tmp_feature)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SFMFeature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> state;<span class="comment">//状态（是否被三角化）</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,Vector2d&gt;&gt; observation;<span class="comment">//所有观测到该特征点的图像帧ID和图像坐标</span></span><br><span class="line">    <span class="keyword">double</span> position[<span class="number">3</span>];<span class="comment">//3d坐标</span></span><br><span class="line">    <span class="keyword">double</span> depth;<span class="comment">//深度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历滑窗内所有的Features，以vector&lt;SFMFeature&gt;形式保存滑窗内所有特征点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;SFMFeature&gt; sfm_f;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> imu_j = it_per_id.start_frame - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    SFMFeature tmp_feature;</span><br><span class="line">    tmp_feature.state = <span class="literal">false</span>;</span><br><span class="line">    tmp_feature.id = it_per_id.feature_id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_frame : it_per_id.feature_per_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        imu_j++;</span><br><span class="line">        Vector3d pts_j = it_per_frame.point;</span><br><span class="line">        tmp_feature.observation.push_back(make_pair(imu_j, Eigen::Vector2d&#123;pts_j.x(), pts_j.y()&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sfm_f.push_back(tmp_feature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sfmfeature></li><li>3.relativePose()恢复出R、t</li></ul><blockquote><p> 1.先通过 FeatureManager::getCorresponding()获取滑动窗口中第i帧和最后一帧的特征匹配corres<br> 2.如果第i帧和最后一帧的特征匹配数corres大于20，且所有匹配的特征点的平均视差大于一定阈值，通过solveRelativeRT（定义在solv_5pts.cpp类中）用五点法求本质矩阵cv::findFundamentalMat 计算出当前帧到参考帧的 T</p><p> 值得注意：relativePose得到的位姿是第l帧的，第l帧的筛选是从第一帧开始到滑动窗口所有帧中一开始满足平均视差足够大的帧，这里的第l帧会作为参考帧到下面的全局SFM使用。这样得到图像的特征点2d坐标的提取，相机第l帧和最后一帧之间的旋转和平移</p></blockquote>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!relativePose(relative_R, relative_T, l))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"Not enough features or parallax; Move device around"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>bool relativePose(relative_R, relative_T, l)</strong><br>   该函数判断每帧到窗口最后一帧对应特征点的平均视差大于30，且内点数目大于12则可进行初始化，同时返回当前帧到第l帧的坐标系变换R和T<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::relativePose(Matrix3d &amp;relative_R, Vector3d &amp;relative_T, <span class="keyword">int</span> &amp;l) &#123;</span><br><span class="line">    <span class="comment">// find previous frame which contians enough correspondance and parallex with newest frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在滑窗内寻找与最新的关键帧共视点超过20(像素点)的关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WINDOW_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">        <span class="comment">//获取第i帧和最后一帧的特征匹配corres</span></span><br><span class="line">        corres = f_manager.getCorresponding(i, WINDOW_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共视的Features应该大于20</span></span><br><span class="line">        <span class="keyword">if</span> (corres.size() &gt; <span class="number">20</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取匹配的特征点在图像上的视差和(归一化平面上)</span></span><br><span class="line">            <span class="keyword">double</span> sum_parallax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(corres.size()); j++) &#123;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_0</span><span class="params">(corres[j].first(<span class="number">0</span>), corres[j].first(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_1</span><span class="params">(corres[j].second(<span class="number">0</span>), corres[j].second(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="keyword">double</span> parallax = (pts_0 - pts_1).norm();</span><br><span class="line">                sum_parallax = sum_parallax + parallax;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取所有匹配的特征点的平均视差</span></span><br><span class="line">            <span class="keyword">double</span> average_parallax = <span class="number">1.0</span> * sum_parallax / <span class="keyword">int</span>(corres.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视差大于一定阈值，并且能够有效地求解出变换矩阵</span></span><br><span class="line">            <span class="keyword">if</span> (average_parallax * <span class="number">460</span> &gt; <span class="number">30</span> &amp;&amp; m_estimator.solveRelativeRT(corres, relative_R, relative_T)) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">                ROS_DEBUG(<span class="string">"average_parallax %f choose l %d and newest frame to triangulate the whole structure"</span>,</span><br><span class="line">                          average_parallax * <span class="number">460</span>, l);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>FeatureManager::getCorresponding()</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; FeatureManager::getCorresponding(<span class="keyword">int</span> frame_count_l, <span class="keyword">int</span> frame_count_r) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : feature) &#123;</span><br><span class="line">        <span class="comment">// 保证两帧的id大于当前特征点的起始id小于当前特征点的终止id</span></span><br><span class="line">        <span class="keyword">if</span> (it.start_frame &lt;= frame_count_l &amp;&amp; it.endFrame() &gt;= frame_count_r) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx_l = frame_count_l - it.start_frame;</span><br><span class="line">            <span class="keyword">int</span> idx_r = frame_count_r - it.start_frame;</span><br><span class="line"></span><br><span class="line">            Vector3d a = it.feature_per_frame[idx_l].point;</span><br><span class="line">            Vector3d b = it.feature_per_frame[idx_r].point;</span><br><span class="line"></span><br><span class="line">            corres.push_back(make_pair(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> corres;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>solveRelativeRT()</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MotionEstimator::solveRelativeRT(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; &amp;corres, Matrix3d &amp;Rotation, Vector3d &amp;Translation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (corres.size() &gt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! Step1：提取匹配完的Features</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; ll, rr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(corres.size()); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll.push_back(cv::Point2f(corres[i].first(<span class="number">0</span>), corres[i].first(<span class="number">1</span>)));</span><br><span class="line">            rr.push_back(cv::Point2f(corres[i].second(<span class="number">0</span>), corres[i].second(<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::Mat mask;</span><br><span class="line">        <span class="comment">//! Step2：利用Ransac算法计算本质矩阵，内外点的阈值距离设定为0.3 / 460</span></span><br><span class="line">        cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, <span class="number">0.3</span> / <span class="number">460</span>, <span class="number">0.99</span>, mask);</span><br><span class="line"></span><br><span class="line">        cv::Mat cameraMatrix = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step3：计算变换矩阵并得到内点个数</span></span><br><span class="line">        cv::Mat rot, trans;</span><br><span class="line">        <span class="keyword">int</span> inlier_cnt = cv::recoverPose(E, ll, rr, cameraMatrix, rot, trans, mask);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "inlier_cnt " &lt;&lt; inlier_cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 得到变换矩阵 ll ==&gt; rr</span></span><br><span class="line">        Eigen::Matrix3d R;</span><br><span class="line">        Eigen::Vector3d T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            T(i) = trans.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                R(i, j) = rot.at&lt;<span class="keyword">double</span>&gt;(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step4：得到旋转矩阵和平移量 rr ==&gt; ll</span></span><br><span class="line">        Rotation    =  R.transpose();</span><br><span class="line">        Translation = -R.transpose() * T;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 判断求取的内点个数是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(inlier_cnt &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>4.对窗口中每个图像帧求解sfm问题，调用sfm.construct(frame_count + 1, Q, T,l,relative_R, relative_T,sfm_f, sfm_tracked_points)估计slidingwindow中所有图像帧相对于参考帧（这里以第l帧作为参考帧）的旋转四元数Q、平移向量T和特征点坐标sfm_tracked_points。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三角化恢复滑窗内的Features</span></span><br><span class="line">GlobalSFM sfm;</span><br><span class="line">Quaterniond Q[frame_count + <span class="number">1</span>];</span><br><span class="line">Vector3d    T[frame_count + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; sfm_tracked_points;</span><br><span class="line"><span class="keyword">if</span>(!sfm.construct(frame_count + <span class="number">1</span>, Q, T, l, relative_R, relative_T, sfm_f, sfm_tracked_points))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"global SFM failed!"</span>);</span><br><span class="line">    marginalization_flag = MARGIN_OLD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool GlobalSFM::construct()</strong><br>函数位于inital_sfm.cpp文件中<br>纯视觉sfm，求解窗口中所有图像帧的位姿QT（相对于第l帧）和特征点坐标sfm_tracked_points<br>frame_num=frame_count + 1=11，frame_num-1表示当前帧</p><blockquote><p>1.把第l帧看作参考坐标系，根据当前帧到第l帧的relative_R，relative_T，得到当前帧在参考坐标系下的位姿，之后的pose[i]表示第l帧到第i帧的变换矩阵[R|T]<br>2.三角化第l帧（参考帧）与第frame_num-1帧（当前帧）的路标点<br>3.pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中，并与当前帧进行三角化<br>4.对第l帧与从第l+1到frame_num-2的每一帧再进行三角化<br>5.PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化<br>6.三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标<br>7.使用cares进行全局BA优化<br>8.得到的是第l帧坐标系到各帧的变换矩阵，将其转变为每一帧在第l帧坐标系上的位姿<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GlobalSFM::construct(<span class="keyword">int</span> frame_num, Quaterniond* q, Vector3d* T, <span class="keyword">int</span> l,</span><br><span class="line">  <span class="keyword">const</span> Matrix3d relative_R, <span class="keyword">const</span> Vector3d relative_T,</span><br><span class="line">  <span class="built_in">vector</span>&lt;SFMFeature&gt; &amp;sfm_f, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; &amp;sfm_tracked_points)</span><br><span class="line">&#123;</span><br><span class="line">feature_num = sfm_f.size();</span><br><span class="line"><span class="comment">//cout &lt;&lt; "set 0 and " &lt;&lt; l &lt;&lt; " as known " &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// have relative_r relative_t</span></span><br><span class="line"><span class="comment">// intial two view</span></span><br><span class="line">q[l].w() = <span class="number">1</span>;</span><br><span class="line">q[l].x() = <span class="number">0</span>;</span><br><span class="line">q[l].y() = <span class="number">0</span>;</span><br><span class="line">q[l].z() = <span class="number">0</span>;</span><br><span class="line">T[l].setZero();</span><br><span class="line">q[frame_num - <span class="number">1</span>] = q[l] * Quaterniond(relative_R);</span><br><span class="line">T[frame_num - <span class="number">1</span>] = relative_T;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "init q_l " &lt;&lt; q[l].w() &lt;&lt; " " &lt;&lt; q[l].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "init t_l " &lt;&lt; T[l].transpose() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//rotate to cam frame</span></span><br><span class="line">Matrix3d c_Rotation[frame_num];</span><br><span class="line">Vector3d c_Translation[frame_num];</span><br><span class="line">Quaterniond c_Quat[frame_num];</span><br><span class="line"><span class="keyword">double</span> c_rotation[frame_num][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">double</span> c_translation[frame_num][<span class="number">3</span>];</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">4</span>&gt; Pose[frame_num];</span><br><span class="line"></span><br><span class="line">c_Quat[l] = q[l].inverse();</span><br><span class="line">c_Rotation[l] = c_Quat[l].toRotationMatrix();</span><br><span class="line">c_Translation[l] = <span class="number">-1</span> * (c_Rotation[l] * T[l]);</span><br><span class="line">Pose[l].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[l];</span><br><span class="line">Pose[l].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[l];</span><br><span class="line"></span><br><span class="line">c_Quat[frame_num - <span class="number">1</span>] = q[frame_num - <span class="number">1</span>].inverse();</span><br><span class="line">c_Rotation[frame_num - <span class="number">1</span>] = c_Quat[frame_num - <span class="number">1</span>].toRotationMatrix();</span><br><span class="line">c_Translation[frame_num - <span class="number">1</span>] = <span class="number">-1</span> * (c_Rotation[frame_num - <span class="number">1</span>] * T[frame_num - <span class="number">1</span>]);</span><br><span class="line">Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[frame_num - <span class="number">1</span>];</span><br><span class="line">Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[frame_num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1: trangulate between l ----- frame_num - 1</span></span><br><span class="line"><span class="comment">//2: solve pnp l + 1; trangulate l + 1 ------- frame_num - 1; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; frame_num - <span class="number">1</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// solve pnp</span></span><br><span class="line"><span class="comment">//pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; l)</span><br><span class="line">&#123;</span><br><span class="line">Matrix3d R_initial = c_Rotation[i - <span class="number">1</span>];</span><br><span class="line">Vector3d P_initial = c_Translation[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">c_Rotation[i] = R_initial;</span><br><span class="line">c_Translation[i] = P_initial;</span><br><span class="line">c_Quat[i] = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// triangulate point based on the solve pnp result</span></span><br><span class="line">triangulateTwoFrames(i, Pose[i], frame_num - <span class="number">1</span>, Pose[frame_num - <span class="number">1</span>], sfm_f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3: triangulate l-----l+1 l+2 ... frame_num -2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; frame_num - <span class="number">1</span>; i++)</span><br><span class="line">triangulateTwoFrames(l, Pose[l], i, Pose[i], sfm_f);</span><br><span class="line"><span class="comment">//4: solve pnp l-1; triangulate l-1 ----- l</span></span><br><span class="line"><span class="comment">//             l-2              l-2 ----- l</span></span><br><span class="line"><span class="comment">//PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//solve pnp</span></span><br><span class="line">Matrix3d R_initial = c_Rotation[i + <span class="number">1</span>];</span><br><span class="line">Vector3d P_initial = c_Translation[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">c_Rotation[i] = R_initial;</span><br><span class="line">c_Translation[i] = P_initial;</span><br><span class="line">c_Quat[i] = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line"><span class="comment">//triangulate</span></span><br><span class="line">triangulateTwoFrames(i, Pose[i], l, Pose[l], sfm_f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5: triangulate all other points</span></span><br><span class="line"><span class="comment">//三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; feature_num; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sfm_f[j].state == <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)sfm_f[j].observation.size() &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">Vector2d point0, point1;</span><br><span class="line"><span class="keyword">int</span> frame_0 = sfm_f[j].observation[<span class="number">0</span>].first;</span><br><span class="line">point0 = sfm_f[j].observation[<span class="number">0</span>].second;</span><br><span class="line"><span class="keyword">int</span> frame_1 = sfm_f[j].observation.back().first;</span><br><span class="line">point1 = sfm_f[j].observation.back().second;</span><br><span class="line">Vector3d point_3d;</span><br><span class="line">triangulatePoint(Pose[frame_0], Pose[frame_1], point0, point1, point_3d);</span><br><span class="line">sfm_f[j].state = <span class="literal">true</span>;</span><br><span class="line">sfm_f[j].position[<span class="number">0</span>] = point_3d(<span class="number">0</span>);</span><br><span class="line">sfm_f[j].position[<span class="number">1</span>] = point_3d(<span class="number">1</span>);</span><br><span class="line">sfm_f[j].position[<span class="number">2</span>] = point_3d(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; "trangulated : " &lt;&lt; frame_0 &lt;&lt; " " &lt;&lt; frame_1 &lt;&lt; "  3d point : "  &lt;&lt; j &lt;&lt; "  " &lt;&lt; point_3d.transpose() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">q[i] = c_Rotation[i].transpose(); </span></span><br><span class="line"><span class="comment">cout &lt;&lt; "solvePnP  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">Vector3d t_tmp;</span></span><br><span class="line"><span class="comment">t_tmp = -1 * (q[i] * c_Translation[i]);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "solvePnP  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; t_tmp.x() &lt;&lt;"  "&lt;&lt; t_tmp.y() &lt;&lt;"  "&lt;&lt; t_tmp.z() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//full BA</span></span><br><span class="line"><span class="comment">//使用cares进行全局BA优化</span></span><br><span class="line">ceres::Problem problem;</span><br><span class="line">ceres::LocalParameterization* local_parameterization = <span class="keyword">new</span> ceres::QuaternionParameterization();</span><br><span class="line"><span class="comment">//cout &lt;&lt; " begin full BA " &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//double array for ceres</span></span><br><span class="line">c_translation[i][<span class="number">0</span>] = c_Translation[i].x();</span><br><span class="line">c_translation[i][<span class="number">1</span>] = c_Translation[i].y();</span><br><span class="line">c_translation[i][<span class="number">2</span>] = c_Translation[i].z();</span><br><span class="line">c_rotation[i][<span class="number">0</span>] = c_Quat[i].w();</span><br><span class="line">c_rotation[i][<span class="number">1</span>] = c_Quat[i].x();</span><br><span class="line">c_rotation[i][<span class="number">2</span>] = c_Quat[i].y();</span><br><span class="line">c_rotation[i][<span class="number">3</span>] = c_Quat[i].z();</span><br><span class="line">problem.AddParameterBlock(c_rotation[i], <span class="number">4</span>, local_parameterization);</span><br><span class="line">problem.AddParameterBlock(c_translation[i], <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (i == l)</span><br><span class="line">&#123;</span><br><span class="line">problem.SetParameterBlockConstant(c_rotation[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == l || i == frame_num - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">problem.SetParameterBlockConstant(c_translation[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; feature_num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sfm_f[i].state != <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(sfm_f[i].observation.size()); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = sfm_f[i].observation[j].first;</span><br><span class="line">ceres::CostFunction* cost_function = ReprojectionError3D::Create(</span><br><span class="line">sfm_f[i].observation[j].second.x(),</span><br><span class="line">sfm_f[i].observation[j].second.y());</span><br><span class="line"></span><br><span class="line">    problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, c_rotation[l], c_translation[l], </span><br><span class="line">    sfm_f[i].position); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ceres::Solver::Options options;</span><br><span class="line">options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line"><span class="comment">//options.minimizer_progress_to_stdout = true;</span></span><br><span class="line">options.max_solver_time_in_seconds = <span class="number">0.2</span>;</span><br><span class="line">ceres::Solver::Summary summary;</span><br><span class="line">ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; summary.BriefReport() &lt;&lt; "\n";</span></span><br><span class="line"><span class="keyword">if</span> (summary.termination_type == ceres::CONVERGENCE || summary.final_cost &lt; <span class="number">5e-03</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "vision only BA converge" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "vision only BA not converge " &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">q[i].w() = c_rotation[i][<span class="number">0</span>]; </span><br><span class="line">q[i].x() = c_rotation[i][<span class="number">1</span>]; </span><br><span class="line">q[i].y() = c_rotation[i][<span class="number">2</span>]; </span><br><span class="line">q[i].z() = c_rotation[i][<span class="number">3</span>]; </span><br><span class="line">q[i] = q[i].inverse();</span><br><span class="line"><span class="comment">//cout &lt;&lt; "final  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第l帧坐标系到各帧的变换矩阵，应将其转变为每一帧在第l帧坐标系上的位姿</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">T[i] = <span class="number">-1</span> * (q[i] * Vector3d(c_translation[i][<span class="number">0</span>], c_translation[i][<span class="number">1</span>], c_translation[i][<span class="number">2</span>]));</span><br><span class="line"><span class="comment">//cout &lt;&lt; "final  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; T[i](0) &lt;&lt;"  "&lt;&lt; T[i](1) &lt;&lt;"  "&lt;&lt; T[i](2) &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)sfm_f.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sfm_f[i].state)</span><br><span class="line">sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[<span class="number">0</span>], sfm_f[i].position[<span class="number">1</span>], sfm_f[i].position[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>对于所有的图像帧，包括不在滑动窗口中的，提供初始的RT估计，然后solvePnP进行优化</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// solve pnp for all frame</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt;::iterator it;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it = all_image_frame.begin( );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; frame_it != all_image_frame.end( ); frame_it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// provide initial guess</span></span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) == Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        frame_it-&gt;second.is_key_frame = <span class="literal">true</span>;</span><br><span class="line">        frame_it-&gt;second.R = Q[i].toRotationMatrix() * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">        frame_it-&gt;second.T = T[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) &gt; Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将滑窗内第i帧的变换矩阵当做初始值</span></span><br><span class="line">    Matrix3d R_inital = (Q[i].inverse()).toRotationMatrix();</span><br><span class="line">    Vector3d P_inital = - R_inital * T[i];</span><br><span class="line">    cv::Mat rvec, t, tmp_r;</span><br><span class="line">    cv::eigen2cv(R_inital, tmp_r);</span><br><span class="line">    cv::Rodrigues(tmp_r, rvec);</span><br><span class="line">    cv::eigen2cv(P_inital, t);</span><br><span class="line"></span><br><span class="line">    frame_it-&gt;second.is_key_frame = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point3f&gt; pts_3_vector;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point2f&gt; pts_2_vector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;id_pts : frame_it-&gt;second.points)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> feature_id = id_pts.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i_p : id_pts.second)</span><br><span class="line">        &#123;</span><br><span class="line">            it = sfm_tracked_points.find(feature_id);</span><br><span class="line">            <span class="keyword">if</span>(it != sfm_tracked_points.end())</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3d world_pts = it-&gt;second;</span><br><span class="line">                cv::<span class="function">Point3f <span class="title">pts_3</span><span class="params">(world_pts(<span class="number">0</span>), world_pts(<span class="number">1</span>), world_pts(<span class="number">2</span>))</span></span>;</span><br><span class="line">                pts_3_vector.push_back(pts_3);</span><br><span class="line"></span><br><span class="line">                Vector2d img_pts = i_p.second.head&lt;<span class="number">2</span>&gt;();</span><br><span class="line">                cv::<span class="function">Point2f <span class="title">pts_2</span><span class="params">(img_pts(<span class="number">0</span>), img_pts(<span class="number">1</span>))</span></span>;</span><br><span class="line">                pts_2_vector.push_back(pts_2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pts_3_vector.size() &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pts_3_vector size "</span> &lt;&lt; pts_3_vector.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ROS_DEBUG(<span class="string">"Not enough points for solve pnp !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat K = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat D;</span><br><span class="line">    <span class="keyword">if</span> (! cv::solvePnP(pts_3_vector, pts_2_vector, K, D, rvec, t, <span class="literal">true</span>)) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve pnp fail!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PnP求解出的位姿要取逆</span></span><br><span class="line">    MatrixXd R_pnp;</span><br><span class="line">    MatrixXd T_pnp;</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat r;</span><br><span class="line">        cv::Rodrigues(rvec, r);</span><br><span class="line">        MatrixXd tmp_R_pnp;</span><br><span class="line">        cv::cv2eigen(r, tmp_R_pnp);</span><br><span class="line">        R_pnp = tmp_R_pnp.transpose();</span><br><span class="line"></span><br><span class="line">        cv::cv2eigen(t, T_pnp);</span><br><span class="line">        T_pnp = R_pnp * (-T_pnp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换到IMU坐标系下</span></span><br><span class="line">    frame_it-&gt;second.R = R_pnp * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">    frame_it-&gt;second.T = T_pnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6.进行视觉惯性联合初始化，imu与视觉对齐，获取绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视觉与IMU对齐</span></span><br><span class="line"><span class="keyword">if</span> (visualInitialAlign())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"misalign visual structure with IMU"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool Estimator::visualInitialAlign()</strong><br>该函数主要实现了陀螺仪的偏置校准(加速度偏置没有处理)，计算速度V[0:n]、重力g、尺度s。<br>同时更新了Bgs后，IMU测量量需要repropagate；得到尺度s和重力g的方向后，需更新所有图像帧在世界坐标系下的Ps、Rs、Vs。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::visualInitialAlign()</span><br><span class="line">&#123;</span><br><span class="line">    TicToc t_g;</span><br><span class="line"></span><br><span class="line">    VectorXd x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve scale</span></span><br><span class="line">    <span class="comment">// 要注意这个地方求解出的g是在C0坐标系下</span></span><br><span class="line">    <span class="comment">//1.计算陀螺仪偏置，尺度，重力加速度和速度</span></span><br><span class="line">    <span class="keyword">bool</span> result = VisualIMUAlignment(all_image_frame, Bgs, g, x);</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve g failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change state</span></span><br><span class="line">    <span class="comment">//2.获取所有图像帧的位姿Ps、Rs，并将其置为关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix3d Ri = all_image_frame[Headers[i].stamp.toSec()].R;</span><br><span class="line">        Vector3d Pi = all_image_frame[Headers[i].stamp.toSec()].T;</span><br><span class="line">        Ps[i] = Pi;</span><br><span class="line">        Rs[i] = Ri;</span><br><span class="line">        all_image_frame[Headers[i].stamp.toSec()].is_key_frame = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有特征点的深度置为-1</span></span><br><span class="line">    VectorXd dep = f_manager.getDepthVector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dep.size(); i++)</span><br><span class="line">        dep[i] = <span class="number">-1</span>;</span><br><span class="line">    f_manager.clearDepth(dep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//triangulat on cam pose , no tic</span></span><br><span class="line">    <span class="comment">//3.重新计算特征点的深度</span></span><br><span class="line">    Vector3d TIC_TMP[NUM_OF_CAM];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">        TIC_TMP[i].setZero();</span><br><span class="line">    ric[<span class="number">0</span>] = RIC[<span class="number">0</span>];</span><br><span class="line">    f_manager.setRic(ric);</span><br><span class="line">    f_manager.triangulate(Ps, &amp;(TIC_TMP[<span class="number">0</span>]), &amp;(RIC[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> s = (x.tail&lt;<span class="number">1</span>&gt;())(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4.陀螺仪的偏置bgs改变，重新计算预积分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= WINDOW_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre_integrations[i]-&gt;repropagate(Vector3d::Zero(), Bgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.将Ps、Vs、depth尺度s缩放后转变为相对于第0帧图像坐标系下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = frame_count; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        Ps[i] = s * Ps[i] - Rs[i] * TIC[<span class="number">0</span>] - (s * Ps[<span class="number">0</span>] - Rs[<span class="number">0</span>] * TIC[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> kv = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_i;</span><br><span class="line">    <span class="keyword">for</span> (frame_i = all_image_frame.begin(); frame_i != all_image_frame.end(); frame_i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(frame_i-&gt;second.is_key_frame)</span><br><span class="line">        &#123;</span><br><span class="line">            kv++;</span><br><span class="line">            Vs[kv] = frame_i-&gt;second.R * x.segment&lt;<span class="number">3</span>&gt;(kv * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">    &#123;</span><br><span class="line">        it_per_id.used_num = it_per_id.feature_per_frame.size();</span><br><span class="line">        <span class="keyword">if</span> (!(it_per_id.used_num &gt;= <span class="number">2</span> &amp;&amp; it_per_id.start_frame &lt; WINDOW_SIZE - <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        it_per_id.estimated_depth *= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转矩阵rot_diff</span></span><br><span class="line">    Matrix3d R0 = Utility::g2R(g);</span><br><span class="line">    <span class="keyword">double</span> yaw = Utility::R2ypr(R0 * Rs[<span class="number">0</span>]).x();</span><br><span class="line">    R0 = Utility::ypr2R(Eigen::Vector3d&#123;-yaw, <span class="number">0</span>, <span class="number">0</span>&#125;) * R0;</span><br><span class="line">    g = R0 * g;</span><br><span class="line">    <span class="comment">//Matrix3d rot_diff = R0 * Rs[0].transpose();</span></span><br><span class="line">    Matrix3d rot_diff = R0;</span><br><span class="line">    <span class="comment">//7.所有变量从参考坐标系c0旋转到世界坐标系w</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Ps[i] = rot_diff * Ps[i];</span><br><span class="line">        Rs[i] = rot_diff * Rs[i];</span><br><span class="line">        Vs[i] = rot_diff * Vs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"g0     "</span> &lt;&lt; g.transpose());</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"my R0  "</span> &lt;&lt; Utility::R2ypr(Rs[<span class="number">0</span>]).transpose()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<br><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719531" target="_blank" rel="noopener">VINS理论与代码详解4——初始化</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;估计器初始化&quot;&gt;&lt;a href=&quot;#估计器初始化&quot; class=&quot;headerlink&quot; title=&quot;估计器初始化&quot;&gt;&lt;/a&gt;估计器初始化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;初始化的原因是单目惯性紧耦合系统是一个非线性程度很高的系统，首先单目是无法获得空间中的绝对尺度，而IMU又必然存在偏置，在后面进行求解的时候还需要用到重力加速度（包括大小和方向），对于速度比较敏感的条件下，比如说无人机，又要精确的速度信息，因此，如何有效的在紧耦合系统处理之前计算出这些量，对整个紧耦合系统的鲁棒性有着重大的意义&lt;/li&gt;
&lt;li&gt;初始化要做的事其实说起来很简单，就是计算出绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v&lt;/li&gt;
&lt;li&gt;VINS-Mono 的初始化采用松组合（loosely coupled）的方式获取初始值。 首先用 SFM求解滑动窗口内所有帧的位姿（以第一帧作为参考坐标系）和所有路标点的 3D 位置。然后将 SFM 的结果与 IMU 预积分的值进行对齐，实现对陀螺仪偏置的校正，再求解每一帧对应的速度，求解重力向量方向，恢复单目相机的尺度因子。&lt;/li&gt;
&lt;li&gt;需要注意的是，在初始化过程中，并没有对加速度计的偏置进行校正，这是因为重力是初始化过程中待求的量，而加速度计偏置与重力耦合，而且系统的加速度相对于重力加速度很小，所以加速度计偏置在初始化过程中很难观测，因此初始化过程中不考虑加速度计偏置的校正。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>17.打印从1到最大的n位数</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/17-打印从1到最大的n位数/</id>
    <published>2019-10-29T06:37:09.000Z</published>
    <updated>2019-10-31T07:23:09.182Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h1><p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>用一个循环从1开始逐个打印，但当n很大时，有可能用整型(int)或长整型(long)都会溢出。</p></li><li><p>字符串模拟运算的解法，<strong>用字符串或者数组表达大数</strong></p><blockquote><p>把字符串中的每一个数字都初始化为’0’<br>每一次为字符串表示的数字加1，再打印出来</p></blockquote></li></ol><a id="more"></a><p>这题对我来说有点难，只是看懂了，python代码以后在整理.</p><p>法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">'0'</span>, n);</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Increment(number))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[]number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，在 number上增加1</span></span><br><span class="line"><span class="comment">// 如果做加法溢出，则返回true；否则为false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTakeOver = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nSum = number[i] - <span class="string">'0'</span> + nTakeOver;</span><br><span class="line">        <span class="keyword">if</span> (i == nLength - <span class="number">1</span>)</span><br><span class="line">            nSum++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nSum &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                isOverflow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nSum -= <span class="number">10</span>;</span><br><span class="line">                nTakeOver = <span class="number">1</span>;</span><br><span class="line">                number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用一个循环从1开始逐个打印，但当n很大时，有可能用整型(int)或长整型(long)都会溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符串模拟运算的解法，&lt;strong&gt;用字符串或者数组表达大数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把字符串中的每一个数字都初始化为’0’&lt;br&gt;每一次为字符串表示的数字加1，再打印出来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>16.数组的整数次方</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/16.%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/16.数组的整数次方/</id>
    <published>2019-10-29T06:35:11.000Z</published>
    <updated>2019-10-30T02:52:27.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>当指数exponent为正</p></li><li><p>当指数为负，可以先对指数取绝对值，算出次方的结果后取倒数，要讨论底数是否为0</p><blockquote><p>底数base不为0</p><p>底数base为0，对0求倒数，导致程序出错，需要进行特殊处理，这里采用全局变量</p><p><img alt="1572402654504" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572402654504.png"></p></blockquote></li></ol><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p><p>法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Exponent;i++)</span><br><span class="line">            result*=base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法2：</p><p>位运算效率比乘除法及求余运算符（%）的效率高很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span> base;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//用右移运算符代替除以2</span></span><br><span class="line">         <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,Exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">         result*=result;</span><br><span class="line">         <span class="comment">//求余运算符（%）判断一个数是奇数还是偶数</span></span><br><span class="line">         <span class="keyword">if</span>(Exponent &amp; <span class="number">0x1</span>==<span class="number">1</span>)</span><br><span class="line">             result*=base;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent&lt;<span class="number">0</span>:</span><br><span class="line">            exponent=-exponent</span><br><span class="line">            flag=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        temp=base</span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(exponent):</span><br><span class="line">            <span class="keyword">if</span> exponent &amp; <span class="number">1</span>:</span><br><span class="line">                res*=temp</span><br><span class="line">            temp*=temp</span><br><span class="line">            exponent=exponent&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。&lt;/p&gt;&lt;p&gt;保证base和exponent不同时为0&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当指数exponent为正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当指数为负，可以先对指数取绝对值，算出次方的结果后取倒数，要讨论底数是否为0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;底数base不为0&lt;/p&gt;
&lt;p&gt;底数base为0，对0求倒数，导致程序出错，需要进行特殊处理，这里采用全局变量&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;1572402654504&quot; data-src=&quot;/home/xiaohu/.config/Typora/typora-user-images/1572402654504.png&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>15.二进制中1的个数</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/15.二进制中1的个数/</id>
    <published>2019-10-29T03:42:07.000Z</published>
    <updated>2019-10-30T03:25:10.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="二进制的5种位运算"><a href="#二进制的5种位运算" class="headerlink" title="二进制的5种位运算"></a>二进制的5种位运算</h1><blockquote><p>与（&amp;）</p><p>或（|）</p><p>异或（^)</p><p>左移(&lt;&lt;)  ：左移n位时，做左边的n位被丢弃，最右边不是那个补上n个0</p><p>右移(&gt;&gt;)  ：右移n位时，最右边的n位被丢弃,左边分两种情况</p><blockquote><p>1.如果数字为正，右移最左边补n个0</p><p>2.如果数字为负，右移最左边补n个1      </p></blockquote></blockquote><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>先判断整数二进制最右边是不是1，接着把输入的整数右移一位，再判断是不是1，直到这个整数变为0为止</p></li><li><p>怎么判断一个整数为1？</p><blockquote><ol><li><p>把整数与1做与运算，但当输入是负数时，如果一直右移运算，最终的数字会变成oxFFFFFFFF陷入死循环</p></li><li><p>为避免死循环，首先把n与1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算，就能判断n的次地位是不是1,反复左移……</p></li><li><p>把一个整数减去1，再和原整数做与运算，会把整个整数最右边的1变为0</p></li></ol></blockquote></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p><p>法1：</p><p>一个int为8位，所以负数的情况中需要<strong>判断32个字节中</strong>1的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">                 result++;</span><br><span class="line">             flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)</span><br><span class="line">         &#123;</span><br><span class="line">             result++;<span class="comment">//一个非0数字至少有一个1</span></span><br><span class="line">             n=(n<span class="number">-1</span>)&amp;n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Python</strong></p><p>法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> n &amp; flag:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n &amp;= <span class="number">0xffffffff</span> <span class="comment">#获取负数补码</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;&lt;h1 id=&quot;二进制的5种位运算&quot;&gt;&lt;a href=&quot;#二进制的5种位运算&quot; class=&quot;headerlink&quot; title=&quot;二进制的5种位运算&quot;&gt;&lt;/a&gt;二进制的5种位运算&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;与（&amp;amp;）&lt;/p&gt;
&lt;p&gt;或（|）&lt;/p&gt;
&lt;p&gt;异或（^)&lt;/p&gt;
&lt;p&gt;左移(&amp;lt;&amp;lt;)  ：左移n位时，做左边的n位被丢弃，最右边不是那个补上n个0&lt;/p&gt;
&lt;p&gt;右移(&amp;gt;&amp;gt;)  ：右移n位时，最右边的n位被丢弃,左边分两种情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.如果数字为正，右移最左边补n个0&lt;/p&gt;
&lt;p&gt;2.如果数字为负，右移最左边补n个1      &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
