<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaohu博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiao-hu.com.cn/"/>
  <updated>2019-10-30T12:52:33.610Z</updated>
  <id>https://xiao-hu.com.cn/</id>
  
  <author>
    <name>xiaohu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高斯分布与边缘化</title>
    <link href="https://xiao-hu.com.cn/2019/10/30/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E8%BE%B9%E7%BC%98%E5%8C%96/"/>
    <id>https://xiao-hu.com.cn/2019/10/30/高斯分布与边缘化/</id>
    <published>2019-10-30T12:14:03.000Z</published>
    <updated>2019-10-30T12:52:33.610Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h1><p>高斯分布有两种表达方式：</p><ul><li>协方差矩阵+均值</li><li>信息矩阵+信息矢量</li></ul><p>协方差矩阵+均值的方式比较常见，如下</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152615298.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152644545.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152656564.png#pic_center"></p><p>左边常数项记为$η$，$p(x)$可以记为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200301827.png"></p><p>其中对称正定矩阵$Σ$为随机变量x的协方差矩阵，μ为x的均值，简记为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200243950.png"></p><p>信息矩阵+信息矢量的形式可以由上式推导而来</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200156360.png"></p><p>现在定义信息矩阵$Ω=Σ^{−1}$ ，信息矢量$ξ=Σ^{−1}μ=Ωμ$，则</p><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200137498.png"></p><h1 id="联合高斯分布的分解"><a href="#联合高斯分布的分解" class="headerlink" title="联合高斯分布的分解"></a>联合高斯分布的分解</h1><p>设随机变量$x_a,x_b$满足联合高斯分布$p(x_a,x_b)$<br>由条件概率公式可知</p><script type="math/tex; mode=display">p(x_a,x_b)=p(x_a)p(x_b∣x_a)</script><p>联合高斯函数的分解就是根据$p(x_a,x_b)$求出上式中的$p(x_a)$和$p(x_b∣x_a)$</p><h2 id="协方差矩阵-均值"><a href="#协方差矩阵-均值" class="headerlink" title="协方差矩阵+均值"></a>协方差矩阵+均值</h2><p>假设多元变量x服从高斯分布，且由两部分组成： $x = [x_a \  x_b]^T$，变量x的概率分布为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204045547.png#pic_center"></p><p>其密度函数可写为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204101961.png#pic_center"></p><p>利用舒尔补对高斯分布进行分解：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204114634.png#pic_center"></p><p>将上式带入$p(x_a,x_b)$的概率密度函数，并注意到对任意矩阵<em>K</em>，有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020412790.png#pic_center"></p><p>可以得到:</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204144966.png#pic_center"></p><p>其中:</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204202528.png#pic_center"></p><p>由此可看出，$p(x_a)$是均值为$μ_a$，协方差矩阵为$Σ_{aa}$的高斯分布，记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204216952.png#pic_center"></p><p>同时，$p(x_b∣x_a)$是均值为$μ_b+Σ_{ba}Σ_{aa}^{−1}(x_a−μ_a)$，协方差矩阵为$Θ_{bb}$的高斯分布，记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204250870.png#pic_center"></p><h2 id="信息矩阵-信息矢量"><a href="#信息矩阵-信息矢量" class="headerlink" title="信息矩阵+信息矢量"></a>信息矩阵+信息矢量</h2><p>$p(x_a,x_b)$以信息矩阵+信息矢量的形式给出，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204311535.png#pic_center"></p><p>通过信息矢量与信息矩阵，可以计算出该分布的均值</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204324848.png#pic_center"></p><p>因此该分布的概率密度函数可写为（注意到信息矩阵与协方差矩阵为互逆关系）</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204348310.png#pic_center"></p><p>为了求出$p(x_a)$和$p(x_b∣x_a)$的表达式，需要再次用到舒尔补（Schur Complement），不过作用对象与之前不同，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204403932.png#pic_center"></p><p>将上式带入$p(x_a,x_b)$的密度函数中，并令$Ω_{aa}−Ω_{ab}Ω_{bb}^−1Ω_{ba}=Λ_{aa}$，可得</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204423266.png#pic_center"></p><ul><li><p>$p(x_a)$是一个均值为$μ_a$，协方差矩阵为$Λ_{aa}^{−1}$的高斯分布</p></li><li><p>$p(x_b∣x_a)$是一个均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，协方差矩阵为$Ω_{bb}^{−1}%$的高斯分布。</p></li></ul><p>$p(x_a)$的均值为$μ_a$，信息矩阵为$Λ_{aa}$，对应的信息矢量为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910302044559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>所以$p(x_a)$完全使用信息矩阵+信息矢量的形式可记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020452532.png#pic_center"></p><p>同理：</p><p>$p(x_b∣x_a)$均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，信息矩阵为$Ω_{bb}$的高斯分布，对应的信息矢量为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204543853.png#pic_center"><br>$p(x_b∣x_a)$完全使用信息矩阵+信息矢量的形式可以记为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204557435.png#pic_center"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。表格总结如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204611958.png#pic_center"></p><p>根据协方差矩阵与信息矩阵的互逆关系，从上表还可以得出如下一组关系</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204627632.png#pic_center"></p><h2 id="边缘化与条件化"><a href="#边缘化与条件化" class="headerlink" title="边缘化与条件化"></a>边缘化与条件化</h2><p>所谓边缘化，就是求某个联合概率分布的边缘分布。比如对于联合概率$p(x_a,x_b)$，对$x_b$进行边缘化，就是对$x_b$在整个空间中积分，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204650325.png#pic_center"></p><p>由贝叶斯公式可知</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204702487.png#pic_center"></p><p>伴随着边缘化，$p(x_b∣x_a)$就是$p(x_a,x_b)$对$x_a$的条件化。</p><p>在信息矩阵+信息矢量的表示方式下，边缘化和条件化与最小二乘法有密切关系。在许多基于最小二乘的优化问题中，常有如下形式的优化目标：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204718621.png#pic_center"></p><p>为了寻找上式的最小值，常使用迭代优化的方法，每一次迭代都会寻找一个增量Δx使目标函数减小。为了求增量，往往会将e(x)在当前<em>x</em>x处展开为一阶近似（这种处理方式即Gauss-Newton Method），即<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204730880.png"></p><p>则优化的目标变为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020474264.png#pic_center"></p><p>这是关于Δx的二次函数，对Δx求导，并令导数等于0，有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204755898.png#pic_center"></p><p>即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204808181.png#pic_center"></p><p>令$J(x)^TW^{−1}J(x)=Ω$，表示变量Δ<em>x</em>Δx的信息矩阵，令−$J(x)^TW^{−1}e(x)=ξ$，表示信息矢量，则有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204822240.png#pic_center"></p><p>以上就是非线性优化时，每次都要求解的线性方程。</p><p>在很多优化问题中，待优化的变量有明确意义，比如在SLAM或者SfM问题中，要优化的是所有相机的位姿<em>p</em>p以及地图中所有三维点的坐标<em>m</em>m，设Δ<em>x</em>Δx由这两个分量的增量构成，即</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204837435.png#pic_center"></p><p>同时设</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204848663.png#pic_center"></p><p>则有</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204900849.png"></p><p>为了简化以上方程的求解，往往使用高斯消元法，具体的，对以上方程等式两边左乘</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204917817.png"></p><p>可得</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204930919.png#pic_center"></p><p>于是原方程可以转换为两个独立方程</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204940320.png#pic_center"></p><p>可以发现，Δp的系数矩阵和等号右边的结果，与上文中高斯分布$p(x_a)$的信息矩阵和信息矢量有相同的形式。而Δm的系数矩阵和等号右边的结果，则与高斯分布$p(x_b∣x_a)$的信息矩阵和信息向量有相同形式</p><p>也就是说，这里的高斯消元法，等价于对变量Δx做了边缘化，先将Δm边缘化掉，单独求Δp，然后再在Δp已知的情况下求Δm。</p><p>参考：<a href="https://blog.csdn.net/AIchipmunk/article/details/86185248" target="_blank" rel="noopener">高斯分布与边缘化</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;多元高斯分布&quot;&gt;&lt;a href=&quot;#多元高斯分布&quot; class=&quot;headerlink&quot; title=&quot;多元高斯分布&quot;&gt;&lt;/a&gt;多元高斯分布&lt;/h1&gt;&lt;p&gt;高斯分布有两种表达方式：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;协方差矩阵+均值&lt;/li&gt;
&lt;li&gt;信息矩阵+信息矢量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;协方差矩阵+均值的方式比较常见，如下&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030152615298.png#pic_center&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030152644545.png#pic_center&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030152656564.png#pic_center&quot;&gt;&lt;/p&gt;&lt;p&gt;左边常数项记为$η$，$p(x)$可以记为：&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030200301827.png&quot;&gt;&lt;/p&gt;&lt;p&gt;其中对称正定矩阵$Σ$为随机变量x的协方差矩阵，μ为x的均值，简记为&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030200243950.png&quot;&gt;&lt;/p&gt;&lt;p&gt;信息矩阵+信息矢量的形式可以由上式推导而来&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030200156360.png&quot;&gt;&lt;/p&gt;&lt;p&gt;现在定义信息矩阵$Ω=Σ^{−1}$ ，信息矢量$ξ=Σ^{−1}μ=Ωμ$，则&lt;/p&gt;
    
    </summary>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/categories/VSLAM/"/>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/tags/VSLAM/"/>
    
  </entry>
  
  <entry>
    <title>舒尔补</title>
    <link href="https://xiao-hu.com.cn/2019/10/30/%E8%88%92%E5%B0%94%E8%A1%A5/"/>
    <id>https://xiao-hu.com.cn/2019/10/30/舒尔补/</id>
    <published>2019-10-30T12:10:35.000Z</published>
    <updated>2019-10-30T12:12:44.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>舒尔补定义<br>给定任意的矩阵块 M，如下所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030155959352.png"><ul><li>如果矩阵块 D 是可逆的，则$A − BD^{−1}C$称之为D关于M的舒尔补</li><li>如果矩阵块 A 是可逆的，则$D − CA^{−1}B$称之为A关于 M的舒尔补</li></ul></li></ul><p>将 M 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160209537.png"></p><p>其中：$∆A=D − CA^{−1}B$。联合起来，将 M 变形成对角形：</p><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160250360.png"></p><p>矩阵 M 的逆为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160322364.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;ul&gt;
&lt;li&gt;舒尔补定义&lt;br&gt;给定任意的矩阵块 M，如下所示:&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030155959352.png&quot;&gt;&lt;ul&gt;
&lt;li&gt;如果矩阵块 D 是可逆的，则$A − BD^{−1}C$称之为D关于M的舒尔补&lt;/li&gt;
&lt;li&gt;如果矩阵块 A 是可逆的，则$D − CA^{−1}B$称之为A关于 M的舒尔补&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将 M 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191030160209537.png&quot;&gt;&lt;/p&gt;&lt;p&gt;其中：$∆A=D − CA^{−1}B$。联合起来，将 M 变形成对角形：&lt;/p&gt;
    
    </summary>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/categories/VSLAM/"/>
    
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/tags/VSLAM/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono——后端优化</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/VINs-Mono%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/VINs-Mono——后端优化/</id>
    <published>2019-10-29T12:43:40.000Z</published>
    <updated>2019-10-30T12:32:45.638Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="状态向量"><a href="#状态向量" class="headerlink" title="状态向量"></a>状态向量</h1><p>VIO 紧耦合方案的主要思路就是通过将基于视觉构造的残差项和基于 IMU 构造的残差项放在一起构造成一个联合优化的问题，整个优化问题的最优解即可认为是比较准确的状态估计。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192151582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>为了限制优化变量的数目， VINS-Mono 采用了滑动窗口的形式， 滑动窗口中的全状态量包括滑动窗口内的n+1个关键帧时刻 IMU 坐标系的位置、姿态、姿态（旋转）、加速度计偏置、陀螺仪偏置， Camera 到 IMU 的外参， m +1个 3D 路标点的逆深度：</p><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192802133.png#pic_center"></p><p>优化过程中的误差状态量为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192821349.png#pic_center"></p><h1 id="代价函数（Minimize-residuals-from-all-sensors）"><a href="#代价函数（Minimize-residuals-from-all-sensors）" class="headerlink" title="代价函数（Minimize residuals from all sensors）"></a>代价函数（Minimize residuals from all sensors）</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192917433.png#pic_center"></p><p>其中$P^{b_{k}}_{b_{k+1}}$ 为 IMU 预积分噪声项的协方差矩阵， $P^{c_j}_l$ 为视觉观测噪声的协方差矩阵。<br>三个残差项即误差项分别为边缘化的先验信息、 IMU 测量残差、视觉的重投影残差。三种残差都是用马氏距离表示。<br>根据高斯牛顿法求优化过程中最为核心的增量方程，以 IMU 测量残差为例，先将$r_{b}(\hat z^{b_k}_{b_{k+1}},\chi )$进行一阶泰勒展开</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194020513.png#pic_center"></p><p>其中$H^{b_k}_{b_{k+1}}$是雅可比矩阵</p><p>等号右边关于$\delta x$的导数，并令其为 0，得到增量方程：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194351591.png#pic_center"></p><p>那么可以写出函数对应的增量方程：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195011958.png#pic_center"></p><p>增量方程可进一步简化为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195045773.png#pic_center"></p><p>其中$\wedge _p$，$\wedge _B$，$\wedge _C$为（近似的） Hessian 矩阵，上述方程称之为增量方程。</p><h1 id="IMU-测量约束"><a href="#IMU-测量约束" class="headerlink" title="IMU 测量约束"></a>IMU 测量约束</h1><h2 id="IMU-测量残差"><a href="#IMU-测量残差" class="headerlink" title="IMU 测量残差"></a>IMU 测量残差</h2><p>根据上面的 IMU 预积分，得到 IMU <strong>预积分残差（估计值 - 测量值）</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195522934.png#pic_center"></p><p>其中$[q]_{xyz}$表示提取四元数q的虚部，$[\hat \alpha^{b_k}_{b_{k+1}},\hat \beta ^{b_k}_{b_{k+1}},\hat \gamma ^{b_k}_{b_{k+1}}]^T$为关键帧$b_k$和关键帧$b_{k+1}$时间间隔内，仅仅使用含有噪声的加速度计和陀螺仪数据计算的预积分 IMU 测量项，$\delta \theta^{b_k}_{b_{k+1}}$是四元数误差的三维表示。</p><h2 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h2><p>对于两帧之间的 IMU 测量残差，待优化变量为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029200304722.png#pic_center"></p><h2 id="雅克比矩阵"><a href="#雅克比矩阵" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>高斯迭代优化过程中会用到 IMU 测量残差对状态量的雅克比矩阵，但此处我们是对误差状<br>态量求偏导</p><ul><li>对k时刻$[\delta p^w_{b_k},\delta \theta^w_{b_k}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201345442.png#pic_center"></p><ul><li>对k时刻$[\delta v^w_{b_k},\delta b_{a_k},\delta \theta b_{w_{k}}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201641707.png#pic_center"></p><ul><li>对k时刻$[\delta p^w_{b_{k+1}},\delta \theta^w_{b_{k+1}}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201652448.png#pic_center"></p><ul><li>对k时刻$[\delta v^w_{b_{k+1}},\delta b_{a_{k+1}},\delta \theta b_{w_{k+1}}]$求偏导数</li></ul><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201704647.png#pic_center"></p><p>上面公式在代码中对应： class IMUFactor : public ceres::SizedCostFunction<15, 9 7, 9,>对于 Evaluate 输入 double const <em>const </em>parameters, parameters[0], parameters[1], parameters[2],parameters[3]分别对应 4 个输入参数, 它们的长度依次是 7,9,7,9， 分别对应 4 个优化变量的参数块。<br>代码 IMUFactor::Evaluate()中 residual 还乘以一个信息矩阵 sqrt_info， 这是因为真正的优化项其实是 Mahalanobis 距离： $d=r^TP^{−1}r$，P 是协方差，又因为 Ceres 只接受最小二乘优化， 也就是$min(e^Te)$所以把𝑃−1做 LLT 分解， 即$LL^T=P^{-1}$, 则有：</15,></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202424429.png#pic_center"></p><p>令$r’=L^Tr$作为新的优化误差, 这样就能用 Ceres 求解了。 Mahalanobis 距离其实相当于一个残差加权, 协方差大的加权小, 协方差小的加权大, 着重优化那些比较确定的残差。若写成“sqrt_info.setIdentity()”相当于不加权</p><h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>IMU 协方差 P 为前面推导的 IMU 预积分中迭代出来的 IMU 增量误差的协方差。</p><h1 id="视觉测量残差"><a href="#视觉测量残差" class="headerlink" title="视觉测量残差"></a>视觉测量残差</h1><p>视觉测量残差即 特征点的重投影误差，视觉残差和雅克比矩阵计算的对应代码在ProjectionFactor::E<br>函数中。</p><h2 id="重投影误差（视觉测量残差）"><a href="#重投影误差（视觉测量残差）" class="headerlink" title="重投影误差（视觉测量残差）"></a>重投影误差（视觉测量残差）</h2><p>对于第 i 帧中的特征点, 它投影到第 j 帧相机坐标系下的值为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202633785.png#pic_center"></p><p>拆写成三维形式为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202722447.png"></p><p>其中：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202739798.png#pic_center"></p><p>为了后面方便求导Jacobian，对$P_{c_j}$拆解，定义如下变量</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202916771.png"></p><p>视觉测量残差为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203023784.png#pic_center"></p><h2 id="优化变量-1"><a href="#优化变量-1" class="headerlink" title="优化变量"></a>优化变量</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203801125.png#pic_center"></p><h2 id="雅克比矩阵-1"><a href="#雅克比矩阵-1" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>根据视觉残差公式，我们可以得到相对于各优化变量的 Jacobian</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203923600.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203934216.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203946932.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102920400339.png"></p><h2 id="协方差矩阵-1"><a href="#协方差矩阵-1" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>视觉约束的噪声协方差与标定相机内参时的重投影误差，也就是偏离几个像素有关， 代<br>码对应为 ProjectionTdFactor::sqrt_info， 这里取的 1.5 个像素，信息矩阵取根号后为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029204041242.png#pic_center"></p><h1 id="边缘化和FEJ"><a href="#边缘化和FEJ" class="headerlink" title="边缘化和FEJ"></a>边缘化和FEJ</h1><h2 id="Marginalization"><a href="#Marginalization" class="headerlink" title="Marginalization"></a>Marginalization</h2><p>然而，将 pose 移出 windows 时，有些约束会被丢弃掉，这样势必会导致求解的精度下降，而<br>且当 MAV 进行一些退化运动 (如: 匀速运动) 时，没有历史信息做约束的话是无法求解的。所以，<br>在移出位姿或特征的时候，需要将相关联的约束转变成一个约束项作为 prior 放到优化问题中，这<br>就是 marginalization 要做的事情。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029213408596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>边缘化的过程就是将滑窗内的某些较旧或者不满足要求的视觉帧剔除的过程，所以边缘化也被描述为将联合概率分布分解为边缘概率分布和条件概率分布的过程 (就是利用 shur 补减少优化参数的过程)。</p><p>直接进行边缘化而不加入先验条件的后果：</p><blockquote><ol><li>无故地移除这些 pose 和 feature 会丢弃帧间约束，会降低了优化器的精度，所以在移除 pose和 feature 的时候需要将相关联的约束转变为一个先验的约束条件作为 prior 放到优化问题中</li><li>在边缘化的过程中，不加先验的边缘化会导致系统尺度的缺失 (参考 [6])，尤其是系统在进行退化运动时 (如无人机的悬停和恒速运动)。一般来说 只有两个轴向的加速度不为 0 的时候，才能保证尺度可观，而退化运动对于无人机或者机器人来说是不可避免的。所以在系统处于退化运动的时候，要加入先验信息保证尺度的可观</li></ol></blockquote><p>VINS 根据次新帧是否为关键帧，分为两种边缘化策略：</p><blockquote><ol><li>当次新帧为关键帧时，我们将 marg 掉最老帧，及其看到的路标点和相关联的 IMU<br>数据，将其转化为先验信息加到整体的目标函数中；</li><li>当次新帧不是关键帧时，我们将直接扔掉次新帧及它的视觉观测边，而不对次新帧进行 marg， 因为我们认为当前帧和次新帧很相似，也就是说当前帧跟路标点之间的约束和次新帧与路标点的约束很接近，直接丢弃并不会造成整个约束关系丢失过多信息。 但是值得注意的是，我们要保留次新帧的 IMU 数据，从而保证 IMU 预积分的连贯性</li></ol></blockquote><p>VINS 中的先验残差项的构造可以分为以下几个步骤： </p><blockquote><ol><li>把上一次先验项中的残差项传递给当前先验项，并从中去除需要丢弃的状态量</li><li>添加与当前需要丢弃的状态量相关的约束项；</li><li>通过函数 MarginalizationInfo::preMarginalize()得到每个残差项(cost_function)对应<br>的参数块(parameter_blocks)，雅可比矩阵(jacobians)，残差值(residuals)；</li><li>通过函数 MarginalizationInfo::marginalize()将步骤 3 中得到的雅可比矩阵和残差值<br>进行组合，得到整个先验项的参数块，雅可比矩阵和残差值</li></ol></blockquote><p>通过以上四步先验项就算构造完成了，在对滑动窗口内的状态量进行优化时，把它与IMU 残差项和视觉残差项放在一起优化，从而得到不丢失历史信息的最新状态估计的结果。</p><h2 id="边缘化和舒尔补"><a href="#边缘化和舒尔补" class="headerlink" title="边缘化和舒尔补"></a>边缘化和舒尔补</h2><p>根据前面讨论的基于高斯牛顿的非线性优化理论可知， 𝐻𝛿𝑥 = 𝑏可写成如下形式：</p><p><img alt="1572437838552" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437838552.png"></p><p>INS 中则真正需要边缘化掉滑动窗口中的最老帧或者次新帧，目的是希望不再计算这一帧的位姿或者与其相关的路标点，但是希望保留该帧对窗口内其他帧的约束关系。</p><p>上式中的$x_a$是我们要 marg 的变量，比如一个相机的 pose，因此我们更关心如何只去求解我们希望保留的变量$x_b$，而不再求解$x_a$，但是我们也希望直接将$x_a$和与其相关的路标点直接删除，因为这样会减少约束，丢失信息。因此，采用如下 Schur 进行消元：</p><p><img alt="1572437967596" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437967596.png"></p><p>其中，$ Λ^𝑇_𝑏Λ^{-1}_𝑎Λ_𝑏$就称为Λ𝑎在Λ𝑏中的 Schur 项，那么有了上面式子，我们就可以直接计算$𝛿x_b$了：</p><p><img alt="1572438049891" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438049891.png"></p><p>上面的公式即为要保留变量𝑥𝑏的先验信息。</p><h2 id="滑动窗口中的-FEJ-算法"><a href="#滑动窗口中的-FEJ-算法" class="headerlink" title="滑动窗口中的 FEJ 算法"></a>滑动窗口中的 FEJ 算法</h2><p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</p><p>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量</p><p>滑动窗口算法大致流程</p><ol><li>增加新的变量进入最小二乘系统优化</li><li>如果变量数目达到了一定的维度，则移除老的变量。</li><li>SLAM 系统 不断循环前面两步</li></ol><p>利用边际概率移除老的变量</p><p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量。</p><p><strong>example：</strong></p><p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量</p><p><img alt="1572438273296" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438273296.png"></p><p>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</p><p><img alt="1572438402148" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438402148.png"></p><p><img alt="1572438422145" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438422145.png"></p><p>marg 前，变量 $x_m$ 以及对应测量$S_m$ 构建的最小二乘信息矩阵为：</p><p><img alt="1572438479585" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438479585.png"></p><p>marg 后，变量$x_m$的测量信息传递给了变量 $x_r$:</p><p><img alt="1572438555840" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438555840.png"></p><p>下标 p 表示 prior. 即这些信息将构建一个关于$x_r$ 的先验信息。</p><p><img alt="1572438612496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438612496.png"></p><p><strong>新测量信息和旧测量信息构建新的系统</strong></p><p><img alt="1572438683496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438683496.png"></p><p><img alt="1572438702531" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438702531.png"></p><p><img alt="1572438724298" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438724298.png"></p><p><img alt="1572438749984" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438749984.png"></p><p>参考：<br><a href="https://blog.csdn.net/weixin_44580210/article/details/95748091" target="_blank" rel="noopener">VINS-Mono关键知识点总结——边缘化marginalization理论和代码详解</a><br><a href="https://blog.csdn.net/weixin_44580210/article/details/93377806" target="_blank" rel="noopener">VINS-Mono关键知识点总结——预积分和后端优化IMU部分</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;状态向量&quot;&gt;&lt;a href=&quot;#状态向量&quot; class=&quot;headerlink&quot; title=&quot;状态向量&quot;&gt;&lt;/a&gt;状态向量&lt;/h1&gt;&lt;p&gt;VIO 紧耦合方案的主要思路就是通过将基于视觉构造的残差项和基于 IMU 构造的残差项放在一起构造成一个联合优化的问题，整个优化问题的最优解即可认为是比较准确的状态估计。&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191029192151582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center&quot;&gt;&lt;br&gt;为了限制优化变量的数目， VINS-Mono 采用了滑动窗口的形式， 滑动窗口中的全状态量包括滑动窗口内的n+1个关键帧时刻 IMU 坐标系的位置、姿态、姿态（旋转）、加速度计偏置、陀螺仪偏置， Camera 到 IMU 的外参， m +1个 3D 路标点的逆深度：&lt;/p&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono——初始化</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/VINS-Mono%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/VINS-Mono——初始化/</id>
    <published>2019-10-29T09:31:40.000Z</published>
    <updated>2019-10-30T03:37:18.732Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="估计器初始化"><a href="#估计器初始化" class="headerlink" title="估计器初始化"></a>估计器初始化</h1><ul><li>初始化的原因是单目惯性紧耦合系统是一个非线性程度很高的系统，首先单目是无法获得空间中的绝对尺度，而IMU又必然存在偏置，在后面进行求解的时候还需要用到重力加速度（包括大小和方向），对于速度比较敏感的条件下，比如说无人机，又要精确的速度信息，因此，如何有效的在紧耦合系统处理之前计算出这些量，对整个紧耦合系统的鲁棒性有着重大的意义</li><li>初始化要做的事其实说起来很简单，就是计算出绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li><li>VINS-Mono 的初始化采用松组合（loosely coupled）的方式获取初始值。 首先用 SFM求解滑动窗口内所有帧的位姿（以第一帧作为参考坐标系）和所有路标点的 3D 位置。然后将 SFM 的结果与 IMU 预积分的值进行对齐，实现对陀螺仪偏置的校正，再求解每一帧对应的速度，求解重力向量方向，恢复单目相机的尺度因子。</li><li>需要注意的是，在初始化过程中，并没有对加速度计的偏置进行校正，这是因为重力是初始化过程中待求的量，而加速度计偏置与重力耦合，而且系统的加速度相对于重力加速度很小，所以加速度计偏置在初始化过程中很难观测，因此初始化过程中不考虑加速度计偏置的校正。</li></ul><a id="more"></a><h2 id="滑动窗口-Sliding-Window-纯视觉SfM"><a href="#滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="滑动窗口(Sliding Window)纯视觉SfM"></a>滑动窗口(Sliding Window)纯视觉SfM</h2><p>首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，使用五点法恢复这两个帧之间的相对旋转和尺度平移。否则，将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c_0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}_{c_k}，q^{c0}_{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。</p><p>纯视觉初始化时，我们采用第一帧 c0 作为基准坐标系，若要转化为从 body 坐标系到 c0坐标系，可以进行如下变换，其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"></p><p>上式推导如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185549508.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185607797.png#pic_center"></p><h2 id="B-视觉惯性校准（Visual-Inertial-Alignment"><a href="#B-视觉惯性校准（Visual-Inertial-Alignment" class="headerlink" title="B. 视觉惯性校准（Visual-Inertial Alignment)"></a>B. 视觉惯性校准（Visual-Inertial Alignment)</h2><h3 id="陀螺仪偏置标定"><a href="#陀螺仪偏置标定" class="headerlink" title="陀螺仪偏置标定"></a>陀螺仪偏置标定</h3><p>这 一 部 分 的 内 容 对 应 于 VINS-Mono 代 码 initial_aligment.cpp 中 的<br>solveGyroscopeBias()函数。<br>考虑滑动窗口中连续两帧$b_k$和$b_{k+1}$，我们从视觉sfM中得到旋转$q^{c0}_{b_k}$和$q^{c0}_{b_{k+1}}$，从IMU预积分得到的相对约束$γ^{b_k}_{b_{k+1}}$。<br>陀螺仪的误差有两部分测量噪声和陀螺仪偏置，噪声暂时可以忽略（毕竟太小），而视觉的误差就只有观测噪声（也可以忽略不管），因此两者差值的绝对值就是陀螺仪偏置，将整个滑动窗口的所有的旋转做差构成了一个最小化误差模型：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"></p><p>其中B代表窗口的所有帧。<br>$q^{c0}_{b_k}$$q^{c0}_{b_{k+1}}$：相机从$b_k$到$b_{k+1}$下的相对旋转<br>$γ^{b_k}_{b_{k+1}}$：陀螺仪从$b_{k+1}$到$b_k$下的相对旋转<br>第二个式子给出了$γ^{b_k}_{b_{k+1}}$对陀螺仪偏置的一阶近似。</p><p>因为四元数最小值为单位四元数 [1; 0v]T，所以</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171134242.png#pic_center"></p><p>只考虑虚部，则有：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171213618.png#pic_center"></p><p>然后取最小二乘，当然也可以使用SVD分解等方法求解，得到了陀螺仪偏置$b_w$的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}_{b_{k+1}}、\hat β^{b_k}_{b_{k+1}}、\hat γ^{b_k}_{b_{k+1}}$ 。</p><h3 id="速度、重力向量和尺度初始化："><a href="#速度、重力向量和尺度初始化：" class="headerlink" title="速度、重力向量和尺度初始化："></a>速度、重力向量和尺度初始化：</h3><p>这一部分的内容对应于 VINS-Mono 代码 initial_aligment.cpp 中的 LinearAlignment()<br>函数<br>在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"></p><p>其中，$v^{b_k}_{b_k}$是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。<br>在$c_0$坐标系的预积分：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180200742.png#pic_center"></p><p>$p^{c_0}_{b_{k+1}}$和$p^{c_0}_{b_{k}}$可由视觉 SFM 获得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180301129.png#pic_center"></p><p>将此式带入上式得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180458901.png#pic_center"></p><p>将等式中速度都转换到$c_0$ 坐标系下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181635823.png#pic_center"></p><p>将上式转换成$Hx=b$ 的形式，这样便于利用 cholesky 进行求解，由$s\bar p^{c_0}_{b_k}=p^{c_0}_{c_k}-R^{c_0}_{c_k}p_c^b$，带入上式得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181106531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>联力等式：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181609102.png#pic_center"></p><p>即： $H^{6×10}X_I^{\ 10×1} = b^{6×1}$<br>H矩阵一定是一个正定对称矩阵，以采用快速的 Cholosky 分解下面方程求解$X_I$：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028182207166.png#pic_center"></p><p>可以得到滑动窗口中所有关键帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及单目尺度因子 s 。</p><h3 id="修正重力矢量"><a href="#修正重力矢量" class="headerlink" title="修正重力矢量"></a>修正重力矢量</h3><p>这里计算的重力吸收了重力加速度计的偏置，虽然不需要计算重力加速度计的偏置，但重力还是需要优化的，说到优化重力加速度，肯定包含两个量，大小和方向，也就是三个维度，但是一般来说大小是确定已知的（这里设为9.8），因此其实我们要做的就是优化方向，是一个两维的向量，下图是优化重力的方法以及b1,b2单位向量的方向确定模型。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>将重力向量重新参数化：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183144674.png#pic_center"></p><p>其中g是已知的重力大小，$\bar {\hat g}$是表示重力方向的单位向量，b1、 b2为重力向量正切空间的一对<br>正交基 ，如图所示，w1和w2分别是在b1和b2上的对应位移。<br>将上式代入前面式子中，重新整理可得：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183424735.png#pic_center"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183439415.png"></p><p>这样，可以用 Cholosky 分解下面方程求解$X_I$：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183526590.png#pic_center"></p><p>完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p><h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028160032562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>直接从estimator.cpp中的 if (solver_flag == INITIAL) 开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (solver_flag == INITIAL) &#123;</span><br><span class="line">    <span class="comment">// 滑窗中的Keyframe达到指定大小的时候，才开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (frame_count == WINDOW_SIZE) &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_EXTRINSIC != <span class="number">2</span> &amp;&amp; (header.stamp.toSec() - initial_timestamp) &gt; <span class="number">0.1</span>) &#123;</span><br><span class="line">            result = initialStructure(); <span class="comment">//! 初始化</span></span><br><span class="line">            initial_timestamp = header.stamp.toSec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            solver_flag = NON_LINEAR;</span><br><span class="line">            solveOdometry();</span><br><span class="line">            slideWindow();</span><br><span class="line">            f_manager.removeFailures();</span><br><span class="line">            ROS_INFO(<span class="string">"Initialization finish!"</span>);</span><br><span class="line">            last_R = Rs[WINDOW_SIZE];</span><br><span class="line">            last_P = Ps[WINDOW_SIZE];</span><br><span class="line">            last_R0 = Rs[<span class="number">0</span>];</span><br><span class="line">            last_P0 = Ps[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            slideWindow();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        frame_count++;</span><br></pre></td></tr></table></figure><h3 id="initialStructure-视觉惯性联合初始化"><a href="#initialStructure-视觉惯性联合初始化" class="headerlink" title="initialStructure() 视觉惯性联合初始化"></a>initialStructure() 视觉惯性联合初始化</h3><ul><li>1.通过计算线加速度的标准差，检测IMU的可观性，以进行初始化<br>注意这里并没有算上all_image_frame的第一帧，所以求均值和标准差的时候要减一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 通过计算预积分加速度的标准差，检测IMU的可观性</span></span><br><span class="line"><span class="comment">//check imu observibility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算均值</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it;</span><br><span class="line">    Vector3d sum_g;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        sum_g += tmp_g;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector3d aver_g = sum_g * <span class="number">1.0</span> / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方差</span></span><br><span class="line">    <span class="keyword">double</span> var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        var += (tmp_g - aver_g).transpose() * (tmp_g - aver_g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算标准差</span></span><br><span class="line">    var = <span class="built_in">sqrt</span>(var / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//ROS_WARN("IMU variation %f!", var);</span></span><br><span class="line">    <span class="keyword">if</span>(var &lt; <span class="number">0.25</span>) <span class="comment">//! 以标准差判断可观性</span></span><br><span class="line">    &#123;</span><br><span class="line">        ROS_INFO(<span class="string">"IMU excitation not enouth!"</span>);</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.将f_manager中的所有feature保存到vector<sfmfeature> sfm_f中，SFMFeature数组中包含了特征点状态（是否被三角化），id，2d点，3d坐标以及深度，将特征管理器中的特征信息保存到SFMFeature对象sfm_f中sfm_f.push_back(tmp_feature)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SFMFeature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> state;<span class="comment">//状态（是否被三角化）</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,Vector2d&gt;&gt; observation;<span class="comment">//所有观测到该特征点的图像帧ID和图像坐标</span></span><br><span class="line">    <span class="keyword">double</span> position[<span class="number">3</span>];<span class="comment">//3d坐标</span></span><br><span class="line">    <span class="keyword">double</span> depth;<span class="comment">//深度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历滑窗内所有的Features，以vector&lt;SFMFeature&gt;形式保存滑窗内所有特征点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;SFMFeature&gt; sfm_f;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> imu_j = it_per_id.start_frame - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    SFMFeature tmp_feature;</span><br><span class="line">    tmp_feature.state = <span class="literal">false</span>;</span><br><span class="line">    tmp_feature.id = it_per_id.feature_id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_frame : it_per_id.feature_per_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        imu_j++;</span><br><span class="line">        Vector3d pts_j = it_per_frame.point;</span><br><span class="line">        tmp_feature.observation.push_back(make_pair(imu_j, Eigen::Vector2d&#123;pts_j.x(), pts_j.y()&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sfm_f.push_back(tmp_feature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sfmfeature></li><li>3.relativePose()恢复出R、t</li></ul><blockquote><p> 1.先通过 FeatureManager::getCorresponding()获取滑动窗口中第i帧和最后一帧的特征匹配corres<br> 2.如果第i帧和最后一帧的特征匹配数corres大于20，且所有匹配的特征点的平均视差大于一定阈值，通过solveRelativeRT（定义在solv_5pts.cpp类中）用五点法求本质矩阵cv::findFundamentalMat 计算出当前帧到参考帧的 T</p><p> 值得注意：relativePose得到的位姿是第l帧的，第l帧的筛选是从第一帧开始到滑动窗口所有帧中一开始满足平均视差足够大的帧，这里的第l帧会作为参考帧到下面的全局SFM使用。这样得到图像的特征点2d坐标的提取，相机第l帧和最后一帧之间的旋转和平移</p></blockquote>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!relativePose(relative_R, relative_T, l))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"Not enough features or parallax; Move device around"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>bool relativePose(relative_R, relative_T, l)</strong><br>   该函数判断每帧到窗口最后一帧对应特征点的平均视差大于30，且内点数目大于12则可进行初始化，同时返回当前帧到第l帧的坐标系变换R和T<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::relativePose(Matrix3d &amp;relative_R, Vector3d &amp;relative_T, <span class="keyword">int</span> &amp;l) &#123;</span><br><span class="line">    <span class="comment">// find previous frame which contians enough correspondance and parallex with newest frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在滑窗内寻找与最新的关键帧共视点超过20(像素点)的关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WINDOW_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">        <span class="comment">//获取第i帧和最后一帧的特征匹配corres</span></span><br><span class="line">        corres = f_manager.getCorresponding(i, WINDOW_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共视的Features应该大于20</span></span><br><span class="line">        <span class="keyword">if</span> (corres.size() &gt; <span class="number">20</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取匹配的特征点在图像上的视差和(归一化平面上)</span></span><br><span class="line">            <span class="keyword">double</span> sum_parallax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(corres.size()); j++) &#123;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_0</span><span class="params">(corres[j].first(<span class="number">0</span>), corres[j].first(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_1</span><span class="params">(corres[j].second(<span class="number">0</span>), corres[j].second(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="keyword">double</span> parallax = (pts_0 - pts_1).norm();</span><br><span class="line">                sum_parallax = sum_parallax + parallax;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取所有匹配的特征点的平均视差</span></span><br><span class="line">            <span class="keyword">double</span> average_parallax = <span class="number">1.0</span> * sum_parallax / <span class="keyword">int</span>(corres.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视差大于一定阈值，并且能够有效地求解出变换矩阵</span></span><br><span class="line">            <span class="keyword">if</span> (average_parallax * <span class="number">460</span> &gt; <span class="number">30</span> &amp;&amp; m_estimator.solveRelativeRT(corres, relative_R, relative_T)) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">                ROS_DEBUG(<span class="string">"average_parallax %f choose l %d and newest frame to triangulate the whole structure"</span>,</span><br><span class="line">                          average_parallax * <span class="number">460</span>, l);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>FeatureManager::getCorresponding()</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; FeatureManager::getCorresponding(<span class="keyword">int</span> frame_count_l, <span class="keyword">int</span> frame_count_r) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : feature) &#123;</span><br><span class="line">        <span class="comment">// 保证两帧的id大于当前特征点的起始id小于当前特征点的终止id</span></span><br><span class="line">        <span class="keyword">if</span> (it.start_frame &lt;= frame_count_l &amp;&amp; it.endFrame() &gt;= frame_count_r) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx_l = frame_count_l - it.start_frame;</span><br><span class="line">            <span class="keyword">int</span> idx_r = frame_count_r - it.start_frame;</span><br><span class="line"></span><br><span class="line">            Vector3d a = it.feature_per_frame[idx_l].point;</span><br><span class="line">            Vector3d b = it.feature_per_frame[idx_r].point;</span><br><span class="line"></span><br><span class="line">            corres.push_back(make_pair(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> corres;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>solveRelativeRT()</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MotionEstimator::solveRelativeRT(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; &amp;corres, Matrix3d &amp;Rotation, Vector3d &amp;Translation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (corres.size() &gt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! Step1：提取匹配完的Features</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; ll, rr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(corres.size()); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll.push_back(cv::Point2f(corres[i].first(<span class="number">0</span>), corres[i].first(<span class="number">1</span>)));</span><br><span class="line">            rr.push_back(cv::Point2f(corres[i].second(<span class="number">0</span>), corres[i].second(<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::Mat mask;</span><br><span class="line">        <span class="comment">//! Step2：利用Ransac算法计算本质矩阵，内外点的阈值距离设定为0.3 / 460</span></span><br><span class="line">        cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, <span class="number">0.3</span> / <span class="number">460</span>, <span class="number">0.99</span>, mask);</span><br><span class="line"></span><br><span class="line">        cv::Mat cameraMatrix = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step3：计算变换矩阵并得到内点个数</span></span><br><span class="line">        cv::Mat rot, trans;</span><br><span class="line">        <span class="keyword">int</span> inlier_cnt = cv::recoverPose(E, ll, rr, cameraMatrix, rot, trans, mask);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "inlier_cnt " &lt;&lt; inlier_cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 得到变换矩阵 ll ==&gt; rr</span></span><br><span class="line">        Eigen::Matrix3d R;</span><br><span class="line">        Eigen::Vector3d T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            T(i) = trans.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                R(i, j) = rot.at&lt;<span class="keyword">double</span>&gt;(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step4：得到旋转矩阵和平移量 rr ==&gt; ll</span></span><br><span class="line">        Rotation    =  R.transpose();</span><br><span class="line">        Translation = -R.transpose() * T;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 判断求取的内点个数是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(inlier_cnt &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>4.对窗口中每个图像帧求解sfm问题，调用sfm.construct(frame_count + 1, Q, T,l,relative_R, relative_T,sfm_f, sfm_tracked_points)估计slidingwindow中所有图像帧相对于参考帧（这里以第l帧作为参考帧）的旋转四元数Q、平移向量T和特征点坐标sfm_tracked_points。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三角化恢复滑窗内的Features</span></span><br><span class="line">GlobalSFM sfm;</span><br><span class="line">Quaterniond Q[frame_count + <span class="number">1</span>];</span><br><span class="line">Vector3d    T[frame_count + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; sfm_tracked_points;</span><br><span class="line"><span class="keyword">if</span>(!sfm.construct(frame_count + <span class="number">1</span>, Q, T, l, relative_R, relative_T, sfm_f, sfm_tracked_points))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"global SFM failed!"</span>);</span><br><span class="line">    marginalization_flag = MARGIN_OLD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool GlobalSFM::construct()</strong><br>函数位于inital_sfm.cpp文件中<br>纯视觉sfm，求解窗口中所有图像帧的位姿QT（相对于第l帧）和特征点坐标sfm_tracked_points<br>frame_num=frame_count + 1=11，frame_num-1表示当前帧</p><blockquote><p>1.把第l帧看作参考坐标系，根据当前帧到第l帧的relative_R，relative_T，得到当前帧在参考坐标系下的位姿，之后的pose[i]表示第l帧到第i帧的变换矩阵[R|T]<br>2.三角化第l帧（参考帧）与第frame_num-1帧（当前帧）的路标点<br>3.pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中，并与当前帧进行三角化<br>4.对第l帧与从第l+1到frame_num-2的每一帧再进行三角化<br>5.PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化<br>6.三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标<br>7.使用cares进行全局BA优化<br>8.得到的是第l帧坐标系到各帧的变换矩阵，将其转变为每一帧在第l帧坐标系上的位姿<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GlobalSFM::construct(<span class="keyword">int</span> frame_num, Quaterniond* q, Vector3d* T, <span class="keyword">int</span> l,</span><br><span class="line">  <span class="keyword">const</span> Matrix3d relative_R, <span class="keyword">const</span> Vector3d relative_T,</span><br><span class="line">  <span class="built_in">vector</span>&lt;SFMFeature&gt; &amp;sfm_f, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; &amp;sfm_tracked_points)</span><br><span class="line">&#123;</span><br><span class="line">feature_num = sfm_f.size();</span><br><span class="line"><span class="comment">//cout &lt;&lt; "set 0 and " &lt;&lt; l &lt;&lt; " as known " &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// have relative_r relative_t</span></span><br><span class="line"><span class="comment">// intial two view</span></span><br><span class="line">q[l].w() = <span class="number">1</span>;</span><br><span class="line">q[l].x() = <span class="number">0</span>;</span><br><span class="line">q[l].y() = <span class="number">0</span>;</span><br><span class="line">q[l].z() = <span class="number">0</span>;</span><br><span class="line">T[l].setZero();</span><br><span class="line">q[frame_num - <span class="number">1</span>] = q[l] * Quaterniond(relative_R);</span><br><span class="line">T[frame_num - <span class="number">1</span>] = relative_T;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "init q_l " &lt;&lt; q[l].w() &lt;&lt; " " &lt;&lt; q[l].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "init t_l " &lt;&lt; T[l].transpose() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//rotate to cam frame</span></span><br><span class="line">Matrix3d c_Rotation[frame_num];</span><br><span class="line">Vector3d c_Translation[frame_num];</span><br><span class="line">Quaterniond c_Quat[frame_num];</span><br><span class="line"><span class="keyword">double</span> c_rotation[frame_num][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">double</span> c_translation[frame_num][<span class="number">3</span>];</span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">4</span>&gt; Pose[frame_num];</span><br><span class="line"></span><br><span class="line">c_Quat[l] = q[l].inverse();</span><br><span class="line">c_Rotation[l] = c_Quat[l].toRotationMatrix();</span><br><span class="line">c_Translation[l] = <span class="number">-1</span> * (c_Rotation[l] * T[l]);</span><br><span class="line">Pose[l].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[l];</span><br><span class="line">Pose[l].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[l];</span><br><span class="line"></span><br><span class="line">c_Quat[frame_num - <span class="number">1</span>] = q[frame_num - <span class="number">1</span>].inverse();</span><br><span class="line">c_Rotation[frame_num - <span class="number">1</span>] = c_Quat[frame_num - <span class="number">1</span>].toRotationMatrix();</span><br><span class="line">c_Translation[frame_num - <span class="number">1</span>] = <span class="number">-1</span> * (c_Rotation[frame_num - <span class="number">1</span>] * T[frame_num - <span class="number">1</span>]);</span><br><span class="line">Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[frame_num - <span class="number">1</span>];</span><br><span class="line">Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[frame_num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1: trangulate between l ----- frame_num - 1</span></span><br><span class="line"><span class="comment">//2: solve pnp l + 1; trangulate l + 1 ------- frame_num - 1; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; frame_num - <span class="number">1</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// solve pnp</span></span><br><span class="line"><span class="comment">//pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; l)</span><br><span class="line">&#123;</span><br><span class="line">Matrix3d R_initial = c_Rotation[i - <span class="number">1</span>];</span><br><span class="line">Vector3d P_initial = c_Translation[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">c_Rotation[i] = R_initial;</span><br><span class="line">c_Translation[i] = P_initial;</span><br><span class="line">c_Quat[i] = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// triangulate point based on the solve pnp result</span></span><br><span class="line">triangulateTwoFrames(i, Pose[i], frame_num - <span class="number">1</span>, Pose[frame_num - <span class="number">1</span>], sfm_f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3: triangulate l-----l+1 l+2 ... frame_num -2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; frame_num - <span class="number">1</span>; i++)</span><br><span class="line">triangulateTwoFrames(l, Pose[l], i, Pose[i], sfm_f);</span><br><span class="line"><span class="comment">//4: solve pnp l-1; triangulate l-1 ----- l</span></span><br><span class="line"><span class="comment">//             l-2              l-2 ----- l</span></span><br><span class="line"><span class="comment">//PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//solve pnp</span></span><br><span class="line">Matrix3d R_initial = c_Rotation[i + <span class="number">1</span>];</span><br><span class="line">Vector3d P_initial = c_Translation[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">c_Rotation[i] = R_initial;</span><br><span class="line">c_Translation[i] = P_initial;</span><br><span class="line">c_Quat[i] = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line"><span class="comment">//triangulate</span></span><br><span class="line">triangulateTwoFrames(i, Pose[i], l, Pose[l], sfm_f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5: triangulate all other points</span></span><br><span class="line"><span class="comment">//三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; feature_num; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sfm_f[j].state == <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)sfm_f[j].observation.size() &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">Vector2d point0, point1;</span><br><span class="line"><span class="keyword">int</span> frame_0 = sfm_f[j].observation[<span class="number">0</span>].first;</span><br><span class="line">point0 = sfm_f[j].observation[<span class="number">0</span>].second;</span><br><span class="line"><span class="keyword">int</span> frame_1 = sfm_f[j].observation.back().first;</span><br><span class="line">point1 = sfm_f[j].observation.back().second;</span><br><span class="line">Vector3d point_3d;</span><br><span class="line">triangulatePoint(Pose[frame_0], Pose[frame_1], point0, point1, point_3d);</span><br><span class="line">sfm_f[j].state = <span class="literal">true</span>;</span><br><span class="line">sfm_f[j].position[<span class="number">0</span>] = point_3d(<span class="number">0</span>);</span><br><span class="line">sfm_f[j].position[<span class="number">1</span>] = point_3d(<span class="number">1</span>);</span><br><span class="line">sfm_f[j].position[<span class="number">2</span>] = point_3d(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; "trangulated : " &lt;&lt; frame_0 &lt;&lt; " " &lt;&lt; frame_1 &lt;&lt; "  3d point : "  &lt;&lt; j &lt;&lt; "  " &lt;&lt; point_3d.transpose() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">q[i] = c_Rotation[i].transpose(); </span></span><br><span class="line"><span class="comment">cout &lt;&lt; "solvePnP  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">Vector3d t_tmp;</span></span><br><span class="line"><span class="comment">t_tmp = -1 * (q[i] * c_Translation[i]);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "solvePnP  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; t_tmp.x() &lt;&lt;"  "&lt;&lt; t_tmp.y() &lt;&lt;"  "&lt;&lt; t_tmp.z() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//full BA</span></span><br><span class="line"><span class="comment">//使用cares进行全局BA优化</span></span><br><span class="line">ceres::Problem problem;</span><br><span class="line">ceres::LocalParameterization* local_parameterization = <span class="keyword">new</span> ceres::QuaternionParameterization();</span><br><span class="line"><span class="comment">//cout &lt;&lt; " begin full BA " &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//double array for ceres</span></span><br><span class="line">c_translation[i][<span class="number">0</span>] = c_Translation[i].x();</span><br><span class="line">c_translation[i][<span class="number">1</span>] = c_Translation[i].y();</span><br><span class="line">c_translation[i][<span class="number">2</span>] = c_Translation[i].z();</span><br><span class="line">c_rotation[i][<span class="number">0</span>] = c_Quat[i].w();</span><br><span class="line">c_rotation[i][<span class="number">1</span>] = c_Quat[i].x();</span><br><span class="line">c_rotation[i][<span class="number">2</span>] = c_Quat[i].y();</span><br><span class="line">c_rotation[i][<span class="number">3</span>] = c_Quat[i].z();</span><br><span class="line">problem.AddParameterBlock(c_rotation[i], <span class="number">4</span>, local_parameterization);</span><br><span class="line">problem.AddParameterBlock(c_translation[i], <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (i == l)</span><br><span class="line">&#123;</span><br><span class="line">problem.SetParameterBlockConstant(c_rotation[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == l || i == frame_num - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">problem.SetParameterBlockConstant(c_translation[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; feature_num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sfm_f[i].state != <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(sfm_f[i].observation.size()); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = sfm_f[i].observation[j].first;</span><br><span class="line">ceres::CostFunction* cost_function = ReprojectionError3D::Create(</span><br><span class="line">sfm_f[i].observation[j].second.x(),</span><br><span class="line">sfm_f[i].observation[j].second.y());</span><br><span class="line"></span><br><span class="line">    problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, c_rotation[l], c_translation[l], </span><br><span class="line">    sfm_f[i].position); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ceres::Solver::Options options;</span><br><span class="line">options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line"><span class="comment">//options.minimizer_progress_to_stdout = true;</span></span><br><span class="line">options.max_solver_time_in_seconds = <span class="number">0.2</span>;</span><br><span class="line">ceres::Solver::Summary summary;</span><br><span class="line">ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; summary.BriefReport() &lt;&lt; "\n";</span></span><br><span class="line"><span class="keyword">if</span> (summary.termination_type == ceres::CONVERGENCE || summary.final_cost &lt; <span class="number">5e-03</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "vision only BA converge" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "vision only BA not converge " &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">q[i].w() = c_rotation[i][<span class="number">0</span>]; </span><br><span class="line">q[i].x() = c_rotation[i][<span class="number">1</span>]; </span><br><span class="line">q[i].y() = c_rotation[i][<span class="number">2</span>]; </span><br><span class="line">q[i].z() = c_rotation[i][<span class="number">3</span>]; </span><br><span class="line">q[i] = q[i].inverse();</span><br><span class="line"><span class="comment">//cout &lt;&lt; "final  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第l帧坐标系到各帧的变换矩阵，应将其转变为每一帧在第l帧坐标系上的位姿</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">T[i] = <span class="number">-1</span> * (q[i] * Vector3d(c_translation[i][<span class="number">0</span>], c_translation[i][<span class="number">1</span>], c_translation[i][<span class="number">2</span>]));</span><br><span class="line"><span class="comment">//cout &lt;&lt; "final  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; T[i](0) &lt;&lt;"  "&lt;&lt; T[i](1) &lt;&lt;"  "&lt;&lt; T[i](2) &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)sfm_f.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sfm_f[i].state)</span><br><span class="line">sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[<span class="number">0</span>], sfm_f[i].position[<span class="number">1</span>], sfm_f[i].position[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>对于所有的图像帧，包括不在滑动窗口中的，提供初始的RT估计，然后solvePnP进行优化</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// solve pnp for all frame</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt;::iterator it;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it = all_image_frame.begin( );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; frame_it != all_image_frame.end( ); frame_it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// provide initial guess</span></span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) == Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        frame_it-&gt;second.is_key_frame = <span class="literal">true</span>;</span><br><span class="line">        frame_it-&gt;second.R = Q[i].toRotationMatrix() * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">        frame_it-&gt;second.T = T[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) &gt; Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将滑窗内第i帧的变换矩阵当做初始值</span></span><br><span class="line">    Matrix3d R_inital = (Q[i].inverse()).toRotationMatrix();</span><br><span class="line">    Vector3d P_inital = - R_inital * T[i];</span><br><span class="line">    cv::Mat rvec, t, tmp_r;</span><br><span class="line">    cv::eigen2cv(R_inital, tmp_r);</span><br><span class="line">    cv::Rodrigues(tmp_r, rvec);</span><br><span class="line">    cv::eigen2cv(P_inital, t);</span><br><span class="line"></span><br><span class="line">    frame_it-&gt;second.is_key_frame = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point3f&gt; pts_3_vector;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point2f&gt; pts_2_vector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;id_pts : frame_it-&gt;second.points)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> feature_id = id_pts.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i_p : id_pts.second)</span><br><span class="line">        &#123;</span><br><span class="line">            it = sfm_tracked_points.find(feature_id);</span><br><span class="line">            <span class="keyword">if</span>(it != sfm_tracked_points.end())</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3d world_pts = it-&gt;second;</span><br><span class="line">                cv::<span class="function">Point3f <span class="title">pts_3</span><span class="params">(world_pts(<span class="number">0</span>), world_pts(<span class="number">1</span>), world_pts(<span class="number">2</span>))</span></span>;</span><br><span class="line">                pts_3_vector.push_back(pts_3);</span><br><span class="line"></span><br><span class="line">                Vector2d img_pts = i_p.second.head&lt;<span class="number">2</span>&gt;();</span><br><span class="line">                cv::<span class="function">Point2f <span class="title">pts_2</span><span class="params">(img_pts(<span class="number">0</span>), img_pts(<span class="number">1</span>))</span></span>;</span><br><span class="line">                pts_2_vector.push_back(pts_2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pts_3_vector.size() &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pts_3_vector size "</span> &lt;&lt; pts_3_vector.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ROS_DEBUG(<span class="string">"Not enough points for solve pnp !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat K = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat D;</span><br><span class="line">    <span class="keyword">if</span> (! cv::solvePnP(pts_3_vector, pts_2_vector, K, D, rvec, t, <span class="literal">true</span>)) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve pnp fail!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PnP求解出的位姿要取逆</span></span><br><span class="line">    MatrixXd R_pnp;</span><br><span class="line">    MatrixXd T_pnp;</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat r;</span><br><span class="line">        cv::Rodrigues(rvec, r);</span><br><span class="line">        MatrixXd tmp_R_pnp;</span><br><span class="line">        cv::cv2eigen(r, tmp_R_pnp);</span><br><span class="line">        R_pnp = tmp_R_pnp.transpose();</span><br><span class="line"></span><br><span class="line">        cv::cv2eigen(t, T_pnp);</span><br><span class="line">        T_pnp = R_pnp * (-T_pnp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换到IMU坐标系下</span></span><br><span class="line">    frame_it-&gt;second.R = R_pnp * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">    frame_it-&gt;second.T = T_pnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6.进行视觉惯性联合初始化，imu与视觉对齐，获取绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视觉与IMU对齐</span></span><br><span class="line"><span class="keyword">if</span> (visualInitialAlign())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"misalign visual structure with IMU"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool Estimator::visualInitialAlign()</strong><br>该函数主要实现了陀螺仪的偏置校准(加速度偏置没有处理)，计算速度V[0:n]、重力g、尺度s。<br>同时更新了Bgs后，IMU测量量需要repropagate；得到尺度s和重力g的方向后，需更新所有图像帧在世界坐标系下的Ps、Rs、Vs。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::visualInitialAlign()</span><br><span class="line">&#123;</span><br><span class="line">    TicToc t_g;</span><br><span class="line"></span><br><span class="line">    VectorXd x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve scale</span></span><br><span class="line">    <span class="comment">// 要注意这个地方求解出的g是在C0坐标系下</span></span><br><span class="line">    <span class="comment">//1.计算陀螺仪偏置，尺度，重力加速度和速度</span></span><br><span class="line">    <span class="keyword">bool</span> result = VisualIMUAlignment(all_image_frame, Bgs, g, x);</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve g failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change state</span></span><br><span class="line">    <span class="comment">//2.获取所有图像帧的位姿Ps、Rs，并将其置为关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix3d Ri = all_image_frame[Headers[i].stamp.toSec()].R;</span><br><span class="line">        Vector3d Pi = all_image_frame[Headers[i].stamp.toSec()].T;</span><br><span class="line">        Ps[i] = Pi;</span><br><span class="line">        Rs[i] = Ri;</span><br><span class="line">        all_image_frame[Headers[i].stamp.toSec()].is_key_frame = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有特征点的深度置为-1</span></span><br><span class="line">    VectorXd dep = f_manager.getDepthVector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dep.size(); i++)</span><br><span class="line">        dep[i] = <span class="number">-1</span>;</span><br><span class="line">    f_manager.clearDepth(dep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//triangulat on cam pose , no tic</span></span><br><span class="line">    <span class="comment">//3.重新计算特征点的深度</span></span><br><span class="line">    Vector3d TIC_TMP[NUM_OF_CAM];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">        TIC_TMP[i].setZero();</span><br><span class="line">    ric[<span class="number">0</span>] = RIC[<span class="number">0</span>];</span><br><span class="line">    f_manager.setRic(ric);</span><br><span class="line">    f_manager.triangulate(Ps, &amp;(TIC_TMP[<span class="number">0</span>]), &amp;(RIC[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> s = (x.tail&lt;<span class="number">1</span>&gt;())(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4.陀螺仪的偏置bgs改变，重新计算预积分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= WINDOW_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre_integrations[i]-&gt;repropagate(Vector3d::Zero(), Bgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.将Ps、Vs、depth尺度s缩放后转变为相对于第0帧图像坐标系下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = frame_count; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        Ps[i] = s * Ps[i] - Rs[i] * TIC[<span class="number">0</span>] - (s * Ps[<span class="number">0</span>] - Rs[<span class="number">0</span>] * TIC[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> kv = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_i;</span><br><span class="line">    <span class="keyword">for</span> (frame_i = all_image_frame.begin(); frame_i != all_image_frame.end(); frame_i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(frame_i-&gt;second.is_key_frame)</span><br><span class="line">        &#123;</span><br><span class="line">            kv++;</span><br><span class="line">            Vs[kv] = frame_i-&gt;second.R * x.segment&lt;<span class="number">3</span>&gt;(kv * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">    &#123;</span><br><span class="line">        it_per_id.used_num = it_per_id.feature_per_frame.size();</span><br><span class="line">        <span class="keyword">if</span> (!(it_per_id.used_num &gt;= <span class="number">2</span> &amp;&amp; it_per_id.start_frame &lt; WINDOW_SIZE - <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        it_per_id.estimated_depth *= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转矩阵rot_diff</span></span><br><span class="line">    Matrix3d R0 = Utility::g2R(g);</span><br><span class="line">    <span class="keyword">double</span> yaw = Utility::R2ypr(R0 * Rs[<span class="number">0</span>]).x();</span><br><span class="line">    R0 = Utility::ypr2R(Eigen::Vector3d&#123;-yaw, <span class="number">0</span>, <span class="number">0</span>&#125;) * R0;</span><br><span class="line">    g = R0 * g;</span><br><span class="line">    <span class="comment">//Matrix3d rot_diff = R0 * Rs[0].transpose();</span></span><br><span class="line">    Matrix3d rot_diff = R0;</span><br><span class="line">    <span class="comment">//7.所有变量从参考坐标系c0旋转到世界坐标系w</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Ps[i] = rot_diff * Ps[i];</span><br><span class="line">        Rs[i] = rot_diff * Rs[i];</span><br><span class="line">        Vs[i] = rot_diff * Vs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"g0     "</span> &lt;&lt; g.transpose());</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"my R0  "</span> &lt;&lt; Utility::R2ypr(Rs[<span class="number">0</span>]).transpose()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<br><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719531" target="_blank" rel="noopener">VINS理论与代码详解4——初始化</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;估计器初始化&quot;&gt;&lt;a href=&quot;#估计器初始化&quot; class=&quot;headerlink&quot; title=&quot;估计器初始化&quot;&gt;&lt;/a&gt;估计器初始化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;初始化的原因是单目惯性紧耦合系统是一个非线性程度很高的系统，首先单目是无法获得空间中的绝对尺度，而IMU又必然存在偏置，在后面进行求解的时候还需要用到重力加速度（包括大小和方向），对于速度比较敏感的条件下，比如说无人机，又要精确的速度信息，因此，如何有效的在紧耦合系统处理之前计算出这些量，对整个紧耦合系统的鲁棒性有着重大的意义&lt;/li&gt;
&lt;li&gt;初始化要做的事其实说起来很简单，就是计算出绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v&lt;/li&gt;
&lt;li&gt;VINS-Mono 的初始化采用松组合（loosely coupled）的方式获取初始值。 首先用 SFM求解滑动窗口内所有帧的位姿（以第一帧作为参考坐标系）和所有路标点的 3D 位置。然后将 SFM 的结果与 IMU 预积分的值进行对齐，实现对陀螺仪偏置的校正，再求解每一帧对应的速度，求解重力向量方向，恢复单目相机的尺度因子。&lt;/li&gt;
&lt;li&gt;需要注意的是，在初始化过程中，并没有对加速度计的偏置进行校正，这是因为重力是初始化过程中待求的量，而加速度计偏置与重力耦合，而且系统的加速度相对于重力加速度很小，所以加速度计偏置在初始化过程中很难观测，因此初始化过程中不考虑加速度计偏置的校正。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>17.打印从1到最大的n位数</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/17-打印从1到最大的n位数/</id>
    <published>2019-10-29T06:37:09.000Z</published>
    <updated>2019-10-29T06:37:52.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>16.数组的整数次方</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/16.%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/16.数组的整数次方/</id>
    <published>2019-10-29T06:35:11.000Z</published>
    <updated>2019-10-30T02:52:27.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>当指数exponent为正</p></li><li><p>当指数为负，可以先对指数取绝对值，算出次方的结果后取倒数，要讨论底数是否为0</p><blockquote><p>底数base不为0</p><p>底数base为0，对0求倒数，导致程序出错，需要进行特殊处理，这里采用全局变量</p><p><img alt="1572402654504" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572402654504.png"></p></blockquote></li></ol><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p><p>法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Exponent;i++)</span><br><span class="line">            result*=base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法2：</p><p>位运算效率比乘除法及求余运算符（%）的效率高很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span> base;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//用右移运算符代替除以2</span></span><br><span class="line">         <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,Exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">         result*=result;</span><br><span class="line">         <span class="comment">//求余运算符（%）判断一个数是奇数还是偶数</span></span><br><span class="line">         <span class="keyword">if</span>(Exponent &amp; <span class="number">0x1</span>==<span class="number">1</span>)</span><br><span class="line">             result*=base;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent&lt;<span class="number">0</span>:</span><br><span class="line">            exponent=-exponent</span><br><span class="line">            flag=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        temp=base</span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(exponent):</span><br><span class="line">            <span class="keyword">if</span> exponent &amp; <span class="number">1</span>:</span><br><span class="line">                res*=temp</span><br><span class="line">            temp*=temp</span><br><span class="line">            exponent=exponent&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。&lt;/p&gt;&lt;p&gt;保证base和exponent不同时为0&lt;/p&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当指数exponent为正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当指数为负，可以先对指数取绝对值，算出次方的结果后取倒数，要讨论底数是否为0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;底数base不为0&lt;/p&gt;
&lt;p&gt;底数base为0，对0求倒数，导致程序出错，需要进行特殊处理，这里采用全局变量&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;1572402654504&quot; data-src=&quot;/home/xiaohu/.config/Typora/typora-user-images/1572402654504.png&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>15.二进制中1的个数</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/15.二进制中1的个数/</id>
    <published>2019-10-29T03:42:07.000Z</published>
    <updated>2019-10-30T03:25:10.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="二进制的5种位运算"><a href="#二进制的5种位运算" class="headerlink" title="二进制的5种位运算"></a>二进制的5种位运算</h1><blockquote><p>与（&amp;）</p><p>或（|）</p><p>异或（^)</p><p>左移(&lt;&lt;)  ：左移n位时，做左边的n位被丢弃，最右边不是那个补上n个0</p><p>右移(&gt;&gt;)  ：右移n位时，最右边的n位被丢弃,左边分两种情况</p><blockquote><p>1.如果数字为正，右移最左边补n个0</p><p>2.如果数字为负，右移最左边补n个1      </p></blockquote></blockquote><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>先判断整数二进制最右边是不是1，接着把输入的整数右移一位，再判断是不是1，直到这个整数变为0为止</p></li><li><p>怎么判断一个整数为1？</p><blockquote><ol><li><p>把整数与1做与运算，但当输入是负数时，如果一直右移运算，最终的数字会变成oxFFFFFFFF陷入死循环</p></li><li><p>为避免死循环，首先把n与1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算，就能判断n的次地位是不是1,反复左移……</p></li><li><p>把一个整数减去1，再和原整数做与运算，会把整个整数最右边的1变为0</p></li></ol></blockquote></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p><p>法1：</p><p>一个int为8位，所以负数的情况中需要<strong>判断32个字节中</strong>1的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">                 result++;</span><br><span class="line">             flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)</span><br><span class="line">         &#123;</span><br><span class="line">             result++;<span class="comment">//一个非0数字至少有一个1</span></span><br><span class="line">             n=(n<span class="number">-1</span>)&amp;n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Python</strong></p><p>法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> n &amp; flag:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n &amp;= <span class="number">0xffffffff</span> <span class="comment">#获取负数补码</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;&lt;h1 id=&quot;二进制的5种位运算&quot;&gt;&lt;a href=&quot;#二进制的5种位运算&quot; class=&quot;headerlink&quot; title=&quot;二进制的5种位运算&quot;&gt;&lt;/a&gt;二进制的5种位运算&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;与（&amp;amp;）&lt;/p&gt;
&lt;p&gt;或（|）&lt;/p&gt;
&lt;p&gt;异或（^)&lt;/p&gt;
&lt;p&gt;左移(&amp;lt;&amp;lt;)  ：左移n位时，做左边的n位被丢弃，最右边不是那个补上n个0&lt;/p&gt;
&lt;p&gt;右移(&amp;gt;&amp;gt;)  ：右移n位时，最右边的n位被丢弃,左边分两种情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.如果数字为正，右移最左边补n个0&lt;/p&gt;
&lt;p&gt;2.如果数字为负，右移最左边补n个1      &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>14.剪绳子</title>
    <link href="https://xiao-hu.com.cn/2019/10/29/14-%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>https://xiao-hu.com.cn/2019/10/29/14-剪绳子/</id>
    <published>2019-10-29T02:45:41.000Z</published>
    <updated>2019-10-29T06:10:33.930Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul><li>$O(n^2)$时间和$O(n)$空间的动态规划</li><li>$O(1)$时间和空间的贪婪算法</li></ul><a id="more"></a><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>第一步：确定最优策略，使得剪掉绳子的几段乘积最大。最后一步：乘积最大。子问题：假设该绳子剪成两段，剪完的两个部分都必须是最大乘积。</p><p>第二步：状态转移方程： dp[i] = max{ dp[i - j]<em>dp[j]} ,这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。更好的办法是按照<em>*从下而上</em></em>的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。</p><p>第三步：确定初始值和边界：dp[0] = 0,dp[1] = 1, dp[2] = 1</p><p>第四步：计算顺序，从dp[3]开始到dp[n]</p></blockquote><p><strong>C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product)</span><br><span class="line">                max = product;</span><br><span class="line"></span><br><span class="line">            products[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[length];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self,length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp=[<span class="number">0</span>]*length</span><br><span class="line">    <span class="comment">#dp = [0 for i in range(number + 1)]</span></span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">    dp[<span class="number">3</span>]=<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,length+<span class="number">1</span>):</span><br><span class="line">        cout=<span class="number">0</span></span><br><span class="line">        j=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;=i//<span class="number">2</span>:</span><br><span class="line">            cout=max(dp[i-j]*dp[j],cout)</span><br><span class="line">            dp[i]=cout</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[lentgh]</span><br></pre></td></tr></table></figure><h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>按如下策略来剪绳子</p><ul><li>当n&gt;=5，尽可能多剪长度为3的绳子</li><li>当剩下的绳子长度为4，把绳子剪成两段为2的绳子</li></ul><p><strong>C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽可能多地减去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。</span></span><br><span class="line">    <span class="comment">// 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。</span></span><br><span class="line">    <span class="keyword">if</span>(length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        timesOf3 -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3)) * (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h1&gt;&lt;p&gt;给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&amp;gt;1并且m&amp;gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]&lt;em&gt;k[1]&lt;/em&gt;…*k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.&lt;/p&gt;&lt;h1 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;$O(n^2)$时间和$O(n)$空间的动态规划&lt;/li&gt;
&lt;li&gt;$O(1)$时间和空间的贪婪算法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法——查找</title>
    <link href="https://xiao-hu.com.cn/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/"/>
    <id>https://xiao-hu.com.cn/2019/10/27/数据结构与算法——查找/</id>
    <published>2019-10-27T05:16:28.000Z</published>
    <updated>2019-10-30T03:24:52.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查找定义：查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><blockquote><p>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。</p></blockquote><p>查找又根据操作方式不同分为静态查找和动态查找两种，前者是仅获取数据不进行其他操作，后者则需要动态改变数据，比如在查找过程中插入新数据，或者删除某个已存在的数据。</p><a id="more"></a><h1 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h1><ul><li>定义：<br>从线性表的一段开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</li><li>时间复杂度：O(N）</li><li><p>优缺点：</p><blockquote><p>优点：对数据元素的存储没有需求，顺序存储或链式存储皆可；对表中记录的有序性也没有要求，无论记录是否按关键码有序，均可应用<br>缺点：当n较大时，平均查找长度较大，效率低</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]==key)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入哨兵的目的是使得函数内的循环不用每次都判断数组是否会越界，即不需要每次让 i与 n 作比较<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">a[<span class="number">0</span>]=key;</span><br><span class="line">i=n;</span><br><span class="line"><span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">&#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">/*返回 0 则说明查找失败*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h1><h2 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h2><ul><li><p>定义：</p><blockquote><p>在有序的顺序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域元记录，查找失败为止。</p></blockquote></li><li>时间复杂度：O(logN）</li><li><p>优缺点：</p><blockquote><p>优点：折半查找的时间复杂度为O(logn)，远远优于顺序查找的O(n)，<br>缺点：二分查找的效率高，但是要求表关键字有序</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;<span class="comment">/* 折半 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><ul><li><p>定义：</p><blockquote><p>基于二分查找算法，将查找点的选择改进为自适应选择，mid=low+(key-a[low])/(a[high]-a[low])*(high-low)<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014201459952.png#pic_center"></p></blockquote></li><li>时间复杂度：O(logN）</li><li>优缺点：<blockquote><p>优点：对于表长较大 且关键字分布又比较均匀的查找表，插值查找算法的平均性能比折半查找要好得多<br>缺点：极端不均匀的数据，用插值查找未必是很合适的选择</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插值查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Interpolation_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low,high,mid;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/* 若查找值比插值小 */</span></span><br><span class="line">high=mid<span class="number">-1</span>;<span class="comment">/* 最高下标调整到插值下标小一位 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比插值大 */</span></span><br><span class="line">low=mid+<span class="number">1</span>;<span class="comment">/* 最低下标调整到插值下标大一位 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><ul><li><p>定义：</p><blockquote><p>1.斐波那契实在二分查找基础上，用斐波那契数列来进行分割<br>2.在斐波那契数列上找一个略大于查找元素表个数的值f(n)<br>3.将查找元素表个数扩充到f(n) 如果要补充元素用最后一个元素补充<br>4.完成后对f(n)个元素进行斐波那契分割,即分割成 前面f(n-1)个元素,后面f(n-2)个元素<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014205901920.png#pic_center"><br>5.对要查找元素的那个部分进行递归 </p></blockquote></li><li><p>时间复杂度：O(logN）</p></li><li><p>优缺点：</p><blockquote><p> 就平均性能而言 优于折半查找 但是若一直在左边长半区查找则低于折半查找                      </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low,high,mid,i,k=<span class="number">0</span>;</span><br><span class="line">low=<span class="number">1</span>;<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n;<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line"><span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">a[i]=a[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">k=k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])</span><br><span class="line">&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">k=k<span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line"><span class="keyword">return</span> mid;<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1></blockquote></li><li>索引:就是把一个关键字与它对应的记录相关联的过程。一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</li><li>索引按照结构可以分为线性索引，树形索引和多级索引。</li><li>线性索引是将索引项集合组织为线性结构，也称为索引表。包括稠密索引、分块索引、倒排索引。<h2 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h2><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211157380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li><li>稠密索引是指在线性表中，将数据集中的每个记录对应一个索引项。对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</li><li>优缺点：<blockquote><p>优点：索引项有序也就意味着，我们要查找关键字时，可以用折半，插值及斐波那契等有序查找算法。<br>缺点：如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模。对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能大大下降。</p></blockquote></li></ul><h2 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h2><ul><li><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p><blockquote><ul><li>块内无序，即每一块内的记录宋不要求有序，有序更好，代价比较大</li><li>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记景的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字</li></ul></blockquote><p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。</p></li><li><p>定义的分块索引的索引项结构分三个数据项 :</p><blockquote><ul><li>最大关键码，它存储每一块中的最大关键字，好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li><li>存储了块中的记录个数，以便于循环时使用</li><li>用于指向块首数据元素的指针，便于开始对这一块中记景进行遍历。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211843755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li></ul></blockquote></li><li>分块索引表中查找，就是分两步进行:<blockquote><ul><li>在分块索引表中查找要查的关键字所在块。由于分块索引表是块间有序的，很容易利用折半插值等算法得到结果。</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，只能顺序查找。</li></ul></blockquote></li><li>分块索引的平均查找长度：<blockquote><p>n 个记录的数据集被平均分成 m块，每个块中有 t 条记录，显然 n=m x t<br>Lb 为查找索引表的平均查找长，Lw为块中查找记录的平均查找长度<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213115831.png#pic_center"></p></blockquote></li></ul><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><ul><li>最基础的搜索技术<blockquote><p>样例:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101421402779.png#pic_center"><br>忽略大小写和复数，得出单词表，找到他们分别出现在哪篇文章中<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213725806.png#pic_center"><br>这张单词表就是索引衰， 索引项的通用结构是:</p><ul><li>次关键码.例如上面的”英文单词” </li><li>记录号表，例如上面的”文章编号”</li></ul><p>其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字) 。 这样的索引方法就是倒排索引 (invered index)</p></blockquote></li><li>优缺点：<blockquote><ul><li>优点：显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果<br>缺点：是这个记录号不定长<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1></li></ul></blockquote></li><li>定义：二叉排序树 ( Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。.</li></ul><blockquote><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值 </li><li>若它的右子树不空 ，则右子树上所有结点的值均大于宫的根结点的值</li><li>它的左、右子树也分别为二叉排序树。</li></ul></blockquote><p>   通过<strong>中序遍历</strong>即可得出<strong>有序的序列</strong>， 构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。</p><ul><li>二叉排序树的查找</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;<span class="comment">//BiTNode是该结构体的变量名,*BiTree是该结构体的类型的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 递归查找二叉排序树T中是否存在key, */</span></span><br><span class="line"><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span></span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line"><span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">if</span> (!T)<span class="comment">/*  查找不成功 */</span></span><br><span class="line">&#123; </span><br><span class="line">*p = f;  </span><br><span class="line"><span class="keyword">return</span> FALSE; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key==T-&gt;data) <span class="comment">/*  查找成功 */</span></span><br><span class="line">&#123; </span><br><span class="line">*p = T;  </span><br><span class="line"><span class="keyword">return</span> TRUE; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data) </span><br><span class="line"><span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);  <span class="comment">/*  在左子树中继续查找 */</span></span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);  <span class="comment">/*  在右子树中继续查找 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */</span></span><br><span class="line"><span class="comment">/*  插入key并返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">BiTree p,s;</span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line">    <span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line"><span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">&#123;</span><br><span class="line">s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">s-&gt;data = key;  </span><br><span class="line">s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">if</span> (!p) </span><br><span class="line">*T = s;<span class="comment">/*  插入s为新的根结点 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&lt;p-&gt;data) </span><br><span class="line">p-&gt;lchild = s;<span class="comment">/*  插入s为左孩子 */</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">p-&gt;rchild = s;  <span class="comment">/*  插入s为右孩子 */</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> FALSE;  <span class="comment">/*  树中已有关键字相同的结点，不再插入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>删除<blockquote><p>对删除结点三种情况的分析:</p><ul><li>叶子结点</li><li>仅有左或右子树的结点 </li><li>左右子树都有的结点</li></ul></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree q,s;</span><br><span class="line"><span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; *p=(*p)-&gt;lchild; <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">/* 只需重接它的右子树 */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; *p=(*p)-&gt;rchild; <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; s=(*p)-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span></span><br><span class="line">&#123;</span><br><span class="line">q=s;</span><br><span class="line">s=s-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">(*p)-&gt;data=s-&gt;data; <span class="comment">/*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span></span><br><span class="line"><span class="keyword">if</span>(q!=*p)</span><br><span class="line">q-&gt;rchild=s-&gt;lchild; <span class="comment">/*  重接q的右子树 */</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">q-&gt;lchild=s-&gt;lchild; <span class="comment">/*  重接q的左子树 */</span></span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span></span><br><span class="line"><span class="comment">/* 并返回TRUE；否则返回FALSE。 */</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span> </span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key==(*T)-&gt;data) <span class="comment">/* 找到关键字等于key的数据元素 */</span> </span><br><span class="line"><span class="keyword">return</span> Delete(T);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&lt;(*T)-&gt;data)</span><br><span class="line"><span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h1><ul><li>平衡二叉树(Balanced Binary Tree)(简称平衡树，AVL)也是二叉排序树的一种，其特点在于，左右子树的高度之差的绝对值不超过1，左右子树高度之差被称为平衡因子，每次插入一个新的值的时候，都要检查二叉树的平衡，也就是平衡调整</li><li>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balanoe Factor)，平衡因乎只可能是-1、0和 1</li></ul><ul><li>基本思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。 在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="keyword">int</span> bf; <span class="comment">/*  结点的平衡因子 */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以p为根的二叉排序树作右旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">BiTree L;</span><br><span class="line">L=(*P)-&gt;lchild; <span class="comment">/*  L指向P的左子树根结点 */</span> </span><br><span class="line">(*P)-&gt;lchild=L-&gt;rchild; <span class="comment">/*  L的右子树挂接为P的左子树 */</span> </span><br><span class="line">L-&gt;rchild=(*P);</span><br><span class="line">*P=L; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以P为根的二叉排序树作左旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">BiTree R;</span><br><span class="line">R=(*P)-&gt;rchild; <span class="comment">/*  R指向P的右子树根结点 */</span> </span><br><span class="line">(*P)-&gt;rchild=R-&gt;lchild; <span class="comment">/* R的左子树挂接为P的右子树 */</span> </span><br><span class="line">R-&gt;lchild=(*P);</span><br><span class="line">*P=R; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">/*  左高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0  <span class="comment">/*  等高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">/*  右高 */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</span></span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">BiTree L,Lr;</span><br><span class="line">L=(*T)-&gt;lchild; <span class="comment">/*  L指向T的左子树根结点 */</span> </span><br><span class="line"><span class="keyword">switch</span>(L-&gt;bf)</span><br><span class="line">&#123; <span class="comment">/*  检查T的左子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line"> <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */</span> </span><br><span class="line">(*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">R_Rotate(T);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的左孩子的右子树上，要作双旋处理 */</span> </span><br><span class="line">Lr=L-&gt;rchild; <span class="comment">/*  Lr指向T的左孩子的右子树根 */</span> </span><br><span class="line"><span class="keyword">switch</span>(Lr-&gt;bf)</span><br><span class="line">&#123; <span class="comment">/*  修改T及其左孩子的平衡因子 */</span> </span><br><span class="line"><span class="keyword">case</span> LH: (*T)-&gt;bf=RH;</span><br><span class="line"> L-&gt;bf=EH;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EH: (*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RH: (*T)-&gt;bf=EH;</span><br><span class="line"> L-&gt;bf=LH;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Lr-&gt;bf=EH;</span><br><span class="line">L_Rotate(&amp;(*T)-&gt;lchild); <span class="comment">/*  对T的左子树作左旋平衡处理 */</span> </span><br><span class="line">R_Rotate(T); <span class="comment">/*  对T作右旋平衡处理 */</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */</span> </span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">BiTree R,Rl;</span><br><span class="line">R=(*T)-&gt;rchild; <span class="comment">/*  R指向T的右子树根结点 */</span> </span><br><span class="line"><span class="keyword">switch</span>(R-&gt;bf)</span><br><span class="line">&#123; <span class="comment">/*  检查T的右子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line"> <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */</span> </span><br><span class="line">  (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">  L_Rotate(T);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的右孩子的左子树上，要作双旋处理 */</span> </span><br><span class="line">  Rl=R-&gt;lchild; <span class="comment">/*  Rl指向T的右孩子的左子树根 */</span> </span><br><span class="line">  <span class="keyword">switch</span>(Rl-&gt;bf)</span><br><span class="line">  &#123; <span class="comment">/*  修改T及其右孩子的平衡因子 */</span> </span><br><span class="line"><span class="keyword">case</span> RH: (*T)-&gt;bf=LH;</span><br><span class="line"> R-&gt;bf=EH;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EH: (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LH: (*T)-&gt;bf=EH;</span><br><span class="line"> R-&gt;bf=RH;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Rl-&gt;bf=EH;</span><br><span class="line">  R_Rotate(&amp;(*T)-&gt;rchild); <span class="comment">/*  对T的右子树作右旋平衡处理 */</span> </span><br><span class="line">  L_Rotate(T); <span class="comment">/*  对T作左旋平衡处理 */</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */</span> </span><br><span class="line"><span class="comment">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */</span> </span><br><span class="line"><span class="comment">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BiTree *T,<span class="keyword">int</span> e,Status *taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">if</span>(!*T)</span><br><span class="line">&#123; <span class="comment">/*  插入新结点，树“长高”，置taller为TRUE */</span> </span><br><span class="line"> *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"> (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="literal">NULL</span>; (*T)-&gt;bf=EH;</span><br><span class="line"> *taller=TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e==(*T)-&gt;data)</span><br><span class="line">&#123; <span class="comment">/*  树中已存在和e有相同关键字的结点则不再插入 */</span> </span><br><span class="line">*taller=FALSE; <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e&lt;(*T)-&gt;data)</span><br><span class="line">&#123; <span class="comment">/*  应继续在T的左子树中进行搜索 */</span> </span><br><span class="line"><span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">if</span>(*taller) <span class="comment">/*   已插入到T的左子树中且左子树“长高” */</span> </span><br><span class="line"><span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，需要作左平衡处理 */</span> </span><br><span class="line">LeftBalance(T);*taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因左子树增高而使树增高 */</span> </span><br><span class="line">(*T)-&gt;bf=LH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，现左、右子树等高 */</span>  </span><br><span class="line">(*T)-&gt;bf=EH; *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="comment">/*  应继续在T的右子树中进行搜索 */</span> </span><br><span class="line"><span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">if</span>(*taller) <span class="comment">/*  已插入到T的右子树且右子树“长高” */</span> </span><br><span class="line"><span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，现左、右子树等高 */</span> </span><br><span class="line">(*T)-&gt;bf=EH; *taller=FALSE;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因右子树增高而使树增高  */</span></span><br><span class="line">(*T)-&gt;bf=RH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，需要作右平衡处理 */</span> </span><br><span class="line">RightBalance(T); *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">BiTree T=<span class="literal">NULL</span>;</span><br><span class="line">Status taller;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"本样例建议断点跟踪查看平衡二叉树结构"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="散列表查找-哈希表"><a href="#散列表查找-哈希表" class="headerlink" title="散列表查找(哈希表)"></a>散列表查找(哈希表)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>定义：散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。这种对应关系f称为散列函数， 又称为哈希( Hash) 函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。</p></li><li><p>散列技术既是一种存储方法，也是一种查找方法。两个关键字key1≠key2，但是却有f(key1)=f(key2) ，这种现象我们称为冲突(collision) ，并把key1 和key2 称为这个散列函数的同义词(synonym) 。</p></li></ul><h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>取关键字的某个线性函数值为散列地址：</p><script type="math/tex; mode=display">f(key)=key×a+b(a、b为常数)</script><p>适合查找表较小且连续的情况。</p><h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。</p><h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>对关键字的平方后取中间部分的值。比较适合子不知道关键字的分布，而位数又不是很大的情况。</p><h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p><h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为:</p><script type="math/tex; mode=display">f(key)=key \ mod\ p(p⩽m)</script><p>mod 是取模(求余数)的意思 ，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。<br>若散列表表长为m， 通常p为小于或等于表长(最好接近m ) 的最小质数或不包含小子20质因子的合数。</p><h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一个随机数，取关键字的随机函数值为它的散列地址:</p><script type="math/tex; mode=display">f(key)=random(key)</script><h2 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>一旦发生了冲突， 就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><script type="math/tex; mode=display">fi(key)=(f(key)+di)\ MOD\ m(di=1,2,3,..,m−1)</script><p>为了不让关键字都聚集在某一块区域,一般增加平方运算：</p><script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)\ MOD\ m(di=12,−12,22,−22,..,q2,−q2,q⩽m/2)</script><p>在冲突时，对于位移量$d_i$，采用随机函数计算得到，我们称之为随机探测法:</p><script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)MODm(di是一个随机数列)</script><h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>我们事先准备多个散列函数。</p><script type="math/tex; mode=display">fi(key)=RHi(key)(i=1,2,3,..,k)</script><p>这里RHi就是不同的散列函数。这种方法能够使得关键字不产生聚集，但也增加了计算的时间。</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p><p>它提供了绝不会出现找不到地址的保障，但也带来了查找时需要遍历单链装的性能损耗。</p><h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p>为所有冲突的关键字建立了一个公共的溢出区来存放。在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功； 如果不相等，则到溢出表去进行顺序查找。</p><h2 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12 <span class="comment">/* 定义散列表长为数组的长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY -32768</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem; <span class="comment">/* 数据元素存储基址，动态分配数组 */</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">/*  当前数据元素个数 */</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>; <span class="comment">/* 散列表表长，全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m=HASHSIZE;</span><br><span class="line">    H-&gt;count=m;</span><br><span class="line">    H-&gt;elem=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        H-&gt;elem[i]=NULLKEY;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m; <span class="comment">/* 除留余数法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入关键字进散列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key); <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = (addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;elem[addr] = key; <span class="comment">/* 直到有空位后插入关键字 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);  <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span>(H.elem[*addr] != key) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) <span class="comment">/* 如果循环回到原点 */</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;<span class="comment">/* 则说明关键字不存在 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[HASHSIZE]=&#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,p,key,result;</span><br><span class="line">    HashTable H;</span><br><span class="line"></span><br><span class="line">    key=<span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">    InitHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(&amp;H,arr[i]);</span><br><span class="line"></span><br><span class="line">    result=SearchHash(H,key,&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 失败。\n"</span>,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        key=arr[i];</span><br><span class="line">        SearchHash(H,key,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027131236947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;查找定义：查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;查找又根据操作方式不同分为静态查找和动态查找两种，前者是仅获取数据不进行其他操作，后者则需要动态改变数据，比如在查找过程中插入新数据，或者删除某个已存在的数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Data Structures and Algorithms" scheme="https://xiao-hu.com.cn/categories/Data-Structures-and-Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法——排序</title>
    <link href="https://xiao-hu.com.cn/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://xiao-hu.com.cn/2019/10/27/数据结构与算法——排序/</id>
    <published>2019-10-27T05:16:28.000Z</published>
    <updated>2019-10-30T03:24:46.293Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="术语说明："><a href="#术语说明：" class="headerlink" title="术语说明："></a>术语说明：</h1><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ul><a id="more"></a><h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类:"></a>算法分类:</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204533683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204455511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];<span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">/* 用于记录顺序表的长度 */</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> temp=L-&gt;r[i]; </span><br><span class="line">L-&gt;r[i]=L-&gt;r[j]; </span><br><span class="line">L-&gt;r[j]=temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>依次比较相邻两元素，若前一元素大于后一元素则交换之，直至最后一个元素即为最大；然后重新从首元素开始重复同样的操作，直至倒数第二个元素即为次大元素；依次类推。如同水中的气泡，依次将最大或最小元素气泡浮出水面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)  <span class="comment">/* 注意j是从后往前循环 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>]) <span class="comment">/* 若前者大于后者（注意这里与上一算法的差异）*/</span></span><br><span class="line">&#123;</span><br><span class="line"> swap(L,j,j+<span class="number">1</span>);<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作改进冒泡算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">Status flag=TRUE;<span class="comment">/* flag用来作为标记 */</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag;i++) <span class="comment">/* 若flag为true说明有过数据交换，否则停止循环 */</span></span><br><span class="line">&#123;</span><br><span class="line">flag=FALSE;<span class="comment">/* 初始为False */</span></span><br><span class="line"><span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"> swap(L,j,j+<span class="number">1</span>);<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line"> flag=TRUE;<span class="comment">/* 如果有数据交换，则flag为true */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 O(n)。</p><h2 id="2-简单选择排序"><a href="#2-简单选择排序" class="headerlink" title="2.简单选择排序"></a>2.简单选择排序</h2><p>首先初始化最小元素索引值为首元素，依次遍历待排序数列，若遇到小于该最小索引位置处的元素则刷新最小索引为该较小元素的位置，直至遇到尾元素，结束一次遍历，并将最小索引处元素与首元素交换；然后，初始化最小索引值为第二个待排序数列元素位置，同样的操作，可得到数列第二个元素即为次小元素；以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作简单选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,min;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">&#123; </span><br><span class="line">min = i;<span class="comment">/* 将当前下标定义为最小值下标 */</span></span><br><span class="line"><span class="keyword">for</span> (j = i+<span class="number">1</span>;j&lt;=L-&gt;length;j++)<span class="comment">/* 循环之后的数据 */</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[min]&gt;L-&gt;r[j])<span class="comment">/* 如果有小于当前最小值的关键字 */</span></span><br><span class="line">                min = j;<span class="comment">/* 将此关键字的下标赋值给min */</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(i!=min)<span class="comment">/* 若min不等于i，说明找到最小值，交换 */</span></span><br><span class="line">swap(L,i,min);<span class="comment">/* 交换L-&gt;r[i]与L-&gt;r[min]的值 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度： O(n)，但简单选择排序的性能上还是要略优于冒泡排序。</p><h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h2><p>数列前面部分看为有序，依次将后面的无序数列元素插入到前面的有序数列中，初始状态有序数列仅有一个元素，即首元素。在将无序数列元素插入有序数列的过程中，采用了逆序遍历有序数列，相较于顺序遍历会稍显繁琐，但当数列本身已近排序状态效率会更高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i<span class="number">-1</span>]) <span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></span><br><span class="line">&#123;</span><br><span class="line">L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/* 设置哨兵 */</span></span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="number">0</span>];j--)</span><br><span class="line">L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j]; <span class="comment">/* 记录后移 */</span></span><br><span class="line">L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/* 插入到正确位置 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度： O(n)，直接插入排序法比冒炮和简单选择排序的性能要好一些。</p><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> increment=L-&gt;length;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">increment=increment/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">/* 增量序列 */</span></span><br><span class="line"><span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i-increment])<span class="comment">/*  需将L-&gt;r[i]插入有序增量子表 */</span> </span><br><span class="line">&#123; </span><br><span class="line">L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/*  暂存在L-&gt;r[0] */</span></span><br><span class="line"><span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)</span><br><span class="line">L-&gt;r[j+increment]=L-&gt;r[j]; <span class="comment">/*  记录后移，查找插入位置 */</span></span><br><span class="line">L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/*  插入 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d趟排序结果: "</span>,++k);</span><br><span class="line">print(*L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度：通常认为是O($N^{3/2}$) ，未验证　　稳定性：不稳定</p><h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h2><blockquote><p>堆是具有下列性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值,称为大顶堆 或者每个结点的值都小于或等于其左右孩子结点的值,称为小顶堆。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151257333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151926815.png">堆排序 (Heap 80忱) 就是利用堆(假设利用大顶堆)进行排序的方法。它的基本思想是, 将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根结点。将官移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值) .然后将剩余的 n - 1 个序列重新构造成一个堆,这样就刽寻到 n 个元素中的次小值。如此反复执行 , 便能得到一个有序序列了 。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(i=L-&gt;length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span>   <span class="comment">/*把L中的r构建成一个大顶堆*/</span></span></span><br><span class="line"><span class="function">        <span class="title">HeadAdjust</span><span class="params">(L,i,L-&gt;length)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L,<span class="number">1</span>,i);             <span class="comment">/*将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></span><br><span class="line">        heapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);     <span class="comment">/*将当前的根结点重新调整为大顶堆 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,j;</span><br><span class="line">    temp=L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;m;j*=<span class="number">2</span>)    <span class="comment">/*沿关键字较大的孩子结点向下筛选*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            ++j;           <span class="comment">/*j为关键字中较大的记录的下标*/</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=L-&gt;r[j])   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        L-&gt;r[s]=L-&gt;r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(NlogN) 　　稳定性：不稳定<br>由于初始构建队所需的比较次数较多，并不适合待排序序列个数较少的情况。</p><h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h2><ul><li>归并排序 ( Merging Sort) 就是利用归并的思想实现的排序方法。色的原理是假设初始序列含有 n 个记录 , 则可 以看成是 n 个有序的子序列,每个子序列的长度为1 ,然后两两归并,得到[[n/2] ( [x]表示不小于 x 的最小整数)个长度为 2或1的有序子序列;再两两归并 ,……,如此重复 , 直至得到 一个长度为 n 的有序序列为止 ,这种排序方法称为2路归并排序 。<h3 id="递归实现归并排序"><a href="#递归实现归并排序" class="headerlink" title="递归实现归并排序"></a>递归实现归并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span> <span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MSort (L-&gt;r,L-&gt;r,L-&gt;length) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">MSort (<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR1[],<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> TR2[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s==t)</span><br><span class="line">        TR1[s]=SR[s]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=(s+t)/<span class="number">2</span>;         <span class="comment">/*将SR (S..t]平分为 SR [s..m]和SR[m+1..t] */</span></span><br><span class="line">        MSort(SR,TR2,s,m); <span class="comment">/*递归将SR[s..m]归并为有序的 TR2[s..m]*/</span></span><br><span class="line">        MSort(SR,TR2,m+<span class="number">1</span>,t);<span class="comment">/*递归将SR[m+1..t]归并为有序TR2[m+1..t] */</span></span><br><span class="line">        Merge(TR2,TR1,s,m,t);<span class="comment">/*将TR2[s..m]和TR2[m+1..t]归并到TR1【s..t] */</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将有序的 SR[i..m1 和 $R [m+l..0] 归并为有序的T.R[i..n] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k,i;</span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SR[i]&lt;SR[j])</span><br><span class="line">            TR[k]=SR[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TR[k=SR[j++]]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=m-i;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;n-j;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>假设现在要对数组{50,1 0,90,30, 70.40,80, 60 ,20}进行排序, L.length=9 ,现来看看 MSort 的实现。MSort 被调用时, SR与TR1都是{50, 10,90, 30,70,40,80,60,20} , s=1 , t=9 ,最终我们的目的就是要将TR1中的数组排好顺序。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724171640203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p></blockquote></li><li><p><strong>时间复杂度</strong>为：O(nlogn) </p></li><li><p><strong>空间复杂度</strong>：O(n+Iogn) ，由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为 Iog2 n 的横空间。</p><p>归并排序是一种<strong>稳定的排序算法</strong>，因为 Merge 函数 中有 if (SR[i]&lt;SR[j])语句,这就说明它需要两两比较,不存在跳跃。</p><h3 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h3><p>归并排序大量’引用了递归,尽管在代码上比较清晰,容易理解,但这会造成时间和空间上的性能损耗。排序追求的就是效率,<strong>将递归转化成迭代</strong>。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 非递归法 */</span></span><br><span class="line"><span class="comment">/* 对顺序表L作归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> MSort(L-&gt;r,L-&gt;r,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作归并非递归排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* TR=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(L-&gt;length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">/* 申请额外空间 */</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line">MergePass(L-&gt;r,TR,k,L-&gt;length);</span><br><span class="line">k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span></span><br><span class="line">MergePass(TR,L-&gt;r,k,L-&gt;length);</span><br><span class="line">k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span>       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</span><br><span class="line">&#123;<span class="comment">/* 两两归并 */</span></span><br><span class="line">Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</span><br><span class="line">i=i+<span class="number">2</span>*s;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>) <span class="comment">/* 归并最后两个序列 */</span></span><br><span class="line">Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 若最后只剩下单个子序列 */</span></span><br><span class="line"><span class="keyword">for</span>(j =i;j &lt;= n;j++)</span><br><span class="line">TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h2><p>快速排序 ( Quick Sort) 的基本思想是:通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></span><br><span class="line"><span class="comment">/* 此时在它之前(后)的记录均不大(小)于它。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line">pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">high--;</span><br><span class="line"> swap(L,low,high);<span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></span><br><span class="line"> <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">low++;</span><br><span class="line"> swap(L,low,high);<span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> pivot;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line">pivot=Partition(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">QSort(L,low,pivot<span class="number">-1</span>);<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line">QSort(L,pivot+<span class="number">1</span>,high);<span class="comment">/*  对高子表递归排序 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">QSort(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Partition 函数，其实就是将选取的pivotkey 不断交换，将比它小的换到它的左边，比它大的换到它的右边，包也在交换中不断更改自己的位置，直到完全满足这个要求为止。</p><p>时间复杂度：最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)　<br>空间复杂度： O(logn)<br>由于关键字的比较和交换是跳跃进行的，因此，<strong>快速排序是一种不稳定</strong>的排序方法</p><p><strong>三数取中法</strong>。即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数， 也可以随机选取。 这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中中间数位于较为中间的值的可能性就大大提高了 。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 改进后快速排序******************************** */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>; <span class="comment">/* 计算数组中间的元素的下标 */</span>  </span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])</span><br><span class="line">swap(L,low,high);<span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[high])</span><br><span class="line">swap(L,high,m);<span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[low])</span><br><span class="line">swap(L,m,low);<span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></span><br><span class="line"></span><br><span class="line">pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">L-&gt;r[<span class="number">0</span>]=pivotkey;  <span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">high--;</span><br><span class="line"> L-&gt;r[low]=L-&gt;r[high];</span><br><span class="line"> <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">low++;</span><br><span class="line"> L-&gt;r[high]=L-&gt;r[low];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> pivot;</span><br><span class="line"><span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line">pivot=Partition1(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">QSort1(L,low,pivot<span class="number">-1</span>);<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line"><span class="comment">/* QSort(L,pivot+1,high);/*  对高子表递归排序 */</span></span><br><span class="line">low=pivot+<span class="number">1</span>;<span class="comment">/* 尾递归 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">InsertSort(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort1</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">QSort1(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;术语说明：&quot;&gt;&lt;a href=&quot;#术语说明：&quot; class=&quot;headerlink&quot; title=&quot;术语说明：&quot;&gt;&lt;/a&gt;术语说明：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；&lt;/li&gt;
&lt;li&gt;不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；&lt;/li&gt;
&lt;li&gt;内排序：所有排序操作都在内存中完成；&lt;/li&gt;
&lt;li&gt;外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；&lt;/li&gt;
&lt;li&gt;时间复杂度： 一个算法执行所耗费的时间。&lt;/li&gt;
&lt;li&gt;空间复杂度：运行完一个程序所需内存的大小。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Data Structures and Algorithms" scheme="https://xiao-hu.com.cn/categories/Data-Structures-and-Algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>VINS-Mono——预积分</title>
    <link href="https://xiao-hu.com.cn/2019/10/25/VINS-Mono%E2%80%94%E2%80%94%E9%A2%84%E7%A7%AF%E5%88%86/"/>
    <id>https://xiao-hu.com.cn/2019/10/25/VINS-Mono——预积分/</id>
    <published>2019-10-25T13:49:20.000Z</published>
    <updated>2019-10-30T03:40:21.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了加深理解，参考崔华坤的《VINS论文推导及代码解析》，把相关公式推到一遍。</p><p>intergration_base.h：IMU预积分<br>imu_factor.h：IMU残差、雅可比</p><h1 id="IMU-测量方程"><a href="#IMU-测量方程" class="headerlink" title="IMU 测量方程."></a>IMU 测量方程.</h1><p>忽略地球旋转， IMU 测量方程为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214341590.png#pic_center"></p><h1 id="预积分方程"><a href="#预积分方程" class="headerlink" title="预积分方程"></a>预积分方程</h1><h2 id="IMU-integration-in-world-frame"><a href="#IMU-integration-in-world-frame" class="headerlink" title="IMU integration in world frame"></a>IMU integration in world frame</h2><p>将第 k 帧和第 k+1 帧之间的所有 IMU 进行积分，可得第 k+1 帧的位置、速度和旋转<br>（PVQ），作为视觉估计的初始值，这里的旋转采用的四元数。</p><a id="more"></a><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214621188.png#pic_center"></p><p>其中：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214759817.png#pic_center"></p><h1 id="IMU-integration-in-the-body-frame-of-first-pose-of-interests"><a href="#IMU-integration-in-the-body-frame-of-first-pose-of-interests" class="headerlink" title="IMU integration in the body frame of first pose of interests"></a>IMU integration in the body frame of first pose of interests</h1><p>为避免重新传播 IMU 观测值，选用 IMU 预积分模型，从世界坐标系转为本体坐标</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215210690.png#pic_center"></p><p>其中：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215228467.png#pic_center"></p><p>则 IMU 预积分模型（预积分估计值）为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152209217.png#pic_center"></p><p>离散状态下采用 中值积分 (mid-point) 的预积分方程（预积分测量值）为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102815225757.png#pic_center"></p><p>其中：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152316969.png#pic_center"></p><p>midPointIntegration中的相关代码（没有考虑噪声）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vector3d un_gyr = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">result_delta_q  = delta_q * Quaterniond(<span class="number">1</span>, un_gyr(<span class="number">0</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">1</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">2</span>) * _dt / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Vector3d un_acc_0 =        delta_q * (_acc_0 - linearized_ba);</span><br><span class="line">Vector3d un_acc_1 = result_delta_q * (_acc_1 - linearized_ba);</span><br><span class="line">Vector3d un_acc   = <span class="number">0.5</span> * (un_acc_0 + un_acc_1);</span><br><span class="line"></span><br><span class="line">result_delta_p = delta_p + delta_v * _dt + <span class="number">0.5</span> * un_acc * _dt * _dt;</span><br><span class="line">result_delta_v = delta_v + un_acc * _dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预积分的过程中Bias没有发生改变</span></span><br><span class="line">result_linearized_ba = linearized_ba;</span><br><span class="line">result_linearized_bg = linearized_bg;</span><br></pre></td></tr></table></figure><p>当 bias 估计轻微改变时，我们可以使用如下的一阶近似 对中值积分得到的预积分测量值进矫正，而不重传播，从而得到 更加精确的预积分测量值（bias 修正的线性模型）</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028145945699.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150116815.png#pic_center"></p><p>上式可由误差项雅克比矩阵的迭代公式$J_{b_{k+1}}$得出：<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O_P = 0 , O_R = 3 , O_V = 6 , O_BA = 9 , O_BG = 12</span></span><br><span class="line">           Eigen::Matrix3d dp_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BA);</span><br><span class="line">            Eigen::Matrix3d dp_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BG);</span><br><span class="line">            Eigen::Matrix3d dq_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_R, O_BG);</span><br><span class="line">            Eigen::Matrix3d dv_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BA);</span><br><span class="line">            Eigen::Matrix3d dv_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BG);</span><br></pre></td></tr></table></figure><h1 id="误差状态方程"><a href="#误差状态方程" class="headerlink" title="误差状态方程"></a>误差状态方程</h1><p>状态误差传递的线性递推关系可以通过两种方式实现</p><ul><li>基于误差随时间变化的递推方程</li><li>基于一阶泰勒展开的误差递推方程<br>本文用的第一种方法；我们还可以通过第二种方法：已知 IMU 预积分（中值积分）测量方程，通过求导计算出 F ′ 和 G′。</li></ul><h2 id="连续形式下-PVQ-增量误差的协方差及-Jacobian"><a href="#连续形式下-PVQ-增量误差的协方差及-Jacobian" class="headerlink" title="连续形式下 PVQ 增量误差的协方差及 Jacobian"></a>连续形式下 PVQ 增量误差的协方差及 Jacobian</h2><p>IMU 在每一个时刻积分出来的值是有误差的，下面我们对误差进行分析。首先我们直接给出在 t 时刻误差项的导数为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150603823.png#pic_center"><br>那么根据导数的定义有上一时刻推导下一时刻的误差如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150704700.png#pic_center"><br>上式恰好给出了如 EKF 一般对非线性系统线性化的过程，这里的意义是表示下一个时刻的 IMU 测量误差与上一个时刻的成线性关系，这样我们根据当前时刻的值，可以预测出下一个时刻的均值和协方差，而公式给出的是均值预测，协方差预测公式如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150752961.png#pic_center"><br>上式给出了协方差的迭代公式，初始值$P^{b_k}_{b_k}$ = 0。其中， Q 为表示噪声项的对角协方差<br>矩阵：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150935869.png#pic_center#pic_center"><br>由上式可获得误差项的 Jacobian 的迭代公式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151013604.png#pic_center"><br>其中 Jacobian 的初始值为$J_{b_k}=I$。</p><h2 id="离散形式的-PVQ-增量误差的-Jacobian-和协方差"><a href="#离散形式的-PVQ-增量误差的-Jacobian-和协方差" class="headerlink" title="离散形式的 PVQ 增量误差的 Jacobian 和协方差"></a>离散形式的 PVQ 增量误差的 Jacobian 和协方差</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151537536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>其中:</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151600894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>可以简写为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151718610.png#pic_center"></p><p>则 Jacobian 的迭代公式为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151808834.png#pic_center"></p><p>其中， Jacobian 的初始值为𝐽𝑘 = 𝐼。 这里计算出来的𝐽𝑘+1只是为了给后面提供对 bias 的Jacobian。<br>协方差的迭代公式为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151831375.png#pic_center"></p><p>其中， 初始值𝑃𝑘 = 0。 Q 为表示噪声项的对角协方差矩阵：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151847412.png#pic_center"></p><p>相关代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(update_jacobian)<span class="comment">//否更新雅克比矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3d w_x   = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">        Vector3d a_0_x = _acc_0 - linearized_ba;</span><br><span class="line">        Vector3d a_1_x = _acc_1 - linearized_ba;</span><br><span class="line"></span><br><span class="line">        Matrix3d R_w_x, R_a_0_x, R_a_1_x;</span><br><span class="line"></span><br><span class="line">        R_w_x&lt;&lt;     <span class="number">0</span>, -w_x(<span class="number">2</span>),  w_x(<span class="number">1</span>),</span><br><span class="line">                w_x(<span class="number">2</span>),      <span class="number">0</span>, -w_x(<span class="number">0</span>),</span><br><span class="line">               -w_x(<span class="number">1</span>), w_x(<span class="number">0</span>),       <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_0_x&lt;&lt;        <span class="number">0</span>, -a_0_x(<span class="number">2</span>),  a_0_x(<span class="number">1</span>),</span><br><span class="line">                  a_0_x(<span class="number">2</span>),         <span class="number">0</span>, -a_0_x(<span class="number">0</span>),</span><br><span class="line">                 -a_0_x(<span class="number">1</span>),  a_0_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_1_x&lt;&lt;        <span class="number">0</span>, -a_1_x(<span class="number">2</span>),  a_1_x(<span class="number">1</span>),</span><br><span class="line">                  a_1_x(<span class="number">2</span>),         <span class="number">0</span>, -a_1_x(<span class="number">0</span>),</span><br><span class="line">                 -a_1_x(<span class="number">1</span>),  a_1_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        MatrixXd F = MatrixXd::Zero(<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>)   = <span class="number">-0.25</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt * _dt +</span><br><span class="line">                                <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>)   = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>)   = <span class="number">-0.25</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">12</span>)  = <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>)   = Matrix3d::Identity() - R_w_x * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">12</span>)  = <span class="number">-1.0</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>)   = <span class="number">-0.5</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt +</span><br><span class="line">                                <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>)   = <span class="number">-0.5</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">12</span>)  = <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">9</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">12</span>) = Matrix3d::Identity();</span><br><span class="line"></span><br><span class="line">        MatrixXd V = MatrixXd::Zero(<span class="number">15</span>,<span class="number">18</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) =  <span class="number">0.25</span> * delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) =  <span class="number">0.25</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>) =  <span class="number">0.25</span> *  result_delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">9</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) =  <span class="number">0.5</span> * delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>) =  <span class="number">0.5</span> *  result_delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">12</span>)  = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">15</span>) = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step_jacobian = F;</span></span><br><span class="line">        <span class="comment">//step_V = V;</span></span><br><span class="line">        jacobian   = F * jacobian;</span><br><span class="line">        covariance = F * covariance * F.transpose() + V * noise * V.transpose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过预积分误差的递推公式确实可以求出来从$b_k$帧到$b_{k+1}$帧的累积出来的误差大小，但是这个值并没有用，我们在后端需要的是误差对$b_k$ 帧和$b_{k+1}$帧的导数，而误差对$b_k$帧的导数却可以通过上式的雅克比矩阵直接计算出来，至于协方差矩阵是我们进行后端优化计算残差时用马氏距离需要用到。</p><p>公式推导：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181407525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181458844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521325497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521324273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213150727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213209259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/86290941" target="_blank" rel="noopener">VINS-Mono理论学习——IMU预积分 Pre-integration （Jacobian 协方差）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;为了加深理解，参考崔华坤的《VINS论文推导及代码解析》，把相关公式推到一遍。&lt;/p&gt;&lt;p&gt;intergration_base.h：IMU预积分&lt;br&gt;imu_factor.h：IMU残差、雅可比&lt;/p&gt;&lt;h1 id=&quot;IMU-测量方程&quot;&gt;&lt;a href=&quot;#IMU-测量方程&quot; class=&quot;headerlink&quot; title=&quot;IMU 测量方程.&quot;&gt;&lt;/a&gt;IMU 测量方程.&lt;/h1&gt;&lt;p&gt;忽略地球旋转， IMU 测量方程为&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191024214341590.png#pic_center&quot;&gt;&lt;/p&gt;&lt;h1 id=&quot;预积分方程&quot;&gt;&lt;a href=&quot;#预积分方程&quot; class=&quot;headerlink&quot; title=&quot;预积分方程&quot;&gt;&lt;/a&gt;预积分方程&lt;/h1&gt;&lt;h2 id=&quot;IMU-integration-in-world-frame&quot;&gt;&lt;a href=&quot;#IMU-integration-in-world-frame&quot; class=&quot;headerlink&quot; title=&quot;IMU integration in world frame&quot;&gt;&lt;/a&gt;IMU integration in world frame&lt;/h2&gt;&lt;p&gt;将第 k 帧和第 k+1 帧之间的所有 IMU 进行积分，可得第 k+1 帧的位置、速度和旋转&lt;br&gt;（PVQ），作为视觉估计的初始值，这里的旋转采用的四元数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>随机抽样一致RANSAC-Random-Sample-Consensus</title>
    <link href="https://xiao-hu.com.cn/2019/10/24/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4RANSAC-Random-Sample-Consensus/"/>
    <id>https://xiao-hu.com.cn/2019/10/24/随机抽样一致RANSAC-Random-Sample-Consensus/</id>
    <published>2019-10-24T08:40:49.481Z</published>
    <updated>2019-10-30T03:39:20.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h1><p>随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</p><a id="more"></a><h1 id="RANSAC的基本假设："><a href="#RANSAC的基本假设：" class="headerlink" title="RANSAC的基本假设："></a>RANSAC的基本假设：</h1><p>“内群”数据可以通过几组模型的参数来叙述其分布，而“离群”数据则是不适合模型化的数据。<br>数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。<br>RANSAC假定，给定一组（通常很小）的内群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。</p><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><p>这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内群以及离群，其中内群为可以被拟合到线段上的点，而离群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内群的线，因为最小二乘法会受离群影响而影响其结果。而RANSAC，可以只由内群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020160728989.png#pic_center"><br>包含许多离群的一组数据，要找一条最适合的线。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910201607364.png#pic_center"><br>RANSAC找到的线，离群值对结果没影响（蓝色点为内群，红色点为离群）</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RANSAC算法的输入是一组观测数据（往往含有较大的噪声或无效点），一个用于解释观测数据的参数化模型以及一些可信的参数。RANSAC通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证： </p><ol><li>有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出。</li><li>用1中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li><li>如果有足够多的点被归类为假设的局内点，那么估计的模型就足够合理。</li><li>然后，用所有假设的局内点去重新估计模型（譬如使用最小二乘法），因为它仅仅被初始的假设局内点估计过。</li><li>最后，通过估计局内点与模型的错误率来评估模型。</li><li>上述过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为比现有的模型更好而被选用。<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1>伪码形式的算法如下所示：</li></ol><ul><li><p>输入：</p><blockquote><p>data —— 一组观测数据<br>model —— 适应于数据的模型<br>n —— 适用于模型的最少数据个数<br>k —— 算法的迭代次数<br>t —— 用于决定数据是否适应于模型的阀值<br>d —— 判定模型是否适用于数据集的数据数目</p></blockquote></li><li><p>输出：</p><blockquote><p>best_model —— 跟数据最匹配的模型参数（如果没有找到好的模型，返回null）<br>best_consensus_set —— 估计出模型的数据点<br>best_error —— 跟数据相关的估计出的模型错误</p></blockquote><ul><li>iterations = 0<blockquote><p>best_model = null<br>best_consensus_set = null<br>best_error = 无穷大<br>while ( iterations &lt; k )<br>maybe_inliers = 从数据集中随机选择n个点<br>maybe_model = 适合于maybe_inliers的模型参数<br>consensus_set = maybe_inliers</p></blockquote></li></ul></li><li><p>估计的模型就足够合理</p><blockquote><p>for ( 每个数据集中不属于maybe_inliers的点 ）<br>if ( 如果点适合于maybe_model，且错误小于t ）<br>将点添加到consensus_set<br>if （ consensus_set中的元素数目大于d ）<br>已经找到了好的模型，</p></blockquote></li><li><p>现在测试该模型到底有多好</p><blockquote><p>better_model = 适合于consensus_set中所有点的模型参数<br>this_error = better_model究竟如何适合这些点的度量<br>if ( this_error &lt; best_error )<br>我们发现了比以前好的模型，保存该模型直到更好的模型出现<br>best_model =  better_model<br>best_consensus_set = consensus_set<br>best_error =  this_error</p></blockquote></li><li><p>迭代</p><blockquote><p>增加迭代次数<br>返回 best_model, best_consensus_set, best_error</p></blockquote><p> RANSAC算法的可能变化包括以下几种：</p><ol><li><p>如果发现了一种足够好的模型（该模型有足够小的错误率），则跳出主循环。这样可能会节约计算额外参数的时间。</p><ol><li>直接从maybe_model计算this_error，而不从consensus_set重新估计模型。这样可能会节约比较两种模型错误的时间，但可能会对噪声更敏感。</li></ol><p>其实核心就是随机性和假设性。随机性用于减少计算了，那个循环次数就是利用正确数据出现的概率。所谓的假设性，就是说随机抽出来的数据我都认为是正确的，并以此去计算其他点，获得其他满足变换关系的点，然后利用投票机制，选出获票最多的那一个变换。</p></li></ol></li></ul><h1 id="参数决定"><a href="#参数决定" class="headerlink" title="参数决定"></a>参数决定</h1><p>假设每个点是真正内群的几率是w，则：</p><ul><li>w = 真正内群的数目 / 数据总共的数量</li></ul><p>通常我们不知道w 是多少，$w^{n}$是所选择的n 个点都是内群的几率，$1-w^{n}$ 是所选择的 n 个点至少有一个不是内群的几率， ${(1-w^{n})^{k}}$是表示重复k 次都没有全部的 {\displaystyle n} n 个点都是内群的几率，假设算法跑 k 次以后成功的几率是p，那么：</p><script type="math/tex; mode=display">{1-p=(1-w^{n})^{k}}</script><script type="math/tex; mode=display">{p=1-(1-w^{n})^{k}}</script><p>所以如果希望成功几率高， ${\displaystyle p=0.99}$， 当n 不变时，k 越大， {\displaystyle p} p 越大， 当w 不变时，n 越大，所需的k 就越大， 通常w 未知，所以 n 选小一点比较好。</p><h1 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h1><ul><li>RANSAC的优点是它能鲁棒的估计模型参数。例如，它能从包含大量局外点的数据集中估计出高精度的参数。</li><li>RANSAC的缺点是它计算参数的迭代次数没有上限；如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。</li><li>RANSAC只有一定的概率得到可信的模型，概率与迭代次数成正比。RANSAC的另一个缺点是它要求设置跟问题相关的阀值。</li><li>RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</li></ul><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/pi9nc/article/details/26596519" target="_blank" rel="noopener">RANSAC</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E6%8A%BD%E6%A8%A3%E4%B8%80%E8%87%B4" target="_blank" rel="noopener">随机抽样一致</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;算法简介：&quot;&gt;&lt;a href=&quot;#算法简介：&quot; class=&quot;headerlink&quot; title=&quot;算法简介：&quot;&gt;&lt;/a&gt;算法简介：&lt;/h1&gt;&lt;p&gt;随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/VSLAM/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>IMU测量模型、运动模型、误差模型</title>
    <link href="https://xiao-hu.com.cn/2019/10/24/IMU%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B%E3%80%81%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E3%80%81%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://xiao-hu.com.cn/2019/10/24/IMU测量模型、运动模型、误差模型/</id>
    <published>2019-10-24T08:40:07.344Z</published>
    <updated>2019-10-30T03:38:12.513Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IMU测量模型"><a href="#IMU测量模型" class="headerlink" title="IMU测量模型"></a>IMU测量模型</h1><ul><li><p>MEMS 加速度计工作原理<br>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示<br>加速度计测量值$a_m$为弹簧拉力对应的加速度</p><script type="math/tex; mode=display">a_m=\frac{f}{m}=a-g</script><p>其中m为质量块质量，a为物体在世界（惯性）坐标系下的实际加速度。</p></li><li><p>陀螺仪测量原理<br>陀螺仪的测量值即为IMU在body坐标系下的旋转角速度，要通过运动学模型转换到惯性坐标系下 ，按测量原理分有振动陀螺，光纤陀螺等。</p><p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 Coriolisforce 来间接得到角速度。</p><blockquote><p>在旋转坐标系中，运动的物体受到科氏力作用<br>MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017192448388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h1 id="IMU运动模型"><a href="#IMU运动模型" class="headerlink" title="IMU运动模型"></a>IMU运动模型</h1><h2 id="旋转量求导"><a href="#旋转量求导" class="headerlink" title="旋转量求导"></a>旋转量求导</h2><p>首先，如下图所示，考虑一个从原点出发的向量 r 绕单位轴 u 旋转，角速度大小为 θ˙。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017155511191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>角速度矢量可以表示为${\boldsymbol \omega}=\dot{\theta}u$，易得向量 r 末端点 P 的速度矢量，即 r的时间一阶导为</p><script type="math/tex; mode=display">\frac{d{r}}{dt} = {\boldsymbol \omega} \times {r}</script><p>坐标系 {B} 绕单位轴 u 旋转，如上所述，其三个轴的时间一阶导同样为</p><script type="math/tex; mode=display">\frac{d{\bf i}_B}{dt} = {\boldsymbol \omega} \times {\bf i}_B, \frac{d{\bf j}_B}{dt} = {\boldsymbol \omega} \times {\bf j}_B, \frac{d{\bf k}_B}{dt} = {\boldsymbol \omega} \times {\bf k}_B</script><p>$[ {\bf i}_B \quad {\bf j}_B \quad {\bf k}_B ]$ 实际上就是坐标系 {B} 相对于参考坐标系的旋转矩阵 R，R的时间一阶导为</p><script type="math/tex; mode=display">\dot{\bf R} =  [ {\boldsymbol \omega} \times {\bf i}_B \quad {\boldsymbol \omega} \times {\bf j}_B \quad {\boldsymbol \omega} \times {\bf k}_B ] = {\boldsymbol \omega} \times {\bf R}</script><p>叉乘运算可以转化为负对称矩阵的乘法：</p><script type="math/tex; mode=display">\dot{\bf R} = {\boldsymbol \omega}^{\land} {\bf R}</script><p>其中负对称矩阵${\boldsymbol \omega}^{\land}$为</p><script type="math/tex; mode=display">% <![CDATA[\quad {\boldsymbol \omega}^{\land}= \begin{bmatrix}0 & -\omega_3 & \omega_2\\ \omega_3 & 0 & -\omega_1 \\ -\omega_2 & \omega_1 & 0\end{bmatrix} %]]></script><p>这里的角速度 ω 是在参考坐标系下表达的，角速度也经常表达在体坐标系 {B} 下，记为${}^B{\boldsymbol \omega} = {\bf R}^T{\boldsymbol \omega}$，即${\boldsymbol \omega} = {\bf R}{}^B{\boldsymbol \omega}$<br>上式也可以写作：</p><script type="math/tex; mode=display">\dot{\bf R} =w^{\land}R=(R^Bw)^{\land}R=R{}^{\land}wR^TR= R({}^Bw)^{\land}</script></blockquote></li></ul><a id="more"></a><blockquote><p>证：对任意旋转矩阵 R 和三维向量 v，都有$({\bf R v})^{\land} = {\bf Rv^{\land}R}^T$<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017160718789.png#pic_center"><br>最后一式利用向量叉乘的旋转变换不变性可证，即，对于任意${\bf v,u}\in \mathbb{R}^3$永远有</p><script type="math/tex; mode=display">({\bf Rv})\times({\bf Ru})={\bf R(v\times u)}</script><p>从三维几何的角度来理解：v,u 是任意两个三维向量，(v×u) 是一个和 v,u 都垂直、大小为 |v||u|sin(u,v) 的三维向量；将 v,u,v×u 三个向量都经过同一个旋转，它们的相对位姿和模长都不会改变，所以 (Rv) 和 (Ru) 的叉乘仍是 R(v×u)。</p></blockquote><h2 id="科氏加速度"><a href="#科氏加速度" class="headerlink" title="科氏加速度"></a>科氏加速度</h2><p>这次把绕惯性系 {A} 中固定单位轴 u 旋转的 {B} 作为参考坐标系。考虑下图， 点 P 相对于 {B} 运动，记 ${}^Br$ 分别为 P 在 {B} 下的坐标，r 为 P 的绝对坐标（即 {A} 下坐标）， R 仍为 {B} 相对于 {A} 的旋转矩阵，易知 $r=R{}^Br$。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017163839187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$r=R{}^Br$求一阶时间导</p><script type="math/tex; mode=display">{\bf v} = \dot{\bf r} = \dot{\bf R} {}^B{\bf r} + {\bf R}^B\dot{\bf r} = {\boldsymbol \omega}^{\land}{\bf R}{}^B{\bf r}+ {\bf R}^B\dot{\bf r}</script><p>记P在 {B}下速度为 ${}^Bv$，于是</p><script type="math/tex; mode=display">v = w^{\land}r+ {R}^B{}= w \times r+ v_r</script><p>${\bf v}_r$来表达「相对速度」的概念，准确定义为 P 相对于 {B} 的速度，在惯性系 {A} 下的表达<br>再对求时间导：</p><blockquote><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017165037235.png#pic_center"><br>在旋转坐标系下观察，运动的物体（运动方向和旋转轴不为同一个轴时）会受到科氏力的作用。</p><ul><li>第一项中${\boldsymbol \alpha}$为 {B} 的角加速度，所以第一项的物理意义是 {B} 旋转所造成的 P 的切向加速度</li><li>第二项是 {B} 旋转所造成的向心加速度</li><li>第三项比较特殊，为 {B} 的旋转运动与 P 相对 {B} 的平移运动耦合产生的加速度，称为科氏加速度</li><li>第四项为 P 相对于 {B} 的加速度，但在惯性系{A}下表达，类似于${\bf v}_r$</li></ul></blockquote><h1 id="IMU-误差模型"><a href="#IMU-误差模型" class="headerlink" title="IMU 误差模型"></a>IMU 误差模型</h1><p>加速度计和陀螺仪的误差可以分为：确定性误差，随机误差。</p><ul><li>确定性误差可以事先标定确定，包括： bias, scale …</li><li>随机误差通常假设噪声服从高斯分布，包括：高斯白噪声， bias<br>随机游走…<h2 id="确定性误差"><a href="#确定性误差" class="headerlink" title="确定性误差"></a>确定性误差</h2></li></ul><ol><li>Bias ，Scale<br>理论上，当没有外部作用时， IMU 传感器的输出应该为 0，但实际数据存在一个偏置 b。</li></ol><ul><li>加速度计 bias 对位姿估计的影响：<script type="math/tex; mode=display">v_err=b_at，p_err=\frac{1}{2}b_at^2</script></li><li>scale 可以看成是实际数值和传感器输出值之间的比值</li></ul><ol><li>Nonorthogonality/Misalignment Errors(非正交/错位错误）<br><img alt data-src="https://img-blog.csdnimg.cn/20191017182956354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"> </li><li>其他确定性误差<blockquote><ul><li>Run-to-Run Bias/Scale Facto</li><li>In Run (Stability) Bias/Scale Factor</li><li>Temperature-Dependent Bias/Scale Factor</li></ul></blockquote></li></ol><h3 id="确定性误差误差标定"><a href="#确定性误差误差标定" class="headerlink" title="确定性误差误差标定"></a>确定性误差误差标定</h3><h4 id="六面法标定加速度"><a href="#六面法标定加速度" class="headerlink" title="六面法标定加速度"></a>六面法标定加速度</h4><p><strong>bias 和 scale factor</strong></p><blockquote><p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。如果各个轴都是正交的，那很容易得到 bias 和 scale：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017171617729.png#pic_center"><br>其中,$l$为加速度计某个轴的测量值， g为当地的重力加速度</p></blockquote><p><strong>（Nonorthogonality/Misalignment Errors)</strong></p><blockquote><p>多轴 IMU 传感器制作的时候，由于制作工艺的问题，会使得 xyz 轴可能不垂直，如下图所示。</p><p>考虑轴间误差的时候，实际加速度和测量值之间的关系为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172240109.png#pic_center"><br>水平静止放置 6 面的时候，加速度的理论值为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172303634.png#pic_center"><br>对应的测量值矩阵 L ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172326866.png#pic_center"><br>利用最小二乘就能够把12个变量求出来。</p></blockquote><h4 id="六面法标定陀螺仪"><a href="#六面法标定陀螺仪" class="headerlink" title="六面法标定陀螺仪"></a>六面法标定陀螺仪</h4><blockquote><ul><li>六面法标定陀螺仪 bias 和 scale factor<br>和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这<br>里的 6 面是指各个轴顺时针和逆时针旋转。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017182109980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>参考：<a href="https://blog.csdn.net/CSDN_XCS/article/details/90339761" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_XCS/article/details/90339761</a></li></ul></blockquote><h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><ul><li>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</li><li>两种标定方法：<blockquote><p>• soak method: 控制恒温室的温度值，然后读取传感器数值进行标定。<br>• ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</p></blockquote></li></ul><h2 id="随机误差"><a href="#随机误差" class="headerlink" title="随机误差"></a>随机误差</h2><h3 id="高斯白噪声与随机游走"><a href="#高斯白噪声与随机游走" class="headerlink" title="高斯白噪声与随机游走"></a>高斯白噪声与随机游走</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数。故把瞬时值的概率分布服从高斯分布，功率谱密度服从均匀分布的噪声称为高斯白噪声</p><p>IMU 数据连续时间上受到一个均值为 0，方差为 $σ^2$，各时刻之间相互独立的高斯过程 n(t)：</p><script type="math/tex; mode=display">E[n(t)]=0</script><script type="math/tex; mode=display">E[n(t_1​)n(t_2​)]=σ^2δ(t_1​−t_2​)</script><p>自相关函数的数学定义：$R(τ)=∫^{−∞}_∞　x(t)x(t−τ)dt$</p><p>其中 $δ()$ 表示狄拉克函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190929113450104.png#pic_center"><br><strong>白噪声的离散化</strong><br>实际上， IMU 传感器获取的数据为离散采样，离散和连续高斯白噪声的方差之间存在如下转换关系：</p><script type="math/tex; mode=display">n_d[k] \triangleq n(t_0+\Delta t)\simeq\frac{1}{\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)dt</script><script type="math/tex; mode=display"> \begin{aligned}E(n_d[k]^2) & = E(\frac{1}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)n(t)d \tau dt) \\&= E( \frac{\sigma^2}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\&= E(\frac{\sigma^2}{\Delta t})\end{aligned}</script><p>即:</p><script type="math/tex; mode=display">nd[k] = σ_dw[k]</script><p>其中：$w[k] ∼ N(0, 1)$，$\sigma_d=\sigma \frac{1}{\sqrt{\bigtriangleup t}}$<br>也就是说高斯白噪声的连续时间到离散时间之间差一个 $\frac{1}{\sqrt{\bigtriangleup t}}$ ，√∆t 是传感器的采样时间。</p><h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走</p><script type="math/tex; mode=display">\dot{b}_{(t)}=n(t)=\sigma_bw(t)</script><p>其中 w 是方差为 1 的白噪声</p><p>离散和连续之间的转换：</p><script type="math/tex; mode=display">b_d[k] \triangleq b(t_0) + \int_{t_0}^{t_0+\Delta t}n(t)dt$$$$\begin{aligned}E((b_d[k]-b_d[k-1])^2) &=E(\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(t)n(\tau)d \tau dt)\\&= E({\sigma_{b}^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\&= E(\sigma_{b}^2\Delta t)\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">b_d[k] = b_d[k − 1] + σ_{bd}w[k]</script><p>其中：</p><script type="math/tex; mode=display">w[k] ∼ N(0, 1),σ_{bd} = σ_b\sqrt{\bigtriangleup t}</script><p>bias 随机游走的噪声方差从连续时间到离散之间需要乘以 $\sqrt{\bigtriangleup t}$ </p><h3 id="随机误差的标定"><a href="#随机误差的标定" class="headerlink" title="随机误差的标定"></a>随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><p>Allan 方差法是 20 世纪 60 年代由美国国家标准局的 David Allan 提出的，它是一种基于时域的分析方法。</p><blockquote><p>具体的流程如下：</p><ol><li>保持传感器绝对静止获取数据</li><li>对数据进行分段，设定时间段的时长，如下图所示<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204504508.png#pic_center"></li><li>将传感器数据按照时间段进行平均</li><li>计算方差，绘制艾伦曲线，得到的艾伦曲线如下图所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204557636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">Allan方差法可用于5种随机误差的标定：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017212131103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/YunLaowang/article/details/95608107" target="_blank" rel="noopener">VIO标定IMU随机误差：Allan方差法</a><br><a href="https://blog.csdn.net/lei1105034103/article/details/89159459" target="_blank" rel="noopener">陀螺 Allan 方差分析</a></li></ol></blockquote><h2 id="IMU-数学模型"><a href="#IMU-数学模型" class="headerlink" title="IMU 数学模型"></a>IMU 数学模型</h2><p>以 ECI 为参考坐标系（由于 ECI 为惯性系，不需要考虑地球自转）：<br>忽略 scale 的影响，只考虑白噪声和 bias 随机游走：<br>IMU的真实值：$w^b,a^b$<br>IMU的测量值：$\widetilde{w},\widetilde{a}^b$<br>IMU机体系即b系，w系表示世界坐标系。</p><script type="math/tex; mode=display">\begin{aligned} \widetilde{w}&=w^b +b^g+n^g\\ \widetilde{a}^b&=a^b+b^a+n^a\\&=q_{bw}(a^w+g^w)+b^a+n^a \end{aligned}</script><p>考虑高斯白噪声项，有：</p><script type="math/tex; mode=display">\begin{aligned} &w^b=\widetilde{w} -b^g-n^g\\ &a^w=q_{wb}(\widetilde{a}^b-b^a-n^a)-g^w \end{aligned}</script><p>不考虑高斯白噪声项，有：</p><script type="math/tex; mode=display">\begin{aligned} &w^b=\widetilde{w} -b^g\\ &a^w=q_{wb}(\widetilde{a}^b-b^a)-g^w \end{aligned}</script><p>参考：<a href="https://fzheng.me/2016/11/20/imu_model_eq/#1-2-%E5%89%8D%E7%BD%AE2-%E5%9B%9B%E5%85%83%E6%95%B0" target="_blank" rel="noopener">从零开始的 IMU 状态模型推导</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;IMU测量模型&quot;&gt;&lt;a href=&quot;#IMU测量模型&quot; class=&quot;headerlink&quot; title=&quot;IMU测量模型&quot;&gt;&lt;/a&gt;IMU测量模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MEMS 加速度计工作原理&lt;br&gt;测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示&lt;br&gt;加速度计测量值$a_m$为弹簧拉力对应的加速度&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;a_m=\frac{f}{m}=a-g&lt;/script&gt;&lt;p&gt;其中m为质量块质量，a为物体在世界（惯性）坐标系下的实际加速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;陀螺仪测量原理&lt;br&gt;陀螺仪的测量值即为IMU在body坐标系下的旋转角速度，要通过运动学模型转换到惯性坐标系下 ，按测量原理分有振动陀螺，光纤陀螺等。&lt;/p&gt;
&lt;p&gt;低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 Coriolisforce 来间接得到角速度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在旋转坐标系中，运动的物体受到科氏力作用&lt;br&gt;MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191017192448388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;IMU运动模型&quot;&gt;&lt;a href=&quot;#IMU运动模型&quot; class=&quot;headerlink&quot; title=&quot;IMU运动模型&quot;&gt;&lt;/a&gt;IMU运动模型&lt;/h1&gt;&lt;h2 id=&quot;旋转量求导&quot;&gt;&lt;a href=&quot;#旋转量求导&quot; class=&quot;headerlink&quot; title=&quot;旋转量求导&quot;&gt;&lt;/a&gt;旋转量求导&lt;/h2&gt;&lt;p&gt;首先，如下图所示，考虑一个从原点出发的向量 r 绕单位轴 u 旋转，角速度大小为 θ˙。&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191017155511191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70&quot;&gt;&lt;br&gt;角速度矢量可以表示为${\boldsymbol \omega}=\dot{\theta}u$，易得向量 r 末端点 P 的速度矢量，即 r的时间一阶导为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{d{r}}{dt} = {\boldsymbol \omega} \times {r}&lt;/script&gt;&lt;p&gt;坐标系 {B} 绕单位轴 u 旋转，如上所述，其三个轴的时间一阶导同样为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{d{\bf i}_B}{dt} = {\boldsymbol \omega} \times {\bf i}_B, \frac{d{\bf j}_B}{dt} = {\boldsymbol \omega} \times {\bf j}_B, \frac{d{\bf k}_B}{dt} = {\boldsymbol \omega} \times {\bf k}_B&lt;/script&gt;&lt;p&gt;$[ {\bf i}_B \quad {\bf j}_B \quad {\bf k}_B ]$ 实际上就是坐标系 {B} 相对于参考坐标系的旋转矩阵 R，R的时间一阶导为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot{\bf R} =  [ {\boldsymbol \omega} \times {\bf i}_B \quad {\boldsymbol \omega} \times {\bf j}_B \quad {\boldsymbol \omega} \times {\bf k}_B ] = {\boldsymbol \omega} \times {\bf R}&lt;/script&gt;&lt;p&gt;叉乘运算可以转化为负对称矩阵的乘法：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot{\bf R} = {\boldsymbol \omega}^{\land} {\bf R}&lt;/script&gt;&lt;p&gt;其中负对称矩阵${\boldsymbol \omega}^{\land}$为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\quad {\boldsymbol \omega}^{\land}= \begin{bmatrix}0 &amp; -\omega_3 &amp; \omega_2\\ \omega_3 &amp; 0 &amp; -\omega_1 \\ -\omega_2 &amp; \omega_1 &amp; 0\end{bmatrix} %]]&gt;&lt;/script&gt;&lt;p&gt;这里的角速度 ω 是在参考坐标系下表达的，角速度也经常表达在体坐标系 {B} 下，记为${}^B{\boldsymbol \omega} = {\bf R}^T{\boldsymbol \omega}$，即${\boldsymbol \omega} = {\bf R}{}^B{\boldsymbol \omega}$&lt;br&gt;上式也可以写作：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot{\bf R} =w^{\land}R=(R^Bw)^{\land}R=R{}^{\land}wR^TR= R({}^Bw)^{\land}&lt;/script&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
      <category term="VIO" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/VIO/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
      <category term="VIO" scheme="https://xiao-hu.com.cn/tags/VIO/"/>
    
  </entry>
  
  <entry>
    <title>VINS-Mono——视觉前段处理</title>
    <link href="https://xiao-hu.com.cn/2019/10/23/VINS-Mono%E2%80%94%E2%80%94%E8%A7%86%E8%A7%89%E5%89%8D%E6%AE%B5%E5%A4%84%E7%90%86/"/>
    <id>https://xiao-hu.com.cn/2019/10/23/VINS-Mono——视觉前段处理/</id>
    <published>2019-10-23T14:15:34.000Z</published>
    <updated>2019-10-30T03:40:17.876Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h1><p>每当进入新的图像，都会使用KLT稀疏光流法进行跟踪，同时提取100-300个角点信息，我的理解是角点是用来建立图像，光流跟踪是用来快速定位。同时在这里还进行了关键帧的选取（注意这一过程在代码中是由vins_estimate文件中实现的），主要是两个剔除关键帧的策略，分别是平均视差法和跟踪质量法。平均视差法：如果当前帧的和上一个关键帧跟踪点的平均视差超出了一个设定的阈值，就将当前帧设为关键帧。这里有一个问题，就是旋转和平移都会产生视差（不只是平移哦），当出现纯旋转的时候特征点无法被三角化，无法计算出旋转值，也就无法计算跟踪点间的平均视差，为了解决这一问题，采用短时的陀螺仪观测值来补偿旋转，从而计算出视差，这一过程只应用到平均视差的计算，不会影响真实的旋转结果。</p><a id="more"></a><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023190400778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="节点概览"><a href="#节点概览" class="headerlink" title="节点概览"></a>节点概览</h1><p>该节点的功能是：接收图像数据，进行角点提取和光流跟踪，输出跟踪的特征点（角点）。feature_tracker_node的消息订阅发布如下表：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023221410832.png"></p><h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>主要负责图像角点提取和光流跟踪，主要是三个源程序，分别是feature_tracker、feature_tracker_node以及parameters。feature_tracker_node是特征跟踪线程的系统入口，feature_tracker是特征跟踪算法的具体实现，parameters是设备等参数的读取和存放。</p><h2 id="程序入口main-函数"><a href="#程序入口main-函数" class="headerlink" title="程序入口main()函数"></a>程序入口main()函数</h2><ul><li>1、ros初始化和设置句柄，设置logger级别</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"feature_tracker"</span>);</span><br><span class="line">ros::<span class="function">NodeHandle <span class="title">n</span><span class="params">(<span class="string">"~"</span>)</span></span>;</span><br><span class="line">ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info);</span><br></pre></td></tr></table></figure><ul><li>2、readParameters(n);读取参数，如config-&gt;euroc-&gt;euroc_config.yaml中的一些配置参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readParameters(n);</span><br></pre></td></tr></table></figure><ul><li>3、读取每个相机实例读取对应的相机内参，NUM_OF_CAM=1为单目</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++) </span><br><span class="line">       trackerData[i].readIntrinsicParameter(CAM_NAMES[i]);</span><br></pre></td></tr></table></figure><p>节点在启动时会先读取相机内参，根据config_file文件中model_type的值决定采用何种相机模型，并创建相应模型的对象指针，读取在该模型下需要的参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readIntrinsicParameter(<span class="keyword">const</span> <span class="built_in">string</span> &amp;calib_file)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"reading paramerter of camera %s"</span>, calib_file.c_str());</span><br><span class="line">    m_camera = CameraFactory::instance()-&gt;generateCameraFromYamlFile(calib_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">CameraPtr</span><br><span class="line">CameraFactory::generateCameraFromYamlFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span><br><span class="line">&#123;</span><br><span class="line">    cv::<span class="function">FileStorage <span class="title">fs</span><span class="params">(filename, cv::FileStorage::READ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fs.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> CameraPtr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Camera::ModelType modelType = Camera::MEI;</span><br><span class="line">    <span class="keyword">if</span> (!fs[<span class="string">"model_type"</span>].isNone())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sModelType;</span><br><span class="line">        fs[<span class="string">"model_type"</span>] &gt;&gt; sModelType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//卡特鱼眼相机</span></span><br><span class="line">        <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"kannala_brandt"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::KANNALA_BRANDT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"mei"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::MEI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"scaramuzza"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::SCARAMUZZA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"pinhole"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::PINHOLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"# ERROR: Unknown camera model: "</span> &lt;&lt; sModelType &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> CameraPtr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (modelType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> Camera::KANNALA_BRANDT:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">EquidistantCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> EquidistantCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        EquidistantCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::PINHOLE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">PinholeCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> PinholeCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        PinholeCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::SCARAMUZZA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">OCAMCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> OCAMCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        OCAMCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::MEI:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">CataCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> CataCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        CataCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CameraPtr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、判断是否加入鱼眼mask来去除边缘噪声</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FISHEYE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//FISHEYE_MASK  fisheye_mask.jpg 路径</span></span><br><span class="line">        trackerData[i].fisheye_mask = cv::imread(FISHEYE_MASK, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!trackerData[i].fisheye_mask.data)</span><br><span class="line">        &#123;</span><br><span class="line">            ROS_INFO(<span class="string">"load mask fail"</span>);</span><br><span class="line">            ROS_BREAK();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ROS_INFO(<span class="string">"load mask success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>5、订阅话题IMAGE_TOPIC(如/cam0/image_raw)，执行回调函数img_callback，对新来的图像进行特征点追踪、处理和发布<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub_img = n.subscribe(IMAGE_TOPIC, <span class="number">100</span>, img_callback);</span><br></pre></td></tr></table></figure></li></ul><p>单目时：FeatureTracker::readImage() 函数读取图像数据进行处理<br>单目i=0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readImage(<span class="keyword">const</span> cv::Mat &amp;_img, <span class="keyword">double</span> _cur_time)</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat img;</span><br><span class="line">    TicToc t_r;</span><br><span class="line">    cur_time = _cur_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (EQUALIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">        cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">        TicToc t_c;</span><br><span class="line">        clahe-&gt;apply(_img, img);</span><br><span class="line">        ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        img = _img;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">        prev_img = cur_img = forw_img = img;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forw_img = img;</span><br><span class="line"></span><br><span class="line">    forw_pts.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_pts.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TicToc t_o;</span><br><span class="line">        <span class="built_in">vector</span>&lt;uchar&gt; status;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; err;</span><br><span class="line">        cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">            <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">                status[i] = <span class="number">0</span>;</span><br><span class="line">        reduceVector(prev_pts, status);</span><br><span class="line">        reduceVector(cur_pts, status);</span><br><span class="line">        reduceVector(forw_pts, status);</span><br><span class="line">        reduceVector(ids, status);</span><br><span class="line">        reduceVector(cur_un_pts, status);</span><br><span class="line">        reduceVector(track_cnt, status);</span><br><span class="line">        ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : track_cnt)</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectWithF();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">        TicToc t_m;</span><br><span class="line">        setMask();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">        TicToc <span class="keyword">t_t</span>;</span><br><span class="line">        <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">        <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mask.empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n_pts.clear();</span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">        TicToc t_a;</span><br><span class="line">        addPoints();</span><br><span class="line">        ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    prev_img = cur_img;</span><br><span class="line">    prev_pts = cur_pts;</span><br><span class="line">    prev_un_pts = cur_un_pts;</span><br><span class="line">    cur_img = forw_img;</span><br><span class="line">    cur_pts = forw_pts;</span><br><span class="line">    undistortedPoints();</span><br><span class="line">    prev_time = cur_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6、发布feature，实例feature_points，跟踪的特征点，给后端优化用<br>发布feature_img，实例ptr，跟踪的特征点图，给RVIZ用和调试用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub_img = n.advertise&lt;sensor_msgs::PointCloud&gt;(<span class="string">"feature"</span>, <span class="number">1000</span>);</span><br><span class="line">pub_match = n.advertise&lt;sensor_msgs::Image&gt;(<span class="string">"feature_img"</span>,<span class="number">1000</span>);</span><br><span class="line">pub_restart = n.advertise&lt;std_msgs::Bool&gt;(<span class="string">"restart"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="回调函数img-callback"><a href="#回调函数img-callback" class="headerlink" title="回调函数img_callback()"></a>回调函数img_callback()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">img_callback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;img_msg)</span></span></span><br></pre></td></tr></table></figure><p>该函数是ROS的回调函数，主要功能包括：readImage()函数对新来的图像使用光流法进行特征点跟踪，并将追踪的特征点封装成feature_points发布到pub_img的话题下，将图像封装成ptr发布在pub_match下。</p><ul><li>1、判断是否是第一帧</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为第一帧</span></span><br><span class="line"><span class="keyword">if</span>(first_image_flag)</span><br><span class="line">&#123;</span><br><span class="line">    first_image_flag = <span class="literal">false</span>;</span><br><span class="line">    first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    last_image_time  = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、判断时间间隔是否正确，有问题则restart</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (img_msg-&gt;header.stamp.toSec() - last_image_time &gt; <span class="number">1.0</span> || img_msg-&gt;header.stamp.toSec() &lt; last_image_time)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_WARN(<span class="string">"image discontinue! reset the feature tracker!"</span>);</span><br><span class="line">    first_image_flag = <span class="literal">true</span>; </span><br><span class="line">    last_image_time = <span class="number">0</span>;</span><br><span class="line">    pub_count = <span class="number">1</span>;</span><br><span class="line">    std_msgs::Bool restart_flag;</span><br><span class="line">    restart_flag.data = <span class="literal">true</span>;</span><br><span class="line">    pub_restart.publish(restart_flag);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、发布频率控制，并不是每读入一帧图像，就要发布特征点，通过判断间隔时间内的发布次数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> tmp_freq = <span class="number">1.0</span> * pub_count / (img_msg-&gt;header.stamp.toSec() - first_image_time);</span><br><span class="line"> <span class="keyword">if</span> (round(tmp_freq) &lt;= FREQ)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//PUB_THIS_FRAME 是否需要发布特征点</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">// // 时间间隔内的发布频率十分接近设定频率时，更新时间间隔起始时刻，并将数据发布次数置0</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp_freq - FREQ) &lt; <span class="number">0.01</span> * FREQ)</span><br><span class="line">     &#123;</span><br><span class="line">         first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">         pub_count = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>4、将图像编码8UC1转换为mono8</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cv_bridge::CvImageConstPtr ptr;</span><br><span class="line"><span class="keyword">if</span> (img_msg-&gt;encoding == <span class="string">"8UC1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将图像编码8UC1转换为mono8</span></span><br><span class="line">    sensor_msgs::Image img;</span><br><span class="line">    img.header = img_msg-&gt;header;</span><br><span class="line">    img.height = img_msg-&gt;height;</span><br><span class="line">    img.width = img_msg-&gt;width;</span><br><span class="line">    img.is_bigendian = img_msg-&gt;is_bigendian;</span><br><span class="line">    img.step = img_msg-&gt;step;</span><br><span class="line">    img.data = img_msg-&gt;data;</span><br><span class="line">    img.encoding = <span class="string">"mono8"</span>;</span><br><span class="line">    ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);</span><br></pre></td></tr></table></figure><ul><li>5、单目时：FeatureTracker::readImage() 函数读取图像数据进行处理</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"processing camera %d"</span>, i);</span><br><span class="line">    <span class="comment">//双目跟踪则为1,单目false</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span> || !STEREO_TRACK) <span class="comment">// 针对单目相机读入图像，进入KLT跟踪阶段</span></span><br><span class="line">        <span class="comment">//ROW = fsSettings["image_height"]  rowRange和colRange函数可以获取某些范围内行或列的指针</span></span><br><span class="line">        trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure><ul><li>6、更新特征点ID</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> completed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_OF_CAM; j++)</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span> || !STEREO_TRACK)</span><br><span class="line">                <span class="comment">////更新特征点id</span></span><br><span class="line">                completed |= trackerData[j].updateID(i);</span><br><span class="line">        <span class="keyword">if</span> (!completed)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始FeatureTracker::n_id = 0;id初始化-1</span></span><br><span class="line"><span class="keyword">bool</span> FeatureTracker::updateID(<span class="keyword">unsigned</span> <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; ids.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ids[i] == <span class="number">-1</span>)</span><br><span class="line">            ids[i] = n_id++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7、如果PUB_THIS_FRAME=1则进行发布<blockquote><ul><li>将特征点id，矫正后归一化平面的3D点(x,y,z=1)，像素2D点(u,v)，像素的速度(vx,vy)，封装成sensor_msgs::PointCloudPtr类型的feature_points实例中,发布到pub_img;</li><li>将图像封装到cv_bridge::cvtColor类型的ptr实例中发布到pub_match</li></ul></blockquote></li></ul><h2 id="图像特征跟踪FeatureTracker-readImage"><a href="#图像特征跟踪FeatureTracker-readImage" class="headerlink" title="图像特征跟踪FeatureTracker::readImage()"></a>图像特征跟踪FeatureTracker::readImage()</h2><ul><li>1、通过EQUALIZE值判断是否进行自适应直方图均衡化，如果EQUALIZE=1（表示太亮或则太暗)，调用cv::CLAHE对图像做直方图均衡化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果EQUALIZE=1，表示太亮或则太暗</span></span><br><span class="line"><span class="keyword">if</span> (EQUALIZE)<span class="comment">//判断是否进行直方图均衡化处理</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">    cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">    TicToc t_c;</span><br><span class="line">    clahe-&gt;apply(_img, img);</span><br><span class="line">    ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    img = _img;</span><br></pre></td></tr></table></figure><ul><li>2、 区分是否为第一次读取</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">    <span class="comment">//如果当前帧的图像数据forw_img为空，说明当前是第一次读入图像数据</span></span><br><span class="line">    <span class="comment">//将读入的图像赋给前帧forw_img</span></span><br><span class="line">    <span class="comment">//同时，还将读入的图像赋给prev_img、cur_img，这是为了避免后面使用到这些数据时，它们是空的</span></span><br><span class="line">    prev_img = cur_img = forw_img = img;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则，说明之前就已经有图像读入</span></span><br><span class="line">    <span class="comment">//所以只需要更新前帧forw_img的数据</span></span><br><span class="line">    forw_img = img;</span><br></pre></td></tr></table></figure><ul><li>3、calcOpticalFlowPyrLK() 从cur_pts到forw_pts做LK金字塔光流法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用cv::calcOpticalFlowPyrLK()对前一帧的特征点cur_pts进行LK金字塔光流跟踪，得到forw_pts</span></span><br><span class="line"><span class="comment">//status标记了从前一帧cur_img到forw_img特征点的跟踪状态，无法被追踪到的点标记为0</span></span><br><span class="line">cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>4、根据status，把跟踪失败的和位于图像边界外的点剔除，剔除时不仅要从当前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts、cur_pts，记录特征点id的ids，和记录特征点被跟踪次数的track_cnt中剔除；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//将位于图像边界外的点标记为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">        <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">            status[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据status,把跟踪失败的点剔除</span></span><br><span class="line">    <span class="comment">//不仅要从前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts和cur_pts中剔除</span></span><br><span class="line">    <span class="comment">//prev_pts和cur_pts中的特征点是一一对应的</span></span><br><span class="line">    <span class="comment">//记录特征点id的ids，和记录特征点被跟踪次数的track_cnt也要剔除</span></span><br><span class="line">    reduceVector(prev_pts, status);</span><br><span class="line">    reduceVector(cur_pts, status);</span><br><span class="line">    reduceVector(forw_pts, status);</span><br><span class="line">    reduceVector(ids, status);</span><br><span class="line">    reduceVector(cur_un_pts, status);</span><br><span class="line">    reduceVector(track_cnt, status);</span><br><span class="line">    ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>5、根据PUB_THIS_FRAME是否发布特征，<ul><li>如果不需要发布特征点,则到这步就完了,把当前帧forw赋给上一帧cur, 然后退出 </li><li>如果发布特征：<blockquote><p>1、先调用rejectWithF()对prev_pts和forw_pts做ransac剔除outlier.(实际就是调用了findFundamentalMat函数), 在光流追踪成功就记被追踪+1，数值代表被追踪的次数，数值越大，说明被追踪的就越久<br>2、调用setMask(), 先对跟踪点forw_pts按跟踪次数降排序, 然后依次选点, 选一个点, 在mask中将该点周围一定半径的区域设为0, 后面不再选取该区域内的点. 有点类似与non-max suppression, 但区别是这里保留track_cnt最高的点<br>3、在mask中不为0的区域,调用goodFeaturesToTrack() 寻找新的特征点(shi-tomasi角点)，添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点<br>4、通过addPoints()函数push到forw_pts中, id初始化-1,track_cnt初始化为1.</p></blockquote></li></ul></li></ul><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//主要是通过基本矩阵（F）去除外点outliers</span></span><br><span class="line">    rejectWithF();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">    TicToc t_m;</span><br><span class="line">    <span class="comment">//对跟踪点进行排序并去除密集点。</span></span><br><span class="line">    setMask();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">    TicToc <span class="keyword">t_t</span>;</span><br><span class="line">    <span class="comment">//计算是否需要提取新的特征点,MAX_CNT:特征点最大个数150</span></span><br><span class="line">    <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">    <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MIN_DIST:特征点之间的最小间隔30</span></span><br><span class="line">        <span class="comment">//寻找新的特征点(shi-tomasi角点),添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点</span></span><br><span class="line">        cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">    &#125;</span><br><span class="line">                  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n_pts.clear();</span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">    TicToc t_a;</span><br><span class="line">    <span class="comment">//添将新检测到的特征点n_pts添加到forw_pts中，id初始化-1,track_cnt初始化为1.</span></span><br><span class="line">    addPoints();</span><br><span class="line">    ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>6、undistortedPoints() 对特征点的图像坐标根据不同的相机模型进行去畸变矫正和深度归一化，计算每个角点的速度</li></ul><p>待写！！！</p><p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/85797156" target="_blank" rel="noopener">VINS-Mono代码解读——视觉跟踪 feature_trackers</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719401" target="_blank" rel="noopener">VINS理论与代码详解2——单目视觉跟踪</a><br><a href="https://blog.csdn.net/q597967420/article/details/76099425" target="_blank" rel="noopener">VINS-Mono源码解析（二）前端：特征跟踪</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;论文：&quot;&gt;&lt;a href=&quot;#论文：&quot; class=&quot;headerlink&quot; title=&quot;论文：&quot;&gt;&lt;/a&gt;论文：&lt;/h1&gt;&lt;p&gt;每当进入新的图像，都会使用KLT稀疏光流法进行跟踪，同时提取100-300个角点信息，我的理解是角点是用来建立图像，光流跟踪是用来快速定位。同时在这里还进行了关键帧的选取（注意这一过程在代码中是由vins_estimate文件中实现的），主要是两个剔除关键帧的策略，分别是平均视差法和跟踪质量法。平均视差法：如果当前帧的和上一个关键帧跟踪点的平均视差超出了一个设定的阈值，就将当前帧设为关键帧。这里有一个问题，就是旋转和平移都会产生视差（不只是平移哦），当出现纯旋转的时候特征点无法被三角化，无法计算出旋转值，也就无法计算跟踪点间的平均视差，为了解决这一问题，采用短时的陀螺仪观测值来补偿旋转，从而计算出视差，这一过程只应用到平均视差的计算，不会影响真实的旋转结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
  </entry>
  
  <entry>
    <title>hexo4.0 - Next7.2.4 主题优化配置</title>
    <link href="https://xiao-hu.com.cn/2019/10/23/hexo4.0%20-%20Next7.2.4%20%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiao-hu.com.cn/2019/10/23/hexo4.0 - Next7.2.4 主题优化配置/</id>
    <published>2019-10-23T14:15:34.000Z</published>
    <updated>2019-10-29T13:19:19.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Next主题的安装"><a href="#Next主题的安装" class="headerlink" title="Next主题的安装"></a>Next主题的安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo_blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后设置站点配置文件_config.yml，Hexo博客主题替换为Next主题。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022101546332.png#pic_center">.</p><h1 id="Next主题优化配置"><a href="#Next主题优化配置" class="headerlink" title="Next主题优化配置"></a>Next主题优化配置</h1><h2 id="1-Next主题风格："><a href="#1-Next主题风格：" class="headerlink" title="1.Next主题风格："></a>1.Next主题风格：</h2><a id="more"></a><p>Next提供了四中主题风格scheme，可以在主题配置文件blog/themes/next/_config.yml文件中进行选择，分别是Muse、Mist、Pisces、Gemini：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022102034549.png#pic_center"></p><ul><li>Next主题一般配置：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation. Introduced in NexT v6.0.0.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment">#表示添加缓存功能，这样浏览器后续打开我们的博客网站会更快</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons / item badges.</span></span><br><span class="line">menu_settings:</span><br><span class="line">  icons: <span class="literal">true</span>  <span class="comment">#是否显示各个页面的图标</span></span><br><span class="line">  badges: <span class="literal">false</span> <span class="comment">#是否显示分类/标签/归档页的内容量</span></span><br></pre></td></tr></table></figure><p>相应的站点配置blog/_config.yml文件的基本配置为：</p><h2 id="2-添加博客自定义图标"><a href="#2-添加博客自定义图标" class="headerlink" title="2.添加博客自定义图标"></a>2.添加博客自定义图标</h2><p>选择或者创建相应大小的图标文件，放置在blog/themes/next/sources/images目录下，并在主题配置文件中进行如下配置，只需要设置small和medium两个就可以：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022104457616.png#pic_center"></p><h2 id="3-添加动态背景"><a href="#3-添加动态背景" class="headerlink" title="3.添加动态背景"></a>3.添加动态背景</h2><p>打开 next/layout/_layout.swig<br>在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>修改配置文件，打开 /next/_config.yml,在里面添加如下代码：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022145253296.png#pic_center">.</p><h2 id="4-添加看板娘"><a href="#4-添加看板娘" class="headerlink" title="4.添加看板娘"></a>4.添加看板娘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>下载模型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install live2d-widget-model-wanko</span><br></pre></td></tr></table></figure><h2 id="5-鼠标点击特效"><a href="#5-鼠标点击特效" class="headerlink" title="5.鼠标点击特效"></a>5.鼠标点击特效</h2><p>鼠标的点击红心特效<br>在/themes/next/source/js/src下新建文件clicklove.js ，接着把下面的代码拷贝粘贴到 love.js 文件中：<br>7.4 next没有src文件夹，先建一个src文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(e,t,a)&#123;<span class="keyword">function</span> <span class="function"><span class="title">n</span></span>()&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="keyword">function</span> <span class="function"><span class="title">r</span></span>()&#123;<span class="keyword">for</span>(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="keyword">function</span> <span class="function"><span class="title">o</span></span>()&#123;var t=<span class="string">"function"</span>==typeof e.onclick&amp;&amp;e.onclick;e.onclick=<span class="keyword">function</span>(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="keyword">function</span> i(e)&#123;var a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;<span class="keyword">function</span> c(e)&#123;var a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[0].appendChild(a)&#125;<span class="keyword">function</span> <span class="function"><span class="title">s</span></span>()&#123;<span class="built_in">return</span><span class="string">"rgb("</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">")"</span>&#125;var d=[];e.requestAnimationFrame=<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="keyword">function</span>(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure></p><p>在\themes\next\layout_layout.swig文件末尾添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clicklove.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="6-设置头像"><a href="#6-设置头像" class="headerlink" title="6.设置头像"></a>6.设置头像</h2><p>在主题配置文件中设置头像，将其放置到 themes/next/source/images/avatar.png 路径，rounded是否设置成圆形，rotated是否设置成可旋转的。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022134436646.png#pic_center"></p><h2 id="7-设置RSS订阅"><a href="#7-设置RSS订阅" class="headerlink" title="7.设置RSS订阅"></a>7.设置RSS订阅</h2><p>博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>打开根目录配置文件_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure><p>然后设置主题配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure><h2 id="8-侧边栏社交小图标设置"><a href="#8-侧边栏社交小图标设置" class="headerlink" title="8.侧边栏社交小图标设置"></a>8.侧边栏社交小图标设置</h2><p>打开主题配置文件_config.yml，command+f搜索 Social，将你有的社交账号前面的 # 号去掉。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022135427340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h2 id="9-Tag-标签前图标修改"><a href="#9-Tag-标签前图标修改" class="headerlink" title="9.Tag 标签前图标修改"></a>9.Tag 标签前图标修改</h2><p>文章标签的显示默认前面“#”号，可以通过设置将“#”换为图标。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag_icon: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="10-访问量统计"><a href="#10-访问量统计" class="headerlink" title="10.访问量统计"></a>10.访问量统计</h2><ul><li>打开themes/next/下的_config.yml，查找busuanzi<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</li><li>打开/themes/next/layout/_partials/footer.swig，在最后添加如下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span><br><span class="line">  本站访问次数：&lt;span class=<span class="string">"busuanzi-value"</span> id=<span class="string">"busuanzi_value_site_pv"</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-实现文章统计功能"><a href="#11-实现文章统计功能" class="headerlink" title="11.实现文章统计功能"></a>11.实现文章统计功能</h2><p>统计字数和阅读分钟数<br>安装 hexo-symbols-count-time，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>在站点配置文件 hexo _config.yaml添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  time: <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  total_symbols: <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  total_time: <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  exclude_codeblock: <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure><p>具体可查看：<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a><br>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022142919746.png#pic_center"></p><h2 id="12-添加网页顶部进度加载条"><a href="#12-添加网页顶部进度加载条" class="headerlink" title="12.添加网页顶部进度加载条"></a>12.添加网页顶部进度加载条</h2><p>下载安装Progress module，如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure></p><p>编辑主题配置文件，command+F 搜索 pace，将其值改为 ture 就可以了。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022144354865.png#pic_center"></p><h2 id="13-添加站内搜索"><a href="#13-添加站内搜索" class="headerlink" title="13.添加站内搜索"></a>13.添加站内搜索</h2><p>安装 hexo-generator-search<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><br>安装 hexo-generator-searchdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑站点配置文件，添加以下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure><br>编辑主题配置文件，设置 local_search为 ture<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102215014852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h2 id="14-Footer-页脚设置"><a href="#14-Footer-页脚设置" class="headerlink" title="14.Footer / 页脚设置"></a>14.Footer / 页脚设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  icon:</span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    name: user</span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="comment">## 图标的一个动画效果，类似于心跳</span></span><br><span class="line">    animated: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="comment"># 图标颜色，可格局需要自行修改</span></span><br><span class="line">    color: <span class="string">"#808080"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo 字样，不喜欢可以设置为 false</span></span><br><span class="line">  powered:</span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 主题字样，不喜欢可以 false</span></span><br><span class="line">  theme:</span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="comment"># 备案信息，如果网站有备案号，可以在这里填写备案号</span></span><br><span class="line">  beian:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">    icp:</span><br></pre></td></tr></table></figure><h2 id="15-Creative-Commons-文章版权"><a href="#15-Creative-Commons-文章版权" class="headerlink" title="15.Creative Commons / 文章版权"></a>15.Creative Commons / 文章版权</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-nd</span><br><span class="line">  post: <span class="literal">true</span></span><br><span class="line">  language: deed.zh</span><br></pre></td></tr></table></figure><p>在文章 .md 文件中的上部，添加 copyright: true。</p><h2 id="16-设置阅读全文"><a href="#16-设置阅读全文" class="headerlink" title="16.设置阅读全文"></a>16.设置阅读全文</h2><p>打开主题配置文件，修改auto_excerpt:字段为true，length表示显示文本的长度<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022151038529.png#pic_center"><br>在想要隐藏的位置加入以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p><h2 id="17-开启文章目录"><a href="#17-开启文章目录" class="headerlink" title="17.开启文章目录"></a>17.开启文章目录</h2><p>修改主题配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line">toc:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  number: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  wrap: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  expand_all: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure><h2 id="18-GitHub-Fork-Me"><a href="#18-GitHub-Fork-Me" class="headerlink" title="18.GitHub Fork Me"></a>18.GitHub Fork Me</h2><p>修改主题配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line">github_banner:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  permalink: https://github.com/Xiao-Hu-Z</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure><p>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022161748244.png#pic_center"></p><h2 id="19-bookmark"><a href="#19-bookmark" class="headerlink" title="19.bookmark"></a>19.bookmark</h2><p>Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bookmark:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.</span></span><br><span class="line">  color: <span class="string">"#222"</span></span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure><h2 id="20-添加lazyload"><a href="#20-添加lazyload" class="headerlink" title="20. 添加lazyload"></a>20. 添加lazyload</h2><p>对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-jquery-lazyload <span class="built_in">source</span>/lib/jquery_lazyload</span><br></pre></td></tr></table></figure><br>主题配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Vanilla JavaScript plugin for lazyloading images.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/ApoorvSaxena/lozad.js</span></span><br><span class="line">lazyload: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="21-代码复制"><a href="#21-代码复制" class="headerlink" title="21.代码复制"></a>21.代码复制</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line">copy_button:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="22-SEO支持"><a href="#22-SEO支持" class="headerlink" title="22.SEO支持"></a>22.SEO支持</h2><p>SEO(Search Engine Optimization)意为搜索引擎优化,利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</p><ul><li>安装站点地图(sitemap)插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><ul><li>站点配置文件修改/添加</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SEO </span></span><br><span class="line">sitemap: </span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>启用百度推送功能，博客会自动将网址推送到百度，这对搜索引擎优化非常有帮助。<br>主题配置文件修改 baidu_push: true</p><h2 id="23-显示当前浏览进度"><a href="#23-显示当前浏览进度" class="headerlink" title="23.显示当前浏览进度"></a>23.显示当前浏览进度</h2><p>打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true ，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Scroll percent label in b2t button.# # 是否显示页面浏览百分比</span><br><span class="line">scrollpercent: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h1><h2 id="1-支持数学公式"><a href="#1-支持数学公式" class="headerlink" title="1.支持数学公式"></a>1.支持数学公式</h2><p>可能在一些情况下我们需要写一个公式，makdown是支持的，next也支持。</p><p>Next 主题提供了两个渲染引擎，分别是 mathjax 和katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations。" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/math-equations。</a></p><p>这里选择 mathjax ,通过修改配置即可启用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>注意：使用的时候需要在 文章开头加上mathjax: true</p><ul><li><h1 id="解决语义冲突"><a href="#解决语义冲突" class="headerlink" title="解决语义冲突"></a>解决语义冲突</h1><p>由于LaTeX与markdown语法有语义冲突，在markdown中，斜体和加粗可以用<em>或者_表示，在这里我们修改变量，将_用于LaTeX，而使用</em>表示markdown中的斜体和加粗。<br>在博客根目录下，进入node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>同时把第20行的em变量也要做相应的修改:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  em: /^<span class="symbol">\b</span>_((?:__|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br><span class="line">em: /^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line"><span class="attr">  mathjax:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line"><span class="attr">    mhchem:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-添加APlayer音乐播放器"><a href="#2-添加APlayer音乐播放器" class="headerlink" title="2.添加APlayer音乐播放器"></a>2.添加APlayer音乐播放器</h2><p>为博客添加音乐播放器功能</p><p><strong>download</strong><br>点击访问Aplayer源码：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">GitHub Aplayer</a>。下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下。</p><p><strong>music.js</strong><br>新建themes\next\source\dist\music.js文件，添加内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const ap = new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(<span class="string">'aplayer'</span>),</span><br><span class="line">    fixed: <span class="literal">true</span>,</span><br><span class="line">    autoplay: <span class="literal">true</span>,</span><br><span class="line">    audio: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"暗涌"</span>,</span><br><span class="line">        artist: <span class="string">'王菲'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/52980.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/w8RFsMH8VJfPsBmVudYGsA==/109951163020569833.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Wonderful U'</span>,</span><br><span class="line">        artist: <span class="string">'AGA'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/51181.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Blb_Gi0AJTWIEBLr189F4A==/18791753232142320.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'浮夸'</span>,</span><br><span class="line">        artist: <span class="string">'陈奕迅'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/49639.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Bl1hEdJbMSj5YJsTqUjr-w==/109951163520311175.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>源码参数解释<a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">APlayer 中文文档</a></p><p>audio对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：<a href="http://up.mcyt.net/" target="_blank" rel="noopener">http://up.mcyt.net/</a> ，搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。</p><p><strong>_layout.swig</strong><br>打开themes\next\layout_layout.swig文件,在<body><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body> 里面添加以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"aplayer"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/APlayer.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/music.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>重新生成，访问页面，就能看到左下角的音乐播放器了。</p><h2 id="3-DaoVoice在线联系功能"><a href="#3-DaoVoice在线联系功能" class="headerlink" title="3.DaoVoice在线联系功能"></a>3.DaoVoice在线联系功能</h2><p><a href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/" target="_blank" rel="noopener">https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/</a></p><h1 id="自定义样式支持"><a href="#自定义样式支持" class="headerlink" title="自定义样式支持"></a>自定义样式支持</h1><h2 id="1-文章末尾统一添加“本文结束”标记"><a href="#1-文章末尾统一添加“本文结束”标记" class="headerlink" title="1.文章末尾统一添加“本文结束”标记"></a>1.文章末尾统一添加“本文结束”标记</h2><p>主题配置文件取消注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  postBodyEnd: <span class="built_in">source</span>/_data/post-body-end.swig</span><br></pre></td></tr></table></figure><p>接着打开\themes\next\layout_macro\post.swig文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在路径 /source/_data 下创建/修改 post-body-end.swig文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------本文结束&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-主题及标题栏背景图"><a href="#2-主题及标题栏背景图" class="headerlink" title="2.主题及标题栏背景图"></a>2.主题及标题栏背景图</h2><p>首先主题配置文件取消注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure><p> 在路径~/hexo_blog/source/_data创建/修改 styles.styl文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line">body &#123;</span><br><span class="line">      background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址</span><br><span class="line">      background-size: cover;</span><br><span class="line">      background-repeat: no-repeat;</span><br><span class="line">      background-attachment: fixed;</span><br><span class="line">      background-position: 50% 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 标题栏背景</span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: 20px 0;</span><br><span class="line">    color: <span class="comment">#fff;</span></span><br><span class="line">    background: <span class="variable">$blue</span>;</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:center;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 修改主体透明度</span><br><span class="line">.main-inner&#123;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    opacity: 0.95;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改菜单栏透明度，会引起本地搜索菜单bug</span><br><span class="line">//.header-inner &#123;</span><br><span class="line">//    opacity: 0.95;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 主页文章添加阴影效果</span><br><span class="line">.post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-修改主副标题字体颜色"><a href="#3-修改主副标题字体颜色" class="headerlink" title="3.修改主副标题字体颜色"></a>3.修改主副标题字体颜色</h2><p>继续在/source/_data/styles.styl文件中添加，帮你挑选颜色的网站： <a href="https://www.color-hex.com/" target="_blank" rel="noopener">color-hex</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主标题颜色</span></span><br><span class="line">.brand&#123;</span><br><span class="line">    color: $white</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//副标题颜色</span></span><br><span class="line">.site-subtitle &#123;</span><br><span class="line">    margin-top: <span class="number">10</span>px;</span><br><span class="line">    font-size: <span class="number">13</span>px;</span><br><span class="line">    color: <span class="meta">#ffffff;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-修改按钮，选择区域，代码块，表格等样式"><a href="#4-修改按钮，选择区域，代码块，表格等样式" class="headerlink" title="4.修改按钮，选择区域，代码块，表格等样式"></a>4.修改按钮，选择区域，代码块，表格等样式</h2><p>首先主题配置文件取消注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/variables.styl</span><br></pre></td></tr></table></figure><p>在路径 /source/_data 下创建/修改 variables.styl文件（相当于修改主题文件 next/source/css/_variables/base.styl），并添加以下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buttons</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$btn-<span class="keyword">default</span>-bg                 = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-color              = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-font-size          = $font-size-small;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-width       = <span class="number">2</span>px;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-color       = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-bg           = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-color        = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-border-color = #<span class="number">49b</span>1f5;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Selection</span></span><br><span class="line">$selection-bg                 = #<span class="number">49b</span>1f5;</span><br><span class="line">$selection-color              = white;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code &amp; Code Blocks</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$code-font-family               = $font-family-monospace;</span><br><span class="line">$code-border-radius             = <span class="number">3</span>px;</span><br><span class="line">$code-foreground                = $black-light;</span><br><span class="line">$code-background                = #edf1ff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Table</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$table-width                    = normal;  <span class="comment">//next默认100%</span></span><br><span class="line">$table-border-color             = $gray-lighter;</span><br><span class="line">$table-font-size                = $font-size-small;</span><br><span class="line">$table-content-alignment        = left;</span><br><span class="line">$table-content-vertical         = middle;</span><br><span class="line">$table-th-font-weight           = <span class="number">700</span>;</span><br><span class="line">$table-cell-padding             = <span class="number">8</span>px;</span><br><span class="line">$table-cell-border-right-color  = $gainsboro;</span><br><span class="line">$table-cell-border-bottom-color = $gray-lighter;</span><br><span class="line">$table-row-odd-bg-color         = #f9f9f9;</span><br><span class="line">$table-row-hover-bg-color       = $whitesmoke;</span><br></pre></td></tr></table></figure><h1 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h1><h2 id="托管-Hexo-博客到-Coding"><a href="#托管-Hexo-博客到-Coding" class="headerlink" title="托管 Hexo 博客到 Coding"></a>托管 Hexo 博客到 Coding</h2><p>注意：coding账号注册时请选择个人版（如果注册了团队版，你会发现跟网上给的教程不太一样，而且，部署出来的网页地址无法修改成xxx.coding.me）。</p><ul><li>创建项目<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027145840374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li><li>配置SSH公钥<br>首先点击右上角的头像-个人设置-SSH公钥-新增公匙-输入你自己的SSH公匙-永久有效(推荐)-确定即可。</li><li>修改站点配置文件<br>对该配置进行修改如下(注意缩进)：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">    coding: git@git.dev.tencent.com:Xiao-Hu-Z/Xiao-Hu-Z.coding.me.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>该配置指定了Coding仓库的地址，并通过HTTPS方式进行连接。同样我们也可以通过SSH方式。<br>安装完成后，开始项目的部署操作，用的是HTTPS方式，会弹出输入用户名密码的输入框，键入你的coding用户名密码即可。</p><h2 id="gulp-4-0实现静态资源压缩"><a href="#gulp-4-0实现静态资源压缩" class="headerlink" title="gulp 4.0实现静态资源压缩"></a>gulp 4.0实现静态资源压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install gulp</span><br></pre></td></tr></table></figure><ul><li>安装这些功能模块</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</span><br></pre></td></tr></table></figure><ul><li>创建任务在站点根目录下新建gulpfile.js文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">//Plugins模块获取</span><br><span class="line">var minifycss = require(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line">var uglify = require(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">var htmlmin = require(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line">var htmlclean = require(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line">//压缩css</span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">//压缩html</span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">.pipe(htmlclean())</span><br><span class="line">.pipe(htmlmin(&#123;</span><br><span class="line">removeComments: <span class="literal">true</span>,</span><br><span class="line">minifyJS: <span class="literal">true</span>,</span><br><span class="line">minifyCSS: <span class="literal">true</span>,</span><br><span class="line">minifyURLs: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩js 不压缩min.js</span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.0以前的写法</span><br><span class="line">//gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">  //  <span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span></span><br><span class="line">//]);</span><br><span class="line">//4.0以后的写法</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // Do something after a, b, and c are finished.</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_41518277/article/details/101766036#_355" target="_blank" rel="noopener">NexT主题进阶</a><br><a href="https://blog.csdn.net/colton_null/article/details/97622079" target="_blank" rel="noopener">Hexo Theme NexT 主题个性化配置最佳实践</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86556971" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列4-加速Hexo博客</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86538306" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列2-部署博客到Coding上</a><br><a href="https://hanhanhanxu.github.io/2019/05/15/coding/" target="_blank" rel="noopener">使用coding加快博客网站访问速度</a><br><a href="http://ju.outofmemory.cn/entry/105418" target="_blank" rel="noopener">托管 Hexo 博客到 Coding</a><br><a href="https://www.cnblogs.com/aoguai/p/11405829.html" target="_blank" rel="noopener">2019hexo博客部署到coding该绕的坑</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;Next主题的安装&quot;&gt;&lt;a href=&quot;#Next主题的安装&quot; class=&quot;headerlink&quot; title=&quot;Next主题的安装&quot;&gt;&lt;/a&gt;Next主题的安装&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; hexo_blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/theme-next/hexo-theme-next themes/next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后设置站点配置文件_config.yml，Hexo博客主题替换为Next主题。&lt;br&gt;&lt;img alt=&quot;在这里插入图片描述&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191022101546332.png#pic_center&quot;&gt;.&lt;/p&gt;&lt;h1 id=&quot;Next主题优化配置&quot;&gt;&lt;a href=&quot;#Next主题优化配置&quot; class=&quot;headerlink&quot; title=&quot;Next主题优化配置&quot;&gt;&lt;/a&gt;Next主题优化配置&lt;/h1&gt;&lt;h2 id=&quot;1-Next主题风格：&quot;&gt;&lt;a href=&quot;#1-Next主题风格：&quot; class=&quot;headerlink&quot; title=&quot;1.Next主题风格：&quot;&gt;&lt;/a&gt;1.Next主题风格：&lt;/h2&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://xiao-hu.com.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xiao-hu.com.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16下Github+Hexo搭建博客教程</title>
    <link href="https://xiao-hu.com.cn/2019/10/23/Ubuntu16%E4%B8%8BGithub+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <id>https://xiao-hu.com.cn/2019/10/23/Ubuntu16下Github+Hexo搭建博客教程/</id>
    <published>2019-10-23T14:15:34.000Z</published>
    <updated>2019-10-25T07:02:58.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿博客网址</p><p>==<a href="https://xiao-hu.com.cn/">https://xiao-hu.com.cn/</a>==</p><h1 id="安装git、nodejs"><a href="#安装git、nodejs" class="headerlink" title="安装git、nodejs"></a>安装git、nodejs</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>升级nodejs版本，目前的最新版本v10.6.0<br>参考：<a href="https://blog.csdn.net/u010277553/article/details/80938829" target="_blank" rel="noopener">Ubuntu16 升级nodejs版本</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line"></span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><br>加速下载：<a href="https://blog.csdn.net/ibmall/article/details/81390639" target="_blank" rel="noopener">npm 安装 hexo 卡住问题解决</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init xiaohu</span><br><span class="line"><span class="built_in">cd</span> xiaohu </span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><blockquote><p>   node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p></blockquote><p>再次输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo g <span class="comment">#生成静态页面</span></span><br><span class="line">sudo hexo server <span class="comment">#启动服务器</span></span><br></pre></td></tr></table></figure><blockquote><p>注：这时候就可以用浏览器打开网址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 来进行预览了。</p><h1 id="github创建"><a href="#github创建" class="headerlink" title="github创建"></a>github创建</h1><p>以前创好了：<a href="https://mp.csdn.net/mdeditor/94998475#" target="_blank" rel="noopener">Ubuntu16.04 git安装与配置</a></p><h1 id="创建repo"><a href="#创建repo" class="headerlink" title="创建repo"></a>创建repo</h1><p>在github上面创建一个项目，名为Xiao-Hu-Z+github.io </p><h1 id="将hexo部署到github"><a href="#将hexo部署到github" class="headerlink" title="将hexo部署到github"></a>将hexo部署到github</h1><p>打开站点配置文件_config.yml，翻到最后，进行修改。其中YourgithubName就是你的GitHub账户。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br>deploy时要你输入username和password。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在站点目录下输入下面的插件安装</span></span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo generate</span><br><span class="line">sudo hexo deploy</span><br></pre></td></tr></table></figure><p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p><p>输入：<a href="https://Xiao-Hu-Z.github.io/看到自己的博客" target="_blank" rel="noopener">https://Xiao-Hu-Z.github.io/看到自己的博客</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://Xiao-Hu-Z.github.io/</span><br></pre></td></tr></table></figure><h1 id="绑定域名："><a href="#绑定域名：" class="headerlink" title="绑定域名："></a>绑定域名：</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping Xiao-Hu-Z.github.io</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://www.jianshu.com/p/e3169b681038" target="_blank" rel="noopener">[Hexo个人博客]域名绑定 简明教程（小白篇）</a></p></blockquote><p>参考：<a href="https://blog.csdn.net/zxwsbg/article/details/97487666" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://blog.csdn.net/wang_da_bing/article/details/82818445" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://www.cnblogs.com/yangzhaonan/p/9351838.html" target="_blank" rel="noopener">使用GitHub+Hexo建立个人网站，并绑定自己的域名（Ubuntu环境下）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;﻿博客网址&lt;/p&gt;&lt;p&gt;==&lt;a href=&quot;https://xiao-hu.com.cn/&quot;&gt;https://xiao-hu.com.cn/&lt;/a&gt;==&lt;/p&gt;&lt;h1 id=&quot;安装git、nodejs&quot;&gt;&lt;a href=&quot;#安装git、nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装git、nodejs&quot;&gt;&lt;/a&gt;安装git、nodejs&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install nodejs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install npm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;升级nodejs版本，目前的最新版本v10.6.0&lt;br&gt;参考：&lt;a href=&quot;https://blog.csdn.net/u010277553/article/details/80938829&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu16 升级nodejs版本&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo npm install n -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo n stable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;加速下载：&lt;a href=&quot;https://blog.csdn.net/ibmall/article/details/81390639&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;npm 安装 hexo 卡住问题解决&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm config &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; registry https://registry.npm.taobao.org&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://xiao-hu.com.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xiao-hu.com.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>11.旋转数组的最小数字</title>
    <link href="https://xiao-hu.com.cn/2019/10/22/11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://xiao-hu.com.cn/2019/10/22/11.旋转数组的最小数字/</id>
    <published>2019-10-22T07:16:28.000Z</published>
    <updated>2019-10-30T03:25:17.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目：<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p> <strong>思路1：</strong><br>暴力解法：根据给定的数组特点，从左到右遍历数组元素，当首次遇到数组中某个元素比上一个元素小时，该元素就是我们需要的元素</p><a id="more"></a><p><strong>思路2：</strong></p><ul><li>二分查找：<blockquote><ul><li>用两个指针，分别指向数组的第一个和最后一个元素</li><li>接着找到中间元素，如果中间元素位于前面的递增子数组（中间元素大于或等于第一个元指针指向元素）把第一个指针指向中间元素</li><li>如果中间元素位于后面的递增子数组（中间元素大于或等于第一个元指针指向元素），把第二个指针指向中间元素</li><li>最终，两指针会指向相邻的元素，第二个指针刚好指向是最小元素</li></ul></blockquote></li></ul><p><strong>C++</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[i]&lt;=rotateArray[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>二分查找：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = low;<span class="comment">//防止数组的前面0个元素搬到最后面</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(rotateArray[low]&gt;=rotateArray[high])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(high-low==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid=high;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[low]==rotateArray[high] &amp;&amp; rotateArray[low]==rotateArray[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> result=rotateArray[low];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=high;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rotateArray[i]&lt;result)</span><br><span class="line">                        result=rotateArray[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid]&gt;=rotateArray[low])</span><br><span class="line">                low=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid]&lt;=rotateArray[high])</span><br><span class="line">                high=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Python</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(rotateArray)):</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i<span class="number">-1</span>]&gt;rotateArray[i]):</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        high=len(rotateArray)<span class="number">-1</span></span><br><span class="line">        mid=low</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> rotateArray[low]&gt;=rotateArray[high]:</span><br><span class="line">            <span class="keyword">if</span> high-low==<span class="number">1</span>:</span><br><span class="line">                mid=high</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            mid=(low+high)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[low]==rotateArray[high] <span class="keyword">and</span> rotateArray[low]==rotateArray[mid]:</span><br><span class="line">                result = rotateArray[low]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(low,high+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> result &gt; rotateArray[i]:</span><br><span class="line">                        result = rotateArray[i]</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid]&gt;=rotateArray[low]:</span><br><span class="line">                low=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high=mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;题目：&lt;br&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。&lt;br&gt;NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;&lt;p&gt; &lt;strong&gt;思路1：&lt;/strong&gt;&lt;br&gt;暴力解法：根据给定的数组特点，从左到右遍历数组元素，当首次遇到数组中某个元素比上一个元素小时，该元素就是我们需要的元素&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>10.斐波那契数列（跳台阶）</title>
    <link href="https://xiao-hu.com.cn/2019/10/20/10.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89/"/>
    <id>https://xiao-hu.com.cn/2019/10/20/10.斐波那契数列（跳台阶）/</id>
    <published>2019-10-20T06:16:29.000Z</published>
    <updated>2019-10-30T03:25:19.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿题目一：<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><p>思路</p><ul><li>如果只有一阶台阶，一种跳法，如果只有两阶台阶，两种跳法</li><li>把n阶台阶时的跳法看成n的函数，记法f(n)，f(n)=f(n-1)+f(n-2)</li></ul><p>采用循环方式实现，递归实践效率太低<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result[n];         </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibOne=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibTwo=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fibN=fibOne+fibTwo;</span><br><span class="line">            fibOne=fibTwo;</span><br><span class="line">            fibTwo=fibN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibN;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        result=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> result[n]</span><br><span class="line">        </span><br><span class="line">        f1=<span class="number">1</span></span><br><span class="line">        f2=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            fn=f1+f2</span><br><span class="line">            f1=f2</span><br><span class="line">            f2=fn</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p><strong>相关题目：</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> result[number];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">2</span>,fn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fn=f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=fn;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f=<span class="number">2</span>*f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//return pow(2,number-1);</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;﻿题目一：&lt;br&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法&lt;/p&gt;&lt;p&gt;思路&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;如果只有一阶台阶，一种跳法，如果只有两阶台阶，两种跳法&lt;/li&gt;
&lt;li&gt;把n阶台阶时的跳法看成n的函数，记法f(n)，f(n)=f(n-1)+f(n-2)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;采用循环方式实现，递归实践效率太低&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;climbStairs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; result[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]=&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n&amp;lt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result[n];         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; fibOne=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; fibTwo=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; fibN;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;i&amp;lt;=n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fibN=fibOne+fibTwo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fibOne=fibTwo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fibTwo=fibN;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fibN;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>KLT 光流算法</title>
    <link href="https://xiao-hu.com.cn/2019/10/20/KLT-%E5%85%89%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>https://xiao-hu.com.cn/2019/10/20/KLT-光流算法/</id>
    <published>2019-10-20T05:29:52.000Z</published>
    <updated>2019-10-30T03:40:00.648Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Optical-Flow"><a href="#Optical-Flow" class="headerlink" title="Optical Flow"></a>Optical Flow</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132123717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132137931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="KLT"><a href="#KLT" class="headerlink" title="KLT"></a>KLT</h1><p>KLT 算法本质上也基于光流的三个假设，不同于前述直接比较像素点灰度值的作法，KLT 比较像素点周围的窗口像素，来寻找最相似的像素点。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102013215737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132228980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流—LK光流—基于金字塔分层的LK光流—中值流</a><br><a href="https://leijiezhang001.github.io/KLT/" target="_blank" rel="noopener">KLT 光流算法详解</a><br><a href="https://blog.csdn.net/irobot_davinci/article/details/29635199" target="_blank" rel="noopener">KLT角点跟踪算法(LK)学习（一）——算法原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/"/>
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/categories/VINS-Mono/VSLAM/"/>
    
    
      <category term="VINS-Mono" scheme="https://xiao-hu.com.cn/tags/VINS-Mono/"/>
    
      <category term="VSLAM" scheme="https://xiao-hu.com.cn/tags/VSLAM/"/>
    
  </entry>
  
  <entry>
    <title>9.用两个栈实现队列</title>
    <link href="https://xiao-hu.com.cn/2019/10/20/9.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://xiao-hu.com.cn/2019/10/20/9.用两个栈实现队列/</id>
    <published>2019-10-20T05:16:29.000Z</published>
    <updated>2019-10-30T03:25:24.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：</p><ul><li>首先把元素插入stack1;</li><li>当stack2为空时，把stack1的元素逐个弹出并压入stack2</li><li>当stack2步为空时，在stack2的栈顶元素最先进入队列的元素，可以弹出</li></ul><p><strong>C++</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s.empty();         //如果栈为空则返回true, 否则返回false;</span></span><br><span class="line"><span class="comment">s.size();          //返回栈中元素的个数</span></span><br><span class="line"><span class="comment">s.top();           //返回栈顶元素, 但不删除该元素</span></span><br><span class="line"><span class="comment">s.pop();           //弹出栈顶元素, 但不返回其值</span></span><br><span class="line"><span class="comment">s.push();          //将元素压入栈顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> data=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> head=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Python</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                <span class="comment">#.pop(i)将列表中第i项元素取出并删除该元素</span></span><br><span class="line">                self.stack2.append(self.stack1.pop(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;p&gt;题目描述&lt;br&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;首先把元素插入stack1;&lt;/li&gt;
&lt;li&gt;当stack2为空时，把stack1的元素逐个弹出并压入stack2&lt;/li&gt;
&lt;li&gt;当stack2步为空时，在stack2的栈顶元素最先进入队列的元素，可以弹出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;s.empty();         //如果栈为空则返回true, 否则返回false;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;s.size();          //返回栈中元素的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;s.top();           //返回栈顶元素, 但不删除该元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;s.pop();           //弹出栈顶元素, 但不返回其值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;s.push();          //将元素压入栈顶&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; node)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack1.push(node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stack2.size()==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(stack1.size()&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; data=stack1.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stack2.push(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; head=stack2.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack2.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; stack1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; stack2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://xiao-hu.com.cn/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
</feed>
