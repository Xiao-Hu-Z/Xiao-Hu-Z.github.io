<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>后端优化</title>
    <url>/2019/10/29/VINs-Mono%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="状态向量"><a href="#状态向量" class="headerlink" title="状态向量"></a>状态向量</h1><p>VIO 紧耦合方案的主要思路就是通过将基于视觉构造的残差项和基于 IMU 构造的残差项放在一起构造成一个联合优化的问题，整个优化问题的最优解即可认为是比较准确的状态估计。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192151582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>为了限制优化变量的数目， VINS-Mono 采用了滑动窗口的形式， 滑动窗口中的全状态量包括滑动窗口内的n+1个关键帧时刻 IMU 坐标系的位置、姿态、姿态（旋转）、加速度计偏置、陀螺仪偏置， Camera 到 IMU 的外参， m +1个 3D 路标点的逆深度：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192802133.png#pic_center"><br>优化过程中的误差状态量为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192821349.png#pic_center"></p><a id="more"></a>
<h1 id="代价函数（Minimize-residuals-from-all-sensors）"><a href="#代价函数（Minimize-residuals-from-all-sensors）" class="headerlink" title="代价函数（Minimize residuals from all sensors）"></a>代价函数（Minimize residuals from all sensors）</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192917433.png#pic_center"></p>
<p>其中$P^{b<em>k}</em>{b<em>{k+1}}$为 IMU 预积分噪声项的协方差矩阵， $P^{c_j}_l$为视觉观测噪声的协方差矩阵。<br>三个残差项即误差项分别为边缘化的先验信息、 IMU 测量残差、视觉的重投影残差。三种残差都是用马氏距离表示。<br>根据高斯牛顿法求优化过程中最为核心的增量方程，以 IMU 测量残差为例，先将$r</em>{b}(\hat z^{b<em>k}</em>{b_{k+1}},\chi )$进行一阶泰勒展开</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194020513.png#pic_center"></p>
<p>其中$H^{b<em>k}</em>{b_{k+1}}$是雅可比矩阵</p>
<p>等号右边关于$\delta x$的导数，并令其为 0，得到增量方程：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194351591.png#pic_center"></p>
<p>那么可以写出函数对应的增量方程：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195011958.png#pic_center"></p>
<p>增量方程可进一步简化为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195045773.png#pic_center"></p>
<p>其中$\wedge _p$，$\wedge _B$，$\wedge _C$为（近似的） Hessian 矩阵，上述方程称之为增量方程。</p>
<h1 id="IMU-测量约束"><a href="#IMU-测量约束" class="headerlink" title="IMU 测量约束"></a>IMU 测量约束</h1><h2 id="IMU-测量残差"><a href="#IMU-测量残差" class="headerlink" title="IMU 测量残差"></a>IMU 测量残差</h2><p>根据上面的 IMU 预积分，得到 IMU <strong>预积分残差（估计值 - 测量值）</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195522934.png#pic_center"></p>
<p>其中$[q]<em>{xyz}$表示提取四元数q的虚部，$[\hat \alpha^{b_k}</em>{b<em>{k+1}},\hat \beta ^{b_k}</em>{b<em>{k+1}},\hat \gamma ^{b_k}</em>{b<em>{k+1}}]^T$为关键帧$b_k$和关键帧$b</em>{k+1}$时间间隔内，仅仅使用含有噪声的加速度计和陀螺仪数据计算的预积分 IMU 测量项，$\delta \theta^{b<em>k}</em>{b_{k+1}}$是四元数误差的三维表示。</p>
<h2 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h2><p>对于两帧之间的 IMU 测量残差，待优化变量为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029200304722.png#pic_center"></p>
<h2 id="雅克比矩阵"><a href="#雅克比矩阵" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>高斯迭代优化过程中会用到 IMU 测量残差对状态量的雅克比矩阵，但此处我们是对误差状<br>态量求偏导</p>
<ul>
<li>对k时刻$[\delta p^w<em>{b_k},\delta \theta^w</em>{b_k}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201345442.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta v^w<em>{b_k},\delta b</em>{a<em>k},\delta \theta b</em>{w_{k}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201641707.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta p^w<em>{b</em>{k+1}},\delta \theta^w<em>{b</em>{k+1}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201652448.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta v^w<em>{b</em>{k+1}},\delta b<em>{a</em>{k+1}},\delta \theta b<em>{w</em>{k+1}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201704647.png#pic_center"></p>
<p>上面公式在代码中对应： class IMUFactor : public ceres::SizedCostFunction<15, 9 7, 9,>对于 Evaluate 输入 double const <em>const </em>parameters, parameters[0], parameters[1], parameters[2],parameters[3]分别对应 4 个输入参数, 它们的长度依次是 7,9,7,9， 分别对应 4 个优化变量的参数块。<br>代码 IMUFactor::Evaluate()中 residual 还乘以一个信息矩阵 sqrt_info， 这是因为真正的优化项其实是 Mahalanobis 距离： $d=r^TP^{−1}r$，P 是协方差，又因为 Ceres 只接受最小二乘优化， 也就是$min(e^Te)$所以把𝑃−1做 LLT 分解， 即$LL^T=P^{-1}$, 则有：</15,></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202424429.png#pic_center"></p>
<p>令$r’=L^Tr$作为新的优化误差, 这样就能用 Ceres 求解了。 Mahalanobis 距离其实相当于一个残差加权, 协方差大的加权小, 协方差小的加权大, 着重优化那些比较确定的残差。若写成“sqrt_info.setIdentity()”相当于不加权</p>
<h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>IMU 协方差 P 为前面推导的 IMU 预积分中迭代出来的 IMU 增量误差的协方差。</p>
<h1 id="视觉测量残差"><a href="#视觉测量残差" class="headerlink" title="视觉测量残差"></a>视觉测量残差</h1><p>视觉测量残差即 特征点的重投影误差，视觉残差和雅克比矩阵计算的对应代码在ProjectionFactor::E<br>函数中。</p>
<h2 id="重投影误差（视觉测量残差）"><a href="#重投影误差（视觉测量残差）" class="headerlink" title="重投影误差（视觉测量残差）"></a>重投影误差（视觉测量残差）</h2><p>对于第 i 帧中的特征点, 它投影到第 j 帧相机坐标系下的值为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202633785.png#pic_center"></p>
<p>拆写成三维形式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202722447.png"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202739798.png#pic_center"></p>
<p>为了后面方便求导Jacobian，对$P_{c_j}$拆解，定义如下变量</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202916771.png"></p>
<p>视觉测量残差为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203023784.png#pic_center"></p>
<h2 id="优化变量-1"><a href="#优化变量-1" class="headerlink" title="优化变量"></a>优化变量</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203801125.png#pic_center"></p>
<h2 id="雅克比矩阵-1"><a href="#雅克比矩阵-1" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>根据视觉残差公式，我们可以得到相对于各优化变量的 Jacobian</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203923600.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203934216.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203946932.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102920400339.png"></p>
<h2 id="协方差矩阵-1"><a href="#协方差矩阵-1" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>视觉约束的噪声协方差与标定相机内参时的重投影误差，也就是偏离几个像素有关， 代<br>码对应为 ProjectionTdFactor::sqrt_info， 这里取的 1.5 个像素，信息矩阵取根号后为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029204041242.png#pic_center"></p>
<p><a href="https://blog.csdn.net/weixin_44580210/article/details/95748091" target="_blank" rel="noopener">VINS-Mono关键知识点总结——边缘化marginalization理论和代码详解</a><br><a href="https://blog.csdn.net/weixin_44580210/article/details/93377806" target="_blank" rel="noopener">VINS-Mono关键知识点总结——预积分和后端优化IMU部分</a></p>
]]></content>
      <categories>
        <category>VINS</category>
      </categories>
      <tags>
        <tag>VINS</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——初始化</title>
    <url>/2019/10/29/VINS-Mono%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="估计器初始化"><a href="#估计器初始化" class="headerlink" title="估计器初始化"></a>估计器初始化</h1><ul>
<li>初始化的原因是单目惯性紧耦合系统是一个非线性程度很高的系统，首先单目是无法获得空间中的绝对尺度，而IMU又必然存在偏置，在后面进行求解的时候还需要用到重力加速度（包括大小和方向），对于速度比较敏感的条件下，比如说无人机，又要精确的速度信息，因此，如何有效的在紧耦合系统处理之前计算出这些量，对整个紧耦合系统的鲁棒性有着重大的意义</li>
<li>初始化要做的事其实说起来很简单，就是计算出绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li>
<li>VINS-Mono 的初始化采用松组合（loosely coupled）的方式获取初始值。 首先用 SFM求解滑动窗口内所有帧的位姿（以第一帧作为参考坐标系）和所有路标点的 3D 位置。然后将 SFM 的结果与 IMU 预积分的值进行对齐，实现对陀螺仪偏置的校正，再求解每一帧对应的速度，求解重力向量方向，恢复单目相机的尺度因子。</li>
<li>需要注意的是，在初始化过程中，并没有对加速度计的偏置进行校正，这是因为重力是初始化过程中待求的量，而加速度计偏置与重力耦合，而且系统的加速度相对于重力加速度很小，所以加速度计偏置在初始化过程中很难观测，因此初始化过程中不考虑加速度计偏置的校正。</li>
</ul><a id="more"></a>
<h2 id="滑动窗口-Sliding-Window-纯视觉SfM"><a href="#滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="滑动窗口(Sliding Window)纯视觉SfM"></a>滑动窗口(Sliding Window)纯视觉SfM</h2><p>首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，使用五点法恢复这两个帧之间的相对旋转和尺度平移。否则，将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c<em>0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}</em>{c<em>k}，q^{c0}</em>{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。</p>
<p>纯视觉初始化时，我们采用第一帧 c0 作为基准坐标系，若要转化为从 body 坐标系到 c0坐标系，可以进行如下变换，其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"><br>上式推导如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185549508.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185607797.png#pic_center"></p>
<h2 id="B-视觉惯性校准（Visual-Inertial-Alignment"><a href="#B-视觉惯性校准（Visual-Inertial-Alignment" class="headerlink" title="B. 视觉惯性校准（Visual-Inertial Alignment)"></a>B. 视觉惯性校准（Visual-Inertial Alignment)</h2><h3 id="陀螺仪偏置标定"><a href="#陀螺仪偏置标定" class="headerlink" title="陀螺仪偏置标定"></a>陀螺仪偏置标定</h3><p>这 一 部 分 的 内 容 对 应 于 VINS-Mono 代 码 initial<em>aligment.cpp 中 的<br>solveGyroscopeBias()函数。<br>考虑滑动窗口中连续两帧$b_k$和$b</em>{k+1}$，我们从视觉sfM中得到旋转$q^{c0}<em>{b_k}$和$q^{c0}</em>{b<em>{k+1}}$，从IMU预积分得到的相对约束$γ^{b_k}</em>{b<em>{k+1}}$。<br>陀螺仪的误差有两部分测量噪声和陀螺仪偏置，噪声暂时可以忽略（毕竟太小），而视觉的误差就只有观测噪声（也可以忽略不管），因此两者差值的绝对值就是陀螺仪偏置，将整个滑动窗口的所有的旋转做差构成了一个最小化误差模型：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"><br>其中B代表窗口的所有帧。<br>$q^{c0}</em>{b<em>k}$$q^{c0}</em>{b<em>{k+1}}$：相机从$b_k$到$b</em>{k+1}$下的相对旋转<br>$γ^{b<em>k}</em>{b<em>{k+1}}$：陀螺仪从$b</em>{k+1}$到$b<em>k$下的相对旋转<br>第二个式子给出了$γ^{b_k}</em>{b_{k+1}}$对陀螺仪偏置的一阶近似。</p>
<p>因为四元数最小值为单位四元数 [1; 0v]T，所以<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171134242.png#pic_center"><br>只考虑虚部，则有：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171213618.png#pic_center"></p>
<p>然后取最小二乘，当然也可以使用SVD分解等方法求解，得到了陀螺仪偏置$b<em>w$的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}</em>{b<em>{k+1}}、\hat β^{b_k}</em>{b<em>{k+1}}、\hat γ^{b_k}</em>{b_{k+1}}$ 。</p>
<h3 id="速度、重力向量和尺度初始化："><a href="#速度、重力向量和尺度初始化：" class="headerlink" title="速度、重力向量和尺度初始化："></a>速度、重力向量和尺度初始化：</h3><p>这一部分的内容对应于 VINS-Mono 代码 initial<em>aligment.cpp 中的 LinearAlignment()<br>函数<br>在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"><br>其中，$v^{b_k}</em>{b<em>k}$是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。<br>在$c_0$坐标系的预积分：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180200742.png#pic_center"><br>$p^{c_0}</em>{b<em>{k+1}}$和$p^{c_0}</em>{b<em>{k}}$可由视觉 SFM 获得：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180301129.png#pic_center"><br>将此式带入上式得：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180458901.png#pic_center"><br>将等式中速度都转换到$c_0$ 坐标系下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181635823.png#pic_center"><br>将上式转换成$Hx=b$ 的形式，这样便于利用 cholesky 进行求解，由$s\bar p^{c_0}</em>{b<em>k}=p^{c_0}</em>{c<em>k}-R^{c_0}</em>{c_k}p_c^b$，带入上式得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181106531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>联力等式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181609102.png#pic_center"><br>即： $H^{6×10}X_I^{\ 10×1} = b^{6×1}$<br>H矩阵一定是一个正定对称矩阵，以采用快速的 Cholosky 分解下面方程求解$X_I$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028182207166.png#pic_center"><br>可以得到滑动窗口中所有关键帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及单目尺度因子 s 。</p>
<h3 id="修正重力矢量"><a href="#修正重力矢量" class="headerlink" title="修正重力矢量"></a>修正重力矢量</h3><p>这里计算的重力吸收了重力加速度计的偏置，虽然不需要计算重力加速度计的偏置，但重力还是需要优化的，说到优化重力加速度，肯定包含两个量，大小和方向，也就是三个维度，但是一般来说大小是确定已知的（这里设为9.8），因此其实我们要做的就是优化方向，是一个两维的向量，下图是优化重力的方法以及b1,b2单位向量的方向确定模型。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">将重力向量重新参数化：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183144674.png#pic_center"><br>其中g是已知的重力大小，$\bar {\hat g}$是表示重力方向的单位向量，b1、 b2为重力向量正切空间的一对<br>正交基 ，如图所示，w1和w2分别是在b1和b2上的对应位移。<br>将上式代入前面式子中，重新整理可得：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183424735.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183439415.png"><br>这样，可以用 Cholosky 分解下面方程求解$X_I$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183526590.png#pic_center"></p>
<p>完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028160032562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>直接从estimator.cpp中的 if (solver_flag == INITIAL) 开始</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (solver_flag == INITIAL) &#123;</span><br><span class="line">    <span class="comment">// 滑窗中的Keyframe达到指定大小的时候，才开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (frame_count == WINDOW_SIZE) &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_EXTRINSIC != <span class="number">2</span> &amp;&amp; (header.stamp.toSec() - initial_timestamp) &gt; <span class="number">0.1</span>) &#123;</span><br><span class="line">            result = initialStructure(); <span class="comment">//! 初始化</span></span><br><span class="line">            initial_timestamp = header.stamp.toSec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            solver_flag = NON_LINEAR;</span><br><span class="line">            solveOdometry();</span><br><span class="line">            slideWindow();</span><br><span class="line">            f_manager.removeFailures();</span><br><span class="line">            ROS_INFO(<span class="string">"Initialization finish!"</span>);</span><br><span class="line">            last_R = Rs[WINDOW_SIZE];</span><br><span class="line">            last_P = Ps[WINDOW_SIZE];</span><br><span class="line">            last_R0 = Rs[<span class="number">0</span>];</span><br><span class="line">            last_P0 = Ps[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            slideWindow();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        frame_count++;</span><br></pre></td></tr></table></figure>
<h3 id="initialStructure-视觉惯性联合初始化"><a href="#initialStructure-视觉惯性联合初始化" class="headerlink" title="initialStructure() 视觉惯性联合初始化"></a>initialStructure() 视觉惯性联合初始化</h3><ul>
<li>1.通过计算线加速度的标准差，检测IMU的可观性，以进行初始化<br>注意这里并没有算上all_image_frame的第一帧，所以求均值和标准差的时候要减一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 通过计算预积分加速度的标准差，检测IMU的可观性</span></span><br><span class="line"><span class="comment">//check imu observibility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算均值</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it;</span><br><span class="line">    Vector3d sum_g;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        sum_g += tmp_g;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector3d aver_g = sum_g * <span class="number">1.0</span> / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方差</span></span><br><span class="line">    <span class="keyword">double</span> var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        var += (tmp_g - aver_g).transpose() * (tmp_g - aver_g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算标准差</span></span><br><span class="line">    var = <span class="built_in">sqrt</span>(var / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//ROS_WARN("IMU variation %f!", var);</span></span><br><span class="line">    <span class="keyword">if</span>(var &lt; <span class="number">0.25</span>) <span class="comment">//! 以标准差判断可观性</span></span><br><span class="line">    &#123;</span><br><span class="line">        ROS_INFO(<span class="string">"IMU excitation not enouth!"</span>);</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.将f_manager中的所有feature保存到vector<sfmfeature> sfm_f中，SFMFeature数组中包含了特征点状态（是否被三角化），id，2d点，3d坐标以及深度，将特征管理器中的特征信息保存到SFMFeature对象sfm_f中sfm_f.push_back(tmp_feature)。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SFMFeature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> state;<span class="comment">//状态（是否被三角化）</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,Vector2d&gt;&gt; observation;<span class="comment">//所有观测到该特征点的图像帧ID和图像坐标</span></span><br><span class="line">    <span class="keyword">double</span> position[<span class="number">3</span>];<span class="comment">//3d坐标</span></span><br><span class="line">    <span class="keyword">double</span> depth;<span class="comment">//深度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历滑窗内所有的Features，以vector&lt;SFMFeature&gt;形式保存滑窗内所有特征点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;SFMFeature&gt; sfm_f;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> imu_j = it_per_id.start_frame - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    SFMFeature tmp_feature;</span><br><span class="line">    tmp_feature.state = <span class="literal">false</span>;</span><br><span class="line">    tmp_feature.id = it_per_id.feature_id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_frame : it_per_id.feature_per_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        imu_j++;</span><br><span class="line">        Vector3d pts_j = it_per_frame.point;</span><br><span class="line">        tmp_feature.observation.push_back(make_pair(imu_j, Eigen::Vector2d&#123;pts_j.x(), pts_j.y()&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sfm_f.push_back(tmp_feature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sfmfeature></li>
<li>3.relativePose()恢复出R、t</li>
</ul>
<blockquote>
<p> 1.先通过 FeatureManager::getCorresponding()获取滑动窗口中第i帧和最后一帧的特征匹配corres<br> 2.如果第i帧和最后一帧的特征匹配数corres大于20，且所有匹配的特征点的平均视差大于一定阈值，通过solveRelativeRT（定义在solv_5pts.cpp类中）用五点法求本质矩阵cv::findFundamentalMat 计算出当前帧到参考帧的 T</p>
<p> 值得注意：relativePose得到的位姿是第l帧的，第l帧的筛选是从第一帧开始到滑动窗口所有帧中一开始满足平均视差足够大的帧，这里的第l帧会作为参考帧到下面的全局SFM使用。这样得到图像的特征点2d坐标的提取，相机第l帧和最后一帧之间的旋转和平移</p>
</blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!relativePose(relative_R, relative_T, l))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"Not enough features or parallax; Move device around"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>bool relativePose(relative_R, relative_T, l)</strong><br>   该函数判断每帧到窗口最后一帧对应特征点的平均视差大于30，且内点数目大于12则可进行初始化，同时返回当前帧到第l帧的坐标系变换R和T<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::relativePose(Matrix3d &amp;relative_R, Vector3d &amp;relative_T, <span class="keyword">int</span> &amp;l) &#123;</span><br><span class="line">    <span class="comment">// find previous frame which contians enough correspondance and parallex with newest frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在滑窗内寻找与最新的关键帧共视点超过20(像素点)的关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WINDOW_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">        <span class="comment">//获取第i帧和最后一帧的特征匹配corres</span></span><br><span class="line">        corres = f_manager.getCorresponding(i, WINDOW_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共视的Features应该大于20</span></span><br><span class="line">        <span class="keyword">if</span> (corres.size() &gt; <span class="number">20</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取匹配的特征点在图像上的视差和(归一化平面上)</span></span><br><span class="line">            <span class="keyword">double</span> sum_parallax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(corres.size()); j++) &#123;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_0</span><span class="params">(corres[j].first(<span class="number">0</span>), corres[j].first(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_1</span><span class="params">(corres[j].second(<span class="number">0</span>), corres[j].second(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="keyword">double</span> parallax = (pts_0 - pts_1).norm();</span><br><span class="line">                sum_parallax = sum_parallax + parallax;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取所有匹配的特征点的平均视差</span></span><br><span class="line">            <span class="keyword">double</span> average_parallax = <span class="number">1.0</span> * sum_parallax / <span class="keyword">int</span>(corres.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视差大于一定阈值，并且能够有效地求解出变换矩阵</span></span><br><span class="line">            <span class="keyword">if</span> (average_parallax * <span class="number">460</span> &gt; <span class="number">30</span> &amp;&amp; m_estimator.solveRelativeRT(corres, relative_R, relative_T)) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">                ROS_DEBUG(<span class="string">"average_parallax %f choose l %d and newest frame to triangulate the whole structure"</span>,</span><br><span class="line">                          average_parallax * <span class="number">460</span>, l);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>FeatureManager::getCorresponding()</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; FeatureManager::getCorresponding(<span class="keyword">int</span> frame_count_l, <span class="keyword">int</span> frame_count_r) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : feature) &#123;</span><br><span class="line">        <span class="comment">// 保证两帧的id大于当前特征点的起始id小于当前特征点的终止id</span></span><br><span class="line">        <span class="keyword">if</span> (it.start_frame &lt;= frame_count_l &amp;&amp; it.endFrame() &gt;= frame_count_r) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx_l = frame_count_l - it.start_frame;</span><br><span class="line">            <span class="keyword">int</span> idx_r = frame_count_r - it.start_frame;</span><br><span class="line"></span><br><span class="line">            Vector3d a = it.feature_per_frame[idx_l].point;</span><br><span class="line">            Vector3d b = it.feature_per_frame[idx_r].point;</span><br><span class="line"></span><br><span class="line">            corres.push_back(make_pair(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> corres;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>solveRelativeRT()</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> MotionEstimator::solveRelativeRT(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; &amp;corres, Matrix3d &amp;Rotation, Vector3d &amp;Translation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (corres.size() &gt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! Step1：提取匹配完的Features</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; ll, rr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(corres.size()); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll.push_back(cv::Point2f(corres[i].first(<span class="number">0</span>), corres[i].first(<span class="number">1</span>)));</span><br><span class="line">            rr.push_back(cv::Point2f(corres[i].second(<span class="number">0</span>), corres[i].second(<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::Mat mask;</span><br><span class="line">        <span class="comment">//! Step2：利用Ransac算法计算本质矩阵，内外点的阈值距离设定为0.3 / 460</span></span><br><span class="line">        cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, <span class="number">0.3</span> / <span class="number">460</span>, <span class="number">0.99</span>, mask);</span><br><span class="line"></span><br><span class="line">        cv::Mat cameraMatrix = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step3：计算变换矩阵并得到内点个数</span></span><br><span class="line">        cv::Mat rot, trans;</span><br><span class="line">        <span class="keyword">int</span> inlier_cnt = cv::recoverPose(E, ll, rr, cameraMatrix, rot, trans, mask);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "inlier_cnt " &lt;&lt; inlier_cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 得到变换矩阵 ll ==&gt; rr</span></span><br><span class="line">        Eigen::Matrix3d R;</span><br><span class="line">        Eigen::Vector3d T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            T(i) = trans.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                R(i, j) = rot.at&lt;<span class="keyword">double</span>&gt;(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step4：得到旋转矩阵和平移量 rr ==&gt; ll</span></span><br><span class="line">        Rotation    =  R.transpose();</span><br><span class="line">        Translation = -R.transpose() * T;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 判断求取的内点个数是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(inlier_cnt &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4.对窗口中每个图像帧求解sfm问题，调用sfm.construct(frame_count + 1, Q, T,l,relative_R, relative_T,sfm_f, sfm_tracked_points)估计slidingwindow中所有图像帧相对于参考帧（这里以第l帧作为参考帧）的旋转四元数Q、平移向量T和特征点坐标sfm_tracked_points。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三角化恢复滑窗内的Features</span></span><br><span class="line">GlobalSFM sfm;</span><br><span class="line">Quaterniond Q[frame_count + <span class="number">1</span>];</span><br><span class="line">Vector3d    T[frame_count + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; sfm_tracked_points;</span><br><span class="line"><span class="keyword">if</span>(!sfm.construct(frame_count + <span class="number">1</span>, Q, T, l, relative_R, relative_T, sfm_f, sfm_tracked_points))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"global SFM failed!"</span>);</span><br><span class="line">    marginalization_flag = MARGIN_OLD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool GlobalSFM::construct()</strong><br>函数位于inital_sfm.cpp文件中<br>纯视觉sfm，求解窗口中所有图像帧的位姿QT（相对于第l帧）和特征点坐标sfm_tracked_points<br>frame_num=frame_count + 1=11，frame_num-1表示当前帧</p>
<blockquote>
<p>1.把第l帧看作参考坐标系，根据当前帧到第l帧的relative_R，relative_T，得到当前帧在参考坐标系下的位姿，之后的pose[i]表示第l帧到第i帧的变换矩阵[R|T]<br>2.三角化第l帧（参考帧）与第frame_num-1帧（当前帧）的路标点<br>3.pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中，并与当前帧进行三角化<br>4.对第l帧与从第l+1到frame_num-2的每一帧再进行三角化<br>5.PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化<br>6.三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标<br>7.使用cares进行全局BA优化<br>8.得到的是第l帧坐标系到各帧的变换矩阵，将其转变为每一帧在第l帧坐标系上的位姿<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> GlobalSFM::construct(<span class="keyword">int</span> frame_num, Quaterniond* q, Vector3d* T, <span class="keyword">int</span> l,</span><br><span class="line">			  <span class="keyword">const</span> Matrix3d relative_R, <span class="keyword">const</span> Vector3d relative_T,</span><br><span class="line">			  <span class="built_in">vector</span>&lt;SFMFeature&gt; &amp;sfm_f, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; &amp;sfm_tracked_points)</span><br><span class="line">&#123;</span><br><span class="line">	feature_num = sfm_f.size();</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "set 0 and " &lt;&lt; l &lt;&lt; " as known " &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">// have relative_r relative_t</span></span><br><span class="line">	<span class="comment">// intial two view</span></span><br><span class="line">	q[l].w() = <span class="number">1</span>;</span><br><span class="line">	q[l].x() = <span class="number">0</span>;</span><br><span class="line">	q[l].y() = <span class="number">0</span>;</span><br><span class="line">	q[l].z() = <span class="number">0</span>;</span><br><span class="line">	T[l].setZero();</span><br><span class="line">	q[frame_num - <span class="number">1</span>] = q[l] * Quaterniond(relative_R);</span><br><span class="line">	T[frame_num - <span class="number">1</span>] = relative_T;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "init q_l " &lt;&lt; q[l].w() &lt;&lt; " " &lt;&lt; q[l].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "init t_l " &lt;&lt; T[l].transpose() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//rotate to cam frame</span></span><br><span class="line">	Matrix3d c_Rotation[frame_num];</span><br><span class="line">	Vector3d c_Translation[frame_num];</span><br><span class="line">	Quaterniond c_Quat[frame_num];</span><br><span class="line">	<span class="keyword">double</span> c_rotation[frame_num][<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">double</span> c_translation[frame_num][<span class="number">3</span>];</span><br><span class="line">	Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">4</span>&gt; Pose[frame_num];</span><br><span class="line"></span><br><span class="line">	c_Quat[l] = q[l].inverse();</span><br><span class="line">	c_Rotation[l] = c_Quat[l].toRotationMatrix();</span><br><span class="line">	c_Translation[l] = <span class="number">-1</span> * (c_Rotation[l] * T[l]);</span><br><span class="line">	Pose[l].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[l];</span><br><span class="line">	Pose[l].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[l];</span><br><span class="line"></span><br><span class="line">	c_Quat[frame_num - <span class="number">1</span>] = q[frame_num - <span class="number">1</span>].inverse();</span><br><span class="line">	c_Rotation[frame_num - <span class="number">1</span>] = c_Quat[frame_num - <span class="number">1</span>].toRotationMatrix();</span><br><span class="line">	c_Translation[frame_num - <span class="number">1</span>] = <span class="number">-1</span> * (c_Rotation[frame_num - <span class="number">1</span>] * T[frame_num - <span class="number">1</span>]);</span><br><span class="line">	Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[frame_num - <span class="number">1</span>];</span><br><span class="line">	Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[frame_num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1: trangulate between l ----- frame_num - 1</span></span><br><span class="line">	<span class="comment">//2: solve pnp l + 1; trangulate l + 1 ------- frame_num - 1; </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; frame_num - <span class="number">1</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// solve pnp</span></span><br><span class="line">		<span class="comment">//pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; l)</span><br><span class="line">		&#123;</span><br><span class="line">			Matrix3d R_initial = c_Rotation[i - <span class="number">1</span>];</span><br><span class="line">			Vector3d P_initial = c_Translation[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			c_Rotation[i] = R_initial;</span><br><span class="line">			c_Translation[i] = P_initial;</span><br><span class="line">			c_Quat[i] = c_Rotation[i];</span><br><span class="line">			Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">			Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// triangulate point based on the solve pnp result</span></span><br><span class="line">		triangulateTwoFrames(i, Pose[i], frame_num - <span class="number">1</span>, Pose[frame_num - <span class="number">1</span>], sfm_f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3: triangulate l-----l+1 l+2 ... frame_num -2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; frame_num - <span class="number">1</span>; i++)</span><br><span class="line">		triangulateTwoFrames(l, Pose[l], i, Pose[i], sfm_f);</span><br><span class="line">	<span class="comment">//4: solve pnp l-1; triangulate l-1 ----- l</span></span><br><span class="line">	<span class="comment">//             l-2              l-2 ----- l</span></span><br><span class="line">	<span class="comment">//PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//solve pnp</span></span><br><span class="line">		Matrix3d R_initial = c_Rotation[i + <span class="number">1</span>];</span><br><span class="line">		Vector3d P_initial = c_Translation[i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		c_Rotation[i] = R_initial;</span><br><span class="line">		c_Translation[i] = P_initial;</span><br><span class="line">		c_Quat[i] = c_Rotation[i];</span><br><span class="line">		Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">		Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">		<span class="comment">//triangulate</span></span><br><span class="line">		triangulateTwoFrames(i, Pose[i], l, Pose[l], sfm_f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5: triangulate all other points</span></span><br><span class="line">	<span class="comment">//三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; feature_num; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sfm_f[j].state == <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">int</span>)sfm_f[j].observation.size() &gt;= <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Vector2d point0, point1;</span><br><span class="line">			<span class="keyword">int</span> frame_0 = sfm_f[j].observation[<span class="number">0</span>].first;</span><br><span class="line">			point0 = sfm_f[j].observation[<span class="number">0</span>].second;</span><br><span class="line">			<span class="keyword">int</span> frame_1 = sfm_f[j].observation.back().first;</span><br><span class="line">			point1 = sfm_f[j].observation.back().second;</span><br><span class="line">			Vector3d point_3d;</span><br><span class="line">			triangulatePoint(Pose[frame_0], Pose[frame_1], point0, point1, point_3d);</span><br><span class="line">			sfm_f[j].state = <span class="literal">true</span>;</span><br><span class="line">			sfm_f[j].position[<span class="number">0</span>] = point_3d(<span class="number">0</span>);</span><br><span class="line">			sfm_f[j].position[<span class="number">1</span>] = point_3d(<span class="number">1</span>);</span><br><span class="line">			sfm_f[j].position[<span class="number">2</span>] = point_3d(<span class="number">2</span>);</span><br><span class="line">			<span class="comment">//cout &lt;&lt; "trangulated : " &lt;&lt; frame_0 &lt;&lt; " " &lt;&lt; frame_1 &lt;&lt; "  3d point : "  &lt;&lt; j &lt;&lt; "  " &lt;&lt; point_3d.transpose() &lt;&lt; endl;</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		q[i] = c_Rotation[i].transpose(); </span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "solvePnP  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		Vector3d t_tmp;</span></span><br><span class="line"><span class="comment">		t_tmp = -1 * (q[i] * c_Translation[i]);</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "solvePnP  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; t_tmp.x() &lt;&lt;"  "&lt;&lt; t_tmp.y() &lt;&lt;"  "&lt;&lt; t_tmp.z() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="comment">//full BA</span></span><br><span class="line">	<span class="comment">//使用cares进行全局BA优化</span></span><br><span class="line">	ceres::Problem problem;</span><br><span class="line">	ceres::LocalParameterization* local_parameterization = <span class="keyword">new</span> ceres::QuaternionParameterization();</span><br><span class="line">	<span class="comment">//cout &lt;&lt; " begin full BA " &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//double array for ceres</span></span><br><span class="line">		c_translation[i][<span class="number">0</span>] = c_Translation[i].x();</span><br><span class="line">		c_translation[i][<span class="number">1</span>] = c_Translation[i].y();</span><br><span class="line">		c_translation[i][<span class="number">2</span>] = c_Translation[i].z();</span><br><span class="line">		c_rotation[i][<span class="number">0</span>] = c_Quat[i].w();</span><br><span class="line">		c_rotation[i][<span class="number">1</span>] = c_Quat[i].x();</span><br><span class="line">		c_rotation[i][<span class="number">2</span>] = c_Quat[i].y();</span><br><span class="line">		c_rotation[i][<span class="number">3</span>] = c_Quat[i].z();</span><br><span class="line">		problem.AddParameterBlock(c_rotation[i], <span class="number">4</span>, local_parameterization);</span><br><span class="line">		problem.AddParameterBlock(c_translation[i], <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span> (i == l)</span><br><span class="line">		&#123;</span><br><span class="line">			problem.SetParameterBlockConstant(c_rotation[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == l || i == frame_num - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			problem.SetParameterBlockConstant(c_translation[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; feature_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sfm_f[i].state != <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(sfm_f[i].observation.size()); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> l = sfm_f[i].observation[j].first;</span><br><span class="line">			ceres::CostFunction* cost_function = ReprojectionError3D::Create(</span><br><span class="line">												sfm_f[i].observation[j].second.x(),</span><br><span class="line">												sfm_f[i].observation[j].second.y());</span><br><span class="line"></span><br><span class="line">    		problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, c_rotation[l], c_translation[l], </span><br><span class="line">    								sfm_f[i].position);	 </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	ceres::Solver::Options options;</span><br><span class="line">	options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line">	<span class="comment">//options.minimizer_progress_to_stdout = true;</span></span><br><span class="line">	options.max_solver_time_in_seconds = <span class="number">0.2</span>;</span><br><span class="line">	ceres::Solver::Summary summary;</span><br><span class="line">	ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; summary.BriefReport() &lt;&lt; "\n";</span></span><br><span class="line">	<span class="keyword">if</span> (summary.termination_type == ceres::CONVERGENCE || summary.final_cost &lt; <span class="number">5e-03</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "vision only BA converge" &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "vision only BA not converge " &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q[i].w() = c_rotation[i][<span class="number">0</span>]; </span><br><span class="line">		q[i].x() = c_rotation[i][<span class="number">1</span>]; </span><br><span class="line">		q[i].y() = c_rotation[i][<span class="number">2</span>]; </span><br><span class="line">		q[i].z() = c_rotation[i][<span class="number">3</span>]; </span><br><span class="line">		q[i] = q[i].inverse();</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "final  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第l帧坐标系到各帧的变换矩阵，应将其转变为每一帧在第l帧坐标系上的位姿</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		T[i] = <span class="number">-1</span> * (q[i] * Vector3d(c_translation[i][<span class="number">0</span>], c_translation[i][<span class="number">1</span>], c_translation[i][<span class="number">2</span>]));</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "final  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; T[i](0) &lt;&lt;"  "&lt;&lt; T[i](1) &lt;&lt;"  "&lt;&lt; T[i](2) &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)sfm_f.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(sfm_f[i].state)</span><br><span class="line">			sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[<span class="number">0</span>], sfm_f[i].position[<span class="number">1</span>], sfm_f[i].position[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>对于所有的图像帧，包括不在滑动窗口中的，提供初始的RT估计，然后solvePnP进行优化</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solve pnp for all frame</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt;::iterator it;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it = all_image_frame.begin( );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; frame_it != all_image_frame.end( ); frame_it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// provide initial guess</span></span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) == Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        frame_it-&gt;second.is_key_frame = <span class="literal">true</span>;</span><br><span class="line">        frame_it-&gt;second.R = Q[i].toRotationMatrix() * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">        frame_it-&gt;second.T = T[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) &gt; Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将滑窗内第i帧的变换矩阵当做初始值</span></span><br><span class="line">    Matrix3d R_inital = (Q[i].inverse()).toRotationMatrix();</span><br><span class="line">    Vector3d P_inital = - R_inital * T[i];</span><br><span class="line">    cv::Mat rvec, t, tmp_r;</span><br><span class="line">    cv::eigen2cv(R_inital, tmp_r);</span><br><span class="line">    cv::Rodrigues(tmp_r, rvec);</span><br><span class="line">    cv::eigen2cv(P_inital, t);</span><br><span class="line"></span><br><span class="line">    frame_it-&gt;second.is_key_frame = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point3f&gt; pts_3_vector;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point2f&gt; pts_2_vector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;id_pts : frame_it-&gt;second.points)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> feature_id = id_pts.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i_p : id_pts.second)</span><br><span class="line">        &#123;</span><br><span class="line">            it = sfm_tracked_points.find(feature_id);</span><br><span class="line">            <span class="keyword">if</span>(it != sfm_tracked_points.end())</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3d world_pts = it-&gt;second;</span><br><span class="line">                cv::<span class="function">Point3f <span class="title">pts_3</span><span class="params">(world_pts(<span class="number">0</span>), world_pts(<span class="number">1</span>), world_pts(<span class="number">2</span>))</span></span>;</span><br><span class="line">                pts_3_vector.push_back(pts_3);</span><br><span class="line"></span><br><span class="line">                Vector2d img_pts = i_p.second.head&lt;<span class="number">2</span>&gt;();</span><br><span class="line">                cv::<span class="function">Point2f <span class="title">pts_2</span><span class="params">(img_pts(<span class="number">0</span>), img_pts(<span class="number">1</span>))</span></span>;</span><br><span class="line">                pts_2_vector.push_back(pts_2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pts_3_vector.size() &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pts_3_vector size "</span> &lt;&lt; pts_3_vector.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ROS_DEBUG(<span class="string">"Not enough points for solve pnp !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat K = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat D;</span><br><span class="line">    <span class="keyword">if</span> (! cv::solvePnP(pts_3_vector, pts_2_vector, K, D, rvec, t, <span class="literal">true</span>)) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve pnp fail!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PnP求解出的位姿要取逆</span></span><br><span class="line">    MatrixXd R_pnp;</span><br><span class="line">    MatrixXd T_pnp;</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat r;</span><br><span class="line">        cv::Rodrigues(rvec, r);</span><br><span class="line">        MatrixXd tmp_R_pnp;</span><br><span class="line">        cv::cv2eigen(r, tmp_R_pnp);</span><br><span class="line">        R_pnp = tmp_R_pnp.transpose();</span><br><span class="line"></span><br><span class="line">        cv::cv2eigen(t, T_pnp);</span><br><span class="line">        T_pnp = R_pnp * (-T_pnp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换到IMU坐标系下</span></span><br><span class="line">    frame_it-&gt;second.R = R_pnp * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">    frame_it-&gt;second.T = T_pnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6.进行视觉惯性联合初始化，imu与视觉对齐，获取绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视觉与IMU对齐</span></span><br><span class="line"><span class="keyword">if</span> (visualInitialAlign())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"misalign visual structure with IMU"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool Estimator::visualInitialAlign()</strong><br>该函数主要实现了陀螺仪的偏置校准(加速度偏置没有处理)，计算速度V[0:n]、重力g、尺度s。<br>同时更新了Bgs后，IMU测量量需要repropagate；得到尺度s和重力g的方向后，需更新所有图像帧在世界坐标系下的Ps、Rs、Vs。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::visualInitialAlign()</span><br><span class="line">&#123;</span><br><span class="line">    TicToc t_g;</span><br><span class="line"></span><br><span class="line">    VectorXd x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve scale</span></span><br><span class="line">    <span class="comment">// 要注意这个地方求解出的g是在C0坐标系下</span></span><br><span class="line">    <span class="comment">//1.计算陀螺仪偏置，尺度，重力加速度和速度</span></span><br><span class="line">    <span class="keyword">bool</span> result = VisualIMUAlignment(all_image_frame, Bgs, g, x);</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve g failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change state</span></span><br><span class="line">    <span class="comment">//2.获取所有图像帧的位姿Ps、Rs，并将其置为关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix3d Ri = all_image_frame[Headers[i].stamp.toSec()].R;</span><br><span class="line">        Vector3d Pi = all_image_frame[Headers[i].stamp.toSec()].T;</span><br><span class="line">        Ps[i] = Pi;</span><br><span class="line">        Rs[i] = Ri;</span><br><span class="line">        all_image_frame[Headers[i].stamp.toSec()].is_key_frame = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有特征点的深度置为-1</span></span><br><span class="line">    VectorXd dep = f_manager.getDepthVector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dep.size(); i++)</span><br><span class="line">        dep[i] = <span class="number">-1</span>;</span><br><span class="line">    f_manager.clearDepth(dep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//triangulat on cam pose , no tic</span></span><br><span class="line">    <span class="comment">//3.重新计算特征点的深度</span></span><br><span class="line">    Vector3d TIC_TMP[NUM_OF_CAM];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">        TIC_TMP[i].setZero();</span><br><span class="line">    ric[<span class="number">0</span>] = RIC[<span class="number">0</span>];</span><br><span class="line">    f_manager.setRic(ric);</span><br><span class="line">    f_manager.triangulate(Ps, &amp;(TIC_TMP[<span class="number">0</span>]), &amp;(RIC[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> s = (x.tail&lt;<span class="number">1</span>&gt;())(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4.陀螺仪的偏置bgs改变，重新计算预积分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= WINDOW_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre_integrations[i]-&gt;repropagate(Vector3d::Zero(), Bgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.将Ps、Vs、depth尺度s缩放后转变为相对于第0帧图像坐标系下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = frame_count; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        Ps[i] = s * Ps[i] - Rs[i] * TIC[<span class="number">0</span>] - (s * Ps[<span class="number">0</span>] - Rs[<span class="number">0</span>] * TIC[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> kv = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_i;</span><br><span class="line">    <span class="keyword">for</span> (frame_i = all_image_frame.begin(); frame_i != all_image_frame.end(); frame_i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(frame_i-&gt;second.is_key_frame)</span><br><span class="line">        &#123;</span><br><span class="line">            kv++;</span><br><span class="line">            Vs[kv] = frame_i-&gt;second.R * x.segment&lt;<span class="number">3</span>&gt;(kv * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">    &#123;</span><br><span class="line">        it_per_id.used_num = it_per_id.feature_per_frame.size();</span><br><span class="line">        <span class="keyword">if</span> (!(it_per_id.used_num &gt;= <span class="number">2</span> &amp;&amp; it_per_id.start_frame &lt; WINDOW_SIZE - <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        it_per_id.estimated_depth *= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转矩阵rot_diff</span></span><br><span class="line">    Matrix3d R0 = Utility::g2R(g);</span><br><span class="line">    <span class="keyword">double</span> yaw = Utility::R2ypr(R0 * Rs[<span class="number">0</span>]).x();</span><br><span class="line">    R0 = Utility::ypr2R(Eigen::Vector3d&#123;-yaw, <span class="number">0</span>, <span class="number">0</span>&#125;) * R0;</span><br><span class="line">    g = R0 * g;</span><br><span class="line">    <span class="comment">//Matrix3d rot_diff = R0 * Rs[0].transpose();</span></span><br><span class="line">    Matrix3d rot_diff = R0;</span><br><span class="line">    <span class="comment">//7.所有变量从参考坐标系c0旋转到世界坐标系w</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Ps[i] = rot_diff * Ps[i];</span><br><span class="line">        Rs[i] = rot_diff * Rs[i];</span><br><span class="line">        Vs[i] = rot_diff * Vs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"g0     "</span> &lt;&lt; g.transpose());</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"my R0  "</span> &lt;&lt; Utility::R2ypr(Rs[<span class="number">0</span>]).transpose()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<br><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719531" target="_blank" rel="noopener">VINS理论与代码详解4——初始化</a></p>
</blockquote>
]]></content>
      <categories>
        <category>VINS</category>
      </categories>
      <tags>
        <tag>VINS</tag>
      </tags>
  </entry>
  <entry>
    <title>17.打印从1到最大的n位数</title>
    <url>/2019/10/29/17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>16.数组的整数次方</title>
    <url>/2019/10/29/16.%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>15.二进制中1的个数</title>
    <url>/2019/10/29/15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="二进制的5种位运算"><a href="#二进制的5种位运算" class="headerlink" title="二进制的5种位运算"></a>二进制的5种位运算</h1><blockquote>
<p>与（&amp;）</p>
<p>或（|）</p>
<p>异或（^)</p>
<p>左移(&lt;&lt;)  ：左移n位时，做左边的n位被丢弃，最右边不是那个补上n个0</p>
<p>右移(&gt;&gt;)  ：右移n位时，最右边的n位被丢弃,左边分两种情况</p>
<blockquote>
<p>1.如果数字为正，右移最左边补n个0</p>
<p>2.如果数字为负，右移最左边补n个1      </p>
</blockquote>
</blockquote><a id="more"></a>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>先判断整数二进制最右边是不是1，接着把输入的整数右移一位，再判断是不是1，直到这个整数变为0为止</p>
</li>
<li><p>怎么判断一个整数为1？</p>
<blockquote>
<ol>
<li><p>把整数与1做与运算，但当输入是负数时，如果一直右移运算，最终的数字会变成oxFFFFFFFF陷入死循环</p>
</li>
<li><p>为避免死循环，首先把n与1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算，就能判断n的次地位是不是1,反复左移……</p>
</li>
<li><p>把一个整数减去1，再和原整数做与运算，会把整个整数最右边的1变为0</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p>
<p>法1：</p>
<p>一个int为8位，所以负数的情况中需要<strong>判断32个字节中</strong>1的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">                 result++;</span><br><span class="line">             flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)</span><br><span class="line">         &#123;</span><br><span class="line">             result++;<span class="comment">//一个非0数字至少有一个1</span></span><br><span class="line">             n=(n<span class="number">-1</span>)&amp;n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<p>法1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> n &amp; flag:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n &amp;= <span class="number">0xffffffff</span> <span class="comment">#获取负数补码</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>14.剪绳子</title>
    <url>/2019/10/29/14-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul>
<li>$O(n^2)$时间和$O(n)$空间的动态规划</li>
<li>$O(1)$时间和空间的贪婪算法</li>
</ul><a id="more"></a>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>第一步：确定最优策略，使得剪掉绳子的几段乘积最大。最后一步：乘积最大。子问题：假设该绳子剪成两段，剪完的两个部分都必须是最大乘积。</p>
<p>第二步：状态转移方程： dp[i] = max{ dp[i - j]<em>dp[j]} ,这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。更好的办法是按照<em>*从下而上</em></em>的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。</p>
<p>第三步：确定初始值和边界：dp[0] = 0,dp[1] = 1, dp[2] = 1</p>
<p>第四步：计算顺序，从dp[3]开始到dp[n]</p>
</blockquote>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product)</span><br><span class="line">                max = product;</span><br><span class="line"></span><br><span class="line">            products[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[length];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self,length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp=[<span class="number">0</span>]*length</span><br><span class="line">    <span class="comment">#dp = [0 for i in range(number + 1)]</span></span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">    dp[<span class="number">3</span>]=<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,length+<span class="number">1</span>):</span><br><span class="line">        cout=<span class="number">0</span></span><br><span class="line">        j=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;=i//<span class="number">2</span>:</span><br><span class="line">            cout=max(dp[i-j]*dp[j],cout)</span><br><span class="line">            dp[i]=cout</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[lentgh]</span><br></pre></td></tr></table></figure>
<h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>按如下策略来剪绳子</p>
<ul>
<li>当n&gt;=5，尽可能多剪长度为3的绳子</li>
<li>当剩下的绳子长度为4，把绳子剪成两段为2的绳子</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽可能多地减去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。</span></span><br><span class="line">    <span class="comment">// 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。</span></span><br><span class="line">    <span class="keyword">if</span>(length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        timesOf3 -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3)) * (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法——查找</title>
    <url>/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查找定义：查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><blockquote>
<p>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。</p>
</blockquote><p>查找又根据操作方式不同分为静态查找和动态查找两种，前者是仅获取数据不进行其他操作，后者则需要动态改变数据，比如在查找过程中插入新数据，或者删除某个已存在的数据。</p><a id="more"></a>


<h1 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h1><ul>
<li>定义：<br>从线性表的一段开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</li>
<li>时间复杂度：O(N）</li>
<li>优缺点：<blockquote>
<p>优点：对数据元素的存储没有需求，顺序存储或链式存储皆可；对表中记录的有序性也没有要求，无论记录是否按关键码有序，均可应用<br>缺点：当n较大时，平均查找长度较大，效率低</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]==key)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入哨兵的目的是使得函数内的循环不用每次都判断数组是否会越界，即不需要每次让 i与 n 作比较<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	a[<span class="number">0</span>]=key;</span><br><span class="line">	i=n;</span><br><span class="line">	<span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">	&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;<span class="comment">/*返回 0 则说明查找失败*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h1><h2 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>在有序的顺序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域元记录，查找失败为止。</p>
</blockquote>
</li>
<li>时间复杂度：O(logN）</li>
<li>优缺点：<blockquote>
<p>优点：折半查找的时间复杂度为O(logn)，远远优于顺序查找的O(n)，<br>缺点：二分查找的效率高，但是要求表关键字有序</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;	<span class="comment">/* 折半 */</span></span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])		<span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line">			high=mid<span class="number">-1</span>;		<span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line">			low=mid+<span class="number">1</span>;		<span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><ul>
<li>定义：<blockquote>
<p>基于二分查找算法，将查找点的选择改进为自适应选择，mid=low+(key-a[low])/(a[high]-a[low])*(high-low)<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014201459952.png#pic_center"></p>
</blockquote>
</li>
<li>时间复杂度：O(logN）</li>
<li>优缺点：<blockquote>
<p>优点：对于表长较大 且关键字分布又比较均匀的查找表，插值查找算法的平均性能比折半查找要好得多<br>缺点：极端不均匀的数据，用插值查找未必是很合适的选择</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插值查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Interpolation_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])		<span class="comment">/* 若查找值比插值小 */</span></span><br><span class="line">			high=mid<span class="number">-1</span>;		<span class="comment">/* 最高下标调整到插值下标小一位 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比插值大 */</span></span><br><span class="line">			low=mid+<span class="number">1</span>;		<span class="comment">/* 最低下标调整到插值下标大一位 */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>1.斐波那契实在二分查找基础上，用斐波那契数列来进行分割<br>2.在斐波那契数列上找一个略大于查找元素表个数的值f(n)<br>3.将查找元素表个数扩充到f(n) 如果要补充元素用最后一个元素补充<br>4.完成后对f(n)个元素进行斐波那契分割,即分割成 前面f(n-1)个元素,后面f(n-2)个元素<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014205901920.png#pic_center"><br>5.对要查找元素的那个部分进行递归 </p>
</blockquote>
</li>
<li><p>时间复杂度：O(logN）</p>
</li>
<li><p>优缺点：</p>
<blockquote>
<p> 就平均性能而言 优于折半查找 但是若一直在左边长半区查找则低于折半查找                      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid,i,k=<span class="number">0</span>;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)</span><br><span class="line">		k++;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">		a[i]=a[n];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			high=mid<span class="number">-1</span>;		</span><br><span class="line">			k=k<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			low=mid+<span class="number">1</span>;		</span><br><span class="line">			k=k<span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line">				<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1></blockquote>
</li>
<li>索引:就是把一个关键字与它对应的记录相关联的过程。一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</li>
<li>索引按照结构可以分为线性索引，树形索引和多级索引。</li>
<li>线性索引是将索引项集合组织为线性结构，也称为索引表。包括稠密索引、分块索引、倒排索引。<h2 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h2><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211157380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
<li>稠密索引是指在线性表中，将数据集中的每个记录对应一个索引项。对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</li>
<li>优缺点：<blockquote>
<p>优点：索引项有序也就意味着，我们要查找关键字时，可以用折半，插值及斐波那契等有序查找算法。<br>缺点：如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模。对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能大大下降。</p>
</blockquote>
</li>
</ul>
<h2 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h2><ul>
<li><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p>
<blockquote>
<ul>
<li>块内无序，即每一块内的记录宋不要求有序，有序更好，代价比较大</li>
<li>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记景的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字</li>
</ul>
</blockquote>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。</p>
</li>
<li><p>定义的分块索引的索引项结构分三个数据项 :</p>
<blockquote>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>
<li>存储了块中的记录个数，以便于循环时使用</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记景进行遍历。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211843755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
</ul>
</blockquote>
</li>
<li>分块索引表中查找，就是分两步进行:<blockquote>
<ul>
<li>在分块索引表中查找要查的关键字所在块。由于分块索引表是块间有序的，很容易利用折半插值等算法得到结果。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，只能顺序查找。</li>
</ul>
</blockquote>
</li>
<li>分块索引的平均查找长度：<blockquote>
<p>n 个记录的数据集被平均分成 m块，每个块中有 t 条记录，显然 n=m x t<br>Lb 为查找索引表的平均查找长，Lw为块中查找记录的平均查找长度<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213115831.png#pic_center"></p>
</blockquote>
</li>
</ul>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><ul>
<li>最基础的搜索技术<blockquote>
<p>样例:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101421402779.png#pic_center"><br>忽略大小写和复数，得出单词表，找到他们分别出现在哪篇文章中<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213725806.png#pic_center"><br>这张单词表就是索引衰， 索引项的通用结构是:</p>
<ul>
<li>次关键码.例如上面的”英文单词” </li>
<li>记录号表，例如上面的”文章编号”</li>
</ul>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字) 。 这样的索引方法就是倒排索引 (invered index)</p>
</blockquote>
</li>
<li>优缺点：<blockquote>
<ul>
<li>优点：显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果<br>缺点：是这个记录号不定长<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1></li>
</ul>
</blockquote>
</li>
<li>定义：二叉排序树 ( Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。.</li>
</ul>
<blockquote>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值 </li>
<li>若它的右子树不空 ，则右子树上所有结点的值均大于宫的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
</blockquote>
<p>   通过<strong>中序遍历</strong>即可得出<strong>有序的序列</strong>， 构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。</p>
<ul>
<li>二叉排序树的查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>	/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;<span class="comment">//BiTNode是该结构体的变量名,*BiTree是该结构体的类型的地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归查找二叉排序树T中是否存在key, */</span></span><br><span class="line"><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span></span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line"><span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span> (!T)	<span class="comment">/*  查找不成功 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		*p = f;  </span><br><span class="line">		<span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key==T-&gt;data) <span class="comment">/*  查找成功 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		*p = T;  </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data) </span><br><span class="line">		<span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);  <span class="comment">/*  在左子树中继续查找 */</span></span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">		<span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);  <span class="comment">/*  在右子树中继续查找 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */</span></span><br><span class="line"><span class="comment">/*  插入key并返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	BiTree p,s;</span><br><span class="line">	<span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line">    <span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line">	<span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		s-&gt;data = key;  </span><br><span class="line">		s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;  </span><br><span class="line">		<span class="keyword">if</span> (!p) </span><br><span class="line">			*T = s;			<span class="comment">/*  插入s为新的根结点 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;p-&gt;data) </span><br><span class="line">			p-&gt;lchild = s;	<span class="comment">/*  插入s为左孩子 */</span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			p-&gt;rchild = s;  <span class="comment">/*  插入s为右孩子 */</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> FALSE;  <span class="comment">/*  树中已有关键字相同的结点，不再插入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除<blockquote>
<p>对删除结点三种情况的分析:</p>
<ul>
<li>叶子结点</li>
<li>仅有左或右子树的结点 </li>
<li>左右子树都有的结点</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree q,s;</span><br><span class="line">	<span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; *p=(*p)-&gt;lchild; <span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">/* 只需重接它的右子树 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; *p=(*p)-&gt;rchild; <span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; s=(*p)-&gt;lchild;</span><br><span class="line">		<span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span></span><br><span class="line">		&#123;</span><br><span class="line">			q=s;</span><br><span class="line">			s=s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		(*p)-&gt;data=s-&gt;data; <span class="comment">/*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span></span><br><span class="line">		<span class="keyword">if</span>(q!=*p)</span><br><span class="line">			q-&gt;rchild=s-&gt;lchild; <span class="comment">/*  重接q的右子树 */</span> </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q-&gt;lchild=s-&gt;lchild; <span class="comment">/*  重接q的左子树 */</span></span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span></span><br><span class="line"><span class="comment">/* 并返回TRUE；否则返回FALSE。 */</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span> </span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (key==(*T)-&gt;data) <span class="comment">/* 找到关键字等于key的数据元素 */</span> </span><br><span class="line">			<span class="keyword">return</span> Delete(T);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;(*T)-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h1><ul>
<li>平衡二叉树(Balanced Binary Tree)(简称平衡树，AVL)也是二叉排序树的一种，其特点在于，左右子树的高度之差的绝对值不超过1，左右子树高度之差被称为平衡因子，每次插入一个新的值的时候，都要检查二叉树的平衡，也就是平衡调整</li>
<li>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balanoe Factor)，平衡因乎只可能是-1、0和 1</li>
</ul>
<ul>
<li>基本思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。 在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>	/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="keyword">int</span> bf; <span class="comment">/*  结点的平衡因子 */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以p为根的二叉排序树作右旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree L;</span><br><span class="line">	L=(*P)-&gt;lchild; <span class="comment">/*  L指向P的左子树根结点 */</span> </span><br><span class="line">	(*P)-&gt;lchild=L-&gt;rchild; <span class="comment">/*  L的右子树挂接为P的左子树 */</span> </span><br><span class="line">	L-&gt;rchild=(*P);</span><br><span class="line">	*P=L; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以P为根的二叉排序树作左旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree R;</span><br><span class="line">	R=(*P)-&gt;rchild; <span class="comment">/*  R指向P的右子树根结点 */</span> </span><br><span class="line">	(*P)-&gt;rchild=R-&gt;lchild; <span class="comment">/* R的左子树挂接为P的右子树 */</span> </span><br><span class="line">	R-&gt;lchild=(*P);</span><br><span class="line">	*P=R; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">/*  左高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0  <span class="comment">/*  等高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">/*  右高 */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</span></span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree L,Lr;</span><br><span class="line">	L=(*T)-&gt;lchild; <span class="comment">/*  L指向T的左子树根结点 */</span> </span><br><span class="line">	<span class="keyword">switch</span>(L-&gt;bf)</span><br><span class="line">	&#123; <span class="comment">/*  检查T的左子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line">		 <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */</span> </span><br><span class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">			R_Rotate(T);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		 <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的左孩子的右子树上，要作双旋处理 */</span> </span><br><span class="line">			Lr=L-&gt;rchild; <span class="comment">/*  Lr指向T的左孩子的右子树根 */</span> </span><br><span class="line">			<span class="keyword">switch</span>(Lr-&gt;bf)</span><br><span class="line">			&#123; <span class="comment">/*  修改T及其左孩子的平衡因子 */</span> </span><br><span class="line">				<span class="keyword">case</span> LH: (*T)-&gt;bf=RH;</span><br><span class="line">						 L-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EH: (*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> RH: (*T)-&gt;bf=EH;</span><br><span class="line">						 L-&gt;bf=LH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Lr-&gt;bf=EH;</span><br><span class="line">			L_Rotate(&amp;(*T)-&gt;lchild); <span class="comment">/*  对T的左子树作左旋平衡处理 */</span> </span><br><span class="line">			R_Rotate(T); <span class="comment">/*  对T作右旋平衡处理 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */</span> </span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree R,Rl;</span><br><span class="line">	R=(*T)-&gt;rchild; <span class="comment">/*  R指向T的右子树根结点 */</span> </span><br><span class="line">	<span class="keyword">switch</span>(R-&gt;bf)</span><br><span class="line">	&#123; <span class="comment">/*  检查T的右子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line">	 <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */</span> </span><br><span class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">			  L_Rotate(T);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的右孩子的左子树上，要作双旋处理 */</span> </span><br><span class="line">			  Rl=R-&gt;lchild; <span class="comment">/*  Rl指向T的右孩子的左子树根 */</span> </span><br><span class="line">			  <span class="keyword">switch</span>(Rl-&gt;bf)</span><br><span class="line">			  &#123; <span class="comment">/*  修改T及其右孩子的平衡因子 */</span> </span><br><span class="line">				<span class="keyword">case</span> RH: (*T)-&gt;bf=LH;</span><br><span class="line">						 R-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EH: (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> LH: (*T)-&gt;bf=EH;</span><br><span class="line">						 R-&gt;bf=RH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			  Rl-&gt;bf=EH;</span><br><span class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); <span class="comment">/*  对T的右子树作右旋平衡处理 */</span> </span><br><span class="line">			  L_Rotate(T); <span class="comment">/*  对T作左旋平衡处理 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */</span> </span><br><span class="line"><span class="comment">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */</span> </span><br><span class="line"><span class="comment">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BiTree *T,<span class="keyword">int</span> e,Status *taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span>(!*T)</span><br><span class="line">	&#123; <span class="comment">/*  插入新结点，树“长高”，置taller为TRUE */</span> </span><br><span class="line">		 *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="literal">NULL</span>; (*T)-&gt;bf=EH;</span><br><span class="line">		 *taller=TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e==(*T)-&gt;data)</span><br><span class="line">		&#123; <span class="comment">/*  树中已存在和e有相同关键字的结点则不再插入 */</span> </span><br><span class="line">			*taller=FALSE; <span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (e&lt;(*T)-&gt;data)</span><br><span class="line">		&#123; <span class="comment">/*  应继续在T的左子树中进行搜索 */</span> </span><br><span class="line">			<span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			<span class="keyword">if</span>(*taller) <span class="comment">/*   已插入到T的左子树中且左子树“长高” */</span> </span><br><span class="line">				<span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，需要作左平衡处理 */</span> </span><br><span class="line">							LeftBalance(T);	*taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因左子树增高而使树增高 */</span> </span><br><span class="line">							(*T)-&gt;bf=LH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，现左、右子树等高 */</span>  </span><br><span class="line">							(*T)-&gt;bf=EH; *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; <span class="comment">/*  应继续在T的右子树中进行搜索 */</span> </span><br><span class="line">			<span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			<span class="keyword">if</span>(*taller) <span class="comment">/*  已插入到T的右子树且右子树“长高” */</span> </span><br><span class="line">				<span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，现左、右子树等高 */</span> </span><br><span class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因右子树增高而使树增高  */</span></span><br><span class="line">							(*T)-&gt;bf=RH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，需要作右平衡处理 */</span> </span><br><span class="line">							RightBalance(T); *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	BiTree T=<span class="literal">NULL</span>;</span><br><span class="line">	Status taller;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"本样例建议断点跟踪查看平衡二叉树结构"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="散列表查找-哈希表"><a href="#散列表查找-哈希表" class="headerlink" title="散列表查找(哈希表)"></a>散列表查找(哈希表)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>定义：散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。这种对应关系f称为散列函数， 又称为哈希( Hash) 函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。</p>
</li>
<li><p>散列技术既是一种存储方法，也是一种查找方法。两个关键字key1≠key2，但是却有f(key1)=f(key2) ，这种现象我们称为冲突(collision) ，并把key1 和key2 称为这个散列函数的同义词(synonym) 。</p>
</li>
</ul>
<h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>取关键字的某个线性函数值为散列地址：</p>
<script type="math/tex; mode=display">f(key)=key×a+b(a、b为常数)</script><p>适合查找表较小且连续的情况。</p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>对关键字的平方后取中间部分的值。比较适合子不知道关键字的分布，而位数又不是很大的情况。</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为:</p>
<script type="math/tex; mode=display">f(key)=key \ mod\ p(p⩽m)</script><p>mod 是取模(求余数)的意思 ，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。<br>若散列表表长为m， 通常p为小于或等于表长(最好接近m ) 的最小质数或不包含小子20质因子的合数。</p>
<h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一个随机数，取关键字的随机函数值为它的散列地址:</p>
<script type="math/tex; mode=display">f(key)=random(key)</script><h2 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>一旦发生了冲突， 就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<script type="math/tex; mode=display">fi(key)=(f(key)+di)\ MOD\ m(di=1,2,3,..,m−1)</script><p>为了不让关键字都聚集在某一块区域,一般增加平方运算：</p>
<script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)\ MOD\ m(di=12,−12,22,−22,..,q2,−q2,q⩽m/2)</script><p>在冲突时，对于位移量$d_i$，采用随机函数计算得到，我们称之为随机探测法:</p>
<script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)MODm(di是一个随机数列)</script><h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>我们事先准备多个散列函数。</p>
<script type="math/tex; mode=display">fi(key)=RHi(key)(i=1,2,3,..,k)</script><p>这里RHi就是不同的散列函数。这种方法能够使得关键字不产生聚集，但也增加了计算的时间。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>
<p>它提供了绝不会出现找不到地址的保障，但也带来了查找时需要遍历单链装的性能损耗。</p>
<h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p>为所有冲突的关键字建立了一个公共的溢出区来存放。在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功； 如果不相等，则到溢出表去进行顺序查找。</p>
<h2 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12 <span class="comment">/* 定义散列表长为数组的长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY -32768</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem; <span class="comment">/* 数据元素存储基址，动态分配数组 */</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">/*  当前数据元素个数 */</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>; <span class="comment">/* 散列表表长，全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m=HASHSIZE;</span><br><span class="line">    H-&gt;count=m;</span><br><span class="line">    H-&gt;elem=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        H-&gt;elem[i]=NULLKEY;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m; <span class="comment">/* 除留余数法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入关键字进散列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key); <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = (addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;elem[addr] = key; <span class="comment">/* 直到有空位后插入关键字 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);  <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span>(H.elem[*addr] != key) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) <span class="comment">/* 如果循环回到原点 */</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;	<span class="comment">/* 则说明关键字不存在 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[HASHSIZE]=&#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,p,key,result;</span><br><span class="line">    HashTable H;</span><br><span class="line"></span><br><span class="line">    key=<span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">    InitHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(&amp;H,arr[i]);</span><br><span class="line"></span><br><span class="line">    result=SearchHash(H,key,&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 失败。\n"</span>,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        key=arr[i];</span><br><span class="line">        SearchHash(H,key,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027131236947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法——排序</title>
    <url>/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="术语说明："><a href="#术语说明：" class="headerlink" title="术语说明："></a>术语说明：</h1><ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ul><a id="more"></a>
<h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类:"></a>算法分类:</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204533683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204455511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];	<span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></span><br><span class="line">	<span class="keyword">int</span> length;			<span class="comment">/* 用于记录顺序表的长度 */</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> temp=L-&gt;r[i]; </span><br><span class="line">	L-&gt;r[i]=L-&gt;r[j]; </span><br><span class="line">	L-&gt;r[j]=temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>依次比较相邻两元素，若前一元素大于后一元素则交换之，直至最后一个元素即为最大；然后重新从首元素开始重复同样的操作，直至倒数第二个元素即为次大元素；依次类推。如同水中的气泡，依次将最大或最小元素气泡浮出水面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)  <span class="comment">/* 注意j是从后往前循环 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>]) <span class="comment">/* 若前者大于后者（注意这里与上一算法的差异）*/</span></span><br><span class="line">			&#123;</span><br><span class="line">				 swap(L,j,j+<span class="number">1</span>);<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作改进冒泡算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	Status flag=TRUE;			<span class="comment">/* flag用来作为标记 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag;i++) <span class="comment">/* 若flag为true说明有过数据交换，否则停止循环 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag=FALSE;				<span class="comment">/* 初始为False */</span></span><br><span class="line">		<span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				 swap(L,j,j+<span class="number">1</span>);	<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">				 flag=TRUE;		<span class="comment">/* 如果有数据交换，则flag为true */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 O(n)。</p>
<h2 id="2-简单选择排序"><a href="#2-简单选择排序" class="headerlink" title="2.简单选择排序"></a>2.简单选择排序</h2><p>首先初始化最小元素索引值为首元素，依次遍历待排序数列，若遇到小于该最小索引位置处的元素则刷新最小索引为该较小元素的位置，直至遇到尾元素，结束一次遍历，并将最小索引处元素与首元素交换；然后，初始化最小索引值为第二个待排序数列元素位置，同样的操作，可得到数列第二个元素即为次小元素；以此类推。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作简单选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,min;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		min = i;						<span class="comment">/* 将当前下标定义为最小值下标 */</span></span><br><span class="line">		<span class="keyword">for</span> (j = i+<span class="number">1</span>;j&lt;=L-&gt;length;j++)<span class="comment">/* 循环之后的数据 */</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[min]&gt;L-&gt;r[j])	<span class="comment">/* 如果有小于当前最小值的关键字 */</span></span><br><span class="line">                min = j;				<span class="comment">/* 将此关键字的下标赋值给min */</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(i!=min)						<span class="comment">/* 若min不等于i，说明找到最小值，交换 */</span></span><br><span class="line">			swap(L,i,min);				<span class="comment">/* 交换L-&gt;r[i]与L-&gt;r[min]的值 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n)，但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h2><p>数列前面部分看为有序，依次将后面的无序数列元素插入到前面的有序数列中，初始状态有序数列仅有一个元素，即首元素。在将无序数列元素插入有序数列的过程中，采用了逆序遍历有序数列，相较于顺序遍历会稍显繁琐，但当数列本身已近排序状态效率会更高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i<span class="number">-1</span>]) <span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/* 设置哨兵 */</span></span><br><span class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="number">0</span>];j--)</span><br><span class="line">				L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j]; <span class="comment">/* 记录后移 */</span></span><br><span class="line">			L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/* 插入到正确位置 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n)，直接插入排序法比冒炮和简单选择排序的性能要好一些。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> increment=L-&gt;length;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		increment=increment/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">/* 增量序列 */</span></span><br><span class="line">		<span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i-increment])<span class="comment">/*  需将L-&gt;r[i]插入有序增量子表 */</span> </span><br><span class="line">			&#123; </span><br><span class="line">				L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/*  暂存在L-&gt;r[0] */</span></span><br><span class="line">				<span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)</span><br><span class="line">					L-&gt;r[j+increment]=L-&gt;r[j]; <span class="comment">/*  记录后移，查找插入位置 */</span></span><br><span class="line">				L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/*  插入 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"	第%d趟排序结果: "</span>,++k);</span><br><span class="line">		print(*L);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度：通常认为是O($N^{3/2}$) ，未验证　　稳定性：不稳定</p>
<h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h2><blockquote>
<p>堆是具有下列性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值,称为大顶堆 或者每个结点的值都小于或等于其左右孩子结点的值,称为小顶堆。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151257333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151926815.png">堆排序 (Heap 80忱) 就是利用堆(假设利用大顶堆)进行排序的方法。它的基本思想是, 将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根结点。将官移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值) .然后将剩余的 n - 1 个序列重新构造成一个堆,这样就刽寻到 n 个元素中的次小值。如此反复执行 , 便能得到一个有序序列了 。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(i=L-&gt;length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span>   <span class="comment">/*把L中的r构建成一个大顶堆*/</span></span></span><br><span class="line"><span class="function">        <span class="title">HeadAdjust</span><span class="params">(L,i,L-&gt;length)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L,<span class="number">1</span>,i);             <span class="comment">/*将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></span><br><span class="line">        heapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);     <span class="comment">/*将当前的根结点重新调整为大顶堆 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,j;</span><br><span class="line">    temp=L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;m;j*=<span class="number">2</span>)    <span class="comment">/*沿关键字较大的孩子结点向下筛选*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            ++j;           <span class="comment">/*j为关键字中较大的记录的下标*/</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=L-&gt;r[j])   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        L-&gt;r[s]=L-&gt;r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(NlogN) 　　稳定性：不稳定<br>由于初始构建队所需的比较次数较多，并不适合待排序序列个数较少的情况。</p>
<h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h2><ul>
<li>归并排序 ( Merging Sort) 就是利用归并的思想实现的排序方法。色的原理是假设初始序列含有 n 个记录 , 则可 以看成是 n 个有序的子序列,每个子序列的长度为1 ,然后两两归并,得到[[n/2] ( [x]表示不小于 x 的最小整数)个长度为 2或1的有序子序列;再两两归并 ,……,如此重复 , 直至得到 一个长度为 n 的有序序列为止 ,这种排序方法称为2路归并排序 。<h3 id="递归实现归并排序"><a href="#递归实现归并排序" class="headerlink" title="递归实现归并排序"></a>递归实现归并排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span> <span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MSort (L-&gt;r,L-&gt;r,L-&gt;length) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">MSort (<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR1[],<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> TR2[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s==t)</span><br><span class="line">        TR1[s]=SR[s]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=(s+t)/<span class="number">2</span>;         <span class="comment">/*将SR (S..t]平分为 SR [s..m]和SR[m+1..t] */</span></span><br><span class="line">        MSort(SR,TR2,s,m); <span class="comment">/*递归将SR[s..m]归并为有序的 TR2[s..m]*/</span></span><br><span class="line">        MSort(SR,TR2,m+<span class="number">1</span>,t);<span class="comment">/*递归将SR[m+1..t]归并为有序TR2[m+1..t] */</span></span><br><span class="line">        Merge(TR2,TR1,s,m,t);<span class="comment">/*将TR2[s..m]和TR2[m+1..t]归并到TR1【s..t] */</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将有序的 SR[i..m1 和 $R [m+l..0] 归并为有序的T.R[i..n] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k,i;</span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SR[i]&lt;SR[j])</span><br><span class="line">            TR[k]=SR[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TR[k=SR[j++]]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=m-i;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;n-j;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设现在要对数组{50,1 0,90,30, 70.40,80, 60 ,20}进行排序, L.length=9 ,现来看看 MSort 的实现。MSort 被调用时, SR与TR1都是{50, 10,90, 30,70,40,80,60,20} , s=1 , t=9 ,最终我们的目的就是要将TR1中的数组排好顺序。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724171640203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
</blockquote>
</li>
<li><p><strong>时间复杂度</strong>为：O(nlogn) </p>
</li>
<li><p><strong>空间复杂度</strong>：O(n+Iogn) ，由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为 Iog2 n 的横空间。</p>
<p>归并排序是一种<strong>稳定的排序算法</strong>，因为 Merge 函数 中有 if (SR[i]&lt;SR[j])语句,这就说明它需要两两比较,不存在跳跃。</p>
<h3 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h3><p>归并排序大量’引用了递归,尽管在代码上比较清晰,容易理解,但这会造成时间和空间上的性能损耗。排序追求的就是效率,<strong>将递归转化成迭代</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 非递归法 */</span></span><br><span class="line"><span class="comment">/* 对顺序表L作归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	MSort(L-&gt;r,L-&gt;r,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作归并非递归排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* TR=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(L-&gt;length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">/* 申请额外空间 */</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k&lt;L-&gt;length)</span><br><span class="line">	&#123;</span><br><span class="line">		MergePass(L-&gt;r,TR,k,L-&gt;length);</span><br><span class="line">		k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span></span><br><span class="line">		MergePass(TR,L-&gt;r,k,L-&gt;length);</span><br><span class="line">		k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span>       </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</span><br><span class="line">	&#123;<span class="comment">/* 两两归并 */</span></span><br><span class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</span><br><span class="line">		i=i+<span class="number">2</span>*s;        </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>) <span class="comment">/* 归并最后两个序列 */</span></span><br><span class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 若最后只剩下单个子序列 */</span></span><br><span class="line">		<span class="keyword">for</span>(j =i;j &lt;= n;j++)</span><br><span class="line">			TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h2><p>快速排序 ( Quick Sort) 的基本思想是:通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></span><br><span class="line"><span class="comment">/* 此时在它之前(后)的记录均不大(小)于它。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line">	pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">			high--;</span><br><span class="line">		 swap(L,low,high);<span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">			low++;</span><br><span class="line">		 swap(L,low,high);<span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)</span><br><span class="line">	&#123;</span><br><span class="line">			pivot=Partition(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">			QSort(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line">			QSort(L,pivot+<span class="number">1</span>,high);		<span class="comment">/*  对高子表递归排序 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSort(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Partition 函数，其实就是将选取的pivotkey 不断交换，将比它小的换到它的左边，比它大的换到它的右边，包也在交换中不断更改自己的位置，直到完全满足这个要求为止。</p>
<p>时间复杂度：最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)　<br>空间复杂度： O(logn)<br>由于关键字的比较和交换是跳跃进行的，因此，<strong>快速排序是一种不稳定</strong>的排序方法</p>
<p><strong>三数取中法</strong>。即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数， 也可以随机选取。 这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中中间数位于较为中间的值的可能性就大大提高了 。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 改进后快速排序******************************** */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>; <span class="comment">/* 计算数组中间的元素的下标 */</span>  </span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])			</span><br><span class="line">		swap(L,low,high);	<span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[high])</span><br><span class="line">		swap(L,high,m);		<span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[low])</span><br><span class="line">		swap(L,m,low);		<span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></span><br><span class="line">	</span><br><span class="line">	pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">	L-&gt;r[<span class="number">0</span>]=pivotkey;  <span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">			high--;</span><br><span class="line">		 L-&gt;r[low]=L-&gt;r[high];</span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">			low++;</span><br><span class="line">		 L-&gt;r[high]=L-&gt;r[low];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high)</span><br><span class="line">		&#123;</span><br><span class="line">			pivot=Partition1(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">			QSort1(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line">			<span class="comment">/* QSort(L,pivot+1,high);		/*  对高子表递归排序 */</span></span><br><span class="line">			low=pivot+<span class="number">1</span>;	<span class="comment">/* 尾递归 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort1</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSort1(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>VINS-Mono——预积分，PVQ 增量的误差、 协方差及 Jacobian</title>
    <url>/2019/10/25/VINS-Mono%E2%80%94%E2%80%94%E9%A2%84%E7%A7%AF%E5%88%86%EF%BC%8CPVQ-%E5%A2%9E%E9%87%8F%E7%9A%84%E8%AF%AF%E5%B7%AE%E3%80%81-%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%8F%8A-Jacobian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了加深理解，参考崔华坤的《VINS论文推导及代码解析》，把相关公式推到一遍。<br>想写博客记录下，但懒敲公式。</p><h1 id="预积分"><a href="#预积分" class="headerlink" title="预积分"></a>预积分</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181407525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181521323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center =30x30"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181458844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521325497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="连续形式下-PVQ-增量的误差、-协方差及-Jacobian"><a href="#连续形式下-PVQ-增量的误差、-协方差及-Jacobian" class="headerlink" title="连续形式下 PVQ 增量的误差、 协方差及 Jacobian"></a>连续形式下 PVQ 增量的误差、 协方差及 Jacobian</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521324273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="离散形式下-PVQ-增量的误差、-协方差及-Jacobian"><a href="#离散形式下-PVQ-增量的误差、-协方差及-Jacobian" class="headerlink" title="离散形式下 PVQ 增量的误差、 协方差及 Jacobian"></a>离散形式下 PVQ 增量的误差、 协方差及 Jacobian</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213150727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213209259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025215804453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p>intergration_base.h：IMU预积分<br>imu_factor.h：IMU残差、雅可比</p><a id="more"></a>




<h1 id="IMU-测量方程"><a href="#IMU-测量方程" class="headerlink" title="IMU 测量方程."></a>IMU 测量方程.</h1><p>忽略地球旋转， IMU 测量方程为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214341590.png#pic_center"></p>
<h1 id="预积分方程"><a href="#预积分方程" class="headerlink" title="预积分方程"></a>预积分方程</h1><h2 id="IMU-integration-in-world-frame"><a href="#IMU-integration-in-world-frame" class="headerlink" title="IMU integration in world frame"></a>IMU integration in world frame</h2><p>将第 k 帧和第 k+1 帧之间的所有 IMU 进行积分，可得第 k+1 帧的位置、速度和旋转<br>（PVQ），作为视觉估计的初始值，这里的旋转采用的四元数。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214621188.png"><br>其中：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214759817.png"></p>
<h1 id="IMU-integration-in-the-body-frame-of-first-pose-of-interests"><a href="#IMU-integration-in-the-body-frame-of-first-pose-of-interests" class="headerlink" title="IMU integration in the body frame of first pose of interests"></a>IMU integration in the body frame of first pose of interests</h1><p>为避免重新传播 IMU 观测值，选用 IMU 预积分模型，从世界坐标系转为本体坐标</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215210690.png#pic_center"><br>其中：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215228467.png#pic_center"><br>则 IMU 预积分模型（预积分估计值）为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152209217.png#pic_center"><br>离散状态下采用 中值积分 (mid-point) 的预积分方程（预积分测量值）为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102815225757.png#pic_center"><br>其中：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152316969.png#pic_center"></p>
<p>midPointIntegration中的相关代码（没有考虑噪声）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector3d un_gyr = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">result_delta_q  = delta_q * Quaterniond(<span class="number">1</span>, un_gyr(<span class="number">0</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">1</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">2</span>) * _dt / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Vector3d un_acc_0 =        delta_q * (_acc_0 - linearized_ba);</span><br><span class="line">Vector3d un_acc_1 = result_delta_q * (_acc_1 - linearized_ba);</span><br><span class="line">Vector3d un_acc   = <span class="number">0.5</span> * (un_acc_0 + un_acc_1);</span><br><span class="line"></span><br><span class="line">result_delta_p = delta_p + delta_v * _dt + <span class="number">0.5</span> * un_acc * _dt * _dt;</span><br><span class="line">result_delta_v = delta_v + un_acc * _dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预积分的过程中Bias没有发生改变</span></span><br><span class="line">result_linearized_ba = linearized_ba;</span><br><span class="line">result_linearized_bg = linearized_bg;</span><br></pre></td></tr></table></figure>
<p>当 bias 估计轻微改变时，我们可以使用如下的一阶近似 对中值积分得到的预积分测量值进矫正，而不重传播，从而得到 更加精确的预积分测量值（bias 修正的线性模型）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028145945699.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150116815.png#pic_center"><br>上式可由误差项雅克比矩阵的迭代公式$J<em>{b</em>{k+1}}$得出：<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O_P = 0 , O_R = 3 , O_V = 6 , O_BA = 9 , O_BG = 12</span></span><br><span class="line">           Eigen::Matrix3d dp_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BA);</span><br><span class="line">            Eigen::Matrix3d dp_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BG);</span><br><span class="line">            Eigen::Matrix3d dq_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_R, O_BG);</span><br><span class="line">            Eigen::Matrix3d dv_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BA);</span><br><span class="line">            Eigen::Matrix3d dv_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BG);</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/86290941" target="_blank" rel="noopener">VINS-Mono理论学习——IMU预积分 Pre-integration （Jacobian 协方差）</a></p>
<h1 id="误差状态方程"><a href="#误差状态方程" class="headerlink" title="误差状态方程"></a>误差状态方程</h1><p>状态误差传递的线性递推关系可以通过两种方式实现</p>
<ul>
<li>基于误差随时间变化的递推方程</li>
<li>基于一阶泰勒展开的误差递推方程<br>本文用的第一种方法；我们还可以通过第二种方法：已知 IMU 预积分（中值积分）测量方程，通过求导计算出 F ′ 和 G′。</li>
</ul>
<h2 id="连续形式下-PVQ-增量误差的协方差及-Jacobian"><a href="#连续形式下-PVQ-增量误差的协方差及-Jacobian" class="headerlink" title="连续形式下 PVQ 增量误差的协方差及 Jacobian"></a>连续形式下 PVQ 增量误差的协方差及 Jacobian</h2><p>IMU 在每一个时刻积分出来的值是有误差的，下面我们对误差进行分析。首先我们直接给出在 t 时刻误差项的导数为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150603823.png#pic_center"><br>那么根据导数的定义有上一时刻推导下一时刻的误差如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150704700.png#pic_center"><br>上式恰好给出了如 EKF 一般对非线性系统线性化的过程，这里的意义是表示下一个时刻的 IMU 测量误差与上一个时刻的成线性关系，这样我们根据当前时刻的值，可以预测出下一个时刻的均值和协方差，而公式给出的是均值预测，协方差预测公式如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150752961.png#pic_center"><br>上式给出了协方差的迭代公式，初始值$P^{b<em>k}</em>{b<em>k}$ = 0。其中， Q 为表示噪声项的对角协方差<br>矩阵：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150935869.png#pic_center#pic_center"><br>由上式可获得误差项的 Jacobian 的迭代公式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151013604.png#pic_center"><br>其中 Jacobian 的初始值为$J</em>{b_k}=I$。</p>
<h2 id="离散形式的-PVQ-增量误差的-Jacobian-和协方差"><a href="#离散形式的-PVQ-增量误差的-Jacobian-和协方差" class="headerlink" title="离散形式的 PVQ 增量误差的 Jacobian 和协方差"></a>离散形式的 PVQ 增量误差的 Jacobian 和协方差</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151537536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">其中:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151600894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以简写为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151718610.png#pic_center"><br>则 Jacobian 的迭代公式为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151808834.png#pic_center"><br>其中， Jacobian 的初始值为𝐽𝑘 = 𝐼。 这里计算出来的𝐽𝑘+1只是为了给后面提供对 bias 的Jacobian。<br>协方差的迭代公式为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151831375.png#pic_center"><br>其中， 初始值𝑃𝑘 = 0。 Q 为表示噪声项的对角协方差矩阵：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151847412.png#pic_center"><br>相关代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(update_jacobian)<span class="comment">//否更新雅克比矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3d w_x   = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">        Vector3d a_0_x = _acc_0 - linearized_ba;</span><br><span class="line">        Vector3d a_1_x = _acc_1 - linearized_ba;</span><br><span class="line"></span><br><span class="line">        Matrix3d R_w_x, R_a_0_x, R_a_1_x;</span><br><span class="line"></span><br><span class="line">        R_w_x&lt;&lt;     <span class="number">0</span>, -w_x(<span class="number">2</span>),  w_x(<span class="number">1</span>),</span><br><span class="line">                w_x(<span class="number">2</span>),      <span class="number">0</span>, -w_x(<span class="number">0</span>),</span><br><span class="line">               -w_x(<span class="number">1</span>), w_x(<span class="number">0</span>),       <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_0_x&lt;&lt;        <span class="number">0</span>, -a_0_x(<span class="number">2</span>),  a_0_x(<span class="number">1</span>),</span><br><span class="line">                  a_0_x(<span class="number">2</span>),         <span class="number">0</span>, -a_0_x(<span class="number">0</span>),</span><br><span class="line">                 -a_0_x(<span class="number">1</span>),  a_0_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_1_x&lt;&lt;        <span class="number">0</span>, -a_1_x(<span class="number">2</span>),  a_1_x(<span class="number">1</span>),</span><br><span class="line">                  a_1_x(<span class="number">2</span>),         <span class="number">0</span>, -a_1_x(<span class="number">0</span>),</span><br><span class="line">                 -a_1_x(<span class="number">1</span>),  a_1_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        MatrixXd F = MatrixXd::Zero(<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>)   = <span class="number">-0.25</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt * _dt +</span><br><span class="line">                                <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>)   = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>)   = <span class="number">-0.25</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">12</span>)  = <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>)   = Matrix3d::Identity() - R_w_x * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">12</span>)  = <span class="number">-1.0</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>)   = <span class="number">-0.5</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt +</span><br><span class="line">                                <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>)   = <span class="number">-0.5</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">12</span>)  = <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">9</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">12</span>) = Matrix3d::Identity();</span><br><span class="line"></span><br><span class="line">        MatrixXd V = MatrixXd::Zero(<span class="number">15</span>,<span class="number">18</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) =  <span class="number">0.25</span> * delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) =  <span class="number">0.25</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>) =  <span class="number">0.25</span> *  result_delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">9</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) =  <span class="number">0.5</span> * delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>) =  <span class="number">0.5</span> *  result_delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">12</span>)  = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">15</span>) = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step_jacobian = F;</span></span><br><span class="line">        <span class="comment">//step_V = V;</span></span><br><span class="line">        jacobian   = F * jacobian;</span><br><span class="line">        covariance = F * covariance * F.transpose() + V * noise * V.transpose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过预积分误差的递推公式确实可以求出来从$b<em>k$帧到$b</em>{k+1}$帧的累积出来的误差大小，但是这个值并没有用，我们在后端需要的是误差对$b<em>k$ 帧和$b</em>{k+1}$帧的导数，而误差对$b_k$帧的导数却可以通过上式的雅克比矩阵直接计算出来，至于协方差矩阵是我们进行后端优化计算残差时用马氏距离需要用到。</p>
]]></content>
      <categories>
        <category>VINS</category>
      </categories>
  </entry>
  <entry>
    <title>随机抽样一致RANSAC-Random-Sample-Consensus</title>
    <url>/2019/10/24/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4RANSAC-Random-Sample-Consensus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h1><p>随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</p><a id="more"></a>
<h1 id="RANSAC的基本假设："><a href="#RANSAC的基本假设：" class="headerlink" title="RANSAC的基本假设："></a>RANSAC的基本假设：</h1><p>“内群”数据可以通过几组模型的参数来叙述其分布，而“离群”数据则是不适合模型化的数据。<br>数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。<br>RANSAC假定，给定一组（通常很小）的内群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。</p>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><p>这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内群以及离群，其中内群为可以被拟合到线段上的点，而离群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内群的线，因为最小二乘法会受离群影响而影响其结果。而RANSAC，可以只由内群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020160728989.png#pic_center"><br>包含许多离群的一组数据，要找一条最适合的线。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910201607364.png#pic_center"><br>RANSAC找到的线，离群值对结果没影响（蓝色点为内群，红色点为离群）</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RANSAC算法的输入是一组观测数据（往往含有较大的噪声或无效点），一个用于解释观测数据的参数化模型以及一些可信的参数。RANSAC通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证： </p>
<ol>
<li>有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出。</li>
<li>用1中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li>
<li>如果有足够多的点被归类为假设的局内点，那么估计的模型就足够合理。</li>
<li>然后，用所有假设的局内点去重新估计模型（譬如使用最小二乘法），因为它仅仅被初始的假设局内点估计过。</li>
<li>最后，通过估计局内点与模型的错误率来评估模型。</li>
<li>上述过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为比现有的模型更好而被选用。<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1>伪码形式的算法如下所示：</li>
</ol>
<ul>
<li><p>输入：</p>
<blockquote>
<p>data —— 一组观测数据<br>model —— 适应于数据的模型<br>n —— 适用于模型的最少数据个数<br>k —— 算法的迭代次数<br>t —— 用于决定数据是否适应于模型的阀值<br>d —— 判定模型是否适用于数据集的数据数目</p>
</blockquote>
</li>
<li><p>输出：</p>
<blockquote>
<p>best_model —— 跟数据最匹配的模型参数（如果没有找到好的模型，返回null）<br>best_consensus_set —— 估计出模型的数据点<br>best_error —— 跟数据相关的估计出的模型错误</p>
</blockquote>
<ul>
<li>iterations = 0<blockquote>
<p>best_model = null<br>best_consensus_set = null<br>best_error = 无穷大<br>while ( iterations &lt; k )<br>maybe_inliers = 从数据集中随机选择n个点<br>maybe_model = 适合于maybe_inliers的模型参数<br>consensus_set = maybe_inliers</p>
</blockquote>
</li>
</ul>
</li>
<li><p>估计的模型就足够合理</p>
<blockquote>
<p>for ( 每个数据集中不属于maybe_inliers的点 ）<br>if ( 如果点适合于maybe_model，且错误小于t ）<br>将点添加到consensus_set<br>if （ consensus_set中的元素数目大于d ）<br>已经找到了好的模型，</p>
</blockquote>
</li>
<li><p>现在测试该模型到底有多好</p>
<blockquote>
<p>better_model = 适合于consensus_set中所有点的模型参数<br>this_error = better_model究竟如何适合这些点的度量<br>if ( this_error &lt; best_error )<br>我们发现了比以前好的模型，保存该模型直到更好的模型出现<br>best_model =  better_model<br>best_consensus_set = consensus_set<br>best_error =  this_error</p>
</blockquote>
</li>
<li><p>迭代</p>
<blockquote>
<p>增加迭代次数<br>返回 best_model, best_consensus_set, best_error</p>
</blockquote>
<p> RANSAC算法的可能变化包括以下几种：</p>
<ol>
<li><p>如果发现了一种足够好的模型（该模型有足够小的错误率），则跳出主循环。这样可能会节约计算额外参数的时间。</p>
<ol>
<li>直接从maybe_model计算this_error，而不从consensus_set重新估计模型。这样可能会节约比较两种模型错误的时间，但可能会对噪声更敏感。</li>
</ol>
<p>其实核心就是随机性和假设性。随机性用于减少计算了，那个循环次数就是利用正确数据出现的概率。所谓的假设性，就是说随机抽出来的数据我都认为是正确的，并以此去计算其他点，获得其他满足变换关系的点，然后利用投票机制，选出获票最多的那一个变换。</p>
</li>
</ol>
</li>
</ul>
<h1 id="参数决定"><a href="#参数决定" class="headerlink" title="参数决定"></a>参数决定</h1><p>假设每个点是真正内群的几率是w，则：</p>
<ul>
<li>w = 真正内群的数目 / 数据总共的数量</li>
</ul>
<p>通常我们不知道w 是多少，$w^{n}$是所选择的n 个点都是内群的几率，$1-w^{n}$ 是所选择的 n 个点至少有一个不是内群的几率， ${(1-w^{n})^{k}}$是表示重复k 次都没有全部的 {\displaystyle n} n 个点都是内群的几率，假设算法跑 k 次以后成功的几率是p，那么：</p>
<script type="math/tex; mode=display">{1-p=(1-w^{n})^{k}}</script><script type="math/tex; mode=display">{p=1-(1-w^{n})^{k}}</script><p>所以如果希望成功几率高， ${\displaystyle p=0.99}$， 当n 不变时，k 越大， {\displaystyle p} p 越大， 当w 不变时，n 越大，所需的k 就越大， 通常w 未知，所以 n 选小一点比较好。</p>
<h1 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h1><ul>
<li>RANSAC的优点是它能鲁棒的估计模型参数。例如，它能从包含大量局外点的数据集中估计出高精度的参数。</li>
<li>RANSAC的缺点是它计算参数的迭代次数没有上限；如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。</li>
<li>RANSAC只有一定的概率得到可信的模型，概率与迭代次数成正比。RANSAC的另一个缺点是它要求设置跟问题相关的阀值。</li>
<li>RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</li>
</ul>
<p>参考：</p>
<blockquote>
<p><a href="https://blog.csdn.net/pi9nc/article/details/26596519" target="_blank" rel="noopener">RANSAC</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E6%8A%BD%E6%A8%A3%E4%B8%80%E8%87%B4" target="_blank" rel="noopener">随机抽样一致</a></p>
</blockquote>
]]></content>
      <categories>
        <category>VIO</category>
      </categories>
  </entry>
  <entry>
    <title>IMU测量模型、运动模型、误差模型</title>
    <url>/2019/10/24/IMU%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B%E3%80%81%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E3%80%81%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IMU测量模型"><a href="#IMU测量模型" class="headerlink" title="IMU测量模型"></a>IMU测量模型</h1><ul>
<li><p>MEMS 加速度计工作原理<br>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示<br>加速度计测量值$a_m$为弹簧拉力对应的加速度</p>
<script type="math/tex; mode=display">a_m=\frac{f}{m}=a-g</script><p>其中m为质量块质量，a为物体在世界（惯性）坐标系下的实际加速度。</p>
</li>
<li><p>陀螺仪测量原理<br>陀螺仪的测量值即为IMU在body坐标系下的旋转角速度，要通过运动学模型转换到惯性坐标系下 ，按测量原理分有振动陀螺，光纤陀螺等。</p>
<p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 Coriolisforce 来间接得到角速度。</p>
<blockquote>
<p>在旋转坐标系中，运动的物体受到科氏力作用<br>MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017192448388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="IMU运动模型"><a href="#IMU运动模型" class="headerlink" title="IMU运动模型"></a>IMU运动模型</h1><h2 id="旋转量求导"><a href="#旋转量求导" class="headerlink" title="旋转量求导"></a>旋转量求导</h2><p>首先，如下图所示，考虑一个从原点出发的向量 r 绕单位轴 u 旋转，角速度大小为 θ˙。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017155511191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>角速度矢量可以表示为${\boldsymbol \omega}=\dot{\theta}u$，易得向量 r 末端点 P 的速度矢量，即 r的时间一阶导为</p>
<script type="math/tex; mode=display">\frac{d{r}}{dt} = {\boldsymbol \omega} \times {r}</script><p>坐标系 {B} 绕单位轴 u 旋转，如上所述，其三个轴的时间一阶导同样为</p>
<script type="math/tex; mode=display">\frac{d{\bf i}_B}{dt} = {\boldsymbol \omega} \times {\bf i}_B, \frac{d{\bf j}_B}{dt} = {\boldsymbol \omega} \times {\bf j}_B, \frac{d{\bf k}_B}{dt} = {\boldsymbol \omega} \times {\bf k}_B</script><p>$[ {\bf i}_B \quad {\bf j}_B \quad {\bf k}_B ]$ 实际上就是坐标系 {B} 相对于参考坐标系的旋转矩阵 R，R的时间一阶导为</p>
<script type="math/tex; mode=display">\dot{\bf R} =  [ {\boldsymbol \omega} \times {\bf i}_B \quad {\boldsymbol \omega} \times {\bf j}_B \quad {\boldsymbol \omega} \times {\bf k}_B ] = {\boldsymbol \omega} \times {\bf R}</script><p>叉乘运算可以转化为负对称矩阵的乘法：</p>
<script type="math/tex; mode=display">\dot{\bf R} = {\boldsymbol \omega}^{\land} {\bf R}</script><p>其中负对称矩阵${\boldsymbol \omega}^{\land}$为</p>
<script type="math/tex; mode=display">% <![CDATA[
\quad {\boldsymbol \omega}^{\land}= \begin{bmatrix}0 & -\omega_3 & \omega_2\\ \omega_3 & 0 & -\omega_1 \\ -\omega_2 & \omega_1 & 0\end{bmatrix} %]]></script><p>这里的角速度 ω 是在参考坐标系下表达的，角速度也经常表达在体坐标系 {B} 下，记为${}^B{\boldsymbol \omega} = {\bf R}^T{\boldsymbol \omega}$，即${\boldsymbol \omega} = {\bf R}{}^B{\boldsymbol \omega}$<br>上式也可以写作：</p>
<script type="math/tex; mode=display">\dot{\bf R} =w^{\land}R=(R^Bw)^{\land}R=R{}^{\land}wR^TR= R({}^Bw)^{\land}</script></blockquote>
</li>
</ul><a id="more"></a>
<blockquote>
<p>证：对任意旋转矩阵 R 和三维向量 v，都有$({\bf R v})^{\land} = {\bf Rv^{\land}R}^T$<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017160718789.png#pic_center"><br>最后一式利用向量叉乘的旋转变换不变性可证，即，对于任意${\bf v,u}\in \mathbb{R}^3$永远有</p>
<script type="math/tex; mode=display">({\bf Rv})\times({\bf Ru})={\bf R(v\times u)}</script><p>从三维几何的角度来理解：v,u 是任意两个三维向量，(v×u) 是一个和 v,u 都垂直、大小为 |v||u|sin(u,v) 的三维向量；将 v,u,v×u 三个向量都经过同一个旋转，它们的相对位姿和模长都不会改变，所以 (Rv) 和 (Ru) 的叉乘仍是 R(v×u)。</p>
</blockquote>
<h2 id="科氏加速度"><a href="#科氏加速度" class="headerlink" title="科氏加速度"></a>科氏加速度</h2><p>这次把绕惯性系 {A} 中固定单位轴 u 旋转的 {B} 作为参考坐标系。考虑下图， 点 P 相对于 {B} 运动，记 ${}^Br$ 分别为 P 在 {B} 下的坐标，r 为 P 的绝对坐标（即 {A} 下坐标）， R 仍为 {B} 相对于 {A} 的旋转矩阵，易知 $r=R{}^Br$。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017163839187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$r=R{}^Br$求一阶时间导</p>
<script type="math/tex; mode=display">{\bf v} = \dot{\bf r} = \dot{\bf R} {}^B{\bf r} + {\bf R}^B\dot{\bf r} = {\boldsymbol \omega}^{\land}{\bf R}{}^B{\bf r}+ {\bf R}^B\dot{\bf r}</script><p>记P在 {B}下速度为 ${}^Bv$，于是</p>
<script type="math/tex; mode=display">v = w^{\land}r+ {R}^B{}= w \times r+ v_r</script><p>${\bf v}_r$来表达「相对速度」的概念，准确定义为 P 相对于 {B} 的速度，在惯性系 {A} 下的表达<br>再对求时间导：</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017165037235.png#pic_center"><br>在旋转坐标系下观察，运动的物体（运动方向和旋转轴不为同一个轴时）会受到科氏力的作用。</p>
<ul>
<li>第一项中${\boldsymbol \alpha}$为 {B} 的角加速度，所以第一项的物理意义是 {B} 旋转所造成的 P 的切向加速度</li>
<li>第二项是 {B} 旋转所造成的向心加速度</li>
<li>第三项比较特殊，为 {B} 的旋转运动与 P 相对 {B} 的平移运动耦合产生的加速度，称为科氏加速度</li>
<li>第四项为 P 相对于 {B} 的加速度，但在惯性系{A}下表达，类似于${\bf v}_r$</li>
</ul>
</blockquote>
<h1 id="IMU-误差模型"><a href="#IMU-误差模型" class="headerlink" title="IMU 误差模型"></a>IMU 误差模型</h1><p>加速度计和陀螺仪的误差可以分为：确定性误差，随机误差。</p>
<ul>
<li>确定性误差可以事先标定确定，包括： bias, scale …</li>
<li>随机误差通常假设噪声服从高斯分布，包括：高斯白噪声， bias<br>随机游走…<h2 id="确定性误差"><a href="#确定性误差" class="headerlink" title="确定性误差"></a>确定性误差</h2></li>
</ul>
<ol>
<li>Bias ，Scale<br>理论上，当没有外部作用时， IMU 传感器的输出应该为 0，但实际数据存在一个偏置 b。</li>
</ol>
<ul>
<li>加速度计 bias 对位姿估计的影响：<script type="math/tex; mode=display">v_err=b_at，p_err=\frac{1}{2}b_at^2</script></li>
<li>scale 可以看成是实际数值和传感器输出值之间的比值</li>
</ul>
<ol>
<li>Nonorthogonality/Misalignment Errors(非正交/错位错误）<br><img alt data-src="https://img-blog.csdnimg.cn/20191017182956354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"> </li>
<li>其他确定性误差<blockquote>
<ul>
<li>Run-to-Run Bias/Scale Facto</li>
<li>In Run (Stability) Bias/Scale Factor</li>
<li>Temperature-Dependent Bias/Scale Factor</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="确定性误差误差标定"><a href="#确定性误差误差标定" class="headerlink" title="确定性误差误差标定"></a>确定性误差误差标定</h3><h4 id="六面法标定加速度"><a href="#六面法标定加速度" class="headerlink" title="六面法标定加速度"></a>六面法标定加速度</h4><p><strong>bias 和 scale factor</strong></p>
<blockquote>
<p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。如果各个轴都是正交的，那很容易得到 bias 和 scale：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017171617729.png#pic_center"><br>其中,$l$为加速度计某个轴的测量值， g为当地的重力加速度</p>
</blockquote>
<p><strong>（Nonorthogonality/Misalignment Errors)</strong></p>
<blockquote>
<p>多轴 IMU 传感器制作的时候，由于制作工艺的问题，会使得 xyz 轴可能不垂直，如下图所示。</p>
<p>考虑轴间误差的时候，实际加速度和测量值之间的关系为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172240109.png#pic_center"><br>水平静止放置 6 面的时候，加速度的理论值为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172303634.png#pic_center"><br>对应的测量值矩阵 L ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172326866.png#pic_center"><br>利用最小二乘就能够把12个变量求出来。</p>
</blockquote>
<h4 id="六面法标定陀螺仪"><a href="#六面法标定陀螺仪" class="headerlink" title="六面法标定陀螺仪"></a>六面法标定陀螺仪</h4><blockquote>
<ul>
<li>六面法标定陀螺仪 bias 和 scale factor<br>和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这<br>里的 6 面是指各个轴顺时针和逆时针旋转。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017182109980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>参考：<a href="https://blog.csdn.net/CSDN_XCS/article/details/90339761" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_XCS/article/details/90339761</a></li>
</ul>
</blockquote>
<h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><ul>
<li>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</li>
<li>两种标定方法：<blockquote>
<p>• soak method: 控制恒温室的温度值，然后读取传感器数值进行标定。<br>• ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</p>
</blockquote>
</li>
</ul>
<h2 id="随机误差"><a href="#随机误差" class="headerlink" title="随机误差"></a>随机误差</h2><h3 id="高斯白噪声与随机游走"><a href="#高斯白噪声与随机游走" class="headerlink" title="高斯白噪声与随机游走"></a>高斯白噪声与随机游走</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数。故把瞬时值的概率分布服从高斯分布，功率谱密度服从均匀分布的噪声称为高斯白噪声</p>
<p>IMU 数据连续时间上受到一个均值为 0，方差为 $σ^2$，各时刻之间相互独立的高斯过程 n(t)：</p>
<script type="math/tex; mode=display">E[n(t)]=0</script><script type="math/tex; mode=display">E[n(t_1​)n(t_2​)]=σ^2δ(t_1​−t_2​)</script><p>自相关函数的数学定义：$R(τ)=∫^{−∞}_∞　x(t)x(t−τ)dt$</p>
<p>其中 $δ()$ 表示狄拉克函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190929113450104.png#pic_center"><br><strong>白噪声的离散化</strong><br>实际上， IMU 传感器获取的数据为离散采样，离散和连续高斯白噪声的方差之间存在如下转换关系：</p>
<script type="math/tex; mode=display">n_d[k] \triangleq n(t_0+\Delta t)\simeq\frac{1}{\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)dt</script><script type="math/tex; mode=display">
 \begin{aligned}
E(n_d[k]^2) & = E(\frac{1}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)n(t)d \tau dt) \\
&= E( \frac{\sigma^2}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\
&= E(\frac{\sigma^2}{\Delta t})
\end{aligned}</script><p>即:</p>
<script type="math/tex; mode=display">nd[k] = σ_dw[k]</script><p>其中：$w[k] ∼ N(0, 1)$，$\sigma_d=\sigma \frac{1}{\sqrt{\bigtriangleup t}}$<br>也就是说高斯白噪声的连续时间到离散时间之间差一个 $\frac{1}{\sqrt{\bigtriangleup t}}$ ，√∆t 是传感器的采样时间。</p>
<h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走</p>
<script type="math/tex; mode=display">\dot{b}_{(t)}=n(t)=\sigma_bw(t)</script><p>其中 w 是方差为 1 的白噪声</p>
<p>离散和连续之间的转换：</p>
<script type="math/tex; mode=display">b_d[k] \triangleq b(t_0) + \int_{t_0}^{t_0+\Delta t}n(t)dt$$$$\begin{aligned}
E((b_d[k]-b_d[k-1])^2) 
&=E(\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(t)n(\tau)d \tau dt)\\
&= E({\sigma_{b}^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\
&= E(\sigma_{b}^2\Delta t)
\end{aligned}</script><p>即：</p>
<script type="math/tex; mode=display">b_d[k] = b_d[k − 1] + σ_{bd}w[k]</script><p>其中：</p>
<script type="math/tex; mode=display">w[k] ∼ N(0, 1),σ_{bd} = σ_b\sqrt{\bigtriangleup t}</script><p>bias 随机游走的噪声方差从连续时间到离散之间需要乘以 $\sqrt{\bigtriangleup t}$ </p>
<h3 id="随机误差的标定"><a href="#随机误差的标定" class="headerlink" title="随机误差的标定"></a>随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><p>Allan 方差法是 20 世纪 60 年代由美国国家标准局的 David Allan 提出的，它是一种基于时域的分析方法。</p>
<blockquote>
<p>具体的流程如下：</p>
<ol>
<li>保持传感器绝对静止获取数据</li>
<li>对数据进行分段，设定时间段的时长，如下图所示<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204504508.png#pic_center"></li>
<li>将传感器数据按照时间段进行平均</li>
<li>计算方差，绘制艾伦曲线，得到的艾伦曲线如下图所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204557636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">Allan方差法可用于5种随机误差的标定：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017212131103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/YunLaowang/article/details/95608107" target="_blank" rel="noopener">VIO标定IMU随机误差：Allan方差法</a><br><a href="https://blog.csdn.net/lei1105034103/article/details/89159459" target="_blank" rel="noopener">陀螺 Allan 方差分析</a></li>
</ol>
</blockquote>
<h2 id="IMU-数学模型"><a href="#IMU-数学模型" class="headerlink" title="IMU 数学模型"></a>IMU 数学模型</h2><p>以 ECI 为参考坐标系（由于 ECI 为惯性系，不需要考虑地球自转）：<br>忽略 scale 的影响，只考虑白噪声和 bias 随机游走：<br>IMU的真实值：$w^b,a^b$<br>IMU的测量值：$\widetilde{w},\widetilde{a}^b$<br>IMU机体系即b系，w系表示世界坐标系。</p>
<script type="math/tex; mode=display">\begin{aligned}
 \widetilde{w}&=w^b +b^g+n^g\\
 \widetilde{a}^b&=a^b+b^a+n^a\\&=q_{bw}(a^w+g^w)+b^a+n^a
 \end{aligned}</script><p>考虑高斯白噪声项，有：</p>
<script type="math/tex; mode=display">\begin{aligned}
 &w^b=\widetilde{w} -b^g-n^g\\
 &a^w=q_{wb}(\widetilde{a}^b-b^a-n^a)-g^w
 \end{aligned}</script><p>不考虑高斯白噪声项，有：</p>
<script type="math/tex; mode=display">\begin{aligned}
 &w^b=\widetilde{w} -b^g\\
 &a^w=q_{wb}(\widetilde{a}^b-b^a)-g^w
 \end{aligned}</script><p>参考：<a href="https://fzheng.me/2016/11/20/imu_model_eq/#1-2-%E5%89%8D%E7%BD%AE2-%E5%9B%9B%E5%85%83%E6%95%B0" target="_blank" rel="noopener">从零开始的 IMU 状态模型推导</a></p>
]]></content>
      <categories>
        <category>VIO</category>
      </categories>
  </entry>
  <entry>
    <title>hexo4.0 - Next7.2.4 主题优化配置</title>
    <url>/2019/10/23/hexo4.0%20-%20Next7.2.4%20%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Next主题的安装"><a href="#Next主题的安装" class="headerlink" title="Next主题的安装"></a>Next主题的安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo_blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后设置站点配置文件_config.yml，Hexo博客主题替换为Next主题。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022101546332.png#pic_center">.</p><h1 id="Next主题优化配置"><a href="#Next主题优化配置" class="headerlink" title="Next主题优化配置"></a>Next主题优化配置</h1><h2 id="1-Next主题风格："><a href="#1-Next主题风格：" class="headerlink" title="1.Next主题风格："></a>1.Next主题风格：</h2><a id="more"></a>

<p>Next提供了四中主题风格scheme，可以在主题配置文件blog/themes/next/_config.yml文件中进行选择，分别是Muse、Mist、Pisces、Gemini：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022102034549.png#pic_center"></p>
<ul>
<li>Next主题一般配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation. Introduced in NexT v6.0.0.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment">#表示添加缓存功能，这样浏览器后续打开我们的博客网站会更快</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons / item badges.</span></span><br><span class="line">menu_settings:</span><br><span class="line">  icons: <span class="literal">true</span>  <span class="comment">#是否显示各个页面的图标</span></span><br><span class="line">  badges: <span class="literal">false</span> <span class="comment">#是否显示分类/标签/归档页的内容量</span></span><br></pre></td></tr></table></figure>
<p>相应的站点配置blog/_config.yml文件的基本配置为：</p>
<h2 id="2-添加博客自定义图标"><a href="#2-添加博客自定义图标" class="headerlink" title="2.添加博客自定义图标"></a>2.添加博客自定义图标</h2><p>选择或者创建相应大小的图标文件，放置在blog/themes/next/sources/images目录下，并在主题配置文件中进行如下配置，只需要设置small和medium两个就可以：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022104457616.png#pic_center"></p>
<h2 id="3-添加动态背景"><a href="#3-添加动态背景" class="headerlink" title="3.添加动态背景"></a>3.添加动态背景</h2><p>打开 next/layout/_layout.swig<br>在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件，打开 /next/_config.yml,在里面添加如下代码：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022145253296.png#pic_center">.</p>
<h2 id="4-添加看板娘"><a href="#4-添加看板娘" class="headerlink" title="4.添加看板娘"></a>4.添加看板娘</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>下载模型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install live2d-widget-model-wanko</span><br></pre></td></tr></table></figure>
<h2 id="5-鼠标点击特效"><a href="#5-鼠标点击特效" class="headerlink" title="5.鼠标点击特效"></a>5.鼠标点击特效</h2><p>鼠标的点击红心特效<br>在/themes/next/source/js/src下新建文件clicklove.js ，接着把下面的代码拷贝粘贴到 love.js 文件中：<br>7.4 next没有src文件夹，先建一个src文件夹<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span>(e,t,a)&#123;<span class="keyword">function</span> <span class="function"><span class="title">n</span></span>()&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="keyword">function</span> <span class="function"><span class="title">r</span></span>()&#123;<span class="keyword">for</span>(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="keyword">function</span> <span class="function"><span class="title">o</span></span>()&#123;var t=<span class="string">"function"</span>==typeof e.onclick&amp;&amp;e.onclick;e.onclick=<span class="keyword">function</span>(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="keyword">function</span> i(e)&#123;var a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;<span class="keyword">function</span> c(e)&#123;var a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[0].appendChild(a)&#125;<span class="keyword">function</span> <span class="function"><span class="title">s</span></span>()&#123;<span class="built_in">return</span><span class="string">"rgb("</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">")"</span>&#125;var d=[];e.requestAnimationFrame=<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="keyword">function</span>(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure></p>
<p>在\themes\next\layout_layout.swig文件末尾添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clicklove.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="6-设置头像"><a href="#6-设置头像" class="headerlink" title="6.设置头像"></a>6.设置头像</h2><p>在主题配置文件中设置头像，将其放置到 themes/next/source/images/avatar.png 路径，rounded是否设置成圆形，rotated是否设置成可旋转的。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022134436646.png#pic_center"></p>
<h2 id="7-设置RSS订阅"><a href="#7-设置RSS订阅" class="headerlink" title="7.设置RSS订阅"></a>7.设置RSS订阅</h2><p>博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>打开根目录配置文件_config.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure>
<p>然后设置主题配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>
<h2 id="8-侧边栏社交小图标设置"><a href="#8-侧边栏社交小图标设置" class="headerlink" title="8.侧边栏社交小图标设置"></a>8.侧边栏社交小图标设置</h2><p>打开主题配置文件_config.yml，command+f搜索 Social，将你有的社交账号前面的 # 号去掉。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022135427340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="9-Tag-标签前图标修改"><a href="#9-Tag-标签前图标修改" class="headerlink" title="9.Tag 标签前图标修改"></a>9.Tag 标签前图标修改</h2><p>文章标签的显示默认前面“#”号，可以通过设置将“#”换为图标。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tag_icon: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="10-访问量统计"><a href="#10-访问量统计" class="headerlink" title="10.访问量统计"></a>10.访问量统计</h2><ul>
<li>打开themes/next/下的_config.yml，查找busuanzi<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</li>
<li>打开/themes/next/layout/_partials/footer.swig，在最后添加如下内容：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span><br><span class="line">  本站访问次数：&lt;span class=<span class="string">"busuanzi-value"</span> id=<span class="string">"busuanzi_value_site_pv"</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-实现文章统计功能"><a href="#11-实现文章统计功能" class="headerlink" title="11.实现文章统计功能"></a>11.实现文章统计功能</h2><p>统计字数和阅读分钟数<br>安装 hexo-symbols-count-time，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件 hexo _config.yaml添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  time: <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  total_symbols: <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  total_time: <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  exclude_codeblock: <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>
<p>具体可查看：<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a><br>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022142919746.png#pic_center"></p>
<h2 id="12-添加网页顶部进度加载条"><a href="#12-添加网页顶部进度加载条" class="headerlink" title="12.添加网页顶部进度加载条"></a>12.添加网页顶部进度加载条</h2><p>下载安装Progress module，如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure></p>
<p>编辑主题配置文件，command+F 搜索 pace，将其值改为 ture 就可以了。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022144354865.png#pic_center"></p>
<h2 id="13-添加站内搜索"><a href="#13-添加站内搜索" class="headerlink" title="13.添加站内搜索"></a>13.添加站内搜索</h2><p>安装 hexo-generator-search<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><br>安装 hexo-generator-searchdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>编辑站点配置文件，添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure><br>编辑主题配置文件，设置 local_search为 ture<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102215014852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="14-Footer-页脚设置"><a href="#14-Footer-页脚设置" class="headerlink" title="14.Footer / 页脚设置"></a>14.Footer / 页脚设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  icon:</span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    name: user</span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="comment">## 图标的一个动画效果，类似于心跳</span></span><br><span class="line">    animated: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="comment"># 图标颜色，可格局需要自行修改</span></span><br><span class="line">    color: <span class="string">"#808080"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo 字样，不喜欢可以设置为 false</span></span><br><span class="line">  powered:</span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 主题字样，不喜欢可以 false</span></span><br><span class="line">  theme:</span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="comment"># 备案信息，如果网站有备案号，可以在这里填写备案号</span></span><br><span class="line">  beian:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">    icp:</span><br></pre></td></tr></table></figure>
<h2 id="15-Creative-Commons-文章版权"><a href="#15-Creative-Commons-文章版权" class="headerlink" title="15.Creative Commons / 文章版权"></a>15.Creative Commons / 文章版权</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-nd</span><br><span class="line">  post: <span class="literal">true</span></span><br><span class="line">  language: deed.zh</span><br></pre></td></tr></table></figure>
<p>在文章 .md 文件中的上部，添加 copyright: true。</p>
<h2 id="16-设置阅读全文"><a href="#16-设置阅读全文" class="headerlink" title="16.设置阅读全文"></a>16.设置阅读全文</h2><p>打开主题配置文件，修改auto_excerpt:字段为true，length表示显示文本的长度<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022151038529.png#pic_center"><br>在想要隐藏的位置加入以下代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="17-开启文章目录"><a href="#17-开启文章目录" class="headerlink" title="17.开启文章目录"></a>17.开启文章目录</h2><p>修改主题配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line">toc:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  number: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  wrap: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  expand_all: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure>
<h2 id="18-GitHub-Fork-Me"><a href="#18-GitHub-Fork-Me" class="headerlink" title="18.GitHub Fork Me"></a>18.GitHub Fork Me</h2><p>修改主题配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line">github_banner:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  permalink: https://github.com/Xiao-Hu-Z</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022161748244.png#pic_center"></p>
<h2 id="19-bookmark"><a href="#19-bookmark" class="headerlink" title="19.bookmark"></a>19.bookmark</h2><p>Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bookmark:	</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.	</span></span><br><span class="line">  color: <span class="string">"#222"</span>	</span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.	</span></span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure>
<h2 id="20-添加lazyload"><a href="#20-添加lazyload" class="headerlink" title="20. 添加lazyload"></a>20. 添加lazyload</h2><p>对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-jquery-lazyload <span class="built_in">source</span>/lib/jquery_lazyload</span><br></pre></td></tr></table></figure><br>主题配置文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Vanilla JavaScript plugin for lazyloading images.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/ApoorvSaxena/lozad.js</span></span><br><span class="line">lazyload: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="21-代码复制"><a href="#21-代码复制" class="headerlink" title="21.代码复制"></a>21.代码复制</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line">copy_button:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="22-SEO支持"><a href="#22-SEO支持" class="headerlink" title="22.SEO支持"></a>22.SEO支持</h2><p>SEO(Search Engine Optimization)意为搜索引擎优化,利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</p>
<ul>
<li>安装站点地图(sitemap)插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<ul>
<li>站点配置文件修改/添加</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SEO </span></span><br><span class="line">sitemap: </span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>启用百度推送功能，博客会自动将网址推送到百度，这对搜索引擎优化非常有帮助。<br>主题配置文件修改 baidu_push: true</p>
<h2 id="23-显示当前浏览进度"><a href="#23-显示当前浏览进度" class="headerlink" title="23.显示当前浏览进度"></a>23.显示当前浏览进度</h2><p>打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true ，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Scroll percent label in b2t button.# # 是否显示页面浏览百分比</span><br><span class="line">scrollpercent: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h1><h2 id="1-支持数学公式"><a href="#1-支持数学公式" class="headerlink" title="1.支持数学公式"></a>1.支持数学公式</h2><p>可能在一些情况下我们需要写一个公式，makdown是支持的，next也支持。</p>
<p>Next 主题提供了两个渲染引擎，分别是 mathjax 和katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations。" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/math-equations。</a></p>
<p>这里选择 mathjax ,通过修改配置即可启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>注意：使用的时候需要在 文章开头加上mathjax: true</p>
<h2 id="2-添加APlayer音乐播放器"><a href="#2-添加APlayer音乐播放器" class="headerlink" title="2.添加APlayer音乐播放器"></a>2.添加APlayer音乐播放器</h2><p>为博客添加音乐播放器功能</p>
<p><strong>download</strong><br>点击访问Aplayer源码：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">GitHub Aplayer</a>。下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下。</p>
<p><strong>music.js</strong><br>新建themes\next\source\dist\music.js文件，添加内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const ap = new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(<span class="string">'aplayer'</span>),</span><br><span class="line">    fixed: <span class="literal">true</span>,</span><br><span class="line">    autoplay: <span class="literal">true</span>,</span><br><span class="line">    audio: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"暗涌"</span>,</span><br><span class="line">        artist: <span class="string">'王菲'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/52980.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/w8RFsMH8VJfPsBmVudYGsA==/109951163020569833.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Wonderful U'</span>,</span><br><span class="line">        artist: <span class="string">'AGA'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/51181.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Blb_Gi0AJTWIEBLr189F4A==/18791753232142320.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'浮夸'</span>,</span><br><span class="line">        artist: <span class="string">'陈奕迅'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/49639.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Bl1hEdJbMSj5YJsTqUjr-w==/109951163520311175.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>源码参数解释<a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">APlayer 中文文档</a></p>
<p>audio对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：<a href="http://up.mcyt.net/" target="_blank" rel="noopener">http://up.mcyt.net/</a> ，搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。</p>
<p><strong>_layout.swig</strong><br>打开themes\next\layout_layout.swig文件,在<body><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body> 里面添加以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"aplayer"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/APlayer.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/music.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>重新生成，访问页面，就能看到左下角的音乐播放器了。</p>
<h2 id="3-DaoVoice在线联系功能"><a href="#3-DaoVoice在线联系功能" class="headerlink" title="3.DaoVoice在线联系功能"></a>3.DaoVoice在线联系功能</h2><p><a href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/" target="_blank" rel="noopener">https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/</a></p>
<h1 id="自定义样式支持"><a href="#自定义样式支持" class="headerlink" title="自定义样式支持"></a>自定义样式支持</h1><h2 id="1-文章末尾统一添加“本文结束”标记"><a href="#1-文章末尾统一添加“本文结束”标记" class="headerlink" title="1.文章末尾统一添加“本文结束”标记"></a>1.文章末尾统一添加“本文结束”标记</h2><p>主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  postBodyEnd: <span class="built_in">source</span>/_data/post-body-end.swig</span><br></pre></td></tr></table></figure>
<p>接着打开\themes\next\layout_macro\post.swig文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在路径 /source/_data 下创建/修改 post-body-end.swig文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------本文结束&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-主题及标题栏背景图"><a href="#2-主题及标题栏背景图" class="headerlink" title="2.主题及标题栏背景图"></a>2.主题及标题栏背景图</h2><p>首先主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>
<p> 在路径~/hexo_blog/source/_data创建/修改 styles.styl文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line">body &#123;</span><br><span class="line">      background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址</span><br><span class="line">      background-size: cover;</span><br><span class="line">      background-repeat: no-repeat;</span><br><span class="line">      background-attachment: fixed;</span><br><span class="line">      background-position: 50% 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 标题栏背景</span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: 20px 0;</span><br><span class="line">    color: <span class="comment">#fff;</span></span><br><span class="line">    background: <span class="variable">$blue</span>;</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:center;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 修改主体透明度</span><br><span class="line">.main-inner&#123;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    opacity: 0.95;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改菜单栏透明度，会引起本地搜索菜单bug</span><br><span class="line">//.header-inner &#123;</span><br><span class="line">//    opacity: 0.95;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 主页文章添加阴影效果</span><br><span class="line">.post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-修改主副标题字体颜色"><a href="#3-修改主副标题字体颜色" class="headerlink" title="3.修改主副标题字体颜色"></a>3.修改主副标题字体颜色</h2><p>继续在/source/_data/styles.styl文件中添加，帮你挑选颜色的网站： <a href="https://www.color-hex.com/" target="_blank" rel="noopener">color-hex</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主标题颜色</span></span><br><span class="line">.brand&#123;</span><br><span class="line">    color: $white</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//副标题颜色</span></span><br><span class="line">.site-subtitle &#123;</span><br><span class="line">    margin-top: <span class="number">10</span>px;</span><br><span class="line">    font-size: <span class="number">13</span>px;</span><br><span class="line">    color: <span class="meta">#ffffff;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-修改按钮，选择区域，代码块，表格等样式"><a href="#4-修改按钮，选择区域，代码块，表格等样式" class="headerlink" title="4.修改按钮，选择区域，代码块，表格等样式"></a>4.修改按钮，选择区域，代码块，表格等样式</h2><p>首先主题配置文件取消注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/variables.styl</span><br></pre></td></tr></table></figure>
<p>在路径 /source/_data 下创建/修改 variables.styl文件（相当于修改主题文件 next/source/css/_variables/base.styl），并添加以下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buttons</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$btn-<span class="keyword">default</span>-bg                 = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-color              = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-font-size          = $font-size-small;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-width       = <span class="number">2</span>px;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-color       = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-bg           = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-color        = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-border-color = #<span class="number">49b</span>1f5;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Selection</span></span><br><span class="line">$selection-bg                 = #<span class="number">49b</span>1f5;</span><br><span class="line">$selection-color              = white;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code &amp; Code Blocks</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$code-font-family               = $font-family-monospace;</span><br><span class="line">$code-border-radius             = <span class="number">3</span>px;</span><br><span class="line">$code-foreground                = $black-light;</span><br><span class="line">$code-background                = #edf1ff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Table</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$table-width                    = normal;  <span class="comment">//next默认100%</span></span><br><span class="line">$table-border-color             = $gray-lighter;</span><br><span class="line">$table-font-size                = $font-size-small;</span><br><span class="line">$table-content-alignment        = left;</span><br><span class="line">$table-content-vertical         = middle;</span><br><span class="line">$table-th-font-weight           = <span class="number">700</span>;</span><br><span class="line">$table-cell-padding             = <span class="number">8</span>px;</span><br><span class="line">$table-cell-border-right-color  = $gainsboro;</span><br><span class="line">$table-cell-border-bottom-color = $gray-lighter;</span><br><span class="line">$table-row-odd-bg-color         = #f9f9f9;</span><br><span class="line">$table-row-hover-bg-color       = $whitesmoke;</span><br></pre></td></tr></table></figure>
<h1 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h1><h2 id="托管-Hexo-博客到-Coding"><a href="#托管-Hexo-博客到-Coding" class="headerlink" title="托管 Hexo 博客到 Coding"></a>托管 Hexo 博客到 Coding</h2><p>注意：coding账号注册时请选择个人版（如果注册了团队版，你会发现跟网上给的教程不太一样，而且，部署出来的网页地址无法修改成xxx.coding.me）。</p>
<ul>
<li>创建项目<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027145840374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
<li>配置SSH公钥<br>首先点击右上角的头像-个人设置-SSH公钥-新增公匙-输入你自己的SSH公匙-永久有效(推荐)-确定即可。</li>
<li>修改站点配置文件<br>对该配置进行修改如下(注意缩进)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">    coding: git@git.dev.tencent.com:Xiao-Hu-Z/Xiao-Hu-Z.coding.me.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>该配置指定了Coding仓库的地址，并通过HTTPS方式进行连接。同样我们也可以通过SSH方式。<br>安装完成后，开始项目的部署操作，用的是HTTPS方式，会弹出输入用户名密码的输入框，键入你的coding用户名密码即可。</p>
<h2 id="gulp-4-0实现静态资源压缩"><a href="#gulp-4-0实现静态资源压缩" class="headerlink" title="gulp 4.0实现静态资源压缩"></a>gulp 4.0实现静态资源压缩</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install gulp</span><br></pre></td></tr></table></figure>
<ul>
<li>安装这些功能模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</span><br></pre></td></tr></table></figure>
<ul>
<li>创建任务在站点根目录下新建gulpfile.js文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var gulp = require(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">//Plugins模块获取</span><br><span class="line">var minifycss = require(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line">var uglify = require(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">var htmlmin = require(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line">var htmlclean = require(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line">//压缩css</span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">//压缩html</span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">.pipe(htmlclean())</span><br><span class="line">.pipe(htmlmin(&#123;</span><br><span class="line">removeComments: <span class="literal">true</span>,</span><br><span class="line">minifyJS: <span class="literal">true</span>,</span><br><span class="line">minifyCSS: <span class="literal">true</span>,</span><br><span class="line">minifyURLs: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩js 不压缩min.js</span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.0以前的写法</span><br><span class="line">//gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">  //  <span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span></span><br><span class="line">//]);</span><br><span class="line">//4.0以后的写法</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // Do something after a, b, and c are finished.</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/qq_41518277/article/details/101766036#_355" target="_blank" rel="noopener">NexT主题进阶</a><br><a href="https://blog.csdn.net/colton_null/article/details/97622079" target="_blank" rel="noopener">Hexo Theme NexT 主题个性化配置最佳实践</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86556971" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列4-加速Hexo博客</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86538306" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列2-部署博客到Coding上</a><br><a href="https://hanhanhanxu.github.io/2019/05/15/coding/" target="_blank" rel="noopener">使用coding加快博客网站访问速度</a><br><a href="http://ju.outofmemory.cn/entry/105418" target="_blank" rel="noopener">托管 Hexo 博客到 Coding</a><br><a href="https://www.cnblogs.com/aoguai/p/11405829.html" target="_blank" rel="noopener">2019hexo博客部署到coding该绕的坑</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——视觉前段处理</title>
    <url>/2019/10/23/VINS-Mono%E2%80%94%E2%80%94%E8%A7%86%E8%A7%89%E5%89%8D%E6%AE%B5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h1><p>每当进入新的图像，都会使用KLT稀疏光流法进行跟踪，同时提取100-300个角点信息，我的理解是角点是用来建立图像，光流跟踪是用来快速定位。同时在这里还进行了关键帧的选取（注意这一过程在代码中是由vins_estimate文件中实现的），主要是两个剔除关键帧的策略，分别是平均视差法和跟踪质量法。平均视差法：如果当前帧的和上一个关键帧跟踪点的平均视差超出了一个设定的阈值，就将当前帧设为关键帧。这里有一个问题，就是旋转和平移都会产生视差（不只是平移哦），当出现纯旋转的时候特征点无法被三角化，无法计算出旋转值，也就无法计算跟踪点间的平均视差，为了解决这一问题，采用短时的陀螺仪观测值来补偿旋转，从而计算出视差，这一过程只应用到平均视差的计算，不会影响真实的旋转结果。</p><a id="more"></a>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023190400778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="节点概览"><a href="#节点概览" class="headerlink" title="节点概览"></a>节点概览</h1><p>该节点的功能是：接收图像数据，进行角点提取和光流跟踪，输出跟踪的特征点（角点）。feature_tracker_node的消息订阅发布如下表：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023221410832.png"></p>
<h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>主要负责图像角点提取和光流跟踪，主要是三个源程序，分别是feature_tracker、feature_tracker_node以及parameters。feature_tracker_node是特征跟踪线程的系统入口，feature_tracker是特征跟踪算法的具体实现，parameters是设备等参数的读取和存放。</p>
<h2 id="程序入口main-函数"><a href="#程序入口main-函数" class="headerlink" title="程序入口main()函数"></a>程序入口main()函数</h2><ul>
<li>1、ros初始化和设置句柄，设置logger级别</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"feature_tracker"</span>);</span><br><span class="line">ros::<span class="function">NodeHandle <span class="title">n</span><span class="params">(<span class="string">"~"</span>)</span></span>;</span><br><span class="line">ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info);</span><br></pre></td></tr></table></figure>
<ul>
<li>2、readParameters(n);读取参数，如config-&gt;euroc-&gt;euroc_config.yaml中的一些配置参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">readParameters(n);</span><br></pre></td></tr></table></figure>
<ul>
<li>3、读取每个相机实例读取对应的相机内参，NUM_OF_CAM=1为单目</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++) </span><br><span class="line">       trackerData[i].readIntrinsicParameter(CAM_NAMES[i]);</span><br></pre></td></tr></table></figure>
<p>节点在启动时会先读取相机内参，根据config_file文件中model_type的值决定采用何种相机模型，并创建相应模型的对象指针，读取在该模型下需要的参数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readIntrinsicParameter(<span class="keyword">const</span> <span class="built_in">string</span> &amp;calib_file)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"reading paramerter of camera %s"</span>, calib_file.c_str());</span><br><span class="line">    m_camera = CameraFactory::instance()-&gt;generateCameraFromYamlFile(calib_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CameraPtr</span><br><span class="line">CameraFactory::generateCameraFromYamlFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span><br><span class="line">&#123;</span><br><span class="line">    cv::<span class="function">FileStorage <span class="title">fs</span><span class="params">(filename, cv::FileStorage::READ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fs.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> CameraPtr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Camera::ModelType modelType = Camera::MEI;</span><br><span class="line">    <span class="keyword">if</span> (!fs[<span class="string">"model_type"</span>].isNone())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sModelType;</span><br><span class="line">        fs[<span class="string">"model_type"</span>] &gt;&gt; sModelType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//卡特鱼眼相机</span></span><br><span class="line">        <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"kannala_brandt"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::KANNALA_BRANDT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"mei"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::MEI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"scaramuzza"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::SCARAMUZZA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"pinhole"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::PINHOLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"# ERROR: Unknown camera model: "</span> &lt;&lt; sModelType &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> CameraPtr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (modelType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> Camera::KANNALA_BRANDT:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">EquidistantCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> EquidistantCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        EquidistantCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::PINHOLE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">PinholeCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> PinholeCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        PinholeCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::SCARAMUZZA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">OCAMCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> OCAMCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        OCAMCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::MEI:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">CataCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> CataCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        CataCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CameraPtr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、判断是否加入鱼眼mask来去除边缘噪声</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(FISHEYE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//FISHEYE_MASK  fisheye_mask.jpg 路径</span></span><br><span class="line">        trackerData[i].fisheye_mask = cv::imread(FISHEYE_MASK, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!trackerData[i].fisheye_mask.data)</span><br><span class="line">        &#123;</span><br><span class="line">            ROS_INFO(<span class="string">"load mask fail"</span>);</span><br><span class="line">            ROS_BREAK();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ROS_INFO(<span class="string">"load mask success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、订阅话题IMAGE_TOPIC(如/cam0/image_raw)，执行回调函数img_callback，对新来的图像进行特征点追踪、处理和发布<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros::Subscriber sub_img = n.subscribe(IMAGE_TOPIC, <span class="number">100</span>, img_callback);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>单目时：FeatureTracker::readImage() 函数读取图像数据进行处理<br>单目i=0<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readImage(<span class="keyword">const</span> cv::Mat &amp;_img, <span class="keyword">double</span> _cur_time)</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat img;</span><br><span class="line">    TicToc t_r;</span><br><span class="line">    cur_time = _cur_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (EQUALIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">        cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">        TicToc t_c;</span><br><span class="line">        clahe-&gt;apply(_img, img);</span><br><span class="line">        ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        img = _img;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">        prev_img = cur_img = forw_img = img;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forw_img = img;</span><br><span class="line"></span><br><span class="line">    forw_pts.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_pts.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TicToc t_o;</span><br><span class="line">        <span class="built_in">vector</span>&lt;uchar&gt; status;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; err;</span><br><span class="line">        cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">            <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">                status[i] = <span class="number">0</span>;</span><br><span class="line">        reduceVector(prev_pts, status);</span><br><span class="line">        reduceVector(cur_pts, status);</span><br><span class="line">        reduceVector(forw_pts, status);</span><br><span class="line">        reduceVector(ids, status);</span><br><span class="line">        reduceVector(cur_un_pts, status);</span><br><span class="line">        reduceVector(track_cnt, status);</span><br><span class="line">        ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : track_cnt)</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectWithF();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">        TicToc t_m;</span><br><span class="line">        setMask();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">        TicToc <span class="keyword">t_t</span>;</span><br><span class="line">        <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">        <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mask.empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n_pts.clear();</span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">        TicToc t_a;</span><br><span class="line">        addPoints();</span><br><span class="line">        ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    prev_img = cur_img;</span><br><span class="line">    prev_pts = cur_pts;</span><br><span class="line">    prev_un_pts = cur_un_pts;</span><br><span class="line">    cur_img = forw_img;</span><br><span class="line">    cur_pts = forw_pts;</span><br><span class="line">    undistortedPoints();</span><br><span class="line">    prev_time = cur_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6、发布feature，实例feature_points，跟踪的特征点，给后端优化用<br>发布feature_img，实例ptr，跟踪的特征点图，给RVIZ用和调试用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pub_img = n.advertise&lt;sensor_msgs::PointCloud&gt;(<span class="string">"feature"</span>, <span class="number">1000</span>);</span><br><span class="line">pub_match = n.advertise&lt;sensor_msgs::Image&gt;(<span class="string">"feature_img"</span>,<span class="number">1000</span>);</span><br><span class="line">pub_restart = n.advertise&lt;std_msgs::Bool&gt;(<span class="string">"restart"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="回调函数img-callback"><a href="#回调函数img-callback" class="headerlink" title="回调函数img_callback()"></a>回调函数img_callback()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">img_callback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;img_msg)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数是ROS的回调函数，主要功能包括：readImage()函数对新来的图像使用光流法进行特征点跟踪，并将追踪的特征点封装成feature_points发布到pub_img的话题下，将图像封装成ptr发布在pub_match下。</p>
<ul>
<li>1、判断是否是第一帧</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为第一帧</span></span><br><span class="line"><span class="keyword">if</span>(first_image_flag)</span><br><span class="line">&#123;</span><br><span class="line">    first_image_flag = <span class="literal">false</span>;</span><br><span class="line">    first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    last_image_time  = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、判断时间间隔是否正确，有问题则restart</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (img_msg-&gt;header.stamp.toSec() - last_image_time &gt; <span class="number">1.0</span> || img_msg-&gt;header.stamp.toSec() &lt; last_image_time)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_WARN(<span class="string">"image discontinue! reset the feature tracker!"</span>);</span><br><span class="line">    first_image_flag = <span class="literal">true</span>; </span><br><span class="line">    last_image_time = <span class="number">0</span>;</span><br><span class="line">    pub_count = <span class="number">1</span>;</span><br><span class="line">    std_msgs::Bool restart_flag;</span><br><span class="line">    restart_flag.data = <span class="literal">true</span>;</span><br><span class="line">    pub_restart.publish(restart_flag);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、发布频率控制，并不是每读入一帧图像，就要发布特征点，通过判断间隔时间内的发布次数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> tmp_freq = <span class="number">1.0</span> * pub_count / (img_msg-&gt;header.stamp.toSec() - first_image_time);</span><br><span class="line"> <span class="keyword">if</span> (round(tmp_freq) &lt;= FREQ)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//PUB_THIS_FRAME 是否需要发布特征点</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">// // 时间间隔内的发布频率十分接近设定频率时，更新时间间隔起始时刻，并将数据发布次数置0</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp_freq - FREQ) &lt; <span class="number">0.01</span> * FREQ)</span><br><span class="line">     &#123;</span><br><span class="line">         first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">         pub_count = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、将图像编码8UC1转换为mono8</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv_bridge::CvImageConstPtr ptr;</span><br><span class="line"><span class="keyword">if</span> (img_msg-&gt;encoding == <span class="string">"8UC1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将图像编码8UC1转换为mono8</span></span><br><span class="line">    sensor_msgs::Image img;</span><br><span class="line">    img.header = img_msg-&gt;header;</span><br><span class="line">    img.height = img_msg-&gt;height;</span><br><span class="line">    img.width = img_msg-&gt;width;</span><br><span class="line">    img.is_bigendian = img_msg-&gt;is_bigendian;</span><br><span class="line">    img.step = img_msg-&gt;step;</span><br><span class="line">    img.data = img_msg-&gt;data;</span><br><span class="line">    img.encoding = <span class="string">"mono8"</span>;</span><br><span class="line">    ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);</span><br></pre></td></tr></table></figure>
<ul>
<li>5、单目时：FeatureTracker::readImage() 函数读取图像数据进行处理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"processing camera %d"</span>, i);</span><br><span class="line">    <span class="comment">//双目跟踪则为1,单目false</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span> || !STEREO_TRACK) <span class="comment">// 针对单目相机读入图像，进入KLT跟踪阶段</span></span><br><span class="line">        <span class="comment">//ROW = fsSettings["image_height"]  rowRange和colRange函数可以获取某些范围内行或列的指针</span></span><br><span class="line">        trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure>
<ul>
<li>6、更新特征点ID</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> completed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_OF_CAM; j++)</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span> || !STEREO_TRACK)</span><br><span class="line">                <span class="comment">////更新特征点id</span></span><br><span class="line">                completed |= trackerData[j].updateID(i);</span><br><span class="line">        <span class="keyword">if</span> (!completed)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始FeatureTracker::n_id = 0;id初始化-1</span></span><br><span class="line"><span class="keyword">bool</span> FeatureTracker::updateID(<span class="keyword">unsigned</span> <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; ids.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ids[i] == <span class="number">-1</span>)</span><br><span class="line">            ids[i] = n_id++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7、如果PUB_THIS_FRAME=1则进行发布<blockquote>
<ul>
<li>将特征点id，矫正后归一化平面的3D点(x,y,z=1)，像素2D点(u,v)，像素的速度(vx,vy)，封装成sensor_msgs::PointCloudPtr类型的feature_points实例中,发布到pub_img;</li>
<li>将图像封装到cv_bridge::cvtColor类型的ptr实例中发布到pub_match</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="图像特征跟踪FeatureTracker-readImage"><a href="#图像特征跟踪FeatureTracker-readImage" class="headerlink" title="图像特征跟踪FeatureTracker::readImage()"></a>图像特征跟踪FeatureTracker::readImage()</h2><ul>
<li>1、通过EQUALIZE值判断是否进行自适应直方图均衡化，如果EQUALIZE=1（表示太亮或则太暗)，调用cv::CLAHE对图像做直方图均衡化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果EQUALIZE=1，表示太亮或则太暗</span></span><br><span class="line"><span class="keyword">if</span> (EQUALIZE)<span class="comment">//判断是否进行直方图均衡化处理</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">    cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">    TicToc t_c;</span><br><span class="line">    clahe-&gt;apply(_img, img);</span><br><span class="line">    ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    img = _img;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、 区分是否为第一次读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">    <span class="comment">//如果当前帧的图像数据forw_img为空，说明当前是第一次读入图像数据</span></span><br><span class="line">    <span class="comment">//将读入的图像赋给前帧forw_img</span></span><br><span class="line">    <span class="comment">//同时，还将读入的图像赋给prev_img、cur_img，这是为了避免后面使用到这些数据时，它们是空的</span></span><br><span class="line">    prev_img = cur_img = forw_img = img;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则，说明之前就已经有图像读入</span></span><br><span class="line">    <span class="comment">//所以只需要更新前帧forw_img的数据</span></span><br><span class="line">    forw_img = img;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、calcOpticalFlowPyrLK() 从cur_pts到forw_pts做LK金字塔光流法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用cv::calcOpticalFlowPyrLK()对前一帧的特征点cur_pts进行LK金字塔光流跟踪，得到forw_pts</span></span><br><span class="line"><span class="comment">//status标记了从前一帧cur_img到forw_img特征点的跟踪状态，无法被追踪到的点标记为0</span></span><br><span class="line">cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>4、根据status，把跟踪失败的和位于图像边界外的点剔除，剔除时不仅要从当前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts、cur_pts，记录特征点id的ids，和记录特征点被跟踪次数的track_cnt中剔除；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//将位于图像边界外的点标记为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">        <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">            status[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据status,把跟踪失败的点剔除</span></span><br><span class="line">    <span class="comment">//不仅要从前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts和cur_pts中剔除</span></span><br><span class="line">    <span class="comment">//prev_pts和cur_pts中的特征点是一一对应的</span></span><br><span class="line">    <span class="comment">//记录特征点id的ids，和记录特征点被跟踪次数的track_cnt也要剔除</span></span><br><span class="line">    reduceVector(prev_pts, status);</span><br><span class="line">    reduceVector(cur_pts, status);</span><br><span class="line">    reduceVector(forw_pts, status);</span><br><span class="line">    reduceVector(ids, status);</span><br><span class="line">    reduceVector(cur_un_pts, status);</span><br><span class="line">    reduceVector(track_cnt, status);</span><br><span class="line">    ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、根据PUB_THIS_FRAME是否发布特征，<ul>
<li>如果不需要发布特征点,则到这步就完了,把当前帧forw赋给上一帧cur, 然后退出 </li>
<li>如果发布特征：<blockquote>
<p>1、先调用rejectWithF()对prev_pts和forw_pts做ransac剔除outlier.(实际就是调用了findFundamentalMat函数), 在光流追踪成功就记被追踪+1，数值代表被追踪的次数，数值越大，说明被追踪的就越久<br>2、调用setMask(), 先对跟踪点forw_pts按跟踪次数降排序, 然后依次选点, 选一个点, 在mask中将该点周围一定半径的区域设为0, 后面不再选取该区域内的点. 有点类似与non-max suppression, 但区别是这里保留track_cnt最高的点<br>3、在mask中不为0的区域,调用goodFeaturesToTrack() 寻找新的特征点(shi-tomasi角点)，添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点<br>4、通过addPoints()函数push到forw_pts中, id初始化-1,track_cnt初始化为1.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//主要是通过基本矩阵（F）去除外点outliers</span></span><br><span class="line">    rejectWithF();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">    TicToc t_m;</span><br><span class="line">    <span class="comment">//对跟踪点进行排序并去除密集点。</span></span><br><span class="line">    setMask();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">    TicToc <span class="keyword">t_t</span>;</span><br><span class="line">    <span class="comment">//计算是否需要提取新的特征点,MAX_CNT:特征点最大个数150</span></span><br><span class="line">    <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">    <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MIN_DIST:特征点之间的最小间隔30</span></span><br><span class="line">        <span class="comment">//寻找新的特征点(shi-tomasi角点),添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点</span></span><br><span class="line">        cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">    &#125;</span><br><span class="line">                  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n_pts.clear();</span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">    TicToc t_a;</span><br><span class="line">    <span class="comment">//添将新检测到的特征点n_pts添加到forw_pts中，id初始化-1,track_cnt初始化为1.</span></span><br><span class="line">    addPoints();</span><br><span class="line">    ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>6、undistortedPoints() 对特征点的图像坐标根据不同的相机模型进行去畸变矫正和深度归一化，计算每个角点的速度</li>
</ul>
<p>待写！！！</p>
<p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/85797156" target="_blank" rel="noopener">VINS-Mono代码解读——视觉跟踪 feature_trackers</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719401" target="_blank" rel="noopener">VINS理论与代码详解2——单目视觉跟踪</a><br><a href="https://blog.csdn.net/q597967420/article/details/76099425" target="_blank" rel="noopener">VINS-Mono源码解析（二）前端：特征跟踪</a></p>
]]></content>
      <categories>
        <category>VINS</category>
      </categories>
      <tags>
        <tag>VINS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16下Github+Hexo搭建博客教程</title>
    <url>/2019/10/23/Ubuntu16%E4%B8%8BGithub+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿博客网址</p><p>==<a href="https://xiao-hu.com.cn/">https://xiao-hu.com.cn/</a>==</p><h1 id="安装git、nodejs"><a href="#安装git、nodejs" class="headerlink" title="安装git、nodejs"></a>安装git、nodejs</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>升级nodejs版本，目前的最新版本v10.6.0<br>参考：<a href="https://blog.csdn.net/u010277553/article/details/80938829" target="_blank" rel="noopener">Ubuntu16 升级nodejs版本</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line"></span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><br>加速下载：<a href="https://blog.csdn.net/ibmall/article/details/81390639" target="_blank" rel="noopener">npm 安装 hexo 卡住问题解决</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hexo init xiaohu</span><br><span class="line"><span class="built_in">cd</span> xiaohu </span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹目录下有：</p>
<blockquote>
<p>   node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p>
</blockquote>
<p>再次输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hexo g <span class="comment">#生成静态页面</span></span><br><span class="line">sudo hexo server <span class="comment">#启动服务器</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这时候就可以用浏览器打开网址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 来进行预览了。</p>
<h1 id="github创建"><a href="#github创建" class="headerlink" title="github创建"></a>github创建</h1><p>以前创好了：<a href="https://mp.csdn.net/mdeditor/94998475#" target="_blank" rel="noopener">Ubuntu16.04 git安装与配置</a></p>
<h1 id="创建repo"><a href="#创建repo" class="headerlink" title="创建repo"></a>创建repo</h1><p>在github上面创建一个项目，名为Xiao-Hu-Z+github.io </p>
<h1 id="将hexo部署到github"><a href="#将hexo部署到github" class="headerlink" title="将hexo部署到github"></a>将hexo部署到github</h1><p>打开站点配置文件_config.yml，翻到最后，进行修改。其中YourgithubName就是你的GitHub账户。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br>deploy时要你输入username和password。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在站点目录下输入下面的插件安装</span></span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo generate</span><br><span class="line">sudo hexo deploy</span><br></pre></td></tr></table></figure>
<p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p>
<p>输入：<a href="https://Xiao-Hu-Z.github.io/看到自己的博客" target="_blank" rel="noopener">https://Xiao-Hu-Z.github.io/看到自己的博客</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://Xiao-Hu-Z.github.io/</span><br></pre></td></tr></table></figure>
<h1 id="绑定域名："><a href="#绑定域名：" class="headerlink" title="绑定域名："></a>绑定域名：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping Xiao-Hu-Z.github.io</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/e3169b681038" target="_blank" rel="noopener">[Hexo个人博客]域名绑定 简明教程（小白篇）</a></p>
</blockquote>
<p>参考：<a href="https://blog.csdn.net/zxwsbg/article/details/97487666" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://blog.csdn.net/wang_da_bing/article/details/82818445" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://www.cnblogs.com/yangzhaonan/p/9351838.html" target="_blank" rel="noopener">使用GitHub+Hexo建立个人网站，并绑定自己的域名（Ubuntu环境下）</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>11.旋转数组的最小数字</title>
    <url>/2019/10/22/11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目：<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p> <strong>思路1：</strong><br>暴力解法：根据给定的数组特点，从左到右遍历数组元素，当首次遇到数组中某个元素比上一个元素小时，该元素就是我们需要的元素</p><a id="more"></a>

<p><strong>思路2：</strong></p>
<ul>
<li>二分查找：<blockquote>
<ul>
<li>用两个指针，分别指向数组的第一个和最后一个元素</li>
<li>接着找到中间元素，如果中间元素位于前面的递增子数组（中间元素大于或等于第一个元指针指向元素）把第一个指针指向中间元素</li>
<li>如果中间元素位于后面的递增子数组（中间元素大于或等于第一个元指针指向元素），把第二个指针指向中间元素</li>
<li>最终，两指针会指向相邻的元素，第二个指针刚好指向是最小元素</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[i]&lt;=rotateArray[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>二分查找：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = low;<span class="comment">//防止数组的前面0个元素搬到最后面</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(rotateArray[low]&gt;=rotateArray[high])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(high-low==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid=high;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[low]==rotateArray[high] &amp;&amp; rotateArray[low]==rotateArray[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> result=rotateArray[low];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=high;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rotateArray[i]&lt;result)</span><br><span class="line">                        result=rotateArray[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid]&gt;=rotateArray[low])</span><br><span class="line">                low=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid]&lt;=rotateArray[high])</span><br><span class="line">                high=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(rotateArray)):</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i<span class="number">-1</span>]&gt;rotateArray[i]):</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        high=len(rotateArray)<span class="number">-1</span></span><br><span class="line">        mid=low</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> rotateArray[low]&gt;=rotateArray[high]:</span><br><span class="line">            <span class="keyword">if</span> high-low==<span class="number">1</span>:</span><br><span class="line">                mid=high</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            mid=(low+high)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[low]==rotateArray[high] <span class="keyword">and</span> rotateArray[low]==rotateArray[mid]:</span><br><span class="line">                result = rotateArray[low]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(low,high+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> result &gt; rotateArray[i]:</span><br><span class="line">                        result = rotateArray[i]</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid]&gt;=rotateArray[low]:</span><br><span class="line">                low=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high=mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>10.斐波那契数列（跳台阶）</title>
    <url>/2019/10/20/10.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿题目一：<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><p>思路</p><ul>
<li>如果只有一阶台阶，一种跳法，如果只有两阶台阶，两种跳法</li>
<li>把n阶台阶时的跳法看成n的函数，记法f(n)，f(n)=f(n-1)+f(n-2)</li>
</ul><p>采用循环方式实现，递归实践效率太低<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result[n];         </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibOne=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibTwo=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fibN=fibOne+fibTwo;</span><br><span class="line">            fibOne=fibTwo;</span><br><span class="line">            fibTwo=fibN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibN;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        result=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> result[n]</span><br><span class="line">        </span><br><span class="line">        f1=<span class="number">1</span></span><br><span class="line">        f2=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            fn=f1+f2</span><br><span class="line">            f1=f2</span><br><span class="line">            f2=fn</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>相关题目：</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> result[number];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">2</span>,fn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fn=f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=fn;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f=<span class="number">2</span>*f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//return pow(2,number-1);</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>KLT 光流算法</title>
    <url>/2019/10/20/KLT-%E5%85%89%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Optical-Flow"><a href="#Optical-Flow" class="headerlink" title="Optical Flow"></a>Optical Flow</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132123717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132137931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="KLT"><a href="#KLT" class="headerlink" title="KLT"></a>KLT</h1><p>KLT 算法本质上也基于光流的三个假设，不同于前述直接比较像素点灰度值的作法，KLT 比较像素点周围的窗口像素，来寻找最相似的像素点。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102013215737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132228980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流—LK光流—基于金字塔分层的LK光流—中值流</a><br><a href="https://leijiezhang001.github.io/KLT/" target="_blank" rel="noopener">KLT 光流算法详解</a><br><a href="https://blog.csdn.net/irobot_davinci/article/details/29635199" target="_blank" rel="noopener">KLT角点跟踪算法(LK)学习（一）——算法原理</a></p>]]></content>
      <categories>
        <category>VINS</category>
      </categories>
  </entry>
  <entry>
    <title>9.用两个栈实现队列</title>
    <url>/2019/10/20/9.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：</p><ul>
<li>首先把元素插入stack1;</li>
<li>当stack2为空时，把stack1的元素逐个弹出并压入stack2</li>
<li>当stack2步为空时，在stack2的栈顶元素最先进入队列的元素，可以弹出</li>
</ul><p><strong>C++</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s.empty();         //如果栈为空则返回true, 否则返回false;</span></span><br><span class="line"><span class="comment">s.size();          //返回栈中元素的个数</span></span><br><span class="line"><span class="comment">s.top();           //返回栈顶元素, 但不删除该元素</span></span><br><span class="line"><span class="comment">s.pop();           //弹出栈顶元素, 但不返回其值</span></span><br><span class="line"><span class="comment">s.push();          //将元素压入栈顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> data=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> head=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>




<p><strong>Python</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                <span class="comment">#.pop(i)将列表中第i项元素取出并删除该元素</span></span><br><span class="line">                self.stack2.append(self.stack1.pop(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>Harris角点检测</title>
    <url>/2019/10/20/Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为角点"><a href="#何为角点" class="headerlink" title="何为角点"></a>何为角点</h1><p>下面有两幅不同视角的图像，通过找出对应的角点进行匹配。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095257386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>再看下图所示，放大图像的两处角点区域：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095313814.png#pic_center"><br>角点在保留图像图形重要特征的同时，可以有效地减少信息的数据量，使其信息的含量很高，有效地提高了计算的速度，有利于图像的可靠匹配，使得实时处理成为可能。</p><p>我们可以直观的概括下角点所具有的特征：</p><ul>
<li>轮廓之间的交点；</li>
<li>对于同一场景，即使视角发生变化，通常具备稳定性质的特征；<ul>
<li>该点附近区域的像素点无论在梯度方向上还是其梯度幅值上有着较大变化；<h1 id="角点检测算法基本思想"><a href="#角点检测算法基本思想" class="headerlink" title="角点检测算法基本思想"></a>角点检测算法基本思想</h1>算法基本思想是使用一个固定窗口在图像上进行任意方向上的滑动，比较滑动前与滑动后两种情况，窗口中的像素灰度变化程度，如果存在任意方向上的滑动，都有着较大灰度变化，那么我们可以认为该窗口中存在角点。<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1></li>
</ul>
</li>
</ul><a id="more"></a>


<p>当窗口发生[u,v]移动时，那么滑动前与滑动后对应的窗口中的像素点灰度变化描述如下：</p>
<script type="math/tex; mode=display">E(u, v)=\sum_{x_{s}, y} w(x, y)[I(x+u, y+v)-I(x, y)]^{2}</script><p>[u,v]是窗口的偏移量<br>(x,y)是窗口内所对应的像素坐标位置，窗口有多大，就有多少个位置<br>w(x,y)是窗口函数，最简单情形就是窗口内的所有像素所对应的w权重系数均为1。但有时候，我们会将w(x,y)函数设定为以窗口中心为原点的二元正态分布。如果窗口中心点是角点时，移动前与移动后，该点的灰度变化应该最为剧烈，所以该点权重系数可以设定大些，表示窗口移动时，该点在灰度变化贡献较大；而离窗口中心(角点)较远的点，这些点的灰度变化几近平缓，这些点的权重系数，可以设定小点，以示该点对灰度变化贡献较小，那么我们自然想到使用二元高斯函数来表示窗口函数，所以通常窗口函数有如下两种形式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095759748.png#pic_center"><br>根据上述表达式，当窗口处在平坦区域上滑动，可以想象的到，灰度不会发生变化，那么E(u,v) = 0；如果窗口处在比纹理比较丰富的区域上滑动，那么灰度变化会很大。算法最终思想就是计算灰度发生较大变化时所对应的位置，当然这个较大是指针任意方向上的滑动，并非单指某个方向。</p>
<p>$I(x+u, y+v)$泰勒展开可得：</p>
<script type="math/tex; mode=display">I(x+u, y+v)=I(x, y)+I_{x} u+I_{y} v+O\left(u^{2}, v^{2}\right)</script><p>当发生微小位移时，忽略无穷小量，写成矩阵形式：</p>
<script type="math/tex; mode=display">E(u, v)=\sum_w[u, v]\left[\begin{array}{cc}{I_{x}^{2}} & {I_{x} I_{y}} \\ {I_{x} I_{y}} & {I_{y}^{2}}\end{array}\right]\left[\begin{array}{l}{u} \\ {v}\end{array}\right]=[u, v]M\left[\begin{array}{l}{u} \\ {v}\end{array}\right]</script><p>所以E(u,v)表达式可以更新为：</p>
<script type="math/tex; mode=display">E(u,v)\cong \begin{bmatrix}
u\\ v\end{bmatrix}M\begin{bmatrix}
u & 
v\end{bmatrix}</script><p>矩阵M为:</p>
<script type="math/tex; mode=display">M(x,y)=\Sigma_w \left[ \begin{matrix} I_x^2& I_xI_y \\ I_xI_y & I_y^2\end{matrix} \right]</script><p>E(u,v)是一个二次型，而由下述定理可知<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101744919.png#pic_center"><br>M分解可得：</p>
<script type="math/tex; mode=display">M=X\Sigma X^T = X \left[ \begin{matrix} \lambda_1& 0\\ 0& \lambda_2\end{matrix} \right] X^T</script><p>令E(u,v)=常数，我们可用一个椭圆来描绘这一函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101810715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>椭圆的长短轴是与结构张量M的两个特征值相对应的量。通过判断的情况我们就可以区分出‘flat’，‘edge’，‘corner’这三种区域，因为最直观的印象：</p>
<ul>
<li>corner：在水平、竖直两个方向上变化均较大的点，即Ix、Iy都较大 <ul>
<li>edge ：仅在水平、或者仅在竖直方向有较大的点，即Ix和Iy只有其一较大 </li>
<li>flat   ： 在水平、竖直方向的变化量均较小的点，即Ix、Iy都较小</li>
</ul>
</li>
</ul>
<p>M是由Ix，Iy构成，它的特征值正好可以反映Ix，Iy的情况，下面我以一种更容易理解的方式来讲述椭圆的物理意义。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101904206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>下图是对这三种情况窗口中的对应像素的梯度分布进行绘制：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101940485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>如果使用椭圆进行数据集表示，则绘制图示如下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020103310120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以得出下列结论：</p>
<blockquote>
<p>特征值都比较大时，即窗口中含有角点<br>特征值一个较大，一个较小，窗口中含有边缘<br>特征值都比较小，窗口处在平坦区域<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020102013942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<h1 id="度量角点响应"><a href="#度量角点响应" class="headerlink" title="度量角点响应"></a>度量角点响应</h1><p>特征值计算一般比较繁琐，所以把M写为：</p>
<script type="math/tex; mode=display">M(x,y)=\Sigma_w \left[ \begin{matrix} I_x^2& I_xI_y \\ I_xI_y & I_y^2\end{matrix} \right] = \left[ \begin{matrix} A& C\\ C& B\end{matrix} \right]</script><p>定义角点响应函数R（corner response function），采用近似的形式，α为常数，一般取0.04-0.06：</p>
<script type="math/tex; mode=display">R = detM-\alpha (traceM)^2\\
detM=\lambda_1 \lambda_2=AB-C^2\\
traceM=\lambda_1 + \lambda_2 = A+B</script><blockquote>
<p>可以通过判断R的值来判断某个点是不是角点了。</p>
<ul>
<li>角点：R为大数值整数</li>
<li>边缘：R为大数值负数</li>
<li>平坦区：绝对值R是小数值<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020102127533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center#pic_center"><h1 id="harris角点性质"><a href="#harris角点性质" class="headerlink" title="harris角点性质"></a>harris角点性质</h1>参数α对角点检测的影响：增大α的值，将减小角点响应值R，减少被检测角点的数量；减小α的值，将增大角点响应值R，增加被检测角点的数量。</li>
</ul>
</blockquote>
<ul>
<li>Harris角点检测对亮度和对比度的变化不敏感。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020104945973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
<li>Harris角点检测具有旋转不变性，不具备尺度不变性。如下图所示，在小尺度下的角点被放大后可能会被认为是图像边缘。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020105015840.png#pic_center"></li>
</ul>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>harris角点检测算法步骤</p>
<ol>
<li><p>利用Soble计算出XY方向的梯度值</p>
</li>
<li><p>计算出$I_x^2,I_y^2,I_xI_y$</p>
</li>
<li><p>利用高斯函数对$I_x^2,I_y^2,I_xI_y$进行滤波</p>
</li>
<li><p>计算局部特征结果矩阵M的特征值和响应函数$C(i,j)=Det(M)-k(trace(M))^2   (0.04&lt;=k&lt;=0.06)$</p>
</li>
<li><p>将计算出响应函数的值C进行非极大值抑制，滤除一些不是角点的点，同时要满足大于设定的阈值</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include "opencv2/imgproc/imgproc.hpp"  </span></span><br><span class="line"><span class="comment">#include "opencv2/highgui/highgui.hpp"  </span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">RGB转换成灰度图像的一个常用公式是：</span><br><span class="line">Gray = R*0.299 + G*0.587 + B*0.114</span><br><span class="line">*/</span><br><span class="line">//******************灰度转换函数*************************  </span><br><span class="line">//第一个参数image输入的彩色RGB图像的引用；  </span><br><span class="line">//第二个参数imageGray是转换后输出的灰度图像的引用；  </span><br><span class="line">//*******************************************************</span><br><span class="line">void ConvertRGB2GRAY(const Mat &amp;image, Mat &amp;imageGray);</span><br><span class="line"> </span><br><span class="line">//******************Sobel卷积因子计算X、Y方向梯度和梯度方向角********************  </span><br><span class="line">//第一个参数imageSourc原始灰度图像；  </span><br><span class="line">//第二个参数imageSobelX是X方向梯度图像；  </span><br><span class="line">//第三个参数imageSobelY是Y方向梯度图像；  </span><br><span class="line">//第四个参数pointDrection是梯度方向角数组指针  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelGradDirction(Mat &amp;imageSource, Mat &amp;imageSobelX, Mat &amp;imageSobelY);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的X方向梯度幅值的平方*************************  </span><br><span class="line">//第一个参数imageGradX是X方向梯度图像；    </span><br><span class="line">//第二个参数SobelAmpXX是输出的X方向梯度图像的平方  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelXX(const Mat imageGradX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXX);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的Y方向梯度幅值的平方*************************    </span><br><span class="line">//第一个参数imageGradY是Y方向梯度图像；  </span><br><span class="line">//第二个参数SobelAmpXX是输出的Y方向梯度图像的平方  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelYY(const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpYY);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的XY方向梯度幅值的乘积*************************    </span><br><span class="line">//第一个参数imageGradX是X方向梯度图像；</span><br><span class="line">//第二个参数imageGradY是Y方向梯度图像；</span><br><span class="line">//第二个参数SobelAmpXY是输出的XY方向梯度图像 </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelXY(const Mat imageGradX, const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXY);</span><br><span class="line"> </span><br><span class="line">//****************计算一维高斯的权值数组*****************</span><br><span class="line">//第一个参数size是代表的卷积核的边长的大小</span><br><span class="line">//第二个参数sigma表示的是sigma的大小</span><br><span class="line">//*******************************************************</span><br><span class="line">double *getOneGuassionArray(int size, double sigma);</span><br><span class="line"> </span><br><span class="line">//****************高斯滤波函数的实现*****************</span><br><span class="line">//第一个参数srcImage是代表的输入的原图</span><br><span class="line">//第二个参数dst表示的是输出的图</span><br><span class="line">//第三个参数size表示的是卷积核的边长的大小</span><br><span class="line">//*******************************************************</span><br><span class="line">void MyGaussianBlur(Mat_&lt;<span class="built_in">float</span>&gt; &amp;srcImage, Mat_&lt;<span class="built_in">float</span>&gt; &amp;dst, int size);</span><br><span class="line"> </span><br><span class="line">//****计算局部特涨结果矩阵M的特征值和响应函数H = (A*B - C) - k*(A+B)^2******</span><br><span class="line">//M</span><br><span class="line">//A  C</span><br><span class="line">//C  B</span><br><span class="line">//Tr(M)=a+b=A+B</span><br><span class="line">//Det(M)=a*b=A*B-C^2</span><br><span class="line">//计算输出响应函数的值得矩阵</span><br><span class="line">//****************************************************************************</span><br><span class="line">void harrisResponse(Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussYY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData,<span class="built_in">float</span> k);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//***********非极大值抑制和满足阈值及某邻域内的局部极大值为角点**************</span><br><span class="line">//第一个参数是响应函数的矩阵</span><br><span class="line">//第二个参数是输入的灰度图像</span><br><span class="line">//第三个参数表示的是输出的角点检测到的结果图</span><br><span class="line">void LocalMaxValue(Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData, Mat &amp;srcGray, Mat &amp;ResultImage,int kSize);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	const Mat srcImage = imread(<span class="string">"3.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"could not load image...\n"</span>);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"srcImage"</span>, srcImage);</span><br><span class="line">	Mat srcGray;</span><br><span class="line">	ConvertRGB2GRAY(srcImage, srcGray);</span><br><span class="line">	Mat imageSobelX;</span><br><span class="line">	Mat imageSobelY;</span><br><span class="line">	Mat resultImage;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelXX;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelYY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelXY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianXX;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianYY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianXY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; HarrisRespond;</span><br><span class="line">	//计算Soble的XY梯度</span><br><span class="line">	SobelGradDirction(srcGray, imageSobelX, imageSobelY);</span><br><span class="line">	//计算X方向的梯度的平方</span><br><span class="line">	SobelXX(imageSobelX, imageSobelXX);</span><br><span class="line">	SobelYY(imageSobelY, imageSobelYY);</span><br><span class="line">	SobelXY(imageSobelX, imageSobelY, imageSobelXY);</span><br><span class="line">	//计算高斯模糊XX YY XY</span><br><span class="line">	MyGaussianBlur(imageSobelXX, GaussianXX,3);</span><br><span class="line">	MyGaussianBlur(imageSobelYY, GaussianYY, 3);</span><br><span class="line">	MyGaussianBlur(imageSobelXY, GaussianXY, 3);</span><br><span class="line">	harrisResponse(GaussianXX, GaussianYY, GaussianXY, HarrisRespond, 0.05);</span><br><span class="line">	LocalMaxValue(HarrisRespond, srcGray, resultImage, 3);</span><br><span class="line">	imshow(<span class="string">"imageSobelX"</span>, imageSobelX);</span><br><span class="line">	imshow(<span class="string">"imageSobelY"</span>, imageSobelY);</span><br><span class="line">	imshow(<span class="string">"resultImage"</span>, resultImage);</span><br><span class="line">	waitKey(0);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">void ConvertRGB2GRAY(const Mat &amp;image, Mat &amp;imageGray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!image.data || image.channels() != 3)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//创建一张单通道的灰度图像</span><br><span class="line">	imageGray = Mat::zeros(image.size(), CV_8UC1);</span><br><span class="line">	//取出存储图像像素的数组的指针</span><br><span class="line">	uchar *pointImage = image.data;</span><br><span class="line">	uchar *pointImageGray = imageGray.data;</span><br><span class="line">	//取出图像每行所占的字节数</span><br><span class="line">	size_t stepImage = image.step;</span><br><span class="line">	size_t stepImageGray = imageGray.step;</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; imageGray.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; imageGray.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			pointImageGray[i*stepImageGray + j] = (uchar)(0.114*pointImage[i*stepImage + 3 * j] + 0.587*pointImage[i*stepImage + 3 * j + 1] + 0.299*pointImage[i*stepImage + 3 * j + 2]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//存储梯度膜长</span><br><span class="line">void SobelGradDirction(Mat &amp;imageSource, Mat &amp;imageSobelX, Mat &amp;imageSobelY)</span><br><span class="line">&#123;</span><br><span class="line">	imageSobelX = Mat::zeros(imageSource.size(), CV_32SC1);</span><br><span class="line">	imageSobelY = Mat::zeros(imageSource.size(), CV_32SC1);</span><br><span class="line">	//取出原图和X和Y梯度图的数组的首地址</span><br><span class="line">	uchar *P = imageSource.data;</span><br><span class="line">	uchar *PX = imageSobelX.data;</span><br><span class="line">	uchar *PY = imageSobelY.data;</span><br><span class="line"> </span><br><span class="line">	//取出每行所占据的字节数</span><br><span class="line">	int step = imageSource.step;</span><br><span class="line">	int stepXY = imageSobelX.step;</span><br><span class="line"> </span><br><span class="line">	int index = 0;//梯度方向角的索引</span><br><span class="line">	<span class="keyword">for</span> (int i = 1; i &lt; imageSource.rows - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 1; j &lt; imageSource.cols - 1; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			//通过指针遍历图像上每一个像素   </span><br><span class="line">			double gradY = P[(i + 1)*step + j - 1] + P[(i + 1)*step + j] * 2 + P[(i + 1)*step + j + 1] - P[(i - 1)*step + j - 1] - P[(i - 1)*step + j] * 2 - P[(i - 1)*step + j + 1];</span><br><span class="line">			PY[i*stepXY + j*(stepXY / step)] = abs(gradY);</span><br><span class="line"> </span><br><span class="line">			double gradX = P[(i - 1)*step + j + 1] + P[i*step + j + 1] * 2 + P[(i + 1)*step + j + 1] - P[(i - 1)*step + j - 1] - P[i*step + j - 1] * 2 - P[(i + 1)*step + j - 1];</span><br><span class="line">			PX[i*stepXY + j*(stepXY / step)] = abs(gradX);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//将梯度数组转换成8位无符号整型</span><br><span class="line">	convertScaleAbs(imageSobelX, imageSobelX);</span><br><span class="line">	convertScaleAbs(imageSobelY, imageSobelY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void SobelXX(const Mat imageGradX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXX)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpXX = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpXX.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpXX.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpXX.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradX.at&lt;uchar&gt;(i, j)*imageGradX.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpXX, SobelAmpXX);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void SobelYY(const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpYY)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpYY = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradY.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpYY.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpYY.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpYY.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradY.at&lt;uchar&gt;(i, j)*imageGradY.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpYY, SobelAmpYY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void SobelXY(const Mat imageGradX, const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXY)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpXY = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpXY.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpXY.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpXY.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradX.at&lt;uchar&gt;(i, j)*imageGradY.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpXY, SobelAmpXY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//计算一维高斯的权值数组</span><br><span class="line">double *getOneGuassionArray(int size, double sigma)</span><br><span class="line">&#123;</span><br><span class="line">	double sum = 0.0;</span><br><span class="line">	//定义高斯核半径</span><br><span class="line">	int kerR = size / 2;</span><br><span class="line"> </span><br><span class="line">	//建立一个size大小的动态一维数组</span><br><span class="line">	double *arr = new double[size];</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line"> </span><br><span class="line">		// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去</span><br><span class="line">		arr[i] = exp(-((i - kerR)*(i - kerR)) / (2 * sigma*sigma));</span><br><span class="line">		sum += arr[i];//将所有的值进行相加</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	//进行归一化	</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] /= sum;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MyGaussianBlur(Mat_&lt;<span class="built_in">float</span>&gt; &amp;srcImage, Mat_&lt;<span class="built_in">float</span>&gt; &amp;dst, int size)</span><br><span class="line">&#123;</span><br><span class="line">	CV_Assert(srcImage.channels() == 1 || srcImage.channels() == 3); // 只处理单通道或者三通道图像</span><br><span class="line">	int kerR = size / 2;</span><br><span class="line">	dst = srcImage.clone();</span><br><span class="line">	int channels = dst.channels();</span><br><span class="line">	double* arr;</span><br><span class="line">	arr = getOneGuassionArray(size, 1);//先求出高斯数组</span><br><span class="line"> </span><br><span class="line">									   //遍历图像 水平方向的卷积</span><br><span class="line">	<span class="keyword">for</span> (int i = kerR; i &lt; dst.rows - kerR; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = kerR; j &lt; dst.cols - kerR; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> GuassionSum[3] = &#123; 0 &#125;;</span><br><span class="line">			//滑窗搜索完成高斯核平滑</span><br><span class="line">			<span class="keyword">for</span> (int k = -kerR; k &lt;= kerR; k++)</span><br><span class="line">			&#123;</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (channels == 1)//如果只是单通道</span><br><span class="line">				&#123;</span><br><span class="line">					GuassionSum[0] += arr[kerR + k] * dst.at&lt;<span class="built_in">float</span>&gt;(i, j + k);//行不变，列变换，先做水平方向的卷积</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)//如果是三通道的情况</span><br><span class="line">				&#123;</span><br><span class="line">					Vec3f bgr = dst.at&lt;Vec3f&gt;(i, j + k);</span><br><span class="line">					auto a = arr[kerR + k];</span><br><span class="line">					GuassionSum[0] += a*bgr[0];</span><br><span class="line">					GuassionSum[1] += a*bgr[1];</span><br><span class="line">					GuassionSum[2] += a*bgr[2];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (int k = 0; k &lt; channels; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (GuassionSum[k] &lt; 0)</span><br><span class="line">					GuassionSum[k] = 0;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (GuassionSum[k] &gt; 255)</span><br><span class="line">					GuassionSum[k] = 255;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (channels == 1)</span><br><span class="line">				dst.at&lt;<span class="built_in">float</span>&gt;(i, j) = static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)</span><br><span class="line">			&#123;</span><br><span class="line">				Vec3f bgr = &#123; static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[1]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[2]) &#125;;</span><br><span class="line">				dst.at&lt;Vec3f&gt;(i, j) = bgr;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//竖直方向</span><br><span class="line">	<span class="keyword">for</span> (int i = kerR; i &lt; dst.rows - kerR; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = kerR; j &lt; dst.cols - kerR; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> GuassionSum[3] = &#123; 0 &#125;;</span><br><span class="line">			//滑窗搜索完成高斯核平滑</span><br><span class="line">			<span class="keyword">for</span> (int k = -kerR; k &lt;= kerR; k++)</span><br><span class="line">			&#123;</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (channels == 1)//如果只是单通道</span><br><span class="line">				&#123;</span><br><span class="line">					GuassionSum[0] += arr[kerR + k] * dst.at&lt;<span class="built_in">float</span>&gt;(i + k, j);//行变，列不换，再做竖直方向的卷积</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)//如果是三通道的情况</span><br><span class="line">				&#123;</span><br><span class="line">					Vec3f bgr = dst.at&lt;Vec3f&gt;(i + k, j);</span><br><span class="line">					auto a = arr[kerR + k];</span><br><span class="line">					GuassionSum[0] += a*bgr[0];</span><br><span class="line">					GuassionSum[1] += a*bgr[1];</span><br><span class="line">					GuassionSum[2] += a*bgr[2];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (int k = 0; k &lt; channels; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (GuassionSum[k] &lt; 0)</span><br><span class="line">					GuassionSum[k] = 0;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (GuassionSum[k] &gt; 255)</span><br><span class="line">					GuassionSum[k] = 255;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (channels == 1)</span><br><span class="line">				dst.at&lt;<span class="built_in">float</span>&gt;(i, j) = static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)</span><br><span class="line">			&#123;</span><br><span class="line">				Vec3f bgr = &#123; static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[1]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[2]) &#125;;</span><br><span class="line">				dst.at&lt;Vec3f&gt;(i, j) = bgr;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete[] arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void harrisResponse(Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussYY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData,<span class="built_in">float</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	//创建一张响应函数输出的矩阵</span><br><span class="line">	resultData = Mat_&lt;<span class="built_in">float</span>&gt;(GaussXX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; resultData.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; resultData.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> a = GaussXX.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			<span class="built_in">float</span> b = GaussYY.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			<span class="built_in">float</span> c = GaussXY.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) = a*b - c*c - k*(a + b)*(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//非极大值抑制</span><br><span class="line">void LocalMaxValue(Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData, Mat &amp;srcGray, Mat &amp;ResultImage, int kSize)</span><br><span class="line">&#123;</span><br><span class="line">	int r = kSize / 2;</span><br><span class="line">	ResultImage = srcGray.clone();</span><br><span class="line">	<span class="keyword">for</span> (int i = r; i &lt; ResultImage.rows - r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = r; j &lt; ResultImage.cols - r; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j + 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i, j + 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j + 1))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> ((int)resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; 18000)</span><br><span class="line">				&#123;</span><br><span class="line">					circle(ResultImage, Point(i, j), 5, Scalar(0,0,255), 2, 8, 0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/linqianbi/article/details/78930239" target="_blank" rel="noopener">https://blog.csdn.net/linqianbi/article/details/78930239</a></p>
]]></content>
      <categories>
        <category>VINS</category>
      </categories>
  </entry>
  <entry>
    <title>【VINS-Mono】A Robust and Versatile Monocular Visual-Inertial State Estimator</title>
    <url>/2019/10/19/%E3%80%90VINS%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E3%80%91VINS-Mono-A-Robust-and-Versatile-Monocular-Visual-Inertial-State-Estimator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><font color="gray" size="10"><center>VINS-Mono：一种鲁棒且通用的单目视觉惯性状态估计器</center></font><p><strong>摘要</strong>：由一个相机和一个低成本惯性测量单元(IMU)组成的单目视觉惯性系统(VINS)，构成了用于度量六自由度状态估计的最小传感器套件。然而，由于缺乏直接距离测量，在IMU处理、估计器初始化、外部标定和非线性优化等方面提出了重大挑战。本文提出了VINS-Mono：一种具有鲁棒性和通用性的单目视觉惯性状态估计器。该方法从用于估计器初始化和故障恢复的鲁棒的程序开始。采用一种基于紧耦合、非线性优化的方法，通过融合预积分后的IMU测量值和特征观测值，获得高精度的视觉惯性里程计。结合紧耦合方法，回环检测模块能够以最小的计算代价实现重定位。此外，我们还进行四自由度位姿图优化，以加强全局一致性。我们验证了该系统在公共数据集和真实环境实验的性能，并与其他最先进的算法进行了比较。我们还在MAV平台上执行机载闭环自主飞行，并将算法移植到基于iOS的demo中。特别强调的是，本文提出的工作是一个可靠、完整和通用的系统，适用于需要高精度定位的不同应用。我们为PC和iOS移动设备开源了我们的实现方法。<br>关键词：单目视觉惯性系统，状态估计，传感器融合，SLAM</p><a id="more"></a>


<h1 id="I-引言"><a href="#I-引言" class="headerlink" title="I. 引言"></a>I. 引言</h1><p>状态估计无疑是机器人导航、自主驾驶、虚拟现实(VR)和增强现实(AR)等广泛应用中最基本的模块。仅使用单目摄像机的方法由于其体积小、成本低和硬件设置简单而获得了社会的极大兴趣[1]-[5]。然而，单目视觉系统无法恢复度量尺度，因此限制了它们在实际机器人中的应用。近年来，我们看到了一种发展趋势，即用低成本惯性测量单元(IMU)辅助单目视觉系统。这种单目视觉-惯性系统(VINS)的主要优点是具有可观测的度量尺度，以及翻滚角(roll)和俯仰角(pitch)。这让需要有尺度的状态估计的导航任务成为可能。此外，==对IMU测量值的积分可以显著提高运动跟踪性能，弥补光照变化、缺少纹理的区域或运动模糊的视觉轨迹损失的差距==。事实上，单目VINS不仅广泛应用于移动机器人、无人机和移动设备上，还是满足充分自我感知和环境感知的最小传感器。</p>
<p>然而，所有这些优点都是有代价的。对于单目VINS，众所周知，需要加速度激励以测量尺度。这意味着==单目VIN估计器不能从静止状态启动，而是从未知的移动状态发动==。同时要认识到视觉惯性系统高度非线性的事实，在估计器初始化方面还有重大挑战。两个传感器的存在也使得摄像机-IMU的外部校准至关重要。最后，为了消除在可接受的处理窗口内的长期漂移，提出了一个完整的系统，包括视觉惯性里程计、回环检测、重定位和全局优化。</p>
<p>为了解决所有这些问题，我们提出了VINS-Mono，一个鲁棒且通用的单目视觉惯性状态估计器。我们的解决方案开始于即时估计初始化。这个初始化模块也用于故障恢复。我们的解决方案的核心是一个鲁棒的基于紧耦合的滑动窗非线性优化的单目视觉惯性里程计(VIO)。==单目VIO模块不仅提供精确的局部姿态、速度和方位估计，而且还以在线方式执行摄像机IMU外部校准和IMU偏置校正==。使用DBoW2[6]进行回环检测。==重新定位是在对单目VIO进行特征级别融合的紧耦合设置中完成==。这使得重新定位具有鲁棒性和精确性且有最小的计算代价。最后，几何验证的回环被添加到位姿图中，并且由于来自单目VIO的可观测的翻滚角和俯仰角，生成四自由度(DOF)位姿图以确保全局一致性。</p>
<p>VINS-Mono结合并改进了我们先前在单目视觉-惯性融合方面的工作[7]-[10]。它建立在我们紧耦合、基于优化的单目VIO的公式之上[7][8]，并结合了[9]中引入的改进初始化过程。[10]中给出了移植到移动设备的第一次尝试。与我们以前的工作相比，VINS-Mono的进一步改进包括改进的含偏置校正的IMU预积分、紧耦合重定位、全局位姿图优化、广泛的实验评估以及鲁棒和通用的开源实现。</p>
<p>整个系统完整且易于使用。它已经被成功应用于小规模AR场景、中型无人机导航和大规模状态估计任务。与其他最先进的方法相比具有优异的性能。为此，我们总结了我们的贡献，如下所示：<br>1、一个鲁棒的初始化过程，它能够从未知的初始状态引导系统。<br>2、一个紧耦合、基于优化的单目视觉惯性里程计，具有相机-IMU外部校准和IMU偏置估计。<br>3、在线回环检测与紧耦合重定位。<br>4、四自由度全局位姿图优化。<br>5、用于无人机导航、大规模定位和移动AR应用的实时性能演示。<br>6、完全集成于ros的pc版本以及可在iphone 6或更高版本上运行的IOS版本的开源代码。</p>
<p>论文的其余部分如下：在第二节中，我们讨论了相关的文献。在第三节中，我们对完整的系统框架进行了概述。在第四节中，给出了视觉的预处理和IMU测量值的预积分步骤。在第五节中，我们讨论了估计器的初始化过程。在第六节中提出了一种紧耦合、自标定、非线性优化的单目VIO。第七节和第八节分别给出了紧耦合重定位和全局位姿图优化。实施细节和实验结果见第九节。最后，第十节本文对研究方向进行了探讨和展望。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019194830365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h1><p>关于基于单目视觉的状态估计/里程计SLAM的学术工作非常广泛。值得注意的方法包括PTAM[1]、SVO[2]、LSD-SLAM[3]、DSO[5]和ORB-SLAM[4]。显然，尝试对任何方法进行全面回顾都无法完整。然而，在这一节中，我们跳过了关于只使用视觉的方法的讨论，而只专注于关于单目视觉惯性状态估计的最相关的结果。<br>处理视觉和惯性测量的最简单的方法是松耦合的传感器融合[11][12]，其中IMU被视为一个独立的模块，用于辅助运动的视觉结构(sfm)获得的纯视觉位姿估计。融合通常由扩展卡尔曼滤波(EKF)完成，其中IMU用于状态传播，而视觉位姿用于更新。进一步说，紧耦合视觉惯性算法要么基于EKF[13]-[15]，要么基于图优化[7][8][16][17]，其中相机和IMU测量值是从原始测量水平联合优化的。一种流行的基于EKF的VIO方法是MSCKF[13][14]。MSCKF在状态向量中维护以前的几个摄像机位姿，并使用多个摄像机视图中相同特征的视觉测量来形成多约束更新。SR-ISWF[18][19]是MSCKF的扩展。它采用squareroot形式[20]实现单精度表示，避免了较差的数值性质。该方法采用逆滤波器进行迭代再线性化，使其与基于优化的算法相当。批量图优化或集束调整技术（BA）维护和优化所有测量值以获得最优状态估计。为了达到恒定的处理时间，==流行的基于图的VIO方法[8][16][17]通常采用边缘化过去的状态和测量来优化最近状态的有界滑动窗口==。由于对非线性系统迭代求解的计算要求很高，很少有基于图的非线性系统能够在资源受限的平台（如手机上）实现实时性能。</p>
<p>对于视觉测量处理，根据视差模型的定义，算法可分为直接法和间接法。直接法[2][3][21]最小化光度误差，而间接法最小化几何位移。直接法因其吸引区域小，需要很好的初始估计，而间接法在提取和匹配特征时需要额外的计算资源。间接法由于其成熟性和鲁棒性，在实际工程部署中得到了广泛的应用。然而，直接法更容易扩展到稠密建图，因为它们是直接在像素级别上操作的。</p>
<p>在实践中，IMU通常以比摄像机更高的速率获取数据。不同的方法被提出来处理高速率的IMU测量值。最简单的方法是在基于EKF的方法中使用IMU进行状态传播[11][13]。在图优化公式中，为了避免重复的IMU重复积分，提出了一种有效的方法，即IMU预积分(IMU pre-integration)。这种方法在[22]中首次提出的，它用欧拉角来参数化旋转误差。在我们先前的工作中[7]，我们提出了一种流形上的IMU预积分旋转公式，利用连续IMU误差状态动力学推导了协方差传递方程。然而IMU偏置被忽略了。在[23]中通过增加后验IMU偏置校正，进一步改进了预积分理论。</p>
<p>精确的初始值对于引导任何单目VINS是至关重要的。在[8][24]中提出了一种利用短期IMU预积分相对旋转的线性估计器初始化方法。但是，该方法不对陀螺仪偏置进行建模，无法在原始投影方程中对现代传感器噪声进行建模。在实际应用中，当视觉特性远离传感器套件时，这会导致不可靠的初始化。在[25]中给出了单目视觉惯性初始化问题的一种封闭解。随后，在[26]中提出了对这种封闭形式的解决方案的扩展，增加了陀螺仪的偏置校准。这些方法依赖于长时间内IMU测量的双重积分，无法模拟惯性积分的不确定性。在[27]中，提出了一种基于SVO的重初始化和故障恢复算法。这是一种基于松耦合融合框架的实用方法。然而，需要额外的朝下的距离传感器来恢复度量尺度。在[17]中引入了一种建立在ORB-SLAM[4]上的初始化算法。给出了一组ORB-SLAM的关键帧，计算了视觉惯性全局BA的尺度、重力方向、速度和IMU偏置的初步估计。然而，尺度收敛所需的时间可能超过10秒。这可能会给需要在一开始就进行尺度估计的机器人导航任务带来问题。</p>
<p>VIO方法，不管它们所依赖的基本数学公式，在全局的平移和旋转中长期受到漂移的影响。为此，回环检测在长期操作中起着重要的作用。ORB-SLAM[4] 利用了词袋模型能够闭合回环并重用地图。回环检测之后进行7自由度（位置、方向和尺度）的位姿图优化。相对于单目VINS，由于IMU的加入，漂移只发生在4自由度，即三维平移，和围绕重力方向的旋转（偏航角）。因此，本文选择在最小四自由度设定下，优化具有回环约束的位姿图。</p>
<h1 id="III-概述"><a href="#III-概述" class="headerlink" title="III.概述"></a>III.概述</h1><p>提出的单目视觉惯性状态估计器的结构如图2所示。该系统从测量预处理(IV)开始，在其中提取和跟踪特征，对两个连续帧间的IMU测量值进行预积分。初始化过程(V)提供了所有必要的值，包括姿态、速度、重力向量、陀螺仪偏置和三维特征位置，用于引导随后的基于非线性优化的VIO。VIO(VI)与重定位(VII)模块紧密地融合了预先积分的IMU测量、特征观测和回环重新检测到的特征。最后，位姿图优化模块(VIII)接受几何验证的重定位结果，并进行全局优化以消除漂移。VIO、重新定位和位姿图优化模块在多线程设置中同时运行。每个模块有不同的运行速度和实时保证，以确保在任何时候可靠运行。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920013857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们现在对整篇论文中使用的符号和坐标系进行定义。我们认为(.)w(.)w是世界坐标系(world frame)。重力方向与世界坐标系z轴对齐。$(⋅)b$是本体坐标系(body frame)，我们把它定义为与IMU坐标系相同。$(⋅)c$是相机坐标系(camera frame)。我们同时使用旋转矩阵R和Hamilton四元数q来表示旋转。我们主要在状态向量中使用四元数，也用旋转矩阵来表示三维向量的旋转。$q<em>{wb}，p</em>{wb}$​表示从本体坐标系到世界坐标系的旋转和平移。$b_k$​表示获取第k个图像时的本体坐标系。$c_k$表示获取第k个图像时的相机坐标系。⊗表示两个四元数之间的乘法运算。$g_w=[0,0,g]T$是世界坐标系上的重力向量。最后，我们将(^)表示为某一具体量的噪声测量值或估计值。</p>
<h1 id="IV-测量预处理"><a href="#IV-测量预处理" class="headerlink" title="IV.测量预处理"></a>IV.测量预处理</h1><p>本节介绍VIO的预处理步骤。对于视觉测量，我们跟踪连续帧之间的特征，并在最新帧中检测新特征。对于IMU测量，我们在两个连续帧之间做预积分。请注意，我们使用的低成本IMU的测量值受到偏置和噪声的影响。因此，我们在IMU预积分过程中特别考虑偏置。</p>
<h2 id="A-视觉处理前端"><a href="#A-视觉处理前端" class="headerlink" title="A.视觉处理前端"></a>A.视觉处理前端</h2><p>对于每一幅新图像，KLT稀疏光流算法对现有特征进行跟踪[29]。同时，检测新的角点特征[30]以保证每个图像特征的最小数目(100-300)。该检测器通过设置两个相邻特征之间像素的最小间隔来执行均匀的特征分布。二维特征首先是不失真的，然后在通过外点剔除后投影到一个单位球面上。利用基本矩阵模型的RANSAC算法进行外点剔除。<br>在此步骤中还选择了关键帧。我们有两个关键帧选择标准。第一是与上一个关键帧的平均视差。如果在当前帧和最新关键帧之间跟踪的特征点的平均视差超出某个特定阈值，则将该帧视为新的关键帧。请注意，不仅平移，旋转也会产生视差。然而，特征点无法在纯旋转运动中三角化。为了避免这种情况，在计算视差时我们使用陀螺仪测量值的短时积分来补偿旋转。请注意，此旋转补偿仅用于关键帧选择，而不涉及VINS公式中的旋转计算。为此，即使陀螺仪含有较大的噪声或存在偏置，也只会导致次优的关键帧选择结果，不会直接影响估计质量。另一个标准是跟踪质量。如果跟踪的特征数量低于某一阈值，我们将此帧视为新的关键帧。这个标准是为了避免跟踪特征完全丢失。</p>
<h1 id="B-IMU预积分"><a href="#B-IMU预积分" class="headerlink" title="B.IMU预积分"></a>B.IMU预积分</h1><p>IMU预积分是在[22]中首次提出的，它将欧拉角的旋转误差参数化。在我们先前的工作中[7]，我们提出了一个流形上的IMU预积分旋转公式。该文利用连续时间的IMU误差状态动力学推导协方差传递函数，但忽略了IMU偏置。文[23]通过增加后验IMU偏置校正，进一步改进了预积分理论。本文通过引入IMU偏置校正，扩展了我们在前面工作[7]中提出的IMU预积分。<br>IMU的原始陀螺仪和加速度计测量结果$\hat w$ 和$\hat a$如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019201549992.png#pic_center"><br>IMU测量值是在本体坐标系中测量的，它是平衡重力和平台动力的合力，并受到加速度偏置$b<em>a$、陀螺仪偏置$b_w$和附加噪声的影响。假设加速度计和陀螺仪测量值中的附加噪声为高斯噪声，$n_a～N(0,sigma^2_a)$，$n_w～N(0,sigma^2_w)$​。加速度计偏置和陀螺仪偏置被建模为随机游走，其导数为高斯性的，$n</em>{ba}～N(0,σ^2<em>{ba})$，$n</em>{bw}～N(0,σ^2_{bw})$。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202057834.png#pic_center"></p>
<p>给定对应于体坐标系$b<em>k$和$b</em>{k+1}$的两个时刻，位置、速度和方向状态可以在时间间隔$[t<em>k,t</em>{k+1}]$间，在世界坐标系下中通过惯性测量值传递：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202237245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$∆t<em>k$是时间间隔$[t_k,t</em>{k+1}]$之间的持续时间。</p>
<p>可见，IMU状态传递需要坐标系$b_k$的旋转、位置和速度。当这些起始状态改变时，我们需要重新传递IMU测量值。特别是在基于优化的算法中，每次调整位姿时，都需要在它们之间重新传递IMU测量值。这种传递策略在计算上要求很高。为了避免重新传递，我们采用了预积分算法。<br>将参考坐标系从世界坐标系转变为局部坐标系$b_k$后，我们只能对线性的加速度$\hat a$和角速度$\hat w$相关的部分进行预积分，如下所示：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202449110.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202554843.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920251370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以看出预积分项(6)能通过将$b<em>k$视为参考帧的IMU测量值单独得到。$α^{b_k}</em>{k+1}$、$β^{b-k}b<em>{k+1}$、$γ^{b-k}</em>{k+1}$只与$b<em>k$和$b</em>{k+1}$中的IMU偏置有关，与其他状态无关。当偏置估计发生变化时，若偏置变化很小，我们将$α^{bk}<em>{k+1}、β^{bk}b</em>{k+1}、γ^{bk}_{k+1}$按其对偏置的一阶近似来调整，否则就进行重新传递。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传递IMU测量值。</p>
<p>对于离散时间的实现，可以采用不同的数值积分方法，如欧拉积分、中点积分、RK4积分等。这里选择了欧拉积分来演示易于理解的过程(我们在代码中使用了中点积分)。</p>
<p>在开始时，$\alpha^{bk}<em>{k}$、$β^{bk}</em>{k}$是0，$\gamma^{bk}<em>{k}$是单位四元数。$α$，$β$，$γ$在(6)中的平均值是如下逐步传递的。注意，增加的噪声项$n_a$，$n_w$是未知的，在实现中被视为零。这得到了预积分的估计值，标记为$(\hat⋅)$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203125870.png#pic_center"><br>i是在$[t_k,t</em>{k+1}]$中IMU测量值对应的离散时刻，$δ_t$是IMU测量值i和i+1之间的时间间隔。</p>
<p>然后讨论协方差传递问题。由于四维旋转四元数$γ^{b_k}_t$被过参数化，我们将其误差项定义为围绕其平均值的扰动：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203259791.png#pic_center"><br>其中$δθ^{b_k}_t$是三维小扰动。</p>
<p>我们可以导出误差项的连续时间线性化方程(6)：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203414375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$P^{bk}<em>{b</em>{k+1}}$可以通过初始协方差$P^{b<em>k}</em>{b<em>k}=0$的一阶离散时间协方差更新递归计算：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203627976.png#pic_center"><br>其中Q是噪声的对角线协方差矩阵$(σ^2_a,σ^2_w,σ^2</em>{b<em>a},σ^2</em>{b_w})$</p>
<p>同时，$δz<em>{b</em>{k+1}}^{b<em>k}$​的一阶雅可比矩阵$J</em>{b<em>{k+1}}$​​相对于δzbk​bk​​也可以用初始雅可比矩阵$J</em>{b<em>k}=I$ 递归计算。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203912837.png#pic_center"><br>利用这个递推公式，得到协方差矩阵$P^{b_k}</em>{b<em>{k+1}}$​​和雅可比矩阵$J^{b_k}</em>{b<em>{k+1}}$​​、$α^{b_k}</em>{b<em>{k+1}}$、$β^{b_k}</em>{b<em>{k+1}}$、$γ^{b_k}</em>{b<em>{k+1}}$关于偏置的一阶近似可以写为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203947220.png#pic_center"><br>其中$J^α</em>{b<em>a}$是$J_b{k+1}$中的子块矩阵，其位置对应于$\frac{δα^{b_k}</em>{b<em>{k+1}}}{δb</em>{a<em>k}}$。<br>$J^α</em>{b<em>w}、J^β</em>{b<em>a}、J^β</em>{b<em>w}、J^γ</em>{b_w}$也使用同样的含义。当偏置估计发生轻微变化时，我们使用(12)近似校正预积分结果，而不重新传递。</p>
<p>现在我们可以写下IMU测量模型所其对应的协方差$P^{b<em>k}</em>{b_{k+1}}$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204124533.png#pic_center"></p>
<h1 id="V-估计器初始化"><a href="#V-估计器初始化" class="headerlink" title="V.估计器初始化"></a>V.估计器初始化</h1><p>单目紧耦合VIO是一个高度非线性的系统。由于单目相机无法直接观测到尺度，因此，如果没有良好的初始值，很难直接将这两种测量结果融合在一起。可以假设一个静止的初始条件来启动单目VINS估计器。然而，这种假设是不合适的，因为在实际应用中经常会遇到运动下的初始化。当IMU测量结果被大偏置破坏时，情况就变得更加复杂了。事实上，初始化通常是单目VINS最脆弱的步骤。需要一个鲁棒的初始化过程以确保系统的适用性。</p>
<p>我们采用松耦合的传感器融合方法得到初始值。我们发现纯视觉SLAM，或从运动中恢复结构(SfM)，具有良好的初始化性质。在大多数情况下，纯视觉系统可以通过从相对运动方法（如八点法[32]或五点法[33]或估计单应性矩阵）中导出初始值来引导自己。通过对齐IMU预积分与纯视觉SfM结果，我们可以粗略地恢复尺度、重力、速度，甚至偏置。这足以引导非线性单目VINS估计器，如图4所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204212487.png#pic_center"><br>与在初始阶段同时估计陀螺仪和加速度计偏置的[17]相比，我们在初始阶段选择忽略加速度计偏置项。加速度计偏置与重力耦合，且由于重力向量相对于平台动力学的大量级，以及初始阶段相对较短，这些偏置项很难被观测到。我们以前的工作对加速度计偏置标定进行了详细的分析[34]。</p>
<h1 id="A-滑动窗口-Sliding-Window-纯视觉SfM"><a href="#A-滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="A. 滑动窗口(Sliding Window)纯视觉SfM"></a>A. 滑动窗口(Sliding Window)纯视觉SfM</h1><p>初始化过程从纯视觉SfM估计相机尺度位姿(up-to-scale)和特征位置图开始。</p>
<p>我们保持了一个帧的滑动窗口来限制计算复杂度。首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，我们使用五点法[33]恢复这两个帧之间的相对旋转和尺度平移。否则，我们将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，我们任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP[35]来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)[36]最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c<em>0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}</em>{c<em>k}，q^{c0}</em>{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"><br>其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p>
<h2 id="B-视觉惯性校准"><a href="#B-视觉惯性校准" class="headerlink" title="B. 视觉惯性校准"></a>B. 视觉惯性校准</h2><p>1）陀螺仪偏置标定：考虑窗口中连续两帧bk和bk+1，我们从视觉sfM中得到旋转$q^{c0}<em>{b_k}$和$q^{c0}</em>{b<em>{k+1}}$​​，从IMU预积分得到的相对约束$γ^{b_k}</em>{b<em>{k+1}}$​。我们对陀螺仪偏置求IMU预积分项的线性化，并最小化以下代价函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"><br>其中B代表窗口的所有帧。利用第四部分导出的偏置雅可比，给出了$γ^{b_k}</em>{b<em>{k+1}}$​对陀螺仪偏置的一阶近似。这样，我们得到了陀螺仪偏置bw的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}</em>{b<em>{k+1}}、\hat β^{b_k}</em>{b<em>{k+1}}、\hat γ^{b_k}</em>{b_{k+1}}$ 。</p>
<p>2）速度、重力向量和尺度初始化：在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"><br>其中，$v^{b<em>k}</em>{b_k}$​​是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。</p>
<p>考虑窗口中两个连续帧$b<em>k$和$b</em>{k+1}$，那么(5)可以写成：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205047939.png#pic_center"><br>我们可以将(14)和(17)合并成以下线性测量模型：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204900731.png#pic_center"><br>可以看出，$R^{c<em>0}</em>{b<em>k}，R^{c_0}</em>{b<em>{k+1}}，\hat p^{c_0}</em>{c<em>k}，\hat p^{c_0}</em>{c_{k+1}}$是从带尺度的单目视觉中得到的，$∆t_k$是两个连续帧之间的时间间隔。通过求解线性最小二乘问题：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205002105.png#pic_center"><br>我们可以得到窗口中每一帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及尺度参数。</p>
<p>3）重力细化：通过约束量值，可以对原线性初始化步骤得到的重力向量进行细化。在大多数情况下，重力向量的大小是已知的。这导致重力向量只剩2个自由度。因此，我们在其切线空间上用两个变量重新参数化重力。参数化将重力向量表示为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205157776.png#pic_center"><br>其中g是已知的重力大小，$\bar {\hat g}$​​是表示重力方向的单位向量，b1和b2是跨越切平面的两个正交基，如图5所示，w1和w2分别是在b1和b2上的对应位移。通过算法1的叉乘运算，可以找到一组b1、b2。然后用</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920522547.png#pic_center"><br>代替(17)中的g，并与其它状态变量一起求解w1和w2。此过程迭代到$\bar {\hat g}$收敛为止。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205247493.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>4）完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$​。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p>
<h1 id="VI-紧耦合单目VIO"><a href="#VI-紧耦合单目VIO" class="headerlink" title="VI. 紧耦合单目VIO"></a>VI. 紧耦合单目VIO</h1><p>在估计器初始化后，我们采用基于滑动窗口的紧耦合单目VIO进行高精度和鲁棒的状态估计。图3显示了滑动窗口的图示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205519675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="A-公式"><a href="#A-公式" class="headerlink" title="A. 公式"></a>A. 公式</h2><p>滑动窗口中的完整状态向量定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205554259.png#pic_center"><br>其中$x_k$是捕获第k图像时的IMU状态。它包含了IMU在世界坐标系中的位置、速度和方向，以及在IMU本体坐标系中的加速度计偏置和陀螺仪偏置。n是关键帧的总数，m是滑动窗口中的特征总数，$λ_l$是第一次观测到第l个特征的逆深度。</p>
<p>我们使用视觉惯性BA。我们最小化所有测量残差的先验和Mahalanobis范数之和，得到最大后验估计：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205631782.png#pic_center"><br>$r<em>B​(z^{b_k}</em>{b_{k+1}},X)$和$r_C(\hat z_l^{c_j},X)$分别是IMU和视觉测量的残差。残差的详细定义将在第六节的B和C中提出。B是所有IMU测量的集合，C是在当前滑动窗口中至少观察到两次的一组特征。${r_p,H_p}$是来自边缘化的先验信息。Ceres Solver[38]被用来解决这个非线性问题。</p>
<h2 id="B-IMU测量残差"><a href="#B-IMU测量残差" class="headerlink" title="B. IMU测量残差"></a>B. IMU测量残差</h2><p>考虑滑动窗口中连续两个帧$b<em>k$和$b</em>{k+1}$内的IMU测量，根据(13)中定义的IMU测量模型，预积分IMU测量的残差可以定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205738287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>其中，$[·]<em>{xyz}$是提取四元数q的向量部分，以进行误差状态表示。$δθ^{bk}</em>{b<em>{k+1}}$​​是四元数的三维误差状态表示。$[\hat α^{b_k}</em>{b{k+1}}、\hat β^{b<em>k}</em>{b{k+1}}      \hat γ^{b<em>k}</em>{b{k+1}}]^T$是在两个连续图像帧的间隔时间内使用仅包含噪声的加速度计和陀螺仪测量值预积分的IMU测量项。加速度计和陀螺仪偏置也包括在在线校正的剩余项中。</p>
<h2 id="C-视觉测量残差"><a href="#C-视觉测量残差" class="headerlink" title="C. 视觉测量残差"></a>C. 视觉测量残差</h2><p>与在广义图像平面上定义重投影误差的传统针孔相机模型相比，我们在单位球面上定义摄像机的测量残差。几乎所有类型相机的光学，包括广角、鱼眼或全向相机，都可以模拟为连接单位球体表面的单位射线。假设第l个特征在第i幅图像中被第一次观察到，第j幅图像中的特征观测的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205925902.png#pic_center"><br>其中$[u^{c_i}_l,v^{c_i}_l]$是第一次观测到出现在第i图像中的第l个特征。$[\hat u^{c_i}_l,\hat v^{c_i}_l]$是在第j图像中对相同特征的观察。$π^{−1}_c$​是利用摄像机内参将像素位置转换成单位向量的反投影函数。由于视觉残差的自由度是2，所以我们将残差向量投影到切平面上。如图6所示，b1、b2是在切平面$\hat {\bar P^{c_j}_l}$上的两个任意选择的正交基。我们可以很容易地找到一组$b_1、b_2$，如算法1所示。在(22)中使用的$P^{c_j}_l$​​是正切空间中固定长度的标准协方差。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210021988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="D-边缘化"><a href="#D-边缘化" class="headerlink" title="D. 边缘化"></a>D. 边缘化</h2><p>为了限制基于优化的VIO的计算复杂度，本文引入了边缘化。我们有选择地从滑动窗口中将IMU状态xK和特征λ1边缘化，同时将对应于边缘状态的测量值转换为先验。</p>
<p>如图7所示，当倒数第二帧是关键帧时，它将停留在窗口中，而最旧的帧与其相应的测量值被边缘化。但如果倒数第二帧是非关键帧，我们丢掉视觉测量值，保留连接到这个非关键帧的IMU测量值。为了保持系统的稀疏性，我们不会边缘化非关键帧的所有测量值。我们的边缘化方案旨在保持窗口中空间分离的关键帧。这确保了特征三角化有足够的视差，并且最大化了在大激励下获得加速度计测量值的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210401727.png#pic_center"></p>
<h2 id="E-摄像机速率状态估计的纯运动视觉惯性BA"><a href="#E-摄像机速率状态估计的纯运动视觉惯性BA" class="headerlink" title="E. 摄像机速率状态估计的纯运动视觉惯性BA"></a>E. 摄像机速率状态估计的纯运动视觉惯性BA</h2><p>对于计算能力较低的设备如手机，由于对非线性优化的计算要求很高，紧耦合单目VIO无法实现摄像机速率输出。为此，我们采用了一种轻量级的纯运动视觉惯性BA，以提升状态估计速率到相机速率(30Hz)。</p>
<p>纯运动单目视觉惯性BA的代价函数与(22)中单目VIO的代价函数相同。然而我们只对固定数量的最新IMU状态的姿态和速度进行了优化，而不是对滑动窗口中的所有状态进行优化。我们将特征深度、外部参数、偏置和旧的IMU状态这些不希望优化的状态作为常量来处理。我们使用所有的视觉和惯性测量来进行纯运动的BA。这导致了比单帧PnP方法更平滑的状态估计。图8显示了提出方法的插图。与在最先进的嵌入式计算机上可能导致超过50ms的完全紧耦合单目VIO不同，这种纯运动的视觉惯性BA只需大约5ms来计算。这使得低延迟的相机频率进行位姿估计对无人机和AR应用特别有利。<br>F. IMU前向传递以达到IMU速率状态估计</p>
<p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="F-IMU前向传递以达到IMU速率状态估计"><a href="#F-IMU前向传递以达到IMU速率状态估计" class="headerlink" title="F. IMU前向传递以达到IMU速率状态估计"></a>F. IMU前向传递以达到IMU速率状态估计</h2><p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="G-故障检测与恢复"><a href="#G-故障检测与恢复" class="headerlink" title="G. 故障检测与恢复"></a>G. 故障检测与恢复</h2><p>虽然我们紧耦合的单目视觉对各种具有挑战性的环境和运动是鲁棒的。由于强烈的光照变化或剧烈的运动，故障仍然是不可避免的。主动故障检测和恢复策略可以提高系统的实用性。故障检测是一个独立的模块，它检测估计器的异常输出。我们目前使用以下标准进行故障检测：<br>1、在最新帧中跟踪的特征数小于某一阈值；<br>2、最近两个估计器输出之间的位置或旋转有较大的不连续性；<br>3、偏置或外部参数估计有较大的变化；</p>
<p>一旦检测到故障，系统将切换回初始化阶段。一旦单目VIO被成功初始化，将新建一个独立的位姿图。</p>
<h1 id="VII-重定位"><a href="#VII-重定位" class="headerlink" title="VII. 重定位"></a>VII. 重定位</h1><p>我们的滑动窗口和边缘化方案限制了计算的复杂性，但也给系统带来了累积漂移。更确切地说，漂移发生在全局三维位置(x,y,z)和围绕重力方向的旋转(yaw)。为了消除漂移，提出了一种与单目VIO无缝集成的紧耦合重定位模块。重定位过程从一个循环检测模块开始，该模块识别已经访问过的地方。然后建立回环检测候选帧和当前帧之间的特征级连接。这些特征的对应关系紧密地集成到单目VIO模块中，从而以最小计算代价得到无漂移状态估计。多个特征的多个观测直接用于重定位，从而提高了定位的精度和状态估计的平滑性。重定位过程如图9(a)所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210456719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-特征恢复"><a href="#B-特征恢复" class="headerlink" title="B. 特征恢复"></a>B. 特征恢复</h2><p>当检测到回路时，通过检索特征对应关系建立局部滑动窗口与回环候选帧之间的连接。通过BRIEF描述子匹配找到对应关系。直接描述子匹配可能会造成大量异常值。为此，我们使用两步进行几何异常值剔除，如图10所示。<br>1、2D-2D：RANSAC[31]的基本矩阵检验。我们利用当前图像中检索到的特征的二维观测和回环候选图像进行基本矩阵检验。<br>2、3D-2D：RANSAC的PNP检验。基于特征在局部滑动窗口中已知的三维位置，以及回环候选图像中的二维观测，进行PNP检验。</p>
<p>当内点超过一定阈值时，我们将该候选帧视为正确的循环检测并执行重定位。</p>
<h2 id="C-紧耦合重定位"><a href="#C-紧耦合重定位" class="headerlink" title="C. 紧耦合重定位"></a>C. 紧耦合重定位</h2><p>重定位过程有效地使单目VIO(VI)维持的当前滑动窗口与过去的位姿图对齐。在重定位过程中，我们将所有回环帧的位姿作为常量。利用所有IMU测量值、局部视觉测量和从回环中提取特征对应值，共同优化滑动窗口。我们可以轻松地为回环帧v观察到的检索特征编写视觉测量模型，使其与VIO中的视觉测量相同，如(25)所示。唯一的区别是，从位姿图(VIII)或直接从上一个里程计的输出（如果这是第一次重定位）获得的回环帧的姿态$(\hat q^w_v,\hat p^w_v)$<br>(q^​vw​,p^​vw​)被视为常数。为此，我们可以在(22)中稍微修改非线性代价函数，增加回环项：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210641949.png#pic_center"><br>其中L是回环帧中检索到的特征的观测集。$(l,v)$是指在回环帧v中观察到的第l个特征。虽然代价函数与(22)略有不同，但待解状态的维数保持不变，因为回环帧的构成被视为常数。当用当前滑动窗口建立多个回环时，我们同时使用来自所有帧的所有回环特征对应进行优化。这就为重定位提供了多视角的约束，从而提高了定位的精度和平滑性。请注意，过去的姿态和回环帧的全局优化发生在重定位之后，将在第八节中讨论。</p>
<h1 id="VIII-全局位姿图优化"><a href="#VIII-全局位姿图优化" class="headerlink" title="VIII. 全局位姿图优化"></a>VIII. 全局位姿图优化</h1><p>重新定位后，局部滑动窗口移动并与过去的位姿对齐。利用重定位结果，开发了额外的位姿图优化步骤，以确保过去位姿集注册到全局一致的配置中。</p>
<p>由于视觉惯性的建立使翻滚角和俯仰角完全可观测，累积漂移只发生在四个自由度(x，y，z和yaw)。为此，我们忽视对无漂移翻滚和俯仰状态的估计，只进行了四自由度位姿图的优化。</p>
<h2 id="A-在位姿图中添加关键帧"><a href="#A-在位姿图中添加关键帧" class="headerlink" title="A. 在位姿图中添加关键帧"></a>A. 在位姿图中添加关键帧</h2><p>当关键帧从滑动窗口被边缘化时，它将被添加到位姿图中。这个关键帧在位姿图中作为顶点，它通过两种类型的边与其他顶点连接：</p>
<p>1）顺序边(Sequential Edge)：关键帧将建立与之前关键帧的若干顺序边。顺序边表示局部滑动窗口中两个关键帧之间的相对转换，其值直接从VIO中获取。考虑到新边缘化的关键帧i及其先前的一个关键帧j，顺序边只包含相对位置和偏航角。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210857102.png#pic_center">)<br>2）回环边(Loop Closure Edge)：如果新边缘化的关键帧有一个回环连接，它将与回环帧通过一个回环边在位姿图图中连接。同样，闭环边缘只包含与(27)相同定义的四自由度相对位姿变换。回环边的值由重定位结果得出。</p>
<h2 id="B-4自由度位姿图优化"><a href="#B-4自由度位姿图优化" class="headerlink" title="B. 4自由度位姿图优化"></a>B. 4自由度位姿图优化</h2><p>我们将帧i和j之间边的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210815393.png#pic_center"><br>其中，$\hat \phi _i，\hat    θ_i$是直接从单目VIO中得到的翻滚角和俯仰角的估计。</p>
<p>通过最小化以下代价函数，对顺序边和回环边的整个图进行优化：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921101530.png#pic_center"></p>
<p>其中S是所有顺序边的集合，L是回环边的集合。尽管紧耦合的重定位已经有助于消除错误的回环，但我们添加了另一个Huber范数 $ρ(·)$，以进一步减少任何可能的错误回环的影响。相反，我们不对顺序边使用任何鲁棒范数，因为这些边是从VIO中提取出来的，VIO已经包含了足够多的外点排除机制。</p>
<p>位姿图优化和重定位(VII-C)异步运行在两个独立的线程中。以便在需要重定位时，能立即使用最优化的位姿图。同样，即使当前的位姿图优化尚未完成，仍然可以使用现有的位姿图配置进行重新定位。这一过程如图9(b)所示。</p>
<h2 id="C-位姿图管理"><a href="#C-位姿图管理" class="headerlink" title="C. 位姿图管理"></a>C. 位姿图管理</h2><p>随着行程距离的增加，位姿图的大小可能会无限增长，从而限制了长时间系统的实时性。为此，我们实行了一个下采样过程，将位姿图数据库保持在有限的大小。所有具有回环约束的关键帧都将被保留，而其他与相邻帧过近或方向非常相似的关键帧可能会被删除。关键帧被移除的概率和其相邻帧的空间密度成正比。</p>
<h1 id="IX-实验结果"><a href="#IX-实验结果" class="headerlink" title="IX. 实验结果"></a>IX. 实验结果</h1><p>我们进行了三个实验和两个应用，以评估所提出的VINS-Mono系统。在第一个实验中，我们将提出的算法与另一种最先进算法在公共数据集上进行比较。我们通过数值分析以验证了系统的精度。然后在室内环境中测试我们的系统，以评估在重复场景中的性能。通过大量的实验验证了系统的长期实用性。此外，我们还将所提出的系统应用于两个应用。对于空中机器人的应用，我们使用VINS-Mono作为位置反馈来控制无人机跟踪预定的轨迹。然后我们将我们的方法移植到iOS移动设备上，并与Google Tango进行比较。</p>
<h2 id="A-数据集比较"><a href="#A-数据集比较" class="headerlink" title="A. 数据集比较"></a>A. 数据集比较</h2><p>我们使用EuRoC MAV视觉-惯性数据集[41]评估我们提出的VINS-Mono。这个数据集是在一架微型飞行器上收集的，它包含立体图像(Aptina MT9V034全局快门、WVGA单色、20 FPS)、同步IMU测量(ADIS 16448、200 Hz)和地面真实状态(Vicon和Leica MS 50)。我们只使用左边相机的图像。在这数据集中会观察到较大的IMU偏置和光照变化。</p>
<p>在这些实验中，我们将VINS-Mono和OKVIS进行了比较，这是一种最先进的单目和立体相机VIO。OKVIS是另一种基于优化的滑动窗口算法。我们的算法与OKVIS在许多细节上是不同的，如技术部分所示。我们的系统具有良好的初始化和回环功能。我们使用MH_03_median和MH_05_difficult两组序列来证明该方法的性能。为了简化表示，我们使用VINS来表示我们只使用单目VIO的方法，而VINS_loop表示含重定位和位姿图优化的完全版本。我们分别用OKVIS_Mono和OKVIS_stereo表示OKVIS使用单目和立体图像的结果。为了进行公平的比较，我们丢弃前100个输出，并使用接下来的150个输出对齐地面真值，并比较其余的估计器输出。</p>
<p>MH_03_median序列轨迹如图11所示。我们只比较平移误差，因为旋转运动在这个序列中是可以忽略的。图12显示了x、y、z误差与时间的关系，以及平移误差与距离的关系。在误差图中，具有回环的VINS-Mono具有最小的平移误差。我们在MH_05_difficult上观察到类似的结果。该方法具有最小的平移误差。平移和旋转误差如图14所示。由于该序列运动平稳，偏角变化不大，只发生位置漂移。显然，回环闭合有效地约束了累积漂移。OKVIS在翻滚角和俯仰角估计方面表现更好。一个可能的原因是VINS-Mono采用了预积分技术，即IMU传递的一阶近似，以节省计算资源。</p>
<p>VINS-Mono在所有Euroc数据集中都表现良好，即使在最具挑战性的序列V1_03_difficult中，它具有剧烈性的运动、纹理较少的区域和显著的光照变化。由于采用了专用的初始化过程，该方法可以在V1_03_difficult快速初始化。</p>
<p>对于纯VIO，VINS-Mono和OKVIS具有相似的精度，很难区分哪个比较好。然而，VINS-Mono在系统级别上优于OKVIS。它是一个完整的系统，具有鲁棒的初始化和回环闭合功能来辅助单目视觉。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211301627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211334529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-室内实验"><a href="#B-室内实验" class="headerlink" title="B. 室内实验"></a>B. 室内实验</h2><p>在室内实验中，我们选择实验室环境作为实验区域。我们使用的传感器套件如图15所示。它搭载在DJI A3控制器上，包含一个单目照相机（20Hz）和一个IMU（100 Hz）。我们手握传感器套件，在实验室以正常的速度行走。如图16所示，我们遇到行人，光线较弱的位置，纹理较少的区域，玻璃和反射。多媒体附件中可以找到视频。 </p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211501205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们将我们的结果与OKVIS进行了比较，如图17所示。图17(a)是OKVIS的VIO输出。图17(b)是所提出的无回环方法的VIO结果。图17©是所提出的具有重定位和回环闭合的方法的结果。当我们在室内转圈时，会出现明显的漂移。OKVIS和只有VIO版本的VINS-Mono在x、y、z和偏航角上积累了大量漂移。我们的重定位和回环闭合模块有效地消除了所有这些漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211551914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="C-大范围环境"><a href="#C-大范围环境" class="headerlink" title="C. 大范围环境"></a>C. 大范围环境</h2><p>1）走出实验室：我们在室内和室外混合环境中测试VINS-Mono。传感器套件与图15所示的相同。我们从实验室的一个座位上开始，在室内空间里走来走去。然后我们下楼，在大楼外的操场上走来走去。接下来，我们回到楼里并上楼。最后，我们回到了实验室的同一个座位。整个轨迹超过700米，持续约10分钟。在多媒体附件中可以找到实验的视频。</p>
<p>轨迹如图19所示。图19(a)是OKVIS的轨迹。当我们上楼时，OKVIS显示出不稳定的特征跟踪，导致估计错误。我们看不到红色街区楼梯的形状。VINS-Mono的纯VIO结果如图19(b)所示。有闭环的轨迹如图19©所示。该方法的楼梯形状清晰。为验证其准确性，将闭环轨迹与谷歌地图对齐，如图18所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921164349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>OKVIS的 x、y和z轴的最终漂移为[13.80,-5.26,7.23]米。VINS-Mono无环闭路的最终漂移为[-5.47,2.76,-0.29]m，占整个轨迹长度的0.88%，小于OKVIS的2.36%。经回环修正，最终漂移上界为[-0.032,0.09,-0.07]m，与整个轨迹长度相比这是微不足道的。虽然我们没有地面真值，但我们仍然可以直观地检查优化后的轨迹是否平滑并能精确地与卫星地图对齐。</p>
<p>2）环游校园：这张环绕整个科大校园的非常大规模的数据集是用一个手持的VI-Sensor 4记录下来的。该数据集覆盖的地面长度约为710米，宽度为240米，高度变化为60米。总路径长度为5.62km。数据包含25Hz图像和200Hz IMU，持续1小时34分钟。对VINS-Mono的稳定性和耐久性进行测试是一个非常有意义的实验。</p>
<p>在这个大规模的测试中，我们将关键帧数据库的大小设置为2000，以提供足够的回环信息并达到实时性。我们运行此数据集时，采用英特尔i7-4790 CPU运行在3.60GHz。时间统计数据显示在表I中。如图20，估计的轨迹与谷歌地图一致。与谷歌地图相比，我们的结果在这个非常长时间的测试中几乎没有漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921174092.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211751315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>D. 应用1：航空机器人的反馈控制</p>
<p>如图21(a)所示，我们将VINS-Mono应用于航空机器人的自主反馈控制。我们使用了一个具有752×480分辨率的前向全局曝光相机(MatrixVisionMvBlueFOXMLC200w)，并配备了190度鱼眼镜头。DJIA3飞行控制器用于IMU测量和姿态稳定控制。机载计算资源是Intel i7-5500 U CPU运行在3.00GHz。传统的针孔摄像机模型不适用于大视场摄像机。我们使用MEI[42]模型，由[43]介绍的工具包进行校准。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211839510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>在本实验中，我们测试使用VINS_Mono的状态估计来进行自主轨迹跟踪的性能。实验中回环检测被禁止。四旋翼被命令跟踪一个八字形图案，每个圆圈半径为1.0米，如图21(b)所示。在轨迹周围设置了四个障碍物，以验证VINS-Mono无闭环的准确性。在实验过程中，四旋翼连续四次跟踪这一轨迹。100 Hz机载状态估计(VI-F)支持对四旋翼的实时反馈控制。</p>
<p>地面真值是用OptiTrack 5获得的。总轨迹长度为61.97 m。最终漂移为[0.08，0.09，0.13]m，为0.29%的位置漂移。平移和旋转的细节以及它们相应的误差如图23所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211919318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="E-应用2：移动设备"><a href="#E-应用2：移动设备" class="headerlink" title="E. 应用2：移动设备"></a>E. 应用2：移动设备</h2><p>我们将VINS-Mono移植到移动设备上，并提供一个简单的AR应用程序来展示其准确性和鲁棒性。我们将我们的移动实现命名为VINS-Mobile6，并将其与Google Tango Device 7进行了比较，后者是移动平台在商业上最好的增强现实解决方案之一。</p>
<p>VINS-Mono运行在iPhone7 Plus上。我们使用iPhone采集的30 Hz、分辨率为640×480的图像，以及内置InvenSense MP67B 6轴陀螺仪和加速度计获得的100 Hz 的IMU数据。如图24所示，我们将iPhone与一个启用Tango功能的联想Phab 2 Pro一起安装。Tango设备使用全局快门、鱼眼相机和同步IMU进行状态估计。首先，我们在从估计的视觉特征中提取出来的平面上插入一个虚拟立方体，如图25(a)所示。然后，我们拿着这两个装置，以正常的速度在房间内外行走。当检测到回环时，我们使用四自由度位姿图优化(VIII-B)，以消除x，y，z和yaw漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212019875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212037844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921210026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>有趣的是，当我们打开一扇门时，Tango的偏航角估计会跳转到一个很大的角度，如图25(b)所示。其原因可能是由于不稳定的特征跟踪或主动故障检测和恢复而导致的估计器崩溃。然而，VINS-Mono在这个具有挑战性的情况中仍然表现很好。行走了大约264米后我们回到起点。最后的结果可以在图25( c)中看到，Tango的轨迹在最后一圈会漂移，而我们的VINS会回到起点。四自由度位姿图的优化消除了总轨迹的漂移。这与开始相比，立方体被标记到图像上的同一位置也印证了这一点。</p>
<p>诚然，尤其是对局部状态的估计，Tango比我们的实现更准确。但是实验结果表明，我们的方法可以在通用移动设备上运行，并且具有媲美特殊工程设备的潜力。实验还证明了该方法的鲁棒性。视频可以在多媒体附件中找到。</p>
<h1 id="X-结论和未来工作"><a href="#X-结论和未来工作" class="headerlink" title="X. 结论和未来工作"></a>X. 结论和未来工作</h1><p>本文提出了一种鲁棒、通用的单目视觉惯性估计器。我们的方法在IMU预积分，估计器初始化和故障恢复，在线外部校准，紧耦合视觉惯性里程计，重定位和有效的全局优化上，具有最先进的和新颖的解决方案。我们通过与最先进的开源实现和高度优化的行业解决方案进行比较，显示出更好的性能。我们开源了PC和iOS的实现，以造福社会。</p>
<p>虽然基于特征的VINS估计器已经达到了实际使用的成熟程度，我们仍然看到了未来研究的许多方向。单目VINS可能会根据运动和环境而达到较难观测甚至退化的状态。我们最感兴趣的是在线方法来评估单目VINS的可观测性，以及在线生成运动计划来恢复可观测性。另一个研究方向是在大量消费设备上大规模部署单目VINS，例如移动电话。这一应用要求在线校准几乎所有传感器的内参和外参，以及在线鉴定校准质量。最后，我们感兴趣的是制作由单目VINS给出的稠密地图。我们在[44]中首次给出了用于无人机导航的单目视觉-惯性稠密地图的结果。然而，仍需进行广泛的研究以进一步提高系统的精度和鲁棒性。</p>
]]></content>
      <categories>
        <category>VINS</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>8.二叉树的下一节点</title>
    <url>/2019/10/19/8.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目：<br>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。<br>树中的结点不仅包含左右子节点的指针，同时包含指向父结点的指针。<br>思路：</p><ul>
<li>如果一个节点有右子树，那么它的下一个节点就是它的右子树的最左子节点</li>
<li>没有右子树，分两种情况<blockquote>
<p>1.它是它父节点的左子节点，那么它的下一个节点就是它的父节点<br>2.它是它父节点的右子节点，可以沿着指向父节点的指针一直向上遍历，直到找到==一个是它的父节点的左子节点的节点==，如果这个节点存在，那么这个节点的父节点就是要找的下一个节点<br><strong>C++</strong></p>
</blockquote>
</li>
</ul><a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode *father;</span><br><span class="line"> *     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), father(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        TreeNode* p_next=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p_right=p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(p_right-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">               p_right=p_right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p_next=p_right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;father)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p_current=p;</span><br><span class="line">            TreeNode* p_father=p-&gt;father;</span><br><span class="line">            <span class="keyword">while</span>(p_father &amp;&amp; p_current==p_father-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                p_current=p_father;</span><br><span class="line">                p_father=p_father-&gt;father;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p_next=p_father;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p_next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.father = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> p==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        p_next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span>(p.right):</span><br><span class="line">            p_right=p.right</span><br><span class="line">            <span class="keyword">while</span> p_right.left:</span><br><span class="line">                p_right=p_right.left</span><br><span class="line">            p_next=p_right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span>(p.father):</span><br><span class="line">            p_current=p</span><br><span class="line">            p_father=p.father</span><br><span class="line">            <span class="keyword">while</span>(p_father <span class="keyword">and</span> p_current==p_father.right):</span><br><span class="line">                p_current=p_father</span><br><span class="line">                p_father=p_father.father</span><br><span class="line">                </span><br><span class="line">            p_next=p_father</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> p_next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>7.重建二叉树</title>
    <url>/2019/10/19/7.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>在二叉树的前序遍历和中序遍历中确定根节点的值，分别找到前序遍历和中序遍历左右子树对应的子序列，再以同样的方法，构建左右子树，用递归方法完成。<br><strong>C++</strong></p><a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty()||vin.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//前序遍历的第一个数值就是根节点的值</span></span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//在中序遍历序列中找到根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> root_index,i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==pre[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                root_index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_left,pre_right,vin_left,vin_right;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;root_index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_left.push_back(pre[i+<span class="number">1</span>]);</span><br><span class="line">            vin_left.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=root_index+<span class="number">1</span>;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_right.push_back(pre[i]);</span><br><span class="line">            vin_right.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/* 递归调用，层层调用，直到调用到叶子节点，返回NULL*/</span></span><br><span class="line">        <span class="comment">//构建左子树</span></span><br><span class="line">        root-&gt;left=reConstructBinaryTree(pre_left,vin_left);</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root-&gt;right=reConstructBinaryTree(pre_right,vin_right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span>(len(pre)==<span class="number">0</span> <span class="keyword">or</span> len(tin)==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root=TreeNode(pre[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#         for i in range(len(tin)):</span></span><br><span class="line"><span class="comment">#             if tin[i]==pre[0]:</span></span><br><span class="line"><span class="comment">#                 root_index=i </span></span><br><span class="line"><span class="comment">#                 break </span></span><br><span class="line">                </span><br><span class="line">        root_index=tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root.left=self.reConstructBinaryTree(pre[<span class="number">1</span>:<span class="number">1</span>+root_index],tin[:root_index])</span><br><span class="line">        root.right=self.reConstructBinaryTree(pre[root_index+<span class="number">1</span>:],tin[root_index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>9.用两个栈实现队列</title>
    <url>/2019/10/19/6.%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>仅仅需要打印数值,而不是反转链表,这个还是有区别.如果单纯的反转打印链表的值的话,我们可以使用stack操作.<br><strong>C++</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt;nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">        ListNode* node=head;</span><br><span class="line">        <span class="keyword">while</span>(node !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(node);</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node=nodes.top();<span class="comment">//返回栈顶元素, 但不删除该元素</span></span><br><span class="line">            ArrayList.push_back(node-&gt;val);</span><br><span class="line">            nodes.pop();<span class="comment">//弹出栈顶元素, 但不返回其值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>Python</strong></p><a id="more"></a>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ArrayList=[]</span><br><span class="line">        head=listNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ArrayList.insert(<span class="number">0</span>,head.val)</span><br><span class="line">            head=head.next</span><br><span class="line">        <span class="keyword">return</span> ArrayList</span><br><span class="line">        </span><br><span class="line"><span class="comment">#        while head:</span></span><br><span class="line"><span class="comment">#            ArrayList.append(head.val)</span></span><br><span class="line"><span class="comment">#            head=head.next</span></span><br><span class="line"><span class="comment">#        return ArrayList[::-1]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>5.替换空格</title>
    <url>/2019/10/19/5.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><ul>
<li>从前往后替换，时间复杂度$O(n^2)$</li>
<li>从后往前替换，时间复杂度$O(n)$</li>
</ul><p><strong>C++</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 指向字符数组的字符指针str，字符数组长度length</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> originalLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlank=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，统计空格个数、替换前字符个数、替换后字符个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            originalLength++;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">                numberOfBlank++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 替换空格</span></span><br><span class="line">        <span class="keyword">int</span> newLength = originalLength +<span class="number">2</span>* numberOfBlank;</span><br><span class="line">        <span class="keyword">if</span>(newLength+<span class="number">1</span>&gt;length)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *p1 = str+originalLength;	<span class="comment">// 字符指针指向原始字符串的末尾</span></span><br><span class="line">        <span class="keyword">char</span> *p2 = str+newLength;		<span class="comment">// 字符指针指向替换后字符串的末尾</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p1 == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *p2-- = <span class="string">'0'</span>;</span><br><span class="line">                *p2-- = <span class="string">'2'</span>;</span><br><span class="line">                *p2-- = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                *p2-- = *p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*original_length为字符串str的实际长度*/</span></span><br><span class="line">        <span class="keyword">int</span> original_length = <span class="number">0</span>;			<span class="comment">//原始长度</span></span><br><span class="line">        <span class="keyword">int</span> number_blank = <span class="number">0</span>;				<span class="comment">//空格数</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;				<span class="comment">//遍历字符串</span></span><br><span class="line">            original_length++;				<span class="comment">//长度+1</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                number_blank++;				<span class="comment">//遇到空格+1</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*new_length为把空格替换成'%20'之后的长度*/</span></span><br><span class="line">        <span class="keyword">int</span> new_length = original_length + <span class="number">2</span> * number_blank;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p1 = original_length;	<span class="comment">//原始字符串末尾索引值</span></span><br><span class="line">        <span class="keyword">int</span> p2 = new_length;		<span class="comment">//计算长度后的字符串末尾索引值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*index_original指针开始向前移动，如果遇到空格，替换成'%20'，否则进行复制操作*/</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt; p1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[p1] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[p2--] = <span class="string">'0'</span>;</span><br><span class="line">                str[p2--] = <span class="string">'2'</span>;</span><br><span class="line">                str[p2--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[p2--] = str[p1];</span><br><span class="line">            &#125;</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#string（区别于list）是一种不可变的数据类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        origianl_length=len(s)</span><br><span class="line">        number_blank=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">' '</span>:</span><br><span class="line">                number_blank+=<span class="number">1</span></span><br><span class="line">        p1=origianl_length<span class="number">-1</span></span><br><span class="line">        p2=origianl_length+<span class="number">2</span>*number_blank<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        new_s=[<span class="string">' '</span>]*(p2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[p1]==<span class="string">' '</span>:</span><br><span class="line">                new_s[p2]=<span class="string">'0'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">                new_s[p2]=<span class="string">'2'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">                new_s[p2]=<span class="string">'%'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_s[p2]=s[p1]</span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            p1-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>4.二维数组中的查找</title>
    <url>/2019/10/19/4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>Python</strong><br>遍历二维数组<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> target==array[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><a id="more"></a>
<p>规律：首先选取数组右上角的数字</p>
<ul>
<li>如果该数字等于要查找的数字，则查找结束</li>
<li>该数字大于要查找的数字，则剔除这个数字所在的列</li>
<li>该数字小于要查找的数字，则剔除这个数字所在的行<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        row=<span class="number">0</span></span><br><span class="line">        column=len(array[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;len(array) <span class="keyword">and</span> column&gt;=<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(array[row][column]==target):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span>(array[row][column]&gt;target):</span><br><span class="line">                column-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<strong>C++</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">array</span>[<span class="number">0</span>].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target==<span class="built_in">array</span>[i][j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column=<span class="built_in">array</span>[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;<span class="built_in">array</span>.size()&amp;&amp; column&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="built_in">array</span>[row][column])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;<span class="built_in">array</span>[row][column])</span><br><span class="line">                column--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>VINS-Mono论文学习与代码解读</title>
    <url>/2019/10/18/VINS-Mono%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86564879" target="_blank" rel="noopener">VINS-Mono代码解读——启动文件launch与参数配置文件yaml介绍</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86030962" target="_blank" rel="noopener">VINS-Mono代码解读——各种数据结构 sensor_msgs</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/85797156" target="_blank" rel="noopener">VINS-Mono代码解读——视觉跟踪 feature_trackers</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86290941" target="_blank" rel="noopener">VINS-Mono理论学习——IMU预积分 Pre-integration （Jacobian 协方差）</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86293038" target="_blank" rel="noopener">VINS-Mono代码解读——状态估计器流程 estimator 写在初始化和非线性优化前</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/89106128" target="_blank" rel="noopener">VINS-Mono理论学习——视觉惯性联合初始化与外参标定</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/93593844" target="_blank" rel="noopener">VINS-Mono理论学习——后端非线性优化</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/87878550" target="_blank" rel="noopener">VINS-Mono代码解读——回环检测与重定位 pose graph loop closing</a></li>
</ol>]]></content>
      <categories>
        <category>VIO</category>
      </categories>
  </entry>
</search>
