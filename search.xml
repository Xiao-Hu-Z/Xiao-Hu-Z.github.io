<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>随机抽样一致RANSAC-Random-Sample-Consensus</title>
    <url>/2020/05/07/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4RANSAC-Random-Sample-Consensus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h1><p>随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</p><a id="more"></a>
<h1 id="RANSAC的基本假设："><a href="#RANSAC的基本假设：" class="headerlink" title="RANSAC的基本假设："></a>RANSAC的基本假设：</h1><p>“内群”数据可以通过几组模型的参数来叙述其分布，而“离群”数据则是不适合模型化的数据。<br>数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。<br>RANSAC假定，给定一组（通常很小）的内群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。</p>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><p>这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内群以及离群，其中内群为可以被拟合到线段上的点，而离群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内群的线，因为最小二乘法会受离群影响而影响其结果。而RANSAC，可以只由内群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020160728989.png#pic_center"><br>包含许多离群的一组数据，要找一条最适合的线。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910201607364.png#pic_center"><br>RANSAC找到的线，离群值对结果没影响（蓝色点为内群，红色点为离群）</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RANSAC算法的输入是一组观测数据（往往含有较大的噪声或无效点），一个用于解释观测数据的参数化模型以及一些可信的参数。RANSAC通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证： </p>
<ol>
<li>有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出。</li>
<li>用1中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li>
<li>如果有足够多的点被归类为假设的局内点，那么估计的模型就足够合理。</li>
<li>然后，用所有假设的局内点去重新估计模型（譬如使用最小二乘法），因为它仅仅被初始的假设局内点估计过。</li>
<li>最后，通过估计局内点与模型的错误率来评估模型。</li>
<li>上述过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为比现有的模型更好而被选用。<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1>伪码形式的算法如下所示：</li>
</ol>
<ul>
<li><p>输入：</p>
<blockquote>
<p>data —— 一组观测数据<br>model —— 适应于数据的模型<br>n —— 适用于模型的最少数据个数<br>k —— 算法的迭代次数<br>t —— 用于决定数据是否适应于模型的阀值<br>d —— 判定模型是否适用于数据集的数据数目</p>
</blockquote>
</li>
<li><p>输出：</p>
<blockquote>
<p>best_model —— 跟数据最匹配的模型参数（如果没有找到好的模型，返回null）<br>best_consensus_set —— 估计出模型的数据点<br>best_error —— 跟数据相关的估计出的模型错误</p>
</blockquote>
<ul>
<li>iterations = 0<blockquote>
<p>best_model = null<br>best_consensus_set = null<br>best_error = 无穷大<br>while ( iterations &lt; k )<br>maybe_inliers = 从数据集中随机选择n个点<br>maybe_model = 适合于maybe_inliers的模型参数<br>consensus_set = maybe_inliers</p>
</blockquote>
</li>
</ul>
</li>
<li><p>估计的模型就足够合理</p>
<blockquote>
<p>for ( 每个数据集中不属于maybe_inliers的点 ）<br>if ( 如果点适合于maybe_model，且错误小于t ）<br>将点添加到consensus_set<br>if （ consensus_set中的元素数目大于d ）<br>已经找到了好的模型，</p>
</blockquote>
</li>
<li><p>现在测试该模型到底有多好</p>
<blockquote>
<p>better_model = 适合于consensus_set中所有点的模型参数<br>this_error = better_model究竟如何适合这些点的度量<br>if ( this_error &lt; best_error )<br>我们发现了比以前好的模型，保存该模型直到更好的模型出现<br>best_model =  better_model<br>best_consensus_set = consensus_set<br>best_error =  this_error</p>
</blockquote>
</li>
<li><p>迭代</p>
<blockquote>
<p>增加迭代次数<br>返回 best_model, best_consensus_set, best_error</p>
</blockquote>
<p> RANSAC算法的可能变化包括以下几种：</p>
<ol>
<li><p>如果发现了一种足够好的模型（该模型有足够小的错误率），则跳出主循环。这样可能会节约计算额外参数的时间。</p>
<ol>
<li>直接从maybe_model计算this_error，而不从consensus_set重新估计模型。这样可能会节约比较两种模型错误的时间，但可能会对噪声更敏感。</li>
</ol>
<p>其实核心就是随机性和假设性。随机性用于减少计算了，那个循环次数就是利用正确数据出现的概率。所谓的假设性，就是说随机抽出来的数据我都认为是正确的，并以此去计算其他点，获得其他满足变换关系的点，然后利用投票机制，选出获票最多的那一个变换。</p>
</li>
</ol>
</li>
</ul>
<h1 id="参数决定"><a href="#参数决定" class="headerlink" title="参数决定"></a>参数决定</h1><p>假设每个点是真正内群的几率是w，则：</p>
<ul>
<li>w = 真正内群的数目 / 数据总共的数量</li>
</ul>
<p>通常我们不知道w 是多少，$w^{n}$是所选择的n 个点都是内群的几率，$1-w^{n}$ 是所选择的 n 个点至少有一个不是内群的几率， ${(1-w^{n})^{k}}$是表示重复k 次都没有全部的 {\displaystyle n} n 个点都是内群的几率，假设算法跑 k 次以后成功的几率是p，那么：</p>
<script type="math/tex; mode=display">{1-p=(1-w^{n})^{k}}</script><script type="math/tex; mode=display">{p=1-(1-w^{n})^{k}}</script><p>所以如果希望成功几率高， ${\displaystyle p=0.99}$， 当n 不变时，k 越大， {\displaystyle p} p 越大， 当w 不变时，n 越大，所需的k 就越大， 通常w 未知，所以 n 选小一点比较好。</p>
<h1 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h1><ul>
<li>RANSAC的优点是它能鲁棒的估计模型参数。例如，它能从包含大量局外点的数据集中估计出高精度的参数。</li>
<li>RANSAC的缺点是它计算参数的迭代次数没有上限；如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。</li>
<li>RANSAC只有一定的概率得到可信的模型，概率与迭代次数成正比。RANSAC的另一个缺点是它要求设置跟问题相关的阀值。</li>
<li>RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</li>
</ul>
<p>参考：</p>
<blockquote>
<p><a href="https://blog.csdn.net/pi9nc/article/details/26596519" target="_blank" rel="noopener">RANSAC</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E6%8A%BD%E6%A8%A3%E4%B8%80%E8%87%B4" target="_blank" rel="noopener">随机抽样一致</a></p>
</blockquote>
]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>IMU测量模型、运动模型、误差模型</title>
    <url>/2020/05/07/IMU%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B%E3%80%81%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E3%80%81%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IMU测量模型"><a href="#IMU测量模型" class="headerlink" title="IMU测量模型"></a>IMU测量模型</h1><ul>
<li><p>MEMS 加速度计工作原理<br>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示<br>加速度计测量值$a_m$为弹簧拉力对应的加速度</p>
<script type="math/tex; mode=display">a_m=\frac{f}{m}=a-g</script><p>其中m为质量块质量，a为物体在世界（惯性）坐标系下的实际加速度。</p>
</li>
<li><p>陀螺仪测量原理<br>陀螺仪的测量值即为IMU在body坐标系下的旋转角速度，要通过运动学模型转换到惯性坐标系下 ，按测量原理分有振动陀螺，光纤陀螺等。</p>
<p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 Coriolisforce 来间接得到角速度。</p>
<blockquote>
<p>在旋转坐标系中，运动的物体受到科氏力作用<br>MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017192448388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="IMU运动模型"><a href="#IMU运动模型" class="headerlink" title="IMU运动模型"></a>IMU运动模型</h1><h2 id="旋转量求导"><a href="#旋转量求导" class="headerlink" title="旋转量求导"></a>旋转量求导</h2><p>首先，如下图所示，考虑一个从原点出发的向量 r 绕单位轴 u 旋转，角速度大小为 θ˙。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017155511191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>角速度矢量可以表示为${\boldsymbol \omega}=\dot{\theta}u$，易得向量 r 末端点 P 的速度矢量，即 r的时间一阶导为</p>
<script type="math/tex; mode=display">\frac{d{r}}{dt} = {\boldsymbol \omega} \times {r}</script><p>坐标系 {B} 绕单位轴 u 旋转，如上所述，其三个轴的时间一阶导同样为</p>
<script type="math/tex; mode=display">\frac{d{\bf i}_B}{dt} = {\boldsymbol \omega} \times {\bf i}_B, \frac{d{\bf j}_B}{dt} = {\boldsymbol \omega} \times {\bf j}_B, \frac{d{\bf k}_B}{dt} = {\boldsymbol \omega} \times {\bf k}_B</script><p>$[ {\bf i}_B \quad {\bf j}_B \quad {\bf k}_B ]$ 实际上就是坐标系 {B} 相对于参考坐标系的旋转矩阵 R，R的时间一阶导为</p>
<script type="math/tex; mode=display">\dot{\bf R} =  [ {\boldsymbol \omega} \times {\bf i}_B \quad {\boldsymbol \omega} \times {\bf j}_B \quad {\boldsymbol \omega} \times {\bf k}_B ] = {\boldsymbol \omega} \times {\bf R}</script><p>叉乘运算可以转化为负对称矩阵的乘法：</p>
<script type="math/tex; mode=display">\dot{\bf R} = {\boldsymbol \omega}^{\land} {\bf R}</script><p>其中负对称矩阵${\boldsymbol \omega}^{\land}$为</p>
<script type="math/tex; mode=display">% <![CDATA[
\quad {\boldsymbol \omega}^{\land}= \begin{bmatrix}0 & -\omega_3 & \omega_2\\ \omega_3 & 0 & -\omega_1 \\ -\omega_2 & \omega_1 & 0\end{bmatrix} %]]></script><p>这里的角速度 ω 是在参考坐标系下表达的，角速度也经常表达在体坐标系 {B} 下，记为${}^B{\boldsymbol \omega} = {\bf R}^T{\boldsymbol \omega}$，即${\boldsymbol \omega} = {\bf R}{}^B{\boldsymbol \omega}$<br>上式也可以写作：</p>
<script type="math/tex; mode=display">\dot{\bf R} =w^{\land}R=(R^Bw)^{\land}R=R{}^{\land}wR^TR= R({}^Bw)^{\land}</script></blockquote>
</li>
</ul><a id="more"></a>
<blockquote>
<p>证：对任意旋转矩阵 R 和三维向量 v，都有$({\bf R v})^{\land} = {\bf Rv^{\land}R}^T$<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017160718789.png#pic_center"><br>最后一式利用向量叉乘的旋转变换不变性可证，即，对于任意${\bf v,u}\in \mathbb{R}^3$永远有</p>
<script type="math/tex; mode=display">({\bf Rv})\times({\bf Ru})={\bf R(v\times u)}</script><p>从三维几何的角度来理解：v,u 是任意两个三维向量，(v×u) 是一个和 v,u 都垂直、大小为 |v||u|sin(u,v) 的三维向量；将 v,u,v×u 三个向量都经过同一个旋转，它们的相对位姿和模长都不会改变，所以 (Rv) 和 (Ru) 的叉乘仍是 R(v×u)。</p>
</blockquote>
<h2 id="科氏加速度"><a href="#科氏加速度" class="headerlink" title="科氏加速度"></a>科氏加速度</h2><p>这次把绕惯性系 {A} 中固定单位轴 u 旋转的 {B} 作为参考坐标系。考虑下图， 点 P 相对于 {B} 运动，记 ${}^Br$ 分别为 P 在 {B} 下的坐标，r 为 P 的绝对坐标（即 {A} 下坐标）， R 仍为 {B} 相对于 {A} 的旋转矩阵，易知 $r=R{}^Br$。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017163839187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$r=R{}^Br$求一阶时间导</p>
<script type="math/tex; mode=display">{\bf v} = \dot{\bf r} = \dot{\bf R} {}^B{\bf r} + {\bf R}^B\dot{\bf r} = {\boldsymbol \omega}^{\land}{\bf R}{}^B{\bf r}+ {\bf R}^B\dot{\bf r}</script><p>记P在 {B}下速度为 ${}^Bv$，于是</p>
<script type="math/tex; mode=display">v = w^{\land}r+ {R}^B{}= w \times r+ v_r</script><p>${\bf v}_r$来表达「相对速度」的概念，准确定义为 P 相对于 {B} 的速度，在惯性系 {A} 下的表达<br>再对求时间导：</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017165037235.png#pic_center"><br>在旋转坐标系下观察，运动的物体（运动方向和旋转轴不为同一个轴时）会受到科氏力的作用。</p>
<ul>
<li>第一项中${\boldsymbol \alpha}$为 {B} 的角加速度，所以第一项的物理意义是 {B} 旋转所造成的 P 的切向加速度</li>
<li>第二项是 {B} 旋转所造成的向心加速度</li>
<li>第三项比较特殊，为 {B} 的旋转运动与 P 相对 {B} 的平移运动耦合产生的加速度，称为科氏加速度</li>
<li>第四项为 P 相对于 {B} 的加速度，但在惯性系{A}下表达，类似于${\bf v}_r$</li>
</ul>
</blockquote>
<h1 id="IMU-误差模型"><a href="#IMU-误差模型" class="headerlink" title="IMU 误差模型"></a>IMU 误差模型</h1><p>加速度计和陀螺仪的误差可以分为：确定性误差，随机误差。</p>
<ul>
<li>确定性误差可以事先标定确定，包括： bias, scale …</li>
<li>随机误差通常假设噪声服从高斯分布，包括：高斯白噪声， bias<br>随机游走…<h2 id="确定性误差"><a href="#确定性误差" class="headerlink" title="确定性误差"></a>确定性误差</h2></li>
</ul>
<ol>
<li>Bias ，Scale<br>理论上，当没有外部作用时， IMU 传感器的输出应该为 0，但实际数据存在一个偏置 b。</li>
</ol>
<ul>
<li>加速度计 bias 对位姿估计的影响：<script type="math/tex; mode=display">v_err=b_at，p_err=\frac{1}{2}b_at^2</script></li>
<li>scale 可以看成是实际数值和传感器输出值之间的比值</li>
</ul>
<ol>
<li>Nonorthogonality/Misalignment Errors(非正交/错位错误）<br><img alt data-src="https://img-blog.csdnimg.cn/20191017182956354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"> </li>
<li>其他确定性误差<blockquote>
<ul>
<li>Run-to-Run Bias/Scale Facto</li>
<li>In Run (Stability) Bias/Scale Factor</li>
<li>Temperature-Dependent Bias/Scale Factor</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="确定性误差误差标定"><a href="#确定性误差误差标定" class="headerlink" title="确定性误差误差标定"></a>确定性误差误差标定</h3><h4 id="六面法标定加速度"><a href="#六面法标定加速度" class="headerlink" title="六面法标定加速度"></a>六面法标定加速度</h4><p><strong>bias 和 scale factor</strong></p>
<blockquote>
<p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。如果各个轴都是正交的，那很容易得到 bias 和 scale：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017171617729.png#pic_center"><br>其中,$l$为加速度计某个轴的测量值， g为当地的重力加速度</p>
</blockquote>
<p><strong>（Nonorthogonality/Misalignment Errors)</strong></p>
<blockquote>
<p>多轴 IMU 传感器制作的时候，由于制作工艺的问题，会使得 xyz 轴可能不垂直，如下图所示。</p>
<p>考虑轴间误差的时候，实际加速度和测量值之间的关系为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172240109.png#pic_center"><br>水平静止放置 6 面的时候，加速度的理论值为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172303634.png#pic_center"><br>对应的测量值矩阵 L ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172326866.png#pic_center"><br>利用最小二乘就能够把12个变量求出来。</p>
</blockquote>
<h4 id="六面法标定陀螺仪"><a href="#六面法标定陀螺仪" class="headerlink" title="六面法标定陀螺仪"></a>六面法标定陀螺仪</h4><blockquote>
<ul>
<li>六面法标定陀螺仪 bias 和 scale factor<br>和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这<br>里的 6 面是指各个轴顺时针和逆时针旋转。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017182109980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>参考：<a href="https://blog.csdn.net/CSDN_XCS/article/details/90339761" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_XCS/article/details/90339761</a></li>
</ul>
</blockquote>
<h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><ul>
<li>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</li>
<li>两种标定方法：<blockquote>
<p>• soak method: 控制恒温室的温度值，然后读取传感器数值进行标定。<br>• ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</p>
</blockquote>
</li>
</ul>
<h2 id="随机误差"><a href="#随机误差" class="headerlink" title="随机误差"></a>随机误差</h2><h3 id="高斯白噪声与随机游走"><a href="#高斯白噪声与随机游走" class="headerlink" title="高斯白噪声与随机游走"></a>高斯白噪声与随机游走</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数。故把瞬时值的概率分布服从高斯分布，功率谱密度服从均匀分布的噪声称为高斯白噪声</p>
<p>IMU 数据连续时间上受到一个均值为 0，方差为 $σ^2$，各时刻之间相互独立的高斯过程 n(t)：</p>
<script type="math/tex; mode=display">E[n(t)]=0</script><script type="math/tex; mode=display">E[n(t_1​)n(t_2​)]=σ^2δ(t_1​−t_2​)</script><p>自相关函数的数学定义：$R(τ)=∫^{−∞}_∞　x(t)x(t−τ)dt$</p>
<p>其中 $δ()$ 表示狄拉克函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190929113450104.png#pic_center"><br><strong>白噪声的离散化</strong><br>实际上， IMU 传感器获取的数据为离散采样，离散和连续高斯白噪声的方差之间存在如下转换关系：</p>
<script type="math/tex; mode=display">n_d[k] \triangleq n(t_0+\Delta t)\simeq\frac{1}{\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)dt</script><script type="math/tex; mode=display">
 \begin{aligned}
E(n_d[k]^2) & = E(\frac{1}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)n(t)d \tau dt) \\
&= E( \frac{\sigma^2}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\
&= E(\frac{\sigma^2}{\Delta t})
\end{aligned}</script><p>即:</p>
<script type="math/tex; mode=display">nd[k] = σ_dw[k]</script><p>其中：$w[k] ∼ N(0, 1)$，$\sigma_d=\sigma \frac{1}{\sqrt{\bigtriangleup t}}$<br>也就是说高斯白噪声的连续时间到离散时间之间差一个 $\frac{1}{\sqrt{\bigtriangleup t}}$ ，√∆t 是传感器的采样时间。</p>
<h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走</p>
<script type="math/tex; mode=display">\dot{b}_{(t)}=n(t)=\sigma_bw(t)</script><p>其中 w 是方差为 1 的白噪声</p>
<p>离散和连续之间的转换：</p>
<script type="math/tex; mode=display">b_d[k] \triangleq b(t_0) + \int_{t_0}^{t_0+\Delta t}n(t)dt$$$$\begin{aligned}
E((b_d[k]-b_d[k-1])^2) 
&=E(\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(t)n(\tau)d \tau dt)\\
&= E({\sigma_{b}^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\
&= E(\sigma_{b}^2\Delta t)
\end{aligned}</script><p>即：</p>
<script type="math/tex; mode=display">b_d[k] = b_d[k − 1] + σ_{bd}w[k]</script><p>其中：</p>
<script type="math/tex; mode=display">w[k] ∼ N(0, 1),σ_{bd} = σ_b\sqrt{\bigtriangleup t}</script><p>bias 随机游走的噪声方差从连续时间到离散之间需要乘以 $\sqrt{\bigtriangleup t}$ </p>
<h3 id="随机误差的标定"><a href="#随机误差的标定" class="headerlink" title="随机误差的标定"></a>随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><p>Allan 方差法是 20 世纪 60 年代由美国国家标准局的 David Allan 提出的，它是一种基于时域的分析方法。</p>
<blockquote>
<p>具体的流程如下：</p>
<ol>
<li>保持传感器绝对静止获取数据</li>
<li>对数据进行分段，设定时间段的时长，如下图所示<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204504508.png#pic_center"></li>
<li>将传感器数据按照时间段进行平均</li>
<li>计算方差，绘制艾伦曲线，得到的艾伦曲线如下图所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204557636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">Allan方差法可用于5种随机误差的标定：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017212131103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/YunLaowang/article/details/95608107" target="_blank" rel="noopener">VIO标定IMU随机误差：Allan方差法</a><br><a href="https://blog.csdn.net/lei1105034103/article/details/89159459" target="_blank" rel="noopener">陀螺 Allan 方差分析</a></li>
</ol>
</blockquote>
<h2 id="IMU-数学模型"><a href="#IMU-数学模型" class="headerlink" title="IMU 数学模型"></a>IMU 数学模型</h2><p>以 ECI 为参考坐标系（由于 ECI 为惯性系，不需要考虑地球自转）：<br>忽略 scale 的影响，只考虑白噪声和 bias 随机游走：<br>IMU的真实值：$w^b,a^b$<br>IMU的测量值：$\widetilde{w},\widetilde{a}^b$<br>IMU机体系即b系，w系表示世界坐标系。</p>
<script type="math/tex; mode=display">\begin{aligned}
 \widetilde{w}&=w^b +b^g+n^g\\
 \widetilde{a}^b&=a^b+b^a+n^a\\&=q_{bw}(a^w+g^w)+b^a+n^a
 \end{aligned}</script><p>考虑高斯白噪声项，有：</p>
<script type="math/tex; mode=display">\begin{aligned}
 &w^b=\widetilde{w} -b^g-n^g\\
 &a^w=q_{wb}(\widetilde{a}^b-b^a-n^a)-g^w
 \end{aligned}</script><p>不考虑高斯白噪声项，有：</p>
<script type="math/tex; mode=display">\begin{aligned}
 &w^b=\widetilde{w} -b^g\\
 &a^w=q_{wb}(\widetilde{a}^b-b^a)-g^w
 \end{aligned}</script><p>参考：<a href="https://fzheng.me/2016/11/20/imu_model_eq/#1-2-%E5%89%8D%E7%BD%AE2-%E5%9B%9B%E5%85%83%E6%95%B0" target="_blank" rel="noopener">从零开始的 IMU 状态模型推导</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VIO</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VIO</tag>
      </tags>
  </entry>
  <entry>
    <title>C ++ 学习（11）文件输入和输出</title>
    <url>/2019/11/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%8811%EF%BC%89%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019062610063696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在头文件iostream中定义有两个流类：输入流类istream和输出流类ostream,且用这两个类定义了流对象cin和cout:</p><p>Istream cin;      ostream cout;</p><p>C++的iostream与C的printf/scanf的区别</p><ol>
<li><p>类型处理更安全、智能，printf中对付int、float等说明符比较麻烦</p>
</li>
<li><p>扩展性更强，iostream使用的&lt;&lt;、&gt;&gt;操作符都是可重载，只要重载相关的运算符就可以；</p>
<ol>
<li>流风格的写法也比较自然简洁</li>
</ol>
</li>
<li><p>printf/scanf的速度比cin/cout快</p>
</li>
</ol><a id="more"></a>



<p>几个输入函数介绍：</p>
<p>1.. cin.get()</p>
<pre><code>  cin.get(字符变量名)可以用来接收字符

  cin.get(字符数组名,接收字符数目)用来接收一行字符串,可以接收空格
</code></pre><ol>
<li><p>cin.getline(接收字符串的变量,接收字符个数,结束字符)用法:接收一个字符串，可以接收空格并输出</p>
</li>
<li><p>getline()用法：接收一个字符串，可以接收空格并输出，需包含“#include<string>”</string></p>
</li>
</ol>
<p>注意：cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数。</p>
<h1 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h1><p>文件I/O也称为读文件（输入）和写文件（输出），c++标准库中提供两个类ifstream和ofstream，分别用于文件的输入和输出。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><ol>
<li>创建一个ofstream对象来管理输出流</li>
<li>讲对象与文件关联起来</li>
<li>使用cout的方式使用该对象，唯一的区别是输出讲进入文件，而不是屏幕</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ofstream fout;</span><br><span class="line">fout.open('jar.txt‘）;</span><br><span class="line"><span class="comment">//ofstream fout('jar.txt‘）;</span></span><br><span class="line">fout&lt;&lt;<span class="string">"Dull Data"</span>;</span><br><span class="line">fout.close();</span><br></pre></td></tr></table></figure>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><ol>
<li>创建一个ifstream对象来管理输入流</li>
<li>讲对象与文件关联起来</li>
<li>使用cin的方式使用该对象</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ifstream fin;</span><br><span class="line">fin.open('jar.txt‘）;</span><br><span class="line"><span class="comment">//ifstream fin('jar.txt‘）;in</span></span><br><span class="line">fin.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">fin&gt;&gt;ch;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C ++ 学习（10）C++11 智能指针的使用</title>
    <url>/2019/11/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%8810%EF%BC%89C-11-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>C++程序设计中使用new从堆（自由存储区）分配内存，等不需要时，应使用delete将其释放。C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。<br>智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr</memory></p><a id="more"></a>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p>
<ul>
<li>初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的<ul>
<li>拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。</li>
<li>get函数获取原始指针</li>
<li>注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存</li>
<li><strong>注意避免循环引用</strong>，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍。</li>
</ul>
</int></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra2(ptra); <span class="comment">//copy</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> *pb = &amp;a;</span><br><span class="line">        <span class="comment">//std::shared_ptr&lt;int&gt; ptrb = pb;  //error</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptrb = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(b);</span><br><span class="line">        ptra2 = ptrb; <span class="comment">//assign</span></span><br><span class="line">        pb = ptrb.get(); <span class="comment">//获取原始指针</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>　　unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));  <span class="comment">//绑定动态对象</span></span><br><span class="line">        <span class="comment">//std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能賦值</span></span><br><span class="line">        <span class="comment">//std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷貝</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr2 = <span class="built_in">std</span>::move(uptr); <span class="comment">//轉換所有權</span></span><br><span class="line">        uptr2.release(); <span class="comment">//释放所有权</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超過uptr的作用域，內存釋放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="weak-ptr的使用"><a href="#weak-ptr的使用" class="headerlink" title="weak_ptr的使用"></a>weak_ptr的使用</h2><p>　　weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。
　　</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sh_ptr.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sh_ptr);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!wp.expired())&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr2 = wp.lock(); <span class="comment">//get another shared_ptr</span></span><br><span class="line">            *sh_ptr = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete memory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（9）——string</title>
    <url>/2019/11/18/C-%E5%AD%A6%E4%B9%A0%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94string/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++处理字符串的方式有两种</p><ul>
<li><p>来自c语言，常称为C-风格字符串<br>可以将字符串存储在char数组中，C-风格字符串特殊性质：以空字符（\0)结尾，用来标记字符串的结尾</p>
</li>
<li><p>基于string类型库的方法</p>
</li>
</ul><p>strin类使用简单， 提供了将字符串作为一种数据类型的表示方法</p><p>  为了在我们的程序中使用string类型，我们必须包含头文件 &lt; string&gt;</p><a id="more"></a>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //注意这里不是string.h string.h是C字符串头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h1 id="声明一个C-字符串"><a href="#声明一个C-字符串" class="headerlink" title="声明一个C++字符串"></a>声明一个C++字符串</h1><p>声明一个字符串变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> Str;</span><br></pre></td></tr></table></figure>
<p>string是一个类，有构造函数和析构函数，上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。</p>
<ul>
<li>String类的构造函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str   <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span> <span class="comment">//生成字符串为str的复制品</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, strbegin,<span class="built_in">strlen</span>)</span> <span class="comment">//将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//将C字符串作为s的初值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr, char_len)</span><span class="comment">//以C_string类型cstr的前char_len个字符串作为字符串s的初值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(num ,c)</span><span class="comment">//生成num个c字符的字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx)</span><span class="comment">//将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>String类的析构函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">string</span>() <span class="comment">//销毁所有字符，释放内存</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">=,assign()     <span class="comment">//赋以新值</span></span><br><span class="line"></span><br><span class="line">swap()     <span class="comment">//交换两个字符串的内容</span></span><br><span class="line"></span><br><span class="line">+=,append(),push_back() <span class="comment">//在尾部添加字符</span></span><br><span class="line"></span><br><span class="line">insert() <span class="comment">//插入字符</span></span><br><span class="line"></span><br><span class="line">erase() <span class="comment">//删除字符</span></span><br><span class="line"></span><br><span class="line">clear() <span class="comment">//删除全部字符</span></span><br><span class="line"></span><br><span class="line">replace() <span class="comment">//替换字符</span></span><br><span class="line"></span><br><span class="line">+ <span class="comment">//串联字符串</span></span><br><span class="line"></span><br><span class="line">==,!=,&lt;,&lt;=,&gt;,&gt;=,compare()    <span class="comment">//比较字符串</span></span><br><span class="line"></span><br><span class="line">size(),length()    <span class="comment">//返回字符数量</span></span><br><span class="line"></span><br><span class="line">max_size() <span class="comment">//返回字符的可能最大个数</span></span><br><span class="line"></span><br><span class="line">empty()    <span class="comment">//判断字符串是否为空</span></span><br><span class="line"></span><br><span class="line">capacity() <span class="comment">//返回重新分配之前的字符容量</span></span><br><span class="line"></span><br><span class="line">reserve() <span class="comment">//保留一定量内存以容纳一定数量的字符</span></span><br><span class="line"></span><br><span class="line">[ ], at() <span class="comment">//存取单一字符</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;,getline() <span class="comment">//从stream读取某值</span></span><br><span class="line"></span><br><span class="line">&lt;&lt;    <span class="comment">//将谋值写入stream</span></span><br><span class="line"></span><br><span class="line">copy() <span class="comment">//将某值赋值为一个C_string</span></span><br><span class="line"></span><br><span class="line">c_str() <span class="comment">//将内容以C_string返回</span></span><br><span class="line"></span><br><span class="line">data() <span class="comment">//将内容以字符数组形式返回</span></span><br><span class="line"></span><br><span class="line">substr() <span class="comment">//返回某个子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找函数</span></span><br><span class="line">begin() end() <span class="comment">//提供类似STL的迭代器支持</span></span><br><span class="line">rbegin() rend() <span class="comment">//逆向迭代器</span></span><br><span class="line">get_allocator() <span class="comment">//返回配置器</span></span><br></pre></td></tr></table></figure>
<h2 id="C-字符串和C字符串的转换"><a href="#C-字符串和C字符串的转换" class="headerlink" title="C++字符串和C字符串的转换"></a>C++字符串和C字符串的转换</h2><p>C ++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，</p>
<blockquote>
<ul>
<li>data()以字符数组的形式返回字符串内容，但并不添加’/0’。</li>
<li>c_str()返回一个以‘/0’结尾的字符数组</li>
<li>copy()则把字符串的内容复制或写入既有的c_string或 字符数组内。</li>
</ul>
</blockquote>
<p>C++字符串并不以’/0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。  </p>
<h2 id="string的大小和容量"><a href="#string的大小和容量" class="headerlink" title="string的大小和容量"></a>string的大小和容量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">empty() <span class="comment">//判断字符串是否为空</span></span><br><span class="line">    </span><br><span class="line">size()、length()<span class="comment">//返回string对象的字符个数，他们执行效果相同。</span></span><br><span class="line"></span><br><span class="line">max_size()     <span class="comment">//返回string对象最多包含的字符数，超出会抛出length_error异常</span></span><br><span class="line"></span><br><span class="line">capacity()     <span class="comment">//重新分配内存之前，string对象能包含的最大字符数</span></span><br></pre></td></tr></table></figure>
<h2 id="string的字符串比较"><a href="#string的字符串比较" class="headerlink" title="string的字符串比较"></a>string的字符串比较</h2><p>C ++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。</p>
<p>另一个功能强大的比较函数是成员函数compare()，他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (A的ASCII码是65，a的ASCII码是97)</span></span><br><span class="line">    <span class="comment">// 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">A</span><span class="params">(<span class="string">"aBcd"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">B</span><span class="params">(<span class="string">"Abcd"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">C</span><span class="params">(<span class="string">"123456"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">D</span><span class="params">(<span class="string">"123dfg"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "aBcd" 和 "Abcd"比较------ a &gt; A</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A.compare(B)："</span> &lt;&lt; A.compare(B)&lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// "cd" 和 "Abcd"比较------- c &gt; A</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A.compare(2, 3, B):"</span> &lt;&lt;A.compare(<span class="number">2</span>, <span class="number">3</span>, B)&lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// "cd" 和 "cd"比较 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A.compare(2, 3, B, 2, 3):"</span> &lt;&lt; A.compare(<span class="number">2</span>, <span class="number">3</span>, B, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由结果看出来：0表示下标，3表示长度</span></span><br><span class="line">    <span class="comment">// "123" 和 "123"比较 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C.compare(0, 3, D, 0, 3)"</span> &lt;&lt;C.compare(<span class="number">0</span>, <span class="number">3</span>, D, <span class="number">0</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string的插入与删除"><a href="#string的插入与删除" class="headerlink" title="string的插入与删除"></a>string的插入与删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator p)</span></span>;<span class="comment">//删除字符串中p所指的字符</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;<span class="comment">//删除字符串中迭代器区间[first,last)上所有字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span></span>;<span class="comment">//删除字符串中从索引位置pos开始的len个字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//删除字符串中所有字符</span></span><br></pre></td></tr></table></figure>
<h2 id="string拼接字符串：append-amp-操作符"><a href="#string拼接字符串：append-amp-操作符" class="headerlink" title="string拼接字符串：append() &amp; + 操作符"></a>string拼接字符串：append() &amp; + 操作符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s+=str;<span class="comment">//加个字符串</span></span><br><span class="line">s+=”my name is jiayp”;<span class="comment">//加个C字符串</span></span><br><span class="line">s+=<span class="string">'a'</span>;<span class="comment">//加个字符</span></span><br><span class="line">s.append(str);</span><br><span class="line">s.append(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//不解释了 同前面的函数参数assign的解释</span></span><br><span class="line">s.append(str,<span class="number">2</span>,<span class="built_in">string</span>::npos)<span class="comment">//把字符串str从索引值2开始到结尾拼接到s尾</span></span><br><span class="line">s.append(“my name is jiayp”);</span><br><span class="line">s.append(“nico”,<span class="number">5</span>)<span class="comment">//把'n' ‘I' ‘c' ‘o' ‘/0'拼接到s尾</span></span><br><span class="line">s.append(<span class="number">5</span>,<span class="string">'x'</span>)<span class="comment">//把五个x拼接到s尾</span></span><br><span class="line">s.push_back(‘a');<span class="comment">//这个函数只能增加单个字符</span></span><br></pre></td></tr></table></figure>
<h2 id="string的字符替换"><a href="#string的字符替换" class="headerlink" title="string的字符替换"></a>string的字符替换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//将当前字符串从pos索引开始的n个字符，替换成字符串s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n, <span class="keyword">size_t</span> n1, <span class="keyword">char</span> c)</span></span>; <span class="comment">//将当前字符串从pos索引开始的n个字符，替换成n1个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>;<span class="comment">//将当前字符串[i1,i2)区间中的字符串替换为字符串s</span></span><br></pre></td></tr></table></figure>
<h2 id="string查找：find"><a href="#string查找：find" class="headerlink" title="string查找：find"></a>string查找：find</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符c在当前字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s在当前串中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s中前n个字符在当前串中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s在当前串中的位置</span></span><br><span class="line"><span class="comment">//查找成功时返回所在位置，失败返回string::npos的值</span></span><br></pre></td></tr></table></figure>
<h2 id="string的排序：sort-s-begin-s-end"><a href="#string的排序：sort-s-begin-s-end" class="headerlink" title="string的排序：sort(s.begin(),s.end())"></a>string的排序：sort(s.begin(),s.end())</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"cdefba"</span>;</span><br><span class="line">    sort(s.begin(),s.end());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"s:"</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">// 结果：abcdef</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string类的迭代器处理"><a href="#string类的迭代器处理" class="headerlink" title="string类的迭代器处理"></a>string类的迭代器处理</h2><p>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。</p>
<p>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;                <span class="comment">//返回string的起始位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;                    <span class="comment">//返回string的最后一个字符后面的位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">rbegin</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">rbegin</span><span class="params">()</span></span>;                <span class="comment">//返回string的最后一个字符的位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">rend</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">rend</span><span class="params">()</span></span>;                    <span class="comment">//返回string第一个字符位置的前面</span></span><br><span class="line">rbegin和rend用于从后向前的迭代访问，通过设置迭代器<span class="built_in">string</span>::reverse_iterator,<span class="built_in">string</span>::const_reverse_iterator实现</span><br></pre></td></tr></table></figure>
<h2 id="字符串流处理"><a href="#字符串流处理" class="headerlink" title="字符串流处理"></a>字符串流处理</h2><p>通过定义ostringstream和istringstream变量实现，&lt; sstream&gt;头文件中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">input</span><span class="params">(<span class="string">"hello,this is a test"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(input)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3,s4;</span><br><span class="line">is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;<span class="comment">//s1="hello,this",s2="is",s3="a",s4="test"</span></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line">os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;os.str();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>50.第一次只出现一次的字符</title>
    <url>/2019/11/17/50-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>49.丑数</title>
    <url>/2019/11/17/49-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>法1：</p><p>超时</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;index&gt;<span class="number">0</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j=i;</span><br><span class="line">            <span class="keyword">while</span>(j%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                j/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(j%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                j/=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span>(j%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">                j/=<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)</span><br><span class="line">                index--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>法2：</p>
<p>创建数组保存已经找到的丑数，用空间换时间，不需要在非丑数的整数上计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(index);</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> UglyNumber_2=<span class="number">0</span>,UglyNumber_3=<span class="number">0</span>,UglyNumber_5=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//res[i]=Min(res[UglyNumber_2]*2,res[UglyNumber_3]*3,res[UglyNumber_5]*5);</span></span><br><span class="line">            res[i]=min(min(res[UglyNumber_2]*<span class="number">2</span>,res[UglyNumber_3]*<span class="number">3</span>),min(res[UglyNumber_3]*<span class="number">3</span>,res[UglyNumber_5]*<span class="number">5</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(res[i]==res[UglyNumber_2]*<span class="number">2</span>)</span><br><span class="line">                UglyNumber_2++;</span><br><span class="line">            <span class="keyword">if</span>(res[i]==res[UglyNumber_3]*<span class="number">3</span>)</span><br><span class="line">                UglyNumber_3++;</span><br><span class="line">            <span class="keyword">if</span>(res[i]==res[UglyNumber_5]*<span class="number">5</span>)</span><br><span class="line">                UglyNumber_5++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[index<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    int Min(int number1,int number2,int number3)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        int min=(number1&lt;number2)?number1:number2;</span></span><br><span class="line"><span class="comment">//        min=(min&lt;number3)?min:number3;</span></span><br><span class="line"><span class="comment">//        return min;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（8）——数字转字符串</title>
    <url>/2019/11/17/C-%E5%AD%A6%E4%B9%A0%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="std-stringstream"><a href="#std-stringstream" class="headerlink" title="std::stringstream"></a>std::stringstream</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; <span class="number">1.23</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> aaa = ss.str();</span><br></pre></td></tr></table></figure><h1 id="std-to-string"><a href="#std-to-string" class="headerlink" title="std::to_string"></a>std::to_string</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> aaa = <span class="built_in">std</span>::to_string(<span class="number">1.23</span>);</span><br></pre></td></tr></table></figure><h1 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h1><p>头文件：stdio.h<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [argument]…)</span></span></span><br></pre></td></tr></table></figure></p><a id="more"></a>


<ul>
<li><p>参数：</p>
<p>1.buffer：是char类型的指针，指向写入的字符串指针；<br>2.format：格式化字符串，即在程序中想要的格式；<br>3.argument：可选参数，可以为任意类型的数据；</p>
</li>
<li>函数返回值：buffer指向的字符串的长度</li>
</ul>
<p>eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d"</span>,<span class="number">1.23</span>);</span><br></pre></td></tr></table></figure><br>效率方面：C风格的sprintf因为没有动态内存分配，效率最高。std::to_string其次，最差的是std::stringstream。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（7）——char * ,char ** ,char a[ ] ,char *a[] 的区别</title>
    <url>/2019/11/17/C-%E5%AD%A6%E4%B9%A0%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94char-char-char-a-char-a-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑，因此，刻意再次深入探究了指针和数组这玩意儿，其他类型的数组比较简单，容易混淆的是字符数组和字符指针这两个。</p><h1 id="1-数组的本质"><a href="#1-数组的本质" class="headerlink" title="1.数组的本质"></a>1.数组的本质</h1><p>数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。。</p><a id="more"></a>

<h1 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h1><p>指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址。。由于地址也是整数，在64位平台下，指针默认为8位。(32位平台下，指针默认为4位)</p>
<h1 id="3-指针的指向"><a href="#3-指针的指向" class="headerlink" title="3.指针的指向"></a>3.指针的指向</h1><p>指向的直接意思就是指针变量所保存的其他的地址单元中所存放的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  * p ;<span class="comment">//p 变量保存的地址所在内存单元中的数据类型为整型</span></span><br><span class="line"><span class="keyword">float</span> *q;<span class="comment">// q变量保存的地址所在内存单元中的数据类型为浮点型</span></span><br></pre></td></tr></table></figure>
<p>不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的地址。</p>
<p><strong>字符串赋给一个指针变量</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>  *s ;</span><br><span class="line">s = <span class="string">"China"</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-字符数组"><a href="#4-字符数组" class="headerlink" title="4.字符数组"></a>4.字符数组</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>  str[<span class="number">10</span>]; <span class="comment">//定义了一个有十个元素的数组，元素类型为字符</span></span><br><span class="line"><span class="keyword">char</span>  str[<span class="number">10</span>] = &#123;<span class="string">"hello world"</span>&#125;;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<p>C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了。<br>C语言中字符串常量的本质表示其实是一个地址，规定数组代表数组所在内存位置的首地址，也是 str[0]的地址，即str = &amp;str[0];</p>
<h1 id="5-char-与-char-a"><a href="#5-char-与-char-a" class="headerlink" title="5.char *  与 char  a[ ]"></a>5.char *  与 char  a[ ]</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>  *s;</span><br><span class="line"><span class="keyword">char</span>  a[ ] ;</span><br></pre></td></tr></table></figure>
<p>a代表字符串的首地址，而s 这个指针也保存字符串的地址（其实首地址），即第一个字符的地址，这个地址单元中的数据是一个字符，</p>
<p>可以 s = a;但不能 a = s;</p>
<p>C语言中数组名可以复制给指针表示地址， 但是却不能赋给给数组名，它是一个常量类型，所以不能修改。。</p>
<pre><code>   当然也可以这样:
</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>  a [ ] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *s =a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a) ; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i]);</span><br><span class="line"><span class="comment">//  printf("%c",*s++)</span></span><br></pre></td></tr></table></figure>
<p>字符指针可以用间接操作符$<em>$取其内容，也可以用数组的下标形式 [ ]，数组名也可以用 </em>操作，因为它本身表示一个地址 。。<br>比如 printf(“%c”,*a);  将会打印出 ‘h’</p>
<p><strong>char * 与 char a[ ] 的本质区别：</strong></p>
<blockquote>
<p>当定义 char a[10 ]  时，编译器会给数组分配十个单元，每个单元的数据类型为字符。。<br>定义 char *s 时，  这是个指针变量，只占四个字节，32位，用来保存一个地址。。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">10</span> ；</span><br><span class="line"><span class="keyword">sizeof</span>(s)  = <span class="number">4</span>；<span class="comment">//编译器分配4个字节32位的空间，这个空间中将要保存地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>,s);<span class="comment">//表示 s 的单元中所保存的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>,&amp;s);<span class="comment">//表示变量本身所在内存单元地址</span></span><br></pre></td></tr></table></figure>
<p>一句话来概括，就是 $char <em>s$ 只是一个保存字符串首地址的指针变量， char a[ ] 是许多连续的内存单元，单元中的元素为char ，<br>之所以用 $char </em>$能达到char a  [ ] 的效果，还是字符串的本质，地址，即给你一个字符串地址，便可以随心所欲的操所他。但是，char* 和 char a[ ] 的本质属性是不一样的。。</p>
<p>​    </p>
<h1 id="6-char-与char-a"><a href="#6-char-与char-a" class="headerlink" title="6.char *  与char   a[ ] ;"></a>6.char <em>*  与char  </em> a[ ] ;</h1><ul>
<li>char  *a [ ]</li>
</ul>
<p>由于[ ] 的优先级高于<em> 所以a先和 [ ]结合，他还是一个数组，数组中的元素才是char </em> ，前面讲到char * 是一个变量，保存的地址。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *a[ ] = &#123;<span class="string">"China"</span>,<span class="string">"French"</span>,<span class="string">"America"</span>,<span class="string">"German"</span>&#125;；</span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">32</span>；</span><br></pre></td></tr></table></figure>
<p>字符串常量的本质是地址，a 数组中的元素为char * 指针，指针变量占四个字节，那么四个元素就是32个字节了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *a [ ] = &#123;<span class="string">"China"</span>,<span class="string">"French"</span>,<span class="string">"America"</span>,<span class="string">"German"</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p %p %p %p\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191117152702126.png#pic_center"><br>可以看到数组中的四个元素保存了四个内存地址，这四个地址中就代表了四个字符串的首地址，而不是字符串本身。四个地址不是连续的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a [ ] = &#123;<span class="string">"China"</span>,<span class="string">"French"</span>,<span class="string">"America"</span>,<span class="string">"German"</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p %p %p %p\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]); <span class="comment">//数组元素中保存的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p %p %p %p\n"</span>,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>],&amp;a[<span class="number">3</span>]);<span class="comment">//数组元素单元本身的地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191117153403458.png#pic_center"><br>0x7fff2258ff70 0x7fff2258ff78 0x7fff2258ff80 0x7fff2258ff88，这四个是元素单元所在的地址，每个地址相差8个字节，这是由于每个元素是一个指针变量占8个字节</p>
<ul>
<li>char s**</li>
</ul>
<blockquote>
<p>二级指针保存的是一级指针的地址，它的类型是指针变量，而一级指针保存的是指向数据所在的内存单元的地址，虽然都是地址，但是类型是不一样的</p>
</blockquote>
<p>在 char<em>* s 中，s 是一个指针，这个指针（s）指向一块内存地址，该内存地址中存储的是 char</em> 类型的数据。指针的加减运算在这里的体现为：a + 1 表示地址加8字节（在32位系统中，地址加4字节）。</p>
<p>char<em> 也是一个指针，用 </em>s 表示，这个指针（<em>s）指向一块内存地址，该内存地址中存储的是 char 类型的数据。指针的加减运算在这里的体现为：(</em>a) + 1 表示地址加1字节。</p>
<blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/liitdar/article/details/80972088" target="_blank" rel="noopener">char<em>* a 和 char</em> a[] 介绍</a><br><a href="http://www.imooc.com/article/30475" target="_blank" rel="noopener">http://www.imooc.com/article/30475</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（6）——new和malloc的区别</title>
    <url>/2019/11/17/C-%E5%AD%A6%E4%B9%A0%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="new、malloc区分"><a href="#new、malloc区分" class="headerlink" title="new、malloc区分"></a>new、malloc区分</h1><ul>
<li><p>属性</p>
<p> new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。</p>
</li>
<li><p>参数</p>
<p> 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
</li>
<li><p>返回类型</p>
<p> new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void <em> ，需要通过强制类型转换将void</em>指针转换成我们需要的类型。</p>
</li>
<li><p>自定义类型</p>
<p> new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。<br>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
</li>
<li><p>重载</p>
<p> C++允许重载new/delete操作符，malloc不允许重载。</p>
</li>
<li><p>内存区域</p>
<p>  new做两件事：分配内存和调用类的构造函数，delete是：调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。</p>
<p>  new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p>
<blockquote>
<p>堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，用完了要还给操作系统，要不然就是内存泄漏。<br>栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p>
</blockquote>
</li>
<li><p>分配失败</p>
<p>  new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
</li>
<li><p>内存泄漏</p>
<p>  内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。</p>
</li>
</ul><a id="more"></a>
<h1 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a>malloc和free</h1><ul>
<li><strong>malloc:</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure>
<p>malloc 向系统申请分配指定size个字节的内存空间，返回类型是 void<em> 类型。void</em> 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。如果开辟失败，则返回NULL指针。</p>
<ul>
<li><strong>free</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>free函数是来释放动态开辟的内存的。malloc和free要配套使用，如果没有free则会造成内存泄漏。</p>
<h1 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h1><ul>
<li>规则<blockquote>
<p>1.new/delete是关键字，效率高于malloc和free。<br>2.配对使用，避免内存泄漏和多重释放。<br>3.避免交叉使用，比如malloc申请空间delete释放，new出的空间被free。<br>4.new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理</p>
</blockquote>
</li>
</ul>
<ul>
<li>new/new[] 用法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开辟单地址空间</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//开辟大小为sizeof(int)空间</span></span><br><span class="line"><span class="keyword">int</span> *q = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>); <span class="comment">//开辟大小为sizeof(int)的空间，并初始化为5。</span></span><br><span class="line"><span class="comment">//开辟数组空间</span></span><br><span class="line"><span class="comment">//一维</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]&#123;<span class="number">0</span>&#125;;<span class="comment">//开辟大小为100的整型数组空间，并初始化为0。</span></span><br><span class="line"><span class="comment">//二维</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"><span class="comment">//三维</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">5</span>][<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"><span class="comment">//四维及以上以此类推。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delete/delete[] 用法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放单个int空间</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="comment">//释放int数组空间</span></span><br><span class="line"><span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> []b;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>45.把数组排成最小的数</title>
    <url>/2019/11/17/45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>把数字转换成字符串</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><a id="more"></a>


<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><p>把数字转换成字符串</p>
<h1 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h1><h2 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h2><p><strong>sort()函数</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(begin, end, cmp)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数<br>第一个是要排序的数组的起始地址。<br>第二个是结束的地址（最后一位要排序的地址）<br>第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            res += to_string(numbers[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A = to_string(a)+to_string(b);</span><br><span class="line">        <span class="built_in">string</span> B = to_string(b)+to_string(a);</span><br><span class="line">        <span class="keyword">return</span> A&lt;B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h2><p>c写的<br><strong>sprintf()函数</strong></p>
<ul>
<li><p>头文件：stdio.h</p>
</li>
<li><p>函数功能：格式化字符串，将格式化的数据写入字符串中。</p>
</li>
<li>函数原型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [argument]…)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>参数：</p>
<p>1.buffer：是char类型的指针，指向写入的字符串指针；<br>2.format：格式化字符串，即在程序中想要的格式；<br>3.argument：可选参数，可以为任意类型的数据；</p>
</li>
<li>函数返回值：buffer指向的字符串的长度</li>
<li><p>用处：<br>1.格式化数字字符串：在这点上sprintf和printf的用法一样，只是打印到的位置不同而已，前者打印给buffer字符串，后者打印给标准输出，所以sprintf也可以用来将整型转化为字符串，比itoa效率高且如此地简便~比如：sprintf(buffer, “%d”, 123456);执行后buffer即指向字符串“123456”~</p>
<p>2.连接字符</p>
</li>
</ul>
<p><strong>qsort()函数</strong><br>qsort函数(全称quicksort)，它是ANSIC标准中提供的，其声明在stdlib.h文件中，是根据二分法写的，其时间复杂度为$nlog(n)$<br>qsort要求提供一个自己定义的比较函数。比较函数使得qsort通用性更好，有了比较函数qsort可以实现对数组、字符串、结构体等结构进行升序或降序排序。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nitems, <span class="keyword">size_t</span> size, <span class="keyword">int</span> (*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span>*))</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>参数</p>
<p>  base — 指向要排序的数组的第一个元素的指针。<br>  nitems — 由 base 指向的数组中元素的个数。<br>  size — 数组中每个元素的大小，以字节为单位。<br>  compar — 用来比较两个元素的函数。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNumber1, <span class="keyword">const</span> <span class="keyword">void</span>* strNumber2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int型整数用十进制表示最多只有10位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_MaxNumberLength = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span>* g_StrCombine1 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* g_StrCombine2 = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span>** strNumbers = (<span class="keyword">char</span>**)(<span class="keyword">new</span> <span class="keyword">int</span>[length]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        strNumbers[i] = <span class="keyword">new</span> <span class="keyword">char</span>[g_MaxNumberLength + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(strNumbers[i], <span class="string">"%d"</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    qsort(strNumbers, length, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*), compare);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strNumbers[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] strNumbers[i];</span><br><span class="line">    <span class="keyword">delete</span>[] strNumbers;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &gt; [strNumber2][strNumber1], 返回值大于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0</span></span><br><span class="line"><span class="comment">// 如果[strNumber1][strNumber2] &lt; [strNumber2][strNumber1], 返回值小于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNumber1, <span class="keyword">const</span> <span class="keyword">void</span>* strNumber2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [strNumber1][strNumber2]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine1, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// [strNumber2][strNumber1]</span></span><br><span class="line">    <span class="built_in">strcpy</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber2);</span><br><span class="line">    <span class="built_in">strcat</span>(g_StrCombine2, *(<span class="keyword">const</span> <span class="keyword">char</span>**)strNumber1);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(g_StrCombine1, g_StrCombine2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>43.1~n整数中1出现的次数</title>
    <url>/2019/11/16/43-1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><a id="more"></a>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>法1：</p>
<p>时间复杂度：$O(nlog n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            i=j;</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i/=<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">                    count+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>42.连续子数组的最大和</title>
    <url>/2019/11/16/42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><a id="more"></a>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>法1：</strong></p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> thisSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&gt;maxSum)</span><br><span class="line">                maxSum=<span class="built_in">array</span>[i];<span class="comment">//考虑都为负数</span></span><br><span class="line">                </span><br><span class="line">            thisSum+=<span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(thisSum&gt;maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum=thisSum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(thisSum&lt;<span class="number">0</span>)</span><br><span class="line">                thisSum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>法2：</strong></p>
<p><strong>动态规划</strong></p>
<ul>
<li><p>1：令状态 dp[i] 表示以 A[i] 作为末尾的连续序列的最大和（这里是说 A[i] 必须作为连续序列的末尾）。</p>
</li>
<li><p>2：做如下考虑：因为 dp[i] 要求是必须以 A[i] 结尾的连续序列，那么只有两种情况：</p>
<blockquote>
<p>这个最大和的连续序列只有一个元素，即以 A[i] 开始，以 A[i] 结尾，最大和就是 A[i] 本身。</p>
<p>这个最大和的连续序列有多个元素，即从前面某处 A[p] 开始 (p&lt;i)，一直到 A[i] 结尾，最大和是 dp[i-1]+A[i]。<br>得到<strong>状态转移方程</strong>：</p>
</blockquote>
</li>
</ul>
<p>　　　　　　　　<script type="math/tex">dp[i] = max(A[i], dp[i-1]+A[i])</script></p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">int</span> maxSum;</span><br><span class="line">        dp.push_back(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i])&gt;<span class="built_in">array</span>[i])</span><br><span class="line">                dp.push_back(dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        maxSum=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;maxSum)</span><br><span class="line">                maxSum=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法c++(vector)实现</title>
    <url>/2019/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95c-vector-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115190306423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115190315308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>依次比较相邻两元素，若前一元素大于后一元素则交换之，直至最后一个元素即为最大；然后重新从首元素开始重复同样的操作，直至倒数第二个元素即为次大元素；依次类推。如同水中的气泡，依次将最大或最小元素气泡浮出水面。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若flag为true说明有过数据交换，否则停止循环</span></span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size() &amp;&amp; flag;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v.size()<span class="number">-2</span>;j&gt;=i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j]&gt;v[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(v[j],v[j+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115111755847.png#pic_center"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想：任取一个数据元素作为基准，做一次划分，讲所有数据元素集合分成3部分；中间部分值包含一个基准元素，它的前面包含所有关键字小于基准的数据元素，它的后面包含所有关键字大于基础的数据元素，然后分别对前后两部分进行划分。</p>
<p>对数据元素$v_1~v_n$做一趟划分，不失一般性，选择第一个元素作为基准元素，用t代表基准。设i=1，j=n,划分过程如下：</p>
<ul>
<li>1.比较基准元素与第j个元素$a_j$，如果$a_j$&gt;t，则j-  -；继续步骤1；如果$a_j&lt;t$，则将$a_j$移到i的位置，i=i+1转步骤2。</li>
<li>2.比较基准元素与第i个元素$a_i$，如果$a_j$<t，则i++；继续步骤2；如果$a_i>t$，则将$a_i$移到j的位置，j=j+1转步骤3。</t，则i++；继续步骤2；如果$a_i></li>
<li>3.重复步骤1和2，直到i=j，将基准元素放到i的位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    pivot=v[low];<span class="comment">//用子表的第一个记录作枢轴记录</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; v[high]&gt;=pivot)</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            v[low]=v[high];</span><br><span class="line">            low++;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; v[low]&lt;=pivot)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">            &#123;</span><br><span class="line">                v[high]=v[low];</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    v[low]=pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        i=Partition(v,low,high);</span><br><span class="line">        quickSort(v,low,i<span class="number">-1</span>);</span><br><span class="line">        quickSort(v,i+<span class="number">1</span>,high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=v.size();</span><br><span class="line"></span><br><span class="line">    quickSort(v,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    pivot=v[low];<span class="comment">//用子表的第一个记录作枢轴记录</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; v[high]&gt;=pivot)</span><br><span class="line">            high--;</span><br><span class="line">        swap(v[low],v[high]);<span class="comment">//high指示的值小于pivot，交换</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; v[low]&lt;=pivot)</span><br><span class="line">            low++;</span><br><span class="line">        swap(v[low],v[high]);<span class="comment">//low指示的值大于pivot，交换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        i=Partition(v,low,high);</span><br><span class="line">        quickSort(v,low,i<span class="number">-1</span>);</span><br><span class="line">        quickSort(v,i+<span class="number">1</span>,high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=v.size();</span><br><span class="line"></span><br><span class="line">    quickSort(v,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115183209723.png#pic_center"></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min_index=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;v.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[min_index]&gt;v[j])<span class="comment">//如果有小于当前最小值的关键字</span></span><br><span class="line">                min_index=j;<span class="comment">//将此关键字的下标赋值给min_index</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_index!=i)</span><br><span class="line">            swap(v[min_index],v[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    SelectSort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115112308379.png#pic_center"></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap, <span class="keyword">int</span> size, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u, left = u * <span class="number">2</span>, right = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= size &amp;&amp; heap[left] &gt; heap[t])</span><br><span class="line">        t = left;</span><br><span class="line">    <span class="keyword">if</span>(right &lt;= size &amp;&amp; heap[right] &gt; heap[t])</span><br><span class="line">        t = right;</span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        swap(heap[u], heap[t]);</span><br><span class="line">        push_down(heap, size, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; heap[u / <span class="number">2</span>] &lt; heap[u])&#123;</span><br><span class="line">        swap(heap[u / <span class="number">2</span>], heap[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        push_up(q, i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        swap(q[<span class="number">1</span>], q[size]);</span><br><span class="line">        size--;</span><br><span class="line">        push_down(q, size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=v.size();</span><br><span class="line">    heapSort(v, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115185543385.png#pic_center"></p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>数列前面部分看为有序，依次将后面的无序数列元素插入到前面的有序数列中，初始状态有序数列仅有一个元素，即首元素。在将无序数列元素插入有序数列的过程中，采用了逆序遍历有序数列，相较于顺序遍历会稍显繁琐，但当数列本身已近排序状态效率会更高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;v.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=v[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;v[j];j--)</span><br><span class="line">            v[j+<span class="number">1</span>]=v[j];<span class="comment">//后移一位</span></span><br><span class="line"></span><br><span class="line">        v[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">    InsertSort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019111515241373.png"></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序的基本思想如下:选定一个增量$h_1 (h_1&lt;n)$，把序列中的数据元素从第1个开始分组，所有相距$h_1$的数据元素分为一组，一共有$h_1$组， 并在各组内采用直接插入提序，使各组内的数据元素排好序，然后选第个增量$h_2(h_2&lt;h_1)$，以$h_2$为距离对数据元素进行分组及排序；重复该分组及排序过程，知道增量为1。<br>希尔排序的性能取决于增量序列的选择。希尔提出取$h_2=n/2,h_{i-1}=[\frac{h_i}{2}]$。Knuth提出取$h_2=n/2,h_{i-1}=[\frac{h_i}{3}]$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> increment=v.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(increment)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=increment;i&lt;v.size();i+=<span class="number">1</span>)<span class="comment">//对各子表做直接插入排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=v[i], j;</span><br><span class="line">            <span class="keyword">for</span>(j=i-increment;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;v[j];j-=increment)</span><br><span class="line">            &#123;</span><br><span class="line">                v[j+increment]=v[j];</span><br><span class="line">            &#125;</span><br><span class="line">            v[j+increment]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        increment/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ShellSort(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019111518311827.png#pic_center"></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(q, l, mid);</span><br><span class="line">    mergeSort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w;</span><br><span class="line">    w.clear();</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &gt; q[j])</span><br><span class="line">            w.push_back(q[j++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w.push_back(q[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        w.push_back(q[i++]);</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= mid)</span><br><span class="line">        w.push_back(q[j++]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : w)</span><br><span class="line">        q[l++] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=v.size();</span><br><span class="line">    mergeSort(v, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115190126906.png#pic_center"></p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;q, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            cnt[j].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cnt[get(q[j], i)].push_back(q[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : cnt[j])</span><br><span class="line">                q[k++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">35</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=v.size();</span><br><span class="line">    radixSort(v, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191115185843674.png#pic_center"></p>
]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>40.最小的K个数</title>
    <url>/2019/11/15/40-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>法1：</p><p>时间复杂度：O(n^2)</p>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习(6)——哈希表(unordered_map)</title>
    <url>/2019/11/14/C-%E5%AD%A6%E4%B9%A0-6-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8-unordered-map/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>38.字符串的排列</title>
    <url>/2019/11/12/38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、求得所有可能出现在第一个位置上的字符，将第一个位子上的字符与后面的交换</p><p>2、固定第一个字符，求后面字符的排列，就涉及递归的问题了</p><a id="more"></a>


<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        Permutations(result,str,<span class="number">0</span>,len);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Permutations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result,<span class="built_in">string</span> str,<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==len)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(str);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=index &amp;&amp; str[i]==str[index])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                swap(str[i],str[index]);</span><br><span class="line">                Permutations(result,str,index+<span class="number">1</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>39-数组中出现次数超过一半的数字</title>
    <url>/2019/11/12/39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul>
<li>法1</li>
</ul><p>时间复杂度：$O(n^2)$</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int <span class="built_in">length</span>=numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="built_in">length</span><span class="number">-2</span>;<span class="built_in">j</span>&gt;=<span class="built_in">i</span>;<span class="built_in">j</span>--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[<span class="built_in">j</span>]&gt;numbers[<span class="built_in">j</span>+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    int temp=numbers[<span class="built_in">j</span>+<span class="number">1</span>];</span><br><span class="line">                    numbers[<span class="built_in">j</span>+<span class="number">1</span>]=numbers[<span class="built_in">j</span>];</span><br><span class="line">                    numbers[<span class="built_in">j</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int times=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[<span class="built_in">i</span>]==numbers[<span class="built_in">length</span>/<span class="number">2</span>])</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&gt;<span class="built_in">length</span>)</span><br><span class="line">            <span class="keyword">return</span>  numbers[<span class="built_in">length</span>/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>



<ul>
<li>法2</li>
</ul>
<p>时间复杂度：$O(nlogn)$</p>
<ul>
<li>法3</li>
</ul>
<p>时间复杂度：$O(n)$</p>
<p>遍历数组时保存连个值，一个是数组中的数字，一个是出现的次数，遍历到一个数字时，如果该数字和之前保存的数字相同，则次数加一，如果该数字和之前保存的数字不同，则次数减一，如果次数为零，遍历下一个数组元素，并把次数设为一。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> length=numbers.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(times==<span class="number">0</span>)<span class="comment">//该数字已经被自减到0 肯定不是所找的数，换下一个数组元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                result=numbers[i];</span><br><span class="line">                times=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i]==result)</span><br><span class="line">                times++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                times--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// verify whether the input is valid</span></span><br><span class="line">        times=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[j]==result)</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&gt;length)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（5）——多线程</title>
    <url>/2019/11/10/C-%E5%AD%A6%E4%B9%A0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h1><p>mutex是多线程编程时经常用到的，在C++11中需要包含<mutex>模块。而在该文件中还有其他和mutex协作的类和函数，使得多线程编程时非常方便。</mutex></p><h2 id="mutex类"><a href="#mutex类" class="headerlink" title="mutex类"></a>mutex类</h2><p>mutex对象是一个lockable的对象，当关键区域需要被互斥访问的时候被用来当作信号。mutex对象提供互斥的拥有权限，并且不支持递归。</p><p>实际就是mutex是用来进行线程同步的。常用的成员函数有lock()和unlock()</p><a id="more"></a>


<p><strong>lcok()</strong></p>
<p>调用该函数后，调用函数会锁定mutex，在有些情况下调用函数会阻塞。<br>1、如果mutex当前没有被任何其他线程locked，则调用线程lock这个mutex对象（从此刻到直到其成员函数unlock被调用，当前线程拥有mutex对象）。<br>2、如果mutex目前被其他线程locked，则当前线程阻塞直到mutex被其他线程unlock。<br>3、如果mutex目前被当前线程lock，则会产生死锁错误。大部分情况会崩溃，因为mutex不支持递归。</p>
<p><strong>unlock()</strong></p>
<p>unlock mutex对象，释放mutex对象的所有权。通常和lock成对使用。<br>调用该函数后，如果有其他线程因为lock同一个mutex对象而阻塞，则他们中的一个会获得mutex的所有权，从而继续执行。</p>
<p>不使用mutex同步的情况下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread1 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread2 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">	t1.detach();</span><br><span class="line">	t2.detach();</span><br><span class="line"></span><br><span class="line">	this_thread::sleep_for(chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cout是标准输出的接口，所以两个线程同时输出的时候会对cout进行抢占，而两个线程并没有对cout进行同步，所以可能会出现输出错乱的情况。输出结果如下：</strong></p>
<p><img alt="1573373150246" data-src="/home/xiaohu/.config/Typora/typora-user-images/1573373150246.png"></p>
<p>使用mutex对cout进行互斥访问，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread1 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"The thread2 is running !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(fn1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(fn2)</span></span>;</span><br><span class="line">    t1.detach();</span><br><span class="line">    t2.detach();</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出比较工整了，因为我们对cout作了访问保护，当一个线程输出的时候，另一个线程是不能输出的，只有当一个线程输出完毕了，另一个线程才能输出。而这一切是通过mutex来实现的。</p>
<p><img alt="1573373275431" data-src="/home/xiaohu/.config/Typora/typora-user-images/1573373275431.png"></p>
<p><a href="https://blog.csdn.net/coolwriter/article/details/79883253" target="_blank" rel="noopener">C++多线程（一）thread类</a></p>
<p><a href="https://blog.csdn.net/coolwriter/article/details/79884298" target="_blank" rel="noopener">c++ 多线线程（二）-mutex</a></p>
<p><a href="https://www.cnblogs.com/haippy/p/3284540.html" target="_blank" rel="noopener">C++11 并发指南系列</a></p>
<p><a href="https://www.cnblogs.com/haippy/p/3236136.html" target="_blank" rel="noopener">C++11 并发指南二(std::thread 详解)</a></p>
<p><a href="https://www.cnblogs.com/haippy/p/3237213.html" target="_blank" rel="noopener">C++11 并发指南三(std::mutex 详解)</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>36.二叉搜索树与双向链表</title>
    <url>/2019/11/09/36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、将左子树构成双链表，并返回该链表的头节点(左子树最左边的节点)</p><p>2、定位到左链表的最后一个节点(左子树最右边的节点)</p><p>3、如果左子树链表不为空，则将当前root追加到左子树链表后</p><a id="more"></a>



<p>4、将右子树构造成双向链表，并返回链表头结点(右子树最左边的节点)</p>
<p>5、如果右子树链表不为空，将右子树链表追加到当前root后</p>
<p>6、根据左子树链表是否为空返回的整体双向链表的头节点</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>待写！！！</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>35.复杂链表的复制</title>
    <url>/2019/11/09/35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>分为三步走：</p><ol>
<li><p>给原来的链表的每个结点复制一个新节点并且插入到对应的后面 </p>
</li>
<li><p>利用老节点将新节点的random指针域置好</p>
</li>
<li><p>将链表还原,即拆成完整的两个链表</p>
</li>
</ol><a id="more"></a>


<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一步：复制链表结点</span></span><br><span class="line">        RandomListNode* oldnode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(oldnode)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* newnode = <span class="keyword">new</span> RandomListNode(oldnode-&gt;label);<span class="comment">//用老节点的值申请一个新节点</span></span><br><span class="line">            newnode-&gt;next=oldnode-&gt;next;<span class="comment">//将新节点的next链上老节点的next</span></span><br><span class="line">            oldnode-&gt;next=newnode;<span class="comment">//将新节点插在老节点后面</span></span><br><span class="line">            oldnode=oldnode-&gt;next-&gt;next;<span class="comment">//由于已经插入了新节点，因此遍历下一个老节点得走2个next</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二步：置信结点的random指针</span></span><br><span class="line">        oldnode=pHead;<span class="comment">//oldnode指向链表的开始</span></span><br><span class="line">        <span class="keyword">while</span>(oldnode)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* newnode=oldnode-&gt;next;<span class="comment">//由于上面的复制，新节点紧跟在与其对应的老节点后面</span></span><br><span class="line">            <span class="keyword">if</span>(oldnode-&gt;random!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//oldnode-&gt;random是老节点的random域，再指向next就是该老节点对应的新节点应该指向的对应的random域</span></span><br><span class="line">                newnode-&gt;random=oldnode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            oldnode=oldnode-&gt;next-&gt;next;<span class="comment">//只走老节点(为其对应的新节点链上对应的randoum域)</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拆分新/老链表</span></span><br><span class="line">        oldnode=pHead;<span class="comment">//让oldnode指向链表开始</span></span><br><span class="line">        RandomListNode* newHead=oldnode-&gt;next;<span class="comment">//新链表的头是老链表头的下一个(之前复制了的)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(oldnode)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* newnode=oldnode-&gt;next;<span class="comment">//保证newnode一直紧跟咋oldnode后面(老、新节点相对位置)</span></span><br><span class="line">            oldnode-&gt;next=newnode-&gt;next;<span class="comment">//恢复老节点的next指向</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(oldnode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newnode-&gt;next=oldnode-&gt;next-&gt;next;<span class="comment">//恢复新节点的next指向</span></span><br><span class="line">            &#125;</span><br><span class="line">            oldnode=oldnode-&gt;next;<span class="comment">//由于oldnode的next域上面已经恢复了，因此下一个老节点就是oldnode-&gt;next</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>34.二叉树中和为某一路径</title>
    <url>/2019/11/08/34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h1 id><a href="#" class="headerlink" title=" "></a> </h1><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        </span><br><span class="line">        q.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">//如果是叶结点，并且路径上结点的和等于输入的值</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span> &amp;&amp; root-&gt;val==expectNumber)</span><br><span class="line">            p.push_back(q);</span><br><span class="line">        <span class="comment">//如果不是叶结点，则遍历它的子结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;expectNumber &amp;&amp; root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val!=<span class="literal">NULL</span> &amp;&amp; root-&gt;val&lt;expectNumber)</span><br><span class="line">            FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        <span class="comment">//在路径上删除当前结点</span></span><br><span class="line">        q.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>33.二叉树的后序遍历序列</title>
    <url>/2019/11/08/33-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>定义：二叉排序树 ( Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。.</li>
</ul><blockquote>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值 </li>
<li>若它的右子树不空 ，则右子树上所有结点的值均大于宫的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
</blockquote><a id="more"></a>


<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _VerifySquenceOfBST(sequence,<span class="number">0</span>,sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> _VerifySquenceOfBST(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root=s[end];</span><br><span class="line">        <span class="keyword">int</span> i=start;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(s[i]&lt;root)</span><br><span class="line">            i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]&lt;root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _VerifySquenceOfBST(s,start,i<span class="number">-1</span>) &amp;&amp; _VerifySquenceOfBST(s,i,end<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（4）——栈stack</title>
    <url>/2019/11/08/C-%E5%AD%A6%E4%B9%A0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88stack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>1、栈(Stack)是一种线性存储结构，它具有如下特点：</li>
</ul><p>（1）栈中的数据元素遵守“先进后出”(First In Last Out)的原则，简称FILO结构。</p><p>（2）限定只能在栈顶进行插入和删除操作。</p><ul>
<li>2、栈的相关概念：</li>
</ul><p>（1）栈顶与栈底：允许元素插入与删除的一端称为栈顶，另一端称为栈底。</p><p>（2）压栈：栈的插入操作，叫做进栈，也称压栈、入栈。</p><a id="more"></a>





<p>（3）弹栈：栈的删除操作，也叫做出栈。</p>
<ul>
<li>3、栈的常用操作为：</li>
</ul>
<p>（1）弹栈，通常命名为pop</p>
<p>（2）压栈，通常命名为push</p>
<p>（3）求栈的大小</p>
<p>（4）判断栈是否为空</p>
<p>（5）获取栈顶元素的值</p>
<ul>
<li>4、栈的常见分类：</li>
</ul>
<p>（1）基于数组的栈——以数组为底层数据结构时，通常以数组头为栈底，数组头到数组尾为栈顶的生长方向</p>
<p>（2）基于单链表的栈——以链表为底层的数据结构时，以链表头为栈顶，便于节点的插入与删除，压栈产生的新节点将一直出现在链表的头部</p>
<ul>
<li><p>5、实例分析</p>
<p> 使用标准库的栈时, 应包含相关头文件，在栈中应包含头文件： #include&lt; stack &gt; 。定义：stack&lt; int &gt; s;</p>
</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">s.empty<span class="comment">()</span>;         <span class="comment">//如果栈为空则返回true, 否则返回false;</span></span><br><span class="line">s.size<span class="comment">()</span>;          <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">s.top<span class="comment">()</span>;           <span class="comment">//返回栈顶元素, 但不删除该元素</span></span><br><span class="line">s.pop<span class="comment">()</span>;           <span class="comment">//弹出栈顶元素, 但不返回其值</span></span><br><span class="line">s.push<span class="comment">()</span>;          <span class="comment">//将元素压入栈顶</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/QG-whz/p/5170418.html" target="_blank" rel="noopener">数据结构图文解析之：栈的简介及C++模板实现</a></p>
<p><a href="https://blog.csdn.net/zichen_ziqi/article/details/80807989" target="_blank" rel="noopener">C++数据结构——栈</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（3）——set(集合容器）</title>
    <url>/2019/11/08/C-%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94set-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="set集合容器："><a href="#set集合容器：" class="headerlink" title="set集合容器："></a>set集合容器：</h1><p>实现了红黑树（Red-Black Tree）的平衡二叉检索树的数据结构，在插入元素时，它会自动调整二叉树的排列，把该元素放到适当的位置，以确保每个子树根节点的键值大于左子树所有节点的键值，而小于右子树所有节点的键值；另外，还得确保根节点的左子树的高度与有字数的高度相等，<br>这样，二叉树的高度最小，从而检索速度最快。要注意的是，它不会重复插入相同键值的元素，而采取忽略处理。</p><a id="more"></a>
<p>平衡二叉检索树的检索使用中序遍历算法，检索效率高于vector、deque、和list的容器。另外，采用中序遍历算法可将键值由小到大遍历出来，所以，可以理解为平衡二叉检索树在插入元素时，就会自动将元素按键值从小到大的顺序排列。</p>
<p>构造set集合的主要目的是为了快速检索，使用set前，需要在程序头文件中包含声明“#include&lt; set&gt;”。</p>
<h1 id="c-stl集合-Set-："><a href="#c-stl集合-Set-：" class="headerlink" title="c++ stl集合(Set)："></a>c++ stl集合(Set)：</h1><p>是一种包含已排序对象的关联容器。set/multiset会根据待定的排序准则，自动将元素排序。两者不同在于前者不允许元素重复，而后者允许。</p>
<ul>
<li><p>不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素</p>
</li>
<li><p>不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取，而且从迭代器角度来看，元素值是常数</p>
</li>
<li>元素比较动作只能用于型别相同的容器(即元素和排序准则必须相同)<h1 id="set的各成员函数列表如下"><a href="#set的各成员函数列表如下" class="headerlink" title="set的各成员函数列表如下:"></a>set的各成员函数列表如下:</h1></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">begin</span><span class="params">()</span></span>--返回指向第一个元素的迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">clear</span><span class="params">()</span></span>--清除所有元素</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">()</span></span>--返回某个值元素的个数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">empty</span><span class="params">()</span></span>--如果集合为空，返回true</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">end</span><span class="params">()</span></span>--返回指向最后一个元素的迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">()</span></span>--返回集合中与给定值相等的上下限的两个迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span></span>--删除集合中的元素</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span></span>--返回一个指向被查找到元素的迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_allocator</span><span class="params">()</span></span>--返回集合的分配器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span></span>--在集合中插入元素</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span></span>--返回指向大于（或等于）某值的第一个元素的迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">key_comp</span><span class="params">()</span></span>--返回一个用于元素间值比较的函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">max_size</span><span class="params">()</span></span>--返回集合能容纳的元素的最大限值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rbegin</span><span class="params">()</span></span>--返回指向集合中最后一个元素的反向迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rend</span><span class="params">()</span></span>--返回指向集合中第一个元素的反向迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span></span>--集合中元素的数目</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">swap</span><span class="params">()</span></span>--交换两个集合变量</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">upper_bound</span><span class="params">()</span></span>--返回大于某个值元素的迭代器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">value_comp</span><span class="params">()</span></span>--返回一个用于比较元素间的值的函数</span><br></pre></td></tr></table></figure>
<ol>
<li>创建set集合对象<br>创建set对象时，需要指定元素的类型，这一点和其他容器一样。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>元素的插入与中序遍历</p>
<p>采用inset()方法把元素插入到集合中，插入规则在默认的比较规则下，是按元素值从小到大插入，如果自己指定了比较规则函数，则按自定义比较规则函数插入。<br>使用前向迭代器对集合中序遍历，结果正好是元素排序后的结果。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第一次插入5，可以插入  </span></span><br><span class="line">    s.insert(<span class="number">1</span>);  </span><br><span class="line">    s.insert(<span class="number">6</span>);  </span><br><span class="line">    s.insert(<span class="number">3</span>);  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第二次插入5，重复元素，不会插入  </span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it; <span class="comment">//定义前向迭代器  </span></span><br><span class="line">    <span class="comment">//中序遍历集合中的所有元素  </span></span><br><span class="line">    <span class="keyword">for</span>(it = s.begin(); it != s.end(); it++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//运行结果：1 3 5 6</span></span><br></pre></td></tr></table></figure>
<ol>
<li>元素的方向遍历<br>使用反向迭代器reverse_iterator可以反向遍历集合，输出的结果正好是集合元素的反向排序结果。<br>它需要用到rbegin()和rend()两个方法，它们分别给出了反向遍历的开始位置和结束位置。 </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第一次插入5，可以插入  </span></span><br><span class="line">    s.insert(<span class="number">1</span>);  </span><br><span class="line">    s.insert(<span class="number">6</span>);  </span><br><span class="line">    s.insert(<span class="number">3</span>);  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第二次插入5，重复元素，不会插入  </span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit; <span class="comment">//定义反向迭代器  </span></span><br><span class="line">    <span class="comment">//反向遍历集合中的所有元素  </span></span><br><span class="line">    <span class="keyword">for</span>(rit = s.rbegin(); rit != s.rend(); rit++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//运行结果：6 5 3 1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>元素的删除<br> 与插入元素的处理一样，集合具有高效的删除处理功能，并自动重新调整内部的红黑树的平衡。<br>删除的对象可以是某个迭代器位置上的元素、等于某键值的元素、一个区间上的元素和清空集合。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第一次插入5，可以插入  </span></span><br><span class="line">    s.insert(<span class="number">1</span>);  </span><br><span class="line">    s.insert(<span class="number">6</span>);  </span><br><span class="line">    s.insert(<span class="number">3</span>);  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第二次插入5，重复元素，不会插入  </span></span><br><span class="line">    s.erase(<span class="number">6</span>); <span class="comment">//删除键值为6的元素  </span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit; <span class="comment">//定义反向迭代器  </span></span><br><span class="line">    <span class="comment">//反向遍历集合中的所有元素  </span></span><br><span class="line">    <span class="keyword">for</span>(rit = s.rbegin(); rit != s.rend(); rit++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  </span><br><span class="line">  </span><br><span class="line">    it = s.begin();  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)  </span><br><span class="line">        it = s.erase(it);   </span><br><span class="line">    <span class="keyword">for</span>(it = s.begin(); it != s.end(); it++)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    s.clear();  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">运行结果： </span></span><br><span class="line"><span class="comment">5 3 1 </span></span><br><span class="line"><span class="comment">5 </span></span><br><span class="line"><span class="comment">0     </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>元素的检索</p>
<p>使用find()方法对集合进行检索，如果找到查找的的键值，则返回该键值的迭代器位置；否则，返回集合最后一个元素后面的一个位置，即end()。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第一次插入5，可以插入  </span></span><br><span class="line">    s.insert(<span class="number">1</span>);  </span><br><span class="line">    s.insert(<span class="number">6</span>);  </span><br><span class="line">    s.insert(<span class="number">3</span>);  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第二次插入5，重复元素，不会插入  </span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  </span><br><span class="line">    it = s.find(<span class="number">6</span>); <span class="comment">//查找键值为6的元素  </span></span><br><span class="line">    <span class="keyword">if</span>(it != s.end())  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not find it"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    it = s.find(<span class="number">20</span>);  </span><br><span class="line">    <span class="keyword">if</span>(it != s.end())  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not find it"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">运行结果： </span></span><br><span class="line"><span class="comment">6 </span></span><br><span class="line"><span class="comment">not find it    </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下面这种方法也能判断一个数是否在集合中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  </span><br><span class="line">        s.insert(i);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);  </span><br><span class="line">        <span class="keyword">if</span>(!s.count(a)) <span class="comment">//不存在  </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"does not exist\n"</span>);  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"exist\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>自定义比较函数<br> 使用insert将元素插入到集合中去的时候，集合会根据设定的比较函数奖该元素放到该放的节点上去。<br> 在定义集合的时候，如果没有指定比较函数，那么采用默认的比较函数，即按键值从小到大的顺序插入元素。但在很多情况下，需要自己编写比较函数。</p>
<p>编写比较函数有两种方法。</p>
</li>
</ol>
<p>(1)如果元素不是结构体，那么可以编写比较函数。下面的程序比较规则为按键值从大到小的顺序插入到集合中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mycomp</span>  </span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//自定义比较函数，重载“（）”操作符  </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(a != b)  </span><br><span class="line">            <span class="keyword">return</span> a &gt; b;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">return</span> a &gt; b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, mycomp&gt; s; <span class="comment">//采用比较函数mycomp  </span></span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第一次插入5，可以插入  </span></span><br><span class="line">    s.insert(<span class="number">1</span>);  </span><br><span class="line">    s.insert(<span class="number">6</span>);  </span><br><span class="line">    s.insert(<span class="number">3</span>);  </span><br><span class="line">    s.insert(<span class="number">5</span>); <span class="comment">//第二次插入5，重复元素，不会插入  </span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>,mycomp&gt;::iterator it;  </span><br><span class="line">    <span class="keyword">for</span>(it = s.begin(); it != s.end(); it++)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">运行结果：6 5 3 1   </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>(2)如果元素是结构体，那么可以直接把比较函数写在结构体内。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">double</span> score;  </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Info &amp;a) <span class="keyword">const</span> <span class="comment">// 重载“&lt;”操作符，自定义排序规则  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//按score由大到小排序。如果要由小到大排序，使用“&gt;”即可。  </span></span><br><span class="line">        <span class="keyword">return</span> a.score &lt; score;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;Info&gt; s;  </span><br><span class="line">    Info info;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//插入三个元素  </span></span><br><span class="line">    info.name = <span class="string">"Jack"</span>;  </span><br><span class="line">    info.score = <span class="number">80</span>;  </span><br><span class="line">    s.insert(info);  </span><br><span class="line">    info.name = <span class="string">"Tom"</span>;  </span><br><span class="line">    info.score = <span class="number">99</span>;  </span><br><span class="line">    s.insert(info);  </span><br><span class="line">    info.name = <span class="string">"Steaven"</span>;  </span><br><span class="line">    info.score = <span class="number">60</span>;  </span><br><span class="line">    s.insert(info);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">set</span>&lt;Info&gt;::iterator it;  </span><br><span class="line">    <span class="keyword">for</span>(it = s.begin(); it != s.end(); it++)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name &lt;&lt; <span class="string">" : "</span> &lt;&lt; (*it).score &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">运行结果： </span></span><br><span class="line"><span class="comment">Tom : 99 </span></span><br><span class="line"><span class="comment">Jack : 80 </span></span><br><span class="line"><span class="comment">Steaven : 60 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习（2）——队列queue</title>
    <url>/2019/11/08/C-%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>1、队列（Queue）与栈一样，是一种线性存储结构，它具有如下特点：</p>
<p>（1）队列中的数据元素遵循“先进先出”（First In First Out）的原则，简称FIFO结构；</p>
<p>（2）在队尾添加元素，在队头删除元素。</p>
</li>
<li><p>2、队列的相关概念：</p>
<p>（1）队头与队尾： 允许元素插入的一端称为队尾，允许元素删除的一端称为队头；</p>
<p>（2）入队：队列的插入操作；</p>
<p>（3）出队：队列的删除操作。</p>
</li>
<li><p>3、队列的操作：</p>
<p>（1）入队： 通常命名为push()</p>
<p>（2）出队： 通常命名为pop()</p>
<p>（3）求队列中元素个数</p>
<p>（4）判断队列是否为空</p>
<p>（5）获取队首元素</p>
</li>
<li><p>4、队列的分类：</p>
</li>
</ul><a id="more"></a>
<p>（1）基于数组的循环队列（循环队列）</p>
<p>（2）基于链表的队列（链队列）</p>
<ul>
<li><p>5、实例分析</p>
<p> C++队列queue模板类的定义在&lt; queue&gt;头文件中，==queue 模板类需要两个模板参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的==，默认为deque 类型。C++队列Queue是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。</p>
</li>
</ul>
<blockquote>
<p>那么我们如何判断队列是空队列还是已满呢？</p>
<p>${\color{red} 栈空:队首标志=队尾标志时，表示栈空}$</p>
<p>${\color{red}栈满:队尾+1 = 队首时，表示栈满}$</p>
</blockquote>
<p>使用标准库的队列时, 应包含相关头文件，在栈中应包含头文件： #include&lt; queue&gt; 。定义：queue&lt; int &gt; q;</p>
<p><strong>C++队列Queue类成员函数如下:</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">q</span>.empty()               如果队列为空返回true，否则返回false</span><br><span class="line"><span class="selector-tag">q</span>.size()                返回队列中元素的个数</span><br><span class="line"><span class="selector-tag">q</span>.pop()                 删除队列首元素但不返回其值</span><br><span class="line"><span class="selector-tag">q</span>.front()               返回队首元素的值，但不删除该元素</span><br><span class="line"><span class="selector-tag">q</span>.push()                在队尾压入新元素</span><br><span class="line"><span class="selector-tag">q</span>.back()                返回队列尾元素的值，但不删除该元素</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 参考:</p>
<p> <a href="https://blog.csdn.net/zichen_ziqi/article/details/80819939" target="_blank" rel="noopener">C++数据结构——队列</a></p>
<p> <a href="https://www.cnblogs.com/QG-whz/p/5171123.html" target="_blank" rel="noopener">数据结构图文解析之：队列详解与C++模板实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>32.从上到下打印二叉树</title>
    <url>/2019/11/08/32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>借助queue的层次遍历</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.size())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* pNode=q.front();<span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">            q.pop();<span class="comment">//删除队列首元素但不返回其值</span></span><br><span class="line">            p.push_back(pNode-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left)</span><br><span class="line">                q.push(pNode-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right)</span><br><span class="line">                q.push(pNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>ORB-SLAM2——LocalClosing线程</title>
    <url>/2019/11/08/ORB-SLAM2%E2%80%94%E2%80%94LocalClosing%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191114172110832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><blockquote>
<p>参考：<br><a href="https://blog.csdn.net/moyu123456789/article/details/91374510" target="_blank" rel="noopener">ORB-SLAM2代码阅读笔记（八）：LoopClosing线程</a><br><a href="https://blog.csdn.net/try_again_later/article/details/84141825" target="_blank" rel="noopener">ORB-SLAM2源码解读（4）：LocalClosing</a></p>
</blockquote><p>待写！！！</p>]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
  </entry>
  <entry>
    <title>31.栈的压入、弹出序列</title>
    <url>/2019/11/08/31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>建立一个辅助栈，把输入的第一个序列中的数字依次压入辅助栈，并按照第二个序列的顺序依次从该栈中弹出元素</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;stackV;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushV.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stackV.push(pushV[i]);<span class="comment">//将入栈序元素入栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stackV.empty() &amp;&amp; stackV.top()==popV[j])<span class="comment">//栈顶元素等于出栈序，则出栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                stackV.pop();</span><br><span class="line">                j++;<span class="comment">//出栈序下标往后移动一下</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackV.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>30.包含min函数的栈</title>
    <url>/2019/11/08/30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>构造一个数据栈和辅助栈，把每次的最小元素压入辅助栈</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;m_data;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;m_min;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">        m_data.push(value);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(m_min.size()==<span class="number">0</span> || value&lt;m_min.top())</span><br><span class="line">            m_min.push(value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m_min.push(m_min.top());     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_data.pop();</span><br><span class="line">        m_min.pop();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>ORB-SLAM2——LocalMapping线程</title>
    <url>/2019/11/06/ORB-SLAM2%E2%80%94%E2%80%94LocalMapping%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>LocalMapping线程负责对新加入的KeyFrames和MapPoints筛选融合，剔除冗余的KeyFrames和MapPoints，维护稳定的KeyFrame集合，传给后续的LoopClosing线程。<br>主要的功能点在：</p><ul>
<li>处理新的关键帧ProcessNewKeyFrame()</li>
<li>剔除不合格地图点MapPointCulling()</li>
<li>三角化恢复新地图点CreateNewMapPoints()</li>
<li>融合当前帧与相邻帧重复的地图点SearchInNeighbors()</li>
<li>局部BA优化LocalBundleAdjustment()</li>
<li>剔除冗余关键帧KeyFrameCulling()</li>
</ul><a id="more"></a>

<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191114153042167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019111415323352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="入口函数LocalMapping-Run"><a href="#入口函数LocalMapping-Run" class="headerlink" title="入口函数LocalMapping::Run()"></a>入口函数LocalMapping::Run()</h1><p>入口函数是LocalMapping.cc中的Run()函数，Run()函数也相当于LocalMapping的主函数。这个线程在系统运行起来的时候处于休眠或者等待状态。当有新的关键帧加入的时候线程就将自己设置为繁忙状态（告诉Tracking线程我很忙，暂时不接受新的关键帧）并立刻处理新的关键帧；当处理完一个关键帧后，就会将自己设置为空闲状态（告诉Tracking线程，我可以接受新的关键帧了）并进入睡眠状态3秒。当代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LocalMapping::Run()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mbFinished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Tracking will see that Local Mapping is busy</span></span><br><span class="line">        <span class="comment">// 告诉Tracking，LocalMapping正处于繁忙状态，</span></span><br><span class="line">        <span class="comment">// LocalMapping线程处理的关键帧都是Tracking线程发过的</span></span><br><span class="line">        <span class="comment">// 在LocalMapping线程还没有处理完关键帧之前Tracking线程最好不要发送太快</span></span><br><span class="line">        SetAcceptKeyFrames(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if there are keyframes in the queue</span></span><br><span class="line">        <span class="comment">// 等待处理的关键帧列表不为空</span></span><br><span class="line">        <span class="keyword">if</span>(CheckNewKeyFrames())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// BoW conversion and insertion in Map</span></span><br><span class="line">            ProcessNewKeyFrame();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check recent MapPoints</span></span><br><span class="line">            <span class="comment">// 剔除ProcessNewKeyFrame函数中引入的不合格MapPoints</span></span><br><span class="line">            MapPointCulling();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Triangulate new MapPoints</span></span><br><span class="line">            <span class="comment">// 相机运动过程中与相邻关键帧通过三角化恢复出一些MapPoints</span></span><br><span class="line">            CreateNewMapPoints();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 已经处理完队列中的最后的一个关键帧</span></span><br><span class="line">            <span class="keyword">if</span>(!CheckNewKeyFrames())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Find more matches in neighbor keyframes and fuse point duplications</span></span><br><span class="line">                <span class="comment">// 检查并融合当前关键帧与相邻帧（两级相邻）重复的MapPoints</span></span><br><span class="line">                SearchInNeighbors();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mbAbortBA = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!CheckNewKeyFrames() &amp;&amp; !stopRequested())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Local BA</span></span><br><span class="line">                <span class="keyword">if</span>(mpMap-&gt;KeyFramesInMap()&gt;<span class="number">2</span>)</span><br><span class="line">                    Optimizer::LocalBundleAdjustment(mpCurrentKeyFrame,&amp;mbAbortBA, mpMap);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check redundant local Keyframes</span></span><br><span class="line">                <span class="comment">// 检测并剔除当前帧相邻的关键帧中冗余的关键帧</span></span><br><span class="line">                <span class="comment">// 剔除的标准是：该关键帧的90%的MapPoints可以被其它关键帧观测到</span></span><br><span class="line">                <span class="comment">// trick!</span></span><br><span class="line">                <span class="comment">// Tracking中先把关键帧交给LocalMapping线程</span></span><br><span class="line">                <span class="comment">// 并且在Tracking中InsertKeyFrame函数的条件比较松，交给LocalMapping线程的关键帧会比较密</span></span><br><span class="line">                <span class="comment">// 在这里再删除冗余的关键帧</span></span><br><span class="line">                KeyFrameCulling();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前帧加入到闭环检测队列中</span></span><br><span class="line">            mpLoopCloser-&gt;InsertKeyFrame(mpCurrentKeyFrame);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Stop())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Safe area to stop</span></span><br><span class="line">            <span class="keyword">while</span>(isStopped() &amp;&amp; !CheckFinish())</span><br><span class="line">            &#123;</span><br><span class="line">                usleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(CheckFinish())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ResetIfRequested();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tracking will see that Local Mapping is busy</span></span><br><span class="line">        SetAcceptKeyFrames(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(CheckFinish())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-LocalMapping-SetAcceptKeyFrames"><a href="#void-LocalMapping-SetAcceptKeyFrames" class="headerlink" title="void LocalMapping::SetAcceptKeyFrames()"></a>void LocalMapping::SetAcceptKeyFrames()</h2><p>告诉Tracking线程，LocalMapping正处于繁忙状态，不要再添加新的关键帧了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LocalMapping::SetAcceptKeyFrames(<span class="keyword">bool</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(mMutexAccept);</span><br><span class="line">    mbAcceptKeyFrames=flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="void-LocalMapping-ProcessNewKeyFrame"><a href="#void-LocalMapping-ProcessNewKeyFrame" class="headerlink" title="void LocalMapping::ProcessNewKeyFrame()"></a>void LocalMapping::ProcessNewKeyFrame()</h2><p>作用是，从队列取出一个关键帧，计算该关键帧的Bow特征，更新关键帧观测到的地图点的信息，并且将该关键帧新生成的地图点添加进mlpRecentAddedMapPoints，等待后续检测。然后将该关键帧插入地图。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LocalMapping::ProcessNewKeyFrame()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lock(mMutexNewKFs);</span><br><span class="line">        mpCurrentKeyFrame = mlNewKeyFrames.front();</span><br><span class="line">        mlNewKeyFrames.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute Bags of Words structures</span></span><br><span class="line">    mpCurrentKeyFrame-&gt;ComputeBoW();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate MapPoints to the new keyframe and update normal and descriptor</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPointMatches = mpCurrentKeyFrame-&gt;GetMapPointMatches();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;vpMapPointMatches.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = vpMapPointMatches[i];</span><br><span class="line">        <span class="keyword">if</span>(pMP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!pMP-&gt;IsInKeyFrame(mpCurrentKeyFrame))</span><br><span class="line">                &#123;</span><br><span class="line">                    pMP-&gt;AddObservation(mpCurrentKeyFrame, i);</span><br><span class="line">                    pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line">                    pMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// this can only happen for new stereo points inserted by the Tracking</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mlpRecentAddedMapPoints.push_back(pMP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update links in the Covisibility Graph</span></span><br><span class="line">    mpCurrentKeyFrame-&gt;UpdateConnections();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert Keyframe in Map</span></span><br><span class="line">    mpMap-&gt;AddKeyFrame(mpCurrentKeyFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="void-LocalMapping-MapPointCulling"><a href="#void-LocalMapping-MapPointCulling" class="headerlink" title="void LocalMapping::MapPointCulling()"></a>void LocalMapping::MapPointCulling()</h2><p>主要作用是筛选mlpRecentAddedMapPoints里的点，对于不好的点标记为bad。</p>
<blockquote>
<p>1：已经是坏点的MapPoints直接从检查链表中删除，SetBadFlag()<br>2：跟踪到该MapPoint的Frame数相比预计可观测到该MapPoint的Frame数的比例需大于25%，SetBadFlag()   IncreaseFound / IncreaseVisible &lt; 25%，注意不一定是关键帧。<br>3：从该点建立开始，到现在已经过了不小于2个关键帧，但是观测到该点的关键帧数却不超过cnThObs帧，那么该点检验不合格。SetBadFlag()<br>4：从建立该点开始，已经过了3个关键帧而没有被剔除，则认为是质量高的点，因此没有SetBadFlag()，仅从队列中删除，放弃继续对该MapPoint的检测mlpRecentAddedMapPoints剩下的点，需要继续经过以后的检测。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LocalMapping::MapPointCulling()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check Recent Added MapPoints</span></span><br><span class="line">    <span class="built_in">list</span>&lt;MapPoint*&gt;::iterator lit = mlpRecentAddedMapPoints.begin();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> nCurrentKFid = mpCurrentKeyFrame-&gt;mnId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nThObs;</span><br><span class="line">    <span class="keyword">if</span>(mbMonocular)</span><br><span class="line">        nThObs = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nThObs = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cnThObs = nThObs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(lit!=mlpRecentAddedMapPoints.end())</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = *lit;</span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">        &#123;</span><br><span class="line">            lit = mlpRecentAddedMapPoints.erase(lit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pMP-&gt;GetFoundRatio()&lt;<span class="number">0.25f</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            pMP-&gt;SetBadFlag();</span><br><span class="line">            lit = mlpRecentAddedMapPoints.erase(lit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((<span class="keyword">int</span>)nCurrentKFid-(<span class="keyword">int</span>)pMP-&gt;mnFirstKFid)&gt;=<span class="number">2</span> &amp;&amp; pMP-&gt;Observations()&lt;=cnThObs)</span><br><span class="line">        &#123;</span><br><span class="line">            pMP-&gt;SetBadFlag();</span><br><span class="line">            lit = mlpRecentAddedMapPoints.erase(lit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(((<span class="keyword">int</span>)nCurrentKFid-(<span class="keyword">int</span>)pMP-&gt;mnFirstKFid)&gt;=<span class="number">3</span>)</span><br><span class="line">            lit = mlpRecentAddedMapPoints.erase(lit);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lit++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-LocalMapping-CreateNewMapPoints"><a href="#void-LocalMapping-CreateNewMapPoints" class="headerlink" title="void LocalMapping::CreateNewMapPoints()"></a>void LocalMapping::CreateNewMapPoints()</h2><p>利用对极约束对当前帧和共视关键帧通过三角化恢复出一些MapPoints</p>
<blockquote>
<p>1.在当前关键帧的共视关键帧中找到共视程度最高的nn帧相邻帧vpNeighKFs<br>2.遍历相邻关键帧vpNeighKFs，得到基线向量vBaseline = Ow2-Ow1<br>3.判断相机运动的基线是不是足够长，邻接关键帧的场景深度中值medianDepthKF2，baseline与景深的比例，如果特别远(比例特别小)，那么不考虑当前邻接的关键帧，不生成3D点</p>
<ol>
<li>根据两个关键帧的位姿计算它们之间的基本矩阵F<br>5.通过极线约束限制匹配时的搜索范围，对满足对极约束的特征点进行特征点匹配<br>6.对每对匹配通过三角化生成3D点,和Triangulate函数差不多<br>7.接着分别检查新得到的点在两个平面上的重投影误差，如果大于一定的值，直接抛弃该点。<br>8.检查尺度连续性<br>9.如果满足对极约束则建立当前帧的地图点及其属性（a.观测到该MapPoint的关键帧  b.该MapPoint的描述子  c.该MapPoint的平均观测方向和深度范围）<br>10.将地图点加入关键帧，加入全局map<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LocalMapping::CreateNewMapPoints()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Retrieve neighbor keyframes in covisibility graph</span></span><br><span class="line">    <span class="keyword">int</span> nn = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(mbMonocular)</span><br><span class="line">        nn=<span class="number">20</span>;</span><br><span class="line">        <span class="comment">//在当前关键帧的共视关键帧中找到共视程度最高的nn帧相邻帧vpNeighKFs</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpNeighKFs = mpCurrentKeyFrame-&gt;GetBestCovisibilityKeyFrames(nn);</span><br><span class="line"></span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.6</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cv::Mat Rcw1 = mpCurrentKeyFrame-&gt;GetRotation();</span><br><span class="line">    cv::Mat Rwc1 = Rcw1.t();</span><br><span class="line">    cv::Mat tcw1 = mpCurrentKeyFrame-&gt;GetTranslation();</span><br><span class="line">    cv::<span class="function">Mat <span class="title">Tcw1</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>,CV_32F)</span></span>;</span><br><span class="line">    Rcw1.copyTo(Tcw1.colRange(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">    tcw1.copyTo(Tcw1.col(<span class="number">3</span>));</span><br><span class="line">    cv::Mat Ow1 = mpCurrentKeyFrame-&gt;GetCameraCenter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> &amp;fx1 = mpCurrentKeyFrame-&gt;fx;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> &amp;fy1 = mpCurrentKeyFrame-&gt;fy;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> &amp;cx1 = mpCurrentKeyFrame-&gt;cx;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> &amp;cy1 = mpCurrentKeyFrame-&gt;cy;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> &amp;invfx1 = mpCurrentKeyFrame-&gt;invfx;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> &amp;invfy1 = mpCurrentKeyFrame-&gt;invfy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ratioFactor = <span class="number">1.5f</span>*mpCurrentKeyFrame-&gt;mfScaleFactor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nnew=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search matches with epipolar restriction and triangulate</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;vpNeighKFs.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; CheckNewKeyFrames())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        KeyFrame* pKF2 = vpNeighKFs[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check first that baseline is not too short</span></span><br><span class="line">        cv::Mat Ow2 = pKF2-&gt;GetCameraCenter();</span><br><span class="line">        cv::Mat vBaseline = Ow2-Ow1;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> baseline = cv::norm(vBaseline);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!mbMonocular)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(baseline&lt;pKF2-&gt;mb)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> medianDepthKF2 = pKF2-&gt;ComputeSceneMedianDepth(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> ratioBaselineDepth = baseline/medianDepthKF2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ratioBaselineDepth&lt;<span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute Fundamental Matrix</span></span><br><span class="line">        <span class="comment">//根据两个关键帧的位姿计算它们之间的基本矩阵F</span></span><br><span class="line">        cv::Mat F12 = ComputeF12(mpCurrentKeyFrame,pKF2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search matches that fullfil epipolar constraint</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">size_t</span>,<span class="keyword">size_t</span>&gt; &gt; vMatchedIndices;</span><br><span class="line">        matcher.SearchForTriangulation(mpCurrentKeyFrame,pKF2,F12,vMatchedIndices,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        cv::Mat Rcw2 = pKF2-&gt;GetRotation();</span><br><span class="line">        cv::Mat Rwc2 = Rcw2.t();</span><br><span class="line">        cv::Mat tcw2 = pKF2-&gt;GetTranslation();</span><br><span class="line">        cv::<span class="function">Mat <span class="title">Tcw2</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>,CV_32F)</span></span>;</span><br><span class="line">        Rcw2.copyTo(Tcw2.colRange(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        tcw2.copyTo(Tcw2.col(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> &amp;fx2 = pKF2-&gt;fx;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> &amp;fy2 = pKF2-&gt;fy;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> &amp;cx2 = pKF2-&gt;cx;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> &amp;cy2 = pKF2-&gt;cy;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> &amp;invfx2 = pKF2-&gt;invfx;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> &amp;invfy2 = pKF2-&gt;invfy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Triangulate each match</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> nmatches = vMatchedIndices.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ikp=<span class="number">0</span>; ikp&lt;nmatches; ikp++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> &amp;idx1 = vMatchedIndices[ikp].first;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> &amp;idx2 = vMatchedIndices[ikp].second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cv::KeyPoint &amp;kp1 = mpCurrentKeyFrame-&gt;mvKeysUn[idx1];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> kp1_ur=mpCurrentKeyFrame-&gt;mvuRight[idx1];</span><br><span class="line">            <span class="keyword">bool</span> bStereo1 = kp1_ur&gt;=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cv::KeyPoint &amp;kp2 = pKF2-&gt;mvKeysUn[idx2];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> kp2_ur = pKF2-&gt;mvuRight[idx2];</span><br><span class="line">            <span class="keyword">bool</span> bStereo2 = kp2_ur&gt;=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check parallax between rays</span></span><br><span class="line">            cv::Mat xn1 = (cv::Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">1</span>) &lt;&lt; (kp1.pt.x-cx1)*invfx1, (kp1.pt.y-cy1)*invfy1, <span class="number">1.0</span>);</span><br><span class="line">            cv::Mat xn2 = (cv::Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">1</span>) &lt;&lt; (kp2.pt.x-cx2)*invfx2, (kp2.pt.y-cy2)*invfy2, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">            cv::Mat ray1 = Rwc1*xn1;</span><br><span class="line">            cv::Mat ray2 = Rwc2*xn2;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> cosParallaxRays = ray1.dot(ray2)/(cv::norm(ray1)*cv::norm(ray2));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> cosParallaxStereo = cosParallaxRays+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">float</span> cosParallaxStereo1 = cosParallaxStereo;</span><br><span class="line">            <span class="keyword">float</span> cosParallaxStereo2 = cosParallaxStereo;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bStereo1)</span><br><span class="line">                cosParallaxStereo1 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">atan2</span>(mpCurrentKeyFrame-&gt;mb/<span class="number">2</span>,mpCurrentKeyFrame-&gt;mvDepth[idx1]));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bStereo2)</span><br><span class="line">                cosParallaxStereo2 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">atan2</span>(pKF2-&gt;mb/<span class="number">2</span>,pKF2-&gt;mvDepth[idx2]));</span><br><span class="line"></span><br><span class="line">            cosParallaxStereo = min(cosParallaxStereo1,cosParallaxStereo2);</span><br><span class="line"></span><br><span class="line">            cv::Mat x3D;</span><br><span class="line">            <span class="keyword">if</span>(cosParallaxRays&lt;cosParallaxStereo &amp;&amp; cosParallaxRays&gt;<span class="number">0</span> &amp;&amp; (bStereo1 || bStereo2 || cosParallaxRays&lt;<span class="number">0.9998</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Linear Triangulation Method</span></span><br><span class="line">                cv::<span class="function">Mat <span class="title">A</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>,CV_32F)</span></span>;</span><br><span class="line">                A.row(<span class="number">0</span>) = xn1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>)*Tcw1.row(<span class="number">2</span>)-Tcw1.row(<span class="number">0</span>);</span><br><span class="line">                A.row(<span class="number">1</span>) = xn1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>)*Tcw1.row(<span class="number">2</span>)-Tcw1.row(<span class="number">1</span>);</span><br><span class="line">                A.row(<span class="number">2</span>) = xn2.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>)*Tcw2.row(<span class="number">2</span>)-Tcw2.row(<span class="number">0</span>);</span><br><span class="line">                A.row(<span class="number">3</span>) = xn2.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>)*Tcw2.row(<span class="number">2</span>)-Tcw2.row(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                cv::Mat w,u,vt;</span><br><span class="line">                cv::SVD::compute(A,w,u,vt,cv::SVD::MODIFY_A| cv::SVD::FULL_UV);</span><br><span class="line"></span><br><span class="line">                x3D = vt.row(<span class="number">3</span>).t();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(x3D.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Euclidean coordinates</span></span><br><span class="line">                x3D = x3D.rowRange(<span class="number">0</span>,<span class="number">3</span>)/x3D.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bStereo1 &amp;&amp; cosParallaxStereo1&lt;cosParallaxStereo2)</span><br><span class="line">            &#123;</span><br><span class="line">                x3D = mpCurrentKeyFrame-&gt;UnprojectStereo(idx1);                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bStereo2 &amp;&amp; cosParallaxStereo2&lt;cosParallaxStereo1)</span><br><span class="line">            &#123;</span><br><span class="line">                x3D = pKF2-&gt;UnprojectStereo(idx2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//No stereo and very low parallax</span></span><br><span class="line"></span><br><span class="line">            cv::Mat x3Dt = x3D.t();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Check triangulation in front of cameras</span></span><br><span class="line">            <span class="keyword">float</span> z1 = Rcw1.row(<span class="number">2</span>).dot(x3Dt)+tcw1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(z1&lt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> z2 = Rcw2.row(<span class="number">2</span>).dot(x3Dt)+tcw2.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(z2&lt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Check reprojection error in first keyframe</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> &amp;sigmaSquare1 = mpCurrentKeyFrame-&gt;mvLevelSigma2[kp1.octave];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> x1 = Rcw1.row(<span class="number">0</span>).dot(x3Dt)+tcw1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> y1 = Rcw1.row(<span class="number">1</span>).dot(x3Dt)+tcw1.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> invz1 = <span class="number">1.0</span>/z1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!bStereo1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> u1 = fx1*x1*invz1+cx1;</span><br><span class="line">                <span class="keyword">float</span> v1 = fy1*y1*invz1+cy1;</span><br><span class="line">                <span class="keyword">float</span> errX1 = u1 - kp1.pt.x;</span><br><span class="line">                <span class="keyword">float</span> errY1 = v1 - kp1.pt.y;</span><br><span class="line">                <span class="keyword">if</span>((errX1*errX1+errY1*errY1)&gt;<span class="number">5.991</span>*sigmaSquare1)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> u1 = fx1*x1*invz1+cx1;</span><br><span class="line">                <span class="keyword">float</span> u1_r = u1 - mpCurrentKeyFrame-&gt;mbf*invz1;</span><br><span class="line">                <span class="keyword">float</span> v1 = fy1*y1*invz1+cy1;</span><br><span class="line">                <span class="keyword">float</span> errX1 = u1 - kp1.pt.x;</span><br><span class="line">                <span class="keyword">float</span> errY1 = v1 - kp1.pt.y;</span><br><span class="line">                <span class="keyword">float</span> errX1_r = u1_r - kp1_ur;</span><br><span class="line">                <span class="keyword">if</span>((errX1*errX1+errY1*errY1+errX1_r*errX1_r)&gt;<span class="number">7.8</span>*sigmaSquare1)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Check reprojection error in second keyframe</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> sigmaSquare2 = pKF2-&gt;mvLevelSigma2[kp2.octave];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> x2 = Rcw2.row(<span class="number">0</span>).dot(x3Dt)+tcw2.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> y2 = Rcw2.row(<span class="number">1</span>).dot(x3Dt)+tcw2.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> invz2 = <span class="number">1.0</span>/z2;</span><br><span class="line">            <span class="keyword">if</span>(!bStereo2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> u2 = fx2*x2*invz2+cx2;</span><br><span class="line">                <span class="keyword">float</span> v2 = fy2*y2*invz2+cy2;</span><br><span class="line">                <span class="keyword">float</span> errX2 = u2 - kp2.pt.x;</span><br><span class="line">                <span class="keyword">float</span> errY2 = v2 - kp2.pt.y;</span><br><span class="line">                <span class="keyword">if</span>((errX2*errX2+errY2*errY2)&gt;<span class="number">5.991</span>*sigmaSquare2)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> u2 = fx2*x2*invz2+cx2;</span><br><span class="line">                <span class="keyword">float</span> u2_r = u2 - mpCurrentKeyFrame-&gt;mbf*invz2;</span><br><span class="line">                <span class="keyword">float</span> v2 = fy2*y2*invz2+cy2;</span><br><span class="line">                <span class="keyword">float</span> errX2 = u2 - kp2.pt.x;</span><br><span class="line">                <span class="keyword">float</span> errY2 = v2 - kp2.pt.y;</span><br><span class="line">                <span class="keyword">float</span> errX2_r = u2_r - kp2_ur;</span><br><span class="line">                <span class="keyword">if</span>((errX2*errX2+errY2*errY2+errX2_r*errX2_r)&gt;<span class="number">7.8</span>*sigmaSquare2)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Check scale consistency</span></span><br><span class="line">            cv::Mat normal1 = x3D-Ow1;</span><br><span class="line">            <span class="keyword">float</span> dist1 = cv::norm(normal1);</span><br><span class="line"></span><br><span class="line">            cv::Mat normal2 = x3D-Ow2;</span><br><span class="line">            <span class="keyword">float</span> dist2 = cv::norm(normal2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dist1==<span class="number">0</span> || dist2==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> ratioDist = dist2/dist1;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> ratioOctave = mpCurrentKeyFrame-&gt;mvScaleFactors[kp1.octave]/pKF2-&gt;mvScaleFactors[kp2.octave];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*if(fabs(ratioDist-ratioOctave)&gt;ratioFactor)</span></span><br><span class="line"><span class="comment">                continue;*/</span></span><br><span class="line">            <span class="keyword">if</span>(ratioDist*ratioFactor&lt;ratioOctave || ratioDist&gt;ratioOctave*ratioFactor)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Triangulation is succesfull</span></span><br><span class="line">            MapPoint* pMP = <span class="keyword">new</span> MapPoint(x3D,mpCurrentKeyFrame,mpMap);</span><br><span class="line"></span><br><span class="line">            pMP-&gt;AddObservation(mpCurrentKeyFrame,idx1);            </span><br><span class="line">            pMP-&gt;AddObservation(pKF2,idx2);</span><br><span class="line"></span><br><span class="line">            mpCurrentKeyFrame-&gt;AddMapPoint(pMP,idx1);</span><br><span class="line">            pKF2-&gt;AddMapPoint(pMP,idx2);</span><br><span class="line"></span><br><span class="line">            pMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line"></span><br><span class="line">            pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line"></span><br><span class="line">            mpMap-&gt;AddMapPoint(pMP);</span><br><span class="line">            mlpRecentAddedMapPoints.push_back(pMP);</span><br><span class="line"></span><br><span class="line">            nnew++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-LocalMapping-SearchInNeighbors"><a href="#void-LocalMapping-SearchInNeighbors" class="headerlink" title="void LocalMapping::SearchInNeighbors()."></a>void LocalMapping::SearchInNeighbors().</h2>检查并融合当前关键帧与相邻帧（两级相邻）重复的MapPoints，更新当前关键帧的连接关系。</li>
</ol>
<ul>
<li>1.获得当前关键帧在covisibility图中权重排名前nn的邻接关键帧，找到当前帧一级相邻与二级相邻关键帧</li>
<li>2.将当前帧的MapPoints分别与一级二级相邻帧(的MapPoints)进行融合<br><code>matcher.Fuse(pKFi,vpMapPointMatches);</code><br>投影当前帧的MapPoints到相邻关键帧pKFi中，并判断是否有重复的MapPoints<br>(1)如果MapPoint能匹配关键帧的特征点，并且该点有对应的MapPoint，那么将两个MapPoint合并（选择观测数多的）<br>(2)如果MapPoint能匹配关键帧的特征点，并且该点没有对应的MapPoint，那么为该点添加MapPoint</li>
<li>3.将一级二级相邻帧的MapPoints分别与当前帧（的MapPoints）进行融合</li>
<li>4.更新当前帧MapPoints的描述子，深度，观测主方向等属性<br><code>在这里插入代码片</code><br>5.更新当前帧的MapPoints后更新与其它帧的连接关系<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LocalMapping::SearchInNeighbors()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Retrieve neighbor keyframes</span></span><br><span class="line">    <span class="keyword">int</span> nn = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(mbMonocular)</span><br><span class="line">        nn=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpNeighKFs = mpCurrentKeyFrame-&gt;GetBestCovisibilityKeyFrames(nn);</span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpTargetKFs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator vit=vpNeighKFs.begin(), vend=vpNeighKFs.end(); vit!=vend; vit++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKFi = *vit;</span><br><span class="line">        <span class="keyword">if</span>(pKFi-&gt;isBad() || pKFi-&gt;mnFuseTargetForKF == mpCurrentKeyFrame-&gt;mnId)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vpTargetKFs.push_back(pKFi);</span><br><span class="line">        pKFi-&gt;mnFuseTargetForKF = mpCurrentKeyFrame-&gt;mnId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Extend to some second neighbors</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpSecondNeighKFs = pKFi-&gt;GetBestCovisibilityKeyFrames(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator vit2=vpSecondNeighKFs.begin(), vend2=vpSecondNeighKFs.end(); vit2!=vend2; vit2++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pKFi2 = *vit2;</span><br><span class="line">            <span class="keyword">if</span>(pKFi2-&gt;isBad() || pKFi2-&gt;mnFuseTargetForKF==mpCurrentKeyFrame-&gt;mnId || pKFi2-&gt;mnId==mpCurrentKeyFrame-&gt;mnId)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vpTargetKFs.push_back(pKFi2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search matches by projection from current KF in target KFs</span></span><br><span class="line">    ORBmatcher matcher;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPointMatches = mpCurrentKeyFrame-&gt;GetMapPointMatches();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::iterator vit=vpTargetKFs.begin(), vend=vpTargetKFs.end(); vit!=vend; vit++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKFi = *vit;</span><br><span class="line"></span><br><span class="line">        matcher.Fuse(pKFi,vpMapPointMatches);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search matches by projection from target KFs in current KF</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpFuseCandidates;</span><br><span class="line">    vpFuseCandidates.reserve(vpTargetKFs.size()*vpMapPointMatches.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::iterator vitKF=vpTargetKFs.begin(), vendKF=vpTargetKFs.end(); vitKF!=vendKF; vitKF++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKFi = *vitKF;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPointsKFi = pKFi-&gt;GetMapPointMatches();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::iterator vitMP=vpMapPointsKFi.begin(), vendMP=vpMapPointsKFi.end(); vitMP!=vendMP; vitMP++)</span><br><span class="line">        &#123;</span><br><span class="line">            MapPoint* pMP = *vitMP;</span><br><span class="line">            <span class="keyword">if</span>(!pMP)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(pMP-&gt;isBad() || pMP-&gt;mnFuseCandidateForKF == mpCurrentKeyFrame-&gt;mnId)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pMP-&gt;mnFuseCandidateForKF = mpCurrentKeyFrame-&gt;mnId;</span><br><span class="line">            vpFuseCandidates.push_back(pMP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matcher.Fuse(mpCurrentKeyFrame,vpFuseCandidates);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update points</span></span><br><span class="line">    vpMapPointMatches = mpCurrentKeyFrame-&gt;GetMapPointMatches();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=vpMapPointMatches.size(); i&lt;iend; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP=vpMapPointMatches[i];</span><br><span class="line">        <span class="keyword">if</span>(pMP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                pMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line">                pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update connections in covisibility graph</span></span><br><span class="line">    mpCurrentKeyFrame-&gt;UpdateConnections();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-Optimizer-LocalBundleAdjustment"><a href="#void-Optimizer-LocalBundleAdjustment" class="headerlink" title="void Optimizer::LocalBundleAdjustment()"></a>void Optimizer::LocalBundleAdjustment()</h2>参考：<a href="https://blog.csdn.net/chishuideyu/article/details/76013854" target="_blank" rel="noopener">ORBSlam2的位姿优化算法</a><br>优化的顶点是包括局部地图帧的位姿，概念lLocalKeyFrames，指的是当前关键帧和其相连接的关键帧组成的集合。还包括这些关键帧可以观测到的所有地图点，地图点的位置也会优化。还有一些帧，这些帧能够观测到这些地图点，但却不是局部地图里，这些帧的位姿也作为顶点添加进图中，但是却固定不动，不会被优化。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Optimizer::LocalBundleAdjustment(KeyFrame *pKF, <span class="keyword">bool</span>* pbStopFlag, Map* pMap)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// Local KeyFrames: First Breath Search from Current Keyframe</span></span><br><span class="line">    <span class="built_in">list</span>&lt;KeyFrame*&gt; lLocalKeyFrames;</span><br><span class="line"></span><br><span class="line">    lLocalKeyFrames.push_back(pKF);</span><br><span class="line">    pKF-&gt;mnBALocalForKF = pKF-&gt;mnId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyFrame*&gt; vNeighKFs = pKF-&gt;GetVectorCovisibleKeyFrames();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, iend=vNeighKFs.size(); i&lt;iend; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKFi = vNeighKFs[i];</span><br><span class="line">        pKFi-&gt;mnBALocalForKF = pKF-&gt;mnId;</span><br><span class="line">        <span class="keyword">if</span>(!pKFi-&gt;isBad())</span><br><span class="line">            lLocalKeyFrames.push_back(pKFi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local MapPoints seen in Local KeyFrames</span></span><br><span class="line">    <span class="built_in">list</span>&lt;MapPoint*&gt; lLocalMapPoints;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;KeyFrame*&gt;::iterator lit=lLocalKeyFrames.begin() , lend=lLocalKeyFrames.end(); lit!=lend; lit++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMPs = (*lit)-&gt;GetMapPointMatches();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::iterator vit=vpMPs.begin(), vend=vpMPs.end(); vit!=vend; vit++)</span><br><span class="line">        &#123;</span><br><span class="line">            MapPoint* pMP = *vit;</span><br><span class="line">            <span class="keyword">if</span>(pMP)</span><br><span class="line">                <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">                    <span class="keyword">if</span>(pMP-&gt;mnBALocalForKF!=pKF-&gt;mnId)</span><br><span class="line">                    &#123;</span><br><span class="line">                        lLocalMapPoints.push_back(pMP);</span><br><span class="line">                        pMP-&gt;mnBALocalForKF=pKF-&gt;mnId;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fixed Keyframes. Keyframes that see Local MapPoints but that are not Local Keyframes</span></span><br><span class="line">    <span class="built_in">list</span>&lt;KeyFrame*&gt; lFixedCameras;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;MapPoint*&gt;::iterator lit=lLocalMapPoints.begin(), lend=lLocalMapPoints.end(); lit!=lend; lit++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt; observations = (*lit)-&gt;GetObservations();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt;::iterator mit=observations.begin(), mend=observations.end(); mit!=mend; mit++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pKFi = mit-&gt;first;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pKFi-&gt;mnBALocalForKF!=pKF-&gt;mnId &amp;&amp; pKFi-&gt;mnBAFixedForKF!=pKF-&gt;mnId)</span><br><span class="line">            &#123;                </span><br><span class="line">                pKFi-&gt;mnBAFixedForKF=pKF-&gt;mnId;</span><br><span class="line">                <span class="keyword">if</span>(!pKFi-&gt;isBad())</span><br><span class="line">                    lFixedCameras.push_back(pKFi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup optimizer</span></span><br><span class="line">    g2o::SparseOptimizer optimizer;</span><br><span class="line">    g2o::BlockSolver_6_3::LinearSolverType * linearSolver;</span><br><span class="line"></span><br><span class="line">    linearSolver = <span class="keyword">new</span> g2o::LinearSolverEigen&lt;g2o::BlockSolver_6_3::PoseMatrixType&gt;();</span><br><span class="line"></span><br><span class="line">    g2o::BlockSolver_6_3 * solver_ptr = <span class="keyword">new</span> g2o::BlockSolver_6_3(linearSolver);</span><br><span class="line"></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg(solver_ptr);</span><br><span class="line">    optimizer.setAlgorithm(solver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pbStopFlag)</span><br><span class="line">        optimizer.setForceStopFlag(pbStopFlag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxKFid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Local KeyFrame vertices</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;KeyFrame*&gt;::iterator lit=lLocalKeyFrames.begin(), lend=lLocalKeyFrames.end(); lit!=lend; lit++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKFi = *lit;</span><br><span class="line">        g2o::VertexSE3Expmap * vSE3 = <span class="keyword">new</span> g2o::VertexSE3Expmap();</span><br><span class="line">        vSE3-&gt;setEstimate(Converter::toSE3Quat(pKFi-&gt;GetPose()));</span><br><span class="line">        vSE3-&gt;setId(pKFi-&gt;mnId);</span><br><span class="line">        vSE3-&gt;setFixed(pKFi-&gt;mnId==<span class="number">0</span>);</span><br><span class="line">        optimizer.addVertex(vSE3);</span><br><span class="line">        <span class="keyword">if</span>(pKFi-&gt;mnId&gt;maxKFid)</span><br><span class="line">            maxKFid=pKFi-&gt;mnId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Fixed KeyFrame vertices</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;KeyFrame*&gt;::iterator lit=lFixedCameras.begin(), lend=lFixedCameras.end(); lit!=lend; lit++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKFi = *lit;</span><br><span class="line">        g2o::VertexSE3Expmap * vSE3 = <span class="keyword">new</span> g2o::VertexSE3Expmap();</span><br><span class="line">        vSE3-&gt;setEstimate(Converter::toSE3Quat(pKFi-&gt;GetPose()));</span><br><span class="line">        vSE3-&gt;setId(pKFi-&gt;mnId);</span><br><span class="line">        vSE3-&gt;setFixed(<span class="literal">true</span>);</span><br><span class="line">        optimizer.addVertex(vSE3);</span><br><span class="line">        <span class="keyword">if</span>(pKFi-&gt;mnId&gt;maxKFid)</span><br><span class="line">            maxKFid=pKFi-&gt;mnId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set MapPoint vertices</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nExpectedSize = (lLocalKeyFrames.size()+lFixedCameras.size())*lLocalMapPoints.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;g2o::EdgeSE3ProjectXYZ*&gt; vpEdgesMono;</span><br><span class="line">    vpEdgesMono.reserve(nExpectedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpEdgeKFMono;</span><br><span class="line">    vpEdgeKFMono.reserve(nExpectedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPointEdgeMono;</span><br><span class="line">    vpMapPointEdgeMono.reserve(nExpectedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;g2o::EdgeStereoSE3ProjectXYZ*&gt; vpEdgesStereo;</span><br><span class="line">    vpEdgesStereo.reserve(nExpectedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpEdgeKFStereo;</span><br><span class="line">    vpEdgeKFStereo.reserve(nExpectedSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPointEdgeStereo;</span><br><span class="line">    vpMapPointEdgeStereo.reserve(nExpectedSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> thHuberMono = <span class="built_in">sqrt</span>(<span class="number">5.991</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> thHuberStereo = <span class="built_in">sqrt</span>(<span class="number">7.815</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;MapPoint*&gt;::iterator lit=lLocalMapPoints.begin(), lend=lLocalMapPoints.end(); lit!=lend; lit++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = *lit;</span><br><span class="line">        g2o::VertexSBAPointXYZ* vPoint = <span class="keyword">new</span> g2o::VertexSBAPointXYZ();</span><br><span class="line">        vPoint-&gt;setEstimate(Converter::toVector3d(pMP-&gt;GetWorldPos()));</span><br><span class="line">        <span class="keyword">int</span> id = pMP-&gt;mnId+maxKFid+<span class="number">1</span>;</span><br><span class="line">        vPoint-&gt;setId(id);</span><br><span class="line">        vPoint-&gt;setMarginalized(<span class="literal">true</span>);</span><br><span class="line">        optimizer.addVertex(vPoint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt; observations = pMP-&gt;GetObservations();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set edges</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt;::const_iterator mit=observations.begin(), mend=observations.end(); mit!=mend; mit++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pKFi = mit-&gt;first;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!pKFi-&gt;isBad())</span><br><span class="line">            &#123;                </span><br><span class="line">                <span class="keyword">const</span> cv::KeyPoint &amp;kpUn = pKFi-&gt;mvKeysUn[mit-&gt;second];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Monocular observation</span></span><br><span class="line">                <span class="keyword">if</span>(pKFi-&gt;mvuRight[mit-&gt;second]&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">2</span>,<span class="number">1</span>&gt; obs;</span><br><span class="line">                    obs &lt;&lt; kpUn.pt.x, kpUn.pt.y;</span><br><span class="line"></span><br><span class="line">                    g2o::EdgeSE3ProjectXYZ* e = <span class="keyword">new</span> g2o::EdgeSE3ProjectXYZ();</span><br><span class="line"></span><br><span class="line">                    e-&gt;setVertex(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::OptimizableGraph::Vertex*&gt;(optimizer.vertex(id)));</span><br><span class="line">                    e-&gt;setVertex(<span class="number">1</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::OptimizableGraph::Vertex*&gt;(optimizer.vertex(pKFi-&gt;mnId)));</span><br><span class="line">                    e-&gt;setMeasurement(obs);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">float</span> &amp;invSigma2 = pKFi-&gt;mvInvLevelSigma2[kpUn.octave];</span><br><span class="line">                    e-&gt;setInformation(Eigen::Matrix2d::Identity()*invSigma2);</span><br><span class="line"></span><br><span class="line">                    g2o::RobustKernelHuber* rk = <span class="keyword">new</span> g2o::RobustKernelHuber;</span><br><span class="line">                    e-&gt;setRobustKernel(rk);</span><br><span class="line">                    rk-&gt;setDelta(thHuberMono);</span><br><span class="line"></span><br><span class="line">                    e-&gt;fx = pKFi-&gt;fx;</span><br><span class="line">                    e-&gt;fy = pKFi-&gt;fy;</span><br><span class="line">                    e-&gt;cx = pKFi-&gt;cx;</span><br><span class="line">                    e-&gt;cy = pKFi-&gt;cy;</span><br><span class="line"></span><br><span class="line">                    optimizer.addEdge(e);</span><br><span class="line">                    vpEdgesMono.push_back(e);</span><br><span class="line">                    vpEdgeKFMono.push_back(pKFi);</span><br><span class="line">                    vpMapPointEdgeMono.push_back(pMP);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// Stereo observation</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">3</span>,<span class="number">1</span>&gt; obs;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">float</span> kp_ur = pKFi-&gt;mvuRight[mit-&gt;second];</span><br><span class="line">                    obs &lt;&lt; kpUn.pt.x, kpUn.pt.y, kp_ur;</span><br><span class="line"></span><br><span class="line">                    g2o::EdgeStereoSE3ProjectXYZ* e = <span class="keyword">new</span> g2o::EdgeStereoSE3ProjectXYZ();</span><br><span class="line"></span><br><span class="line">                    e-&gt;setVertex(<span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::OptimizableGraph::Vertex*&gt;(optimizer.vertex(id)));</span><br><span class="line">                    e-&gt;setVertex(<span class="number">1</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::OptimizableGraph::Vertex*&gt;(optimizer.vertex(pKFi-&gt;mnId)));</span><br><span class="line">                    e-&gt;setMeasurement(obs);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">float</span> &amp;invSigma2 = pKFi-&gt;mvInvLevelSigma2[kpUn.octave];</span><br><span class="line">                    Eigen::Matrix3d Info = Eigen::Matrix3d::Identity()*invSigma2;</span><br><span class="line">                    e-&gt;setInformation(Info);</span><br><span class="line"></span><br><span class="line">                    g2o::RobustKernelHuber* rk = <span class="keyword">new</span> g2o::RobustKernelHuber;</span><br><span class="line">                    e-&gt;setRobustKernel(rk);</span><br><span class="line">                    rk-&gt;setDelta(thHuberStereo);</span><br><span class="line"></span><br><span class="line">                    e-&gt;fx = pKFi-&gt;fx;</span><br><span class="line">                    e-&gt;fy = pKFi-&gt;fy;</span><br><span class="line">                    e-&gt;cx = pKFi-&gt;cx;</span><br><span class="line">                    e-&gt;cy = pKFi-&gt;cy;</span><br><span class="line">                    e-&gt;bf = pKFi-&gt;mbf;</span><br><span class="line"></span><br><span class="line">                    optimizer.addEdge(e);</span><br><span class="line">                    vpEdgesStereo.push_back(e);</span><br><span class="line">                    vpEdgeKFStereo.push_back(pKFi);</span><br><span class="line">                    vpMapPointEdgeStereo.push_back(pMP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pbStopFlag)</span><br><span class="line">        <span class="keyword">if</span>(*pbStopFlag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> bDoMore= <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pbStopFlag)</span><br><span class="line">        <span class="keyword">if</span>(*pbStopFlag)</span><br><span class="line">            bDoMore = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bDoMore)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check inlier observations</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=vpEdgesMono.size(); i&lt;iend;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeSE3ProjectXYZ* e = vpEdgesMono[i];</span><br><span class="line">        MapPoint* pMP = vpMapPointEdgeMono[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(e-&gt;chi2()&gt;<span class="number">5.991</span> || !e-&gt;isDepthPositive())</span><br><span class="line">        &#123;</span><br><span class="line">            e-&gt;setLevel(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        e-&gt;setRobustKernel(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=vpEdgesStereo.size(); i&lt;iend;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeStereoSE3ProjectXYZ* e = vpEdgesStereo[i];</span><br><span class="line">        MapPoint* pMP = vpMapPointEdgeStereo[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(e-&gt;chi2()&gt;<span class="number">7.815</span> || !e-&gt;isDepthPositive())</span><br><span class="line">        &#123;</span><br><span class="line">            e-&gt;setLevel(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        e-&gt;setRobustKernel(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimize again without the outliers</span></span><br><span class="line"></span><br><span class="line">    optimizer.initializeOptimization(<span class="number">0</span>);</span><br><span class="line">    optimizer.optimize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;KeyFrame*,MapPoint*&gt; &gt; vToErase;</span><br><span class="line">    vToErase.reserve(vpEdgesMono.size()+vpEdgesStereo.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check inlier observations       </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=vpEdgesMono.size(); i&lt;iend;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeSE3ProjectXYZ* e = vpEdgesMono[i];</span><br><span class="line">        MapPoint* pMP = vpMapPointEdgeMono[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(e-&gt;chi2()&gt;<span class="number">5.991</span> || !e-&gt;isDepthPositive())</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pKFi = vpEdgeKFMono[i];</span><br><span class="line">            vToErase.push_back(make_pair(pKFi,pMP));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=vpEdgesStereo.size(); i&lt;iend;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeStereoSE3ProjectXYZ* e = vpEdgesStereo[i];</span><br><span class="line">        MapPoint* pMP = vpMapPointEdgeStereo[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(e-&gt;chi2()&gt;<span class="number">7.815</span> || !e-&gt;isDepthPositive())</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pKFi = vpEdgeKFStereo[i];</span><br><span class="line">            vToErase.push_back(make_pair(pKFi,pMP));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Map Mutex</span></span><br><span class="line">    unique_lock&lt;mutex&gt; lock(pMap-&gt;mMutexMapUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!vToErase.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;vToErase.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pKFi = vToErase[i].first;</span><br><span class="line">            MapPoint* pMPi = vToErase[i].second;</span><br><span class="line">            pKFi-&gt;EraseMapPointMatch(pMPi);</span><br><span class="line">            pMPi-&gt;EraseObservation(pKFi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recover optimized data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Keyframes</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;KeyFrame*&gt;::iterator lit=lLocalKeyFrames.begin(), lend=lLocalKeyFrames.end(); lit!=lend; lit++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = *lit;</span><br><span class="line">        g2o::VertexSE3Expmap* vSE3 = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap*&gt;(optimizer.vertex(pKF-&gt;mnId));</span><br><span class="line">        g2o::SE3Quat SE3quat = vSE3-&gt;estimate();</span><br><span class="line">        pKF-&gt;SetPose(Converter::toCvMat(SE3quat));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Points</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;MapPoint*&gt;::iterator lit=lLocalMapPoints.begin(), lend=lLocalMapPoints.end(); lit!=lend; lit++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = *lit;</span><br><span class="line">        g2o::VertexSBAPointXYZ* vPoint = <span class="keyword">static_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt;(optimizer.vertex(pMP-&gt;mnId+maxKFid+<span class="number">1</span>));</span><br><span class="line">        pMP-&gt;SetWorldPos(Converter::toCvMat(vPoint-&gt;estimate()));</span><br><span class="line">        pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="void-LocalMapping-KeyFrameCulling"><a href="#void-LocalMapping-KeyFrameCulling" class="headerlink" title="void LocalMapping::KeyFrameCulling()"></a>void LocalMapping::KeyFrameCulling()</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191114170936918.png"><br>在Covisibility Graph，也就是局部地图中的关键帧，一个关键帧的90%以上的MapPoints能被其他关键帧（至少3个，这里的其他关键帧不特指当前的局部地图关键帧）观测到，则认为该关键帧为冗余关键帧。</p>
<blockquote>
<p>1.根据Covisibility Graph提取当前帧的共视关键帧<br>2.对所有的局部关键帧进行遍历，提取每个共视关键帧的MapPoints<br>3.遍历该局部关键帧的MapPoints，判断是否90%以上的MapPoints能被其它关键帧（至少3个）观测到<br>4.该局部关键帧90%以上的MapPoints能被其它关键帧（至少3个）观测到，则认为是冗余关键帧<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LocalMapping::KeyFrameCulling()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check redundant keyframes (only local keyframes)</span></span><br><span class="line">    <span class="comment">// A keyframe is considered redundant if the 90% of the MapPoints it sees, are seen</span></span><br><span class="line">    <span class="comment">// in at least other 3 keyframes (in the same or finer scale)</span></span><br><span class="line">    <span class="comment">// We only consider close stereo points</span></span><br><span class="line">    <span class="comment">// 检查冗余关键帧。一个关键帧的地图点中90%的地图点可以被至少其他3个相同或者更小等级（这里的等级是图像金字塔的层数）关键帧看到，则认为这个关键帧是冗余的。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpLocalKeyFrames = mpCurrentKeyFrame-&gt;GetVectorCovisibleKeyFrames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::iterator vit=vpLocalKeyFrames.begin(), vend=vpLocalKeyFrames.end(); vit!=vend; vit++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = *vit;</span><br><span class="line">        <span class="keyword">if</span>(pKF-&gt;mnId==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPoints = pKF-&gt;GetMapPointMatches();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nObs = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> thObs=nObs;</span><br><span class="line">        <span class="keyword">int</span> nRedundantObservations=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nMPs=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=vpMapPoints.size(); i&lt;iend; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            MapPoint* pMP = vpMapPoints[i];</span><br><span class="line">            <span class="keyword">if</span>(pMP)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!mbMonocular)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(pKF-&gt;mvDepth[i]&gt;pKF-&gt;mThDepth || pKF-&gt;mvDepth[i]&lt;<span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//MapPoint计数</span></span><br><span class="line">                    nMPs++;</span><br><span class="line">                    <span class="comment">//该pMP是否可以被大于3个的关键帧看到</span></span><br><span class="line">                    <span class="keyword">if</span>(pMP-&gt;Observations()&gt;thObs)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">int</span> &amp;scaleLevel = pKF-&gt;mvKeysUn[i].octave;</span><br><span class="line">                        <span class="keyword">const</span> <span class="built_in">map</span>&lt;KeyFrame*, <span class="keyword">size_t</span>&gt; observations = pMP-&gt;GetObservations();</span><br><span class="line">                        <span class="keyword">int</span> nObs=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;KeyFrame*, <span class="keyword">size_t</span>&gt;::const_iterator mit=observations.begin(), mend=observations.end(); mit!=mend; mit++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            KeyFrame* pKFi = mit-&gt;first;</span><br><span class="line">                            <span class="keyword">if</span>(pKFi==pKF)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="comment">// 获取关键点在金字塔图像中所处的层数</span></span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">int</span> &amp;scaleLeveli = pKFi-&gt;mvKeysUn[mit-&gt;second].octave;</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">int</span> &amp;scaleLeveli = pKFi-&gt;mvKeysUn[mit-&gt;second].octave;</span><br><span class="line">                            <span class="comment">//pKFi的关键点所处的层数&lt;=scaleLevel+1</span></span><br><span class="line">                            <span class="comment">//为什么要用层数来判断呢？还没有想明白</span></span><br><span class="line">                            <span class="keyword">if</span>(scaleLeveli&lt;=scaleLevel+<span class="number">1</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//共视关键帧计数</span></span><br><span class="line">                                nObs++;</span><br><span class="line">                                <span class="keyword">if</span>(nObs&gt;=thObs)</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//共视关键帧大于等于3判断</span></span><br><span class="line">                        <span class="keyword">if</span>(nObs&gt;=thObs)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nRedundantObservations++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nRedundantObservations&gt;<span class="number">0.9</span>*nMPs)</span><br><span class="line">            <span class="comment">//关键帧设置为bag，即被认为是冗余关键帧</span></span><br><span class="line">            pKF-&gt;SetBadFlag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>参考：<a href="https://blog.csdn.net/try_again_later/article/details/84112125" target="_blank" rel="noopener">ORB-SLAM2源码解读（3）：LocalMapping</a><br><a href="https://blog.csdn.net/moyu123456789/article/details/91299474#5%EF%BC%89%E5%89%94%E9%99%A4%E5%85%B3%E9%94%AE%E5%B8%A7%EF%BC%88%E5%AF%B9%E5%BA%94Local%20KeyFrames%20Culling%EF%BC%89" target="_blank" rel="noopener">ORB-SLAM2代码阅读笔记（七）：LocalMapping线程</a><br><a href="https://blog.csdn.net/qq_30356613/article/details/80588326" target="_blank" rel="noopener">一起学ORBSLAM2（11）ORBSLAM的localmapping</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
  </entry>
  <entry>
    <title>29.顺时针打印矩阵</title>
    <url>/2019/11/05/29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>定义2个变量保存行数和列数，定义4个变量保存边界值，然后使用4个循环就可以了</p><a id="more"></a>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        ret.clear();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(!matrix.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">            <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> bottom = row - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = col - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span>((top &lt;= bottom) &amp;&amp; (left &lt;= right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret.push_back(matrix[top][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret.push_back(matrix[i][right]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = right - <span class="number">1</span> ; i &gt;= left &amp;&amp; top &lt; bottom ; i--)    <span class="comment">//已经打印过了的不用再打印</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret.push_back(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top &amp;&amp; left &lt; right; i--)    <span class="comment">//已经打印过了的不用再打印</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret.push_back(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                top++;</span><br><span class="line">                right--;</span><br><span class="line">                bottom--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>28.对称的二叉树</title>
    <url>/2019/11/05/28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数，用来判断一颗二叉树是不是对称的。如果一颗二叉树和它的镜像一样，那么他是对称的。</p>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>ORB-SLAM2——Tracking</title>
    <url>/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94Tracking/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h1><p>作为ORB-SLAM2里三大线程中的第一个，Tracking线程接收传感器（摄像头）传来的每一帧，并将处理的关键帧传递给LocalMapping线程。Tracking线程其实是系统里的主线程，通过反复调用Track函数进行。<br>Tracking模块主要作用：</p><ul>
<li>单目地图的初始化</li>
<li>当前帧的位姿估计</li>
<li>当前帧的局部地图跟踪</li>
<li>生成候选关键帧</li>
</ul><a id="more"></a>

<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191104210725639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191114105531451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="System-TrackMonocular"><a href="#System-TrackMonocular" class="headerlink" title="System::TrackMonocular"></a>System::TrackMonocular</h1><p>将图片传给slam系统<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat System::TrackMonocular(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mSensor!=MONOCULAR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: you called TrackMonocular but input sensor was not set to Monocular."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check mode change</span></span><br><span class="line">    &#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lock(mMutexMode);</span><br><span class="line">        <span class="keyword">if</span>(mbActivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpLocalMapper-&gt;RequestStop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until Local Mapping has effectively stopped</span></span><br><span class="line">            <span class="keyword">while</span>(!mpLocalMapper-&gt;isStopped())</span><br><span class="line">            &#123;</span><br><span class="line">                usleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">true</span>);</span><br><span class="line">            mbActivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mbDeactivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">false</span>);</span><br><span class="line">            mpLocalMapper-&gt;Release();</span><br><span class="line">            mbDeactivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check reset</span></span><br><span class="line">    &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(mMutexReset);</span><br><span class="line">    <span class="keyword">if</span>(mbReset)</span><br><span class="line">    &#123;</span><br><span class="line">        mpTracker-&gt;Reset();</span><br><span class="line">        mbReset = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat Tcw = mpTracker-&gt;GrabImageMonocular(im,timestamp);</span><br><span class="line"></span><br><span class="line">    unique_lock&lt;mutex&gt; lock2(mMutexState);</span><br><span class="line">    mTrackingState = mpTracker-&gt;mState;</span><br><span class="line">    mTrackedMapPoints = mpTracker-&gt;mCurrentFrame.mvpMapPoints;</span><br><span class="line">    mTrackedKeyPointsUn = mpTracker-&gt;mCurrentFrame.mvKeysUn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Tcw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Tracking-GrabImageMonocular"><a href="#Tracking-GrabImageMonocular" class="headerlink" title="Tracking::GrabImageMonocular"></a>Tracking::GrabImageMonocular</h1><p>将RGB图像化为灰度图像，之后Frame() 建立新帧，提取特征点。数据流以Frame的形式进入Track()函数，输出世界坐标系到该帧相机坐标系的变换矩阵（注意此时返回的变换矩阵是tracking的位姿估计）。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat Tracking::GrabImageMonocular(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    mImGray = im;</span><br><span class="line">    <span class="comment">// 步骤1：将RGB或RGBA图像转为灰度图像</span></span><br><span class="line">    <span class="keyword">if</span>(mImGray.channels()==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mbRGB)</span><br><span class="line">            cvtColor(mImGray,mImGray,CV_RGB2GRAY);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cvtColor(mImGray,mImGray,CV_BGR2GRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mImGray.channels()==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mbRGB)</span><br><span class="line">            cvtColor(mImGray,mImGray,CV_RGBA2GRAY);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cvtColor(mImGray,mImGray,CV_BGRA2GRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤2：构造Frame</span></span><br><span class="line">    <span class="keyword">if</span>(mState==NOT_INITIALIZED || mState==NO_IMAGES_YET)<span class="comment">// 没有成功初始化的前一个状态就是NO_IMAGES_YET</span></span><br><span class="line">        mCurrentFrame = Frame(mImGray,timestamp,mpIniORBextractor,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mCurrentFrame = Frame(mImGray,timestamp,mpORBextractorLeft,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);</span><br><span class="line"></span><br><span class="line">    Track();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mCurrentFrame.mTcw.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Frame-Frame"><a href="#Frame-Frame" class="headerlink" title="Frame::Frame"></a>Frame::Frame</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Frame::Frame(<span class="keyword">const</span> cv::Mat &amp;imGray, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timeStamp, ORBextractor* extractor,ORBVocabulary* voc, cv::Mat &amp;K, cv::Mat &amp;distCoef, <span class="keyword">const</span> <span class="keyword">float</span> &amp;bf, <span class="keyword">const</span> <span class="keyword">float</span> &amp;thDepth)</span><br><span class="line">    :mpORBvocabulary(voc),mpORBextractorLeft(extractor),mpORBextractorRight(<span class="keyword">static_cast</span>&lt;ORBextractor*&gt;(<span class="literal">NULL</span>)),</span><br><span class="line">     mTimeStamp(timeStamp), mK(K.clone()),mDistCoef(distCoef.clone()), mbf(bf), mThDepth(thDepth)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Frame ID</span></span><br><span class="line">    mnId=nNextId++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale Level Info</span></span><br><span class="line">    mnScaleLevels = mpORBextractorLeft-&gt;GetLevels();</span><br><span class="line">    mfScaleFactor = mpORBextractorLeft-&gt;GetScaleFactor();</span><br><span class="line">    mfLogScaleFactor = <span class="built_in">log</span>(mfScaleFactor);</span><br><span class="line">    mvScaleFactors = mpORBextractorLeft-&gt;GetScaleFactors();</span><br><span class="line">    mvInvScaleFactors = mpORBextractorLeft-&gt;GetInverseScaleFactors();</span><br><span class="line">    mvLevelSigma2 = mpORBextractorLeft-&gt;GetScaleSigmaSquares();</span><br><span class="line">    mvInvLevelSigma2 = mpORBextractorLeft-&gt;GetInverseScaleSigmaSquares();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ORB extraction</span></span><br><span class="line">    ExtractORB(<span class="number">0</span>,imGray);</span><br><span class="line"></span><br><span class="line">    N = mvKeys.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mvKeys.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    UndistortKeyPoints();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set no stereo information</span></span><br><span class="line">    mvuRight = <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(N,<span class="number">-1</span>);</span><br><span class="line">    mvDepth = <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(N,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    mvpMapPoints = <span class="built_in">vector</span>&lt;MapPoint*&gt;(N,<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>));</span><br><span class="line">    mvbOutlier = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is done only for the first Frame (or after a change in the calibration)</span></span><br><span class="line">    <span class="keyword">if</span>(mbInitialComputations)</span><br><span class="line">    &#123;</span><br><span class="line">        ComputeImageBounds(imGray);</span><br><span class="line"></span><br><span class="line">        mfGridElementWidthInv=<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(FRAME_GRID_COLS)/<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mnMaxX-mnMinX);</span><br><span class="line">        mfGridElementHeightInv=<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(FRAME_GRID_ROWS)/<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mnMaxY-mnMinY);</span><br><span class="line"></span><br><span class="line">        fx = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        fy = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        cx = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        cy = K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        invfx = <span class="number">1.0f</span>/fx;</span><br><span class="line">        invfy = <span class="number">1.0f</span>/fy;</span><br><span class="line"></span><br><span class="line">        mbInitialComputations=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mb = mbf/fx;</span><br><span class="line"></span><br><span class="line">    AssignFeaturesToGrid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="void-Tracking-Track"><a href="#void-Tracking-Track" class="headerlink" title="void Tracking::Track()"></a>void Tracking::Track()</h1><ol>
<li><p>判断tracking状态：如果是未初始化（NOT_INITIALIZED），则对单目和非单目分别执行MonocularInitialization()、StereoInitialization()进行初始化，并更新地图视图。</p>
</li>
<li><p>对于初始化成功的，接下来进行跟踪ORB-SLAM中关于跟踪状态有两种选择（由mbOnlyTracking判断）</p>
<p>（1）只进行跟踪不建图</p>
<p>（2）同时跟踪和建图：</p>
</li>
</ol>
<p>初始化之后ORB-SLAM有三种跟踪模型可供选择</p>
<ul>
<li><p>a.TrackWithMotionModel(); 运动模型：根据运动模型估计当前帧位姿——根据匀速运动模型对上一帧的地图点进行跟踪——优化位姿。</p>
</li>
<li><p>b.TrackReferenceKeyFrame(); 关键帧模型：BoW搜索当前帧与参考帧的匹配点——将上一帧的位姿作为当前帧的初始值——通过优化3D-2D的重投影误差来获得位姿。</p>
</li>
<li><p>c.Relocalization()；重定位模型：计算当前帧的BoW——检测满足重定位条件的候选帧——通过BoW搜索当前帧与候选帧的匹配点——大于15个点就进行PnP位姿估计——优化。</p>
</li>
</ul>
<p>这三个模型的选择方法：</p>
<p>首先假设相机恒速（即Rt和上一帧相同），然后计算匹配点数（如果匹配足够多则认为跟踪成功），如果匹配点数目较少，说明恒速模型失效，则选择参考帧模型（即特征匹配，PnP求解），如果参考帧模型同样不能进行跟踪，说明两帧键没有相关性，这时需要进行重定位，即和已经产生的关键帧中进行匹配（看看是否到了之前已经到过的地方）确定相机位姿，如果重定位仍然不能成功，则说明跟踪彻底丢失，要么等待相机回转，要不进行重置。</p>
<h2 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::Track()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mState==NO_IMAGES_YET)</span><br><span class="line">    &#123;</span><br><span class="line">        mState = NOT_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastProcessedState=mState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Map Mutex -&gt; Map cannot be changed</span></span><br><span class="line">    unique_lock&lt;mutex&gt; lock(mpMap-&gt;mMutexMapUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mState==NOT_INITIALIZED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mSensor==System::STEREO || mSensor==System::RGBD)</span><br><span class="line">            StereoInitialization();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            MonocularInitialization();</span><br><span class="line"></span><br><span class="line">        mpFrameDrawer-&gt;Update(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mState!=OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tracking-MonocularInitialization"><a href="#Tracking-MonocularInitialization" class="headerlink" title="Tracking::MonocularInitialization()"></a>Tracking::MonocularInitialization()</h3><p>并行地计算基础矩阵和单应性矩阵，选取其中一个模型，恢复出最开始两帧之间的相对姿态以及点云，得到初始两帧的匹配、相对运动、初始MapPoints</p>
<ol>
<li>当第一次进入该方法的时候，没有先前的帧数据，将当前帧保存为初始帧和最后一帧，并初始化一个初始化器。</li>
<li>第二次进入该方法的时候，已经有初始化器了。 </li>
<li>利用ORB匹配器，对当前帧和初始帧进行匹配，对应关系小于100个时失败。 </li>
<li>利用八点法的对极约束，启动两个线程分别计算单应矩阵和基础矩阵，并通过score判断用单应矩阵回复运动轨迹还是使用基础矩阵回复运动轨迹。 </li>
<li>将初始帧和当前帧创建为关键帧，并创建地图点MapPoint </li>
<li>通过全局BundleAdjustment优化相机位姿和关键点坐标 </li>
<li>设置单位深度并缩放初试基线和地图点。 </li>
<li>其他变量的初始化。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::MonocularInitialization()<span class="comment">//单目初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果单目初始器还没有被创建，则创建单目初始器</span></span><br><span class="line">    <span class="keyword">if</span>(!mpInitializer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set Reference Frame</span></span><br><span class="line">        <span class="comment">// 单目初始帧的特征点数必须大于100</span></span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvKeys.size()&gt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤1：得到用于初始化的第一帧，初始化需要两帧</span></span><br><span class="line">            mInitialFrame = Frame(mCurrentFrame);</span><br><span class="line">            <span class="comment">// 记录最后的一帧</span></span><br><span class="line">            mLastFrame = Frame(mCurrentFrame);</span><br><span class="line">            <span class="comment">// mvbPrevMatched最大的情况就是所有特征点都被跟踪上</span></span><br><span class="line">            mvbPrevMatched.resize(mCurrentFrame.mvKeysUn.size());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.mvKeysUn.size(); i++)</span><br><span class="line">                mvbPrevMatched[i]=mCurrentFrame.mvKeysUn[i].pt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mpInitializer)</span><br><span class="line">                <span class="keyword">delete</span> mpInitializer;</span><br><span class="line">            <span class="comment">// 由当前帧构造初始器 sigma:1.0 iterations:200</span></span><br><span class="line">            mpInitializer =  <span class="keyword">new</span> Initializer(mCurrentFrame,<span class="number">1.0</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            fill(mvIniMatches.begin(),mvIniMatches.end(),<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//如果是第二次进入，已经创建了初始器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Try to initialize</span></span><br><span class="line">        <span class="comment">// 步骤2：如果当前帧特征点数大于100，则得到用于单目初始化的第二帧</span></span><br><span class="line">        <span class="comment">// 如果当前帧特征点太少，重新构造初始器</span></span><br><span class="line">        <span class="comment">// 因此只有连续两帧的特征点个数都大于100时，才能继续进行初始化过程</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)mCurrentFrame.mvKeys.size()&lt;=<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mpInitializer;</span><br><span class="line">            mpInitializer = <span class="keyword">static_cast</span>&lt;Initializer*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">            fill(mvIniMatches.begin(),mvIniMatches.end(),<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find correspondences</span></span><br><span class="line">        <span class="comment">// 步骤3：在mInitialFrame与mCurrentFrame中找匹配的特征点对</span></span><br><span class="line">        <span class="comment">// mvbPrevMatched为前一帧的特征点，存储了mInitialFrame中哪些点将进行接下来的匹配</span></span><br><span class="line">        <span class="comment">// mvIniMatches存储mInitialFrame,mCurrentFrame之间匹配的特征点</span></span><br><span class="line">        <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.9</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> nmatches = matcher.SearchForInitialization(mInitialFrame,mCurrentFrame,mvbPrevMatched,mvIniMatches,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if there are enough correspondences</span></span><br><span class="line">        <span class="comment">// 步骤4：如果初始化的两帧之间的匹配点太少，重新初始</span></span><br><span class="line">        <span class="keyword">if</span>(nmatches&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mpInitializer;</span><br><span class="line">            mpInitializer = <span class="keyword">static_cast</span>&lt;Initializer*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::Mat Rcw; <span class="comment">// Current Camera Rotation</span></span><br><span class="line">        cv::Mat tcw; <span class="comment">// Current Camera Translation</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbTriangulated; <span class="comment">// Triangulated Correspondences (mvIniMatches)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤5：通过H模型或F模型进行单目初始化，得到两帧间相对运动、初始MapPoints</span></span><br><span class="line">        <span class="keyword">if</span>(mpInitializer-&gt;Initialize(mCurrentFrame, mvIniMatches, Rcw, tcw, mvIniP3D, vbTriangulated))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤6：删除那些无法进行三角化的匹配点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>, iend=mvIniMatches.size(); i&lt;iend;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mvIniMatches[i]&gt;=<span class="number">0</span> &amp;&amp; !vbTriangulated[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    mvIniMatches[i]=<span class="number">-1</span>;</span><br><span class="line">                    nmatches--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set Frame Poses</span></span><br><span class="line">            <span class="comment">// 将初始化的第一帧作为世界坐标系，因此第一帧变换矩阵为单位矩阵</span></span><br><span class="line">            mInitialFrame.SetPose(cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F));</span><br><span class="line">            <span class="comment">// 由Rcw和tcw构造Tcw,并赋值给mTcw，mTcw为世界坐标系到该帧的变换矩阵</span></span><br><span class="line">            cv::Mat Tcw = cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F);</span><br><span class="line">            Rcw.copyTo(Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).colRange(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">            tcw.copyTo(Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).col(<span class="number">3</span>));</span><br><span class="line">            mCurrentFrame.SetPose(Tcw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤6：将三角化得到的3D点包装成MapPoints</span></span><br><span class="line">            <span class="comment">// Initialize函数会得到mvIniP3D，</span></span><br><span class="line">            <span class="comment">// mvIniP3D是cv::Point3f类型的一个容器，是个存放3D点的临时变量，</span></span><br><span class="line">            <span class="comment">// CreateInitialMapMonocular将3D点包装成MapPoint类型存入KeyFrame和Map中</span></span><br><span class="line">            CreateInitialMapMonocular();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="void-Tracking-CreateInitialMapMonocular"><a href="#void-Tracking-CreateInitialMapMonocular" class="headerlink" title="void Tracking::CreateInitialMapMonocular()"></a>void Tracking::CreateInitialMapMonocular()</h4><blockquote>
<ol>
<li>当第一次进入该方法的时候，没有先前的帧数据，将当前帧保存为初始帧和最后一帧，并初始化一个初始化器。</li>
<li>利用ORB匹配器，对当前帧和初始帧进行匹配，对应关系小于100个时失败。</li>
<li>利用八点法的对极约束，启动两个线程分别计算单应矩阵和基础矩阵，并通过score判断用单应矩阵&gt;回复运动轨迹还是使用基础矩阵回复运动轨迹。  </li>
<li>将初始帧和当前帧创建为关键帧，并创建地图点MapPoint </li>
<li>通过全局BundleAdjustment优化相机位姿和关键点坐标 </li>
<li>设置单位深度并缩放初试基线和地图点。  </li>
<li>其他变量的初始化。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">void</span> Tracking::CreateInitialMapMonocular()</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="comment">// 创建两帧，一个为初始帧，一个为当前帧</span></span><br><span class="line">&gt;KeyFrame* pKFini = <span class="keyword">new</span> KeyFrame(mInitialFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">&gt;KeyFrame* pKFcur = <span class="keyword">new</span> KeyFrame(mCurrentFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">&gt;<span class="comment">// 步骤1：将初始关键帧的描述子转为BoW</span></span><br><span class="line">&gt;pKFini-&gt;ComputeBoW();</span><br><span class="line">&gt;<span class="comment">// 步骤2：将当前关键帧的描述子转为BoW</span></span><br><span class="line">&gt;pKFcur-&gt;ComputeBoW();</span><br><span class="line">&gt;<span class="comment">// Insert KFs in the map</span></span><br><span class="line">&gt;<span class="comment">// 步骤3：将关键帧插入到地图</span></span><br><span class="line">&gt;<span class="comment">// 凡是关键帧，都要插入地图</span></span><br><span class="line">&gt;mpMap-&gt;AddKeyFrame(pKFini);</span><br><span class="line">&gt;mpMap-&gt;AddKeyFrame(pKFcur);</span><br><span class="line">&gt;<span class="comment">// Create MapPoints and asscoiate to keyframes</span></span><br><span class="line">&gt;<span class="comment">// 步骤4：将3D点包装成MapPoints</span></span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;mvIniMatches.size();i++)<span class="comment">//遍历所有匹配</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span>(mvIniMatches[i]&lt;<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">//Create MapPoint.</span></span><br><span class="line">  cv::<span class="function">Mat <span class="title">worldPos</span><span class="params">(mvIniP3D[i])</span></span>;</span><br><span class="line">  <span class="comment">// 步骤4.1：用3D点构造MapPoint</span></span><br><span class="line">  MapPoint* pMP = <span class="keyword">new</span> MapPoint(worldPos,pKFcur,mpMap);</span><br><span class="line">  <span class="comment">// 步骤4.2：为该MapPoint添加属性：</span></span><br><span class="line">  <span class="comment">// a.观测到该MapPoint的关键帧</span></span><br><span class="line">  <span class="comment">// b.该MapPoint的描述子</span></span><br><span class="line">  <span class="comment">// c.该MapPoint的平均观测方向和深度范围</span></span><br><span class="line">  <span class="comment">// 步骤4.3：表示该KeyFrame的哪个特征点可以观测到哪个3D点</span></span><br><span class="line">pKFini-&gt;AddMapPoint(pMP,i);</span><br><span class="line">  pKFcur-&gt;AddMapPoint(pMP,mvIniMatches[i]);</span><br><span class="line">  <span class="comment">// a.表示该MapPoint可以被哪个KeyFrame的哪个特征点观测到</span></span><br><span class="line">  pMP-&gt;AddObservation(pKFini,i);</span><br><span class="line">  pMP-&gt;AddObservation(pKFcur,mvIniMatches[i]);</span><br><span class="line">  <span class="comment">// b.从众多观测到该MapPoint的特征点中挑选区分读最高的描述子</span></span><br><span class="line">  pMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line"> <span class="comment">// c.更新该MapPoint平均观测方向以及观测距离的范围</span></span><br><span class="line">  pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line">  <span class="comment">//Fill Current Frame structure</span></span><br><span class="line">  mCurrentFrame.mvpMapPoints[mvIniMatches[i]] = pMP;</span><br><span class="line">  mCurrentFrame.mvbOutlier[mvIniMatches[i]] = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//Add to Map</span></span><br><span class="line">  <span class="comment">// 步骤4.4：在地图中添加该MapPoint</span></span><br><span class="line">  mpMap-&gt;AddMapPoint(pMP);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// Update Connections</span></span><br><span class="line">&gt;<span class="comment">// 步骤5：更新关键帧间的连接关系</span></span><br><span class="line">&gt;<span class="comment">// 在3D点和关键帧之间建立边，每个边有一个权重，边的权重是该关键帧与当前帧公共3D点的个数</span></span><br><span class="line">&gt;pKFini-&gt;UpdateConnections();</span><br><span class="line">&gt;pKFcur-&gt;UpdateConnections();</span><br><span class="line">&gt;<span class="comment">// Bundle Adjustment</span></span><br><span class="line">&gt;<span class="built_in">cout</span> &lt;&lt; <span class="string">"New Map created with "</span> &lt;&lt; mpMap-&gt;MapPointsInMap() &lt;&lt; <span class="string">" points"</span> &lt;&lt; <span class="built_in">endl</span>；</span><br><span class="line">&gt;<span class="comment">// 步骤5：BA优化</span></span><br><span class="line">&gt;Optimizer::GlobalBundleAdjustemnt(mpMap,<span class="number">20</span>);</span><br><span class="line">&gt;<span class="comment">// Set median depth to 1</span></span><br><span class="line">&gt;<span class="comment">// 步骤6：!!!将MapPoints的中值深度归一化到1，并归一化两帧之间变换</span></span><br><span class="line">&gt;<span class="comment">// 评估关键帧场景深度，q=2表示中值</span></span><br><span class="line">&gt;<span class="keyword">float</span> medianDepth = pKFini-&gt;ComputeSceneMedianDepth(<span class="number">2</span>);</span><br><span class="line">&gt;<span class="keyword">float</span> invMedianDepth = <span class="number">1.0f</span>/medianDepth;</span><br><span class="line">&gt;<span class="keyword">if</span>(medianDepth&lt;<span class="number">0</span> || pKFcur-&gt;TrackedMapPoints(<span class="number">1</span>)&lt;<span class="number">100</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong initialization, reseting..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  Reset();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// Scale initial baseline</span></span><br><span class="line">&gt;cv::Mat Tc2w = pKFcur-&gt;GetPose();</span><br><span class="line">&gt;<span class="comment">// x/z y/z 将z归一化到1 </span></span><br><span class="line">&gt;Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>) = Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>)*invMedianDepth;</span><br><span class="line">&gt;pKFcur-&gt;SetPose(Tc2w);</span><br><span class="line">&gt;<span class="comment">// Scale point</span></span><br><span class="line">&gt;<span class="comment">// 把3D点的尺度也归一化到</span></span><br><span class="line">&gt;<span class="built_in">vector</span>&lt;MapPoint*&gt; vpAllMapPoints = pKFini-&gt;GetMapPointMatches();</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">size_t</span> iMP=<span class="number">0</span>; iMP&lt;vpAllMapPoints.size(); iMP++)</span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(vpAllMapPoints[iMP])</span><br><span class="line">  &#123;</span><br><span class="line">      MapPoint* pMP = vpAllMapPoints[iMP];</span><br><span class="line">      pMP-&gt;SetWorldPos(pMP-&gt;GetWorldPos()*invMedianDepth);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 这部分和SteroInitialization()相似</span></span><br><span class="line">&gt;mpLocalMapper-&gt;InsertKeyFrame(pKFini);</span><br><span class="line">&gt;mpLocalMapper-&gt;InsertKeyFrame(pKFcur);</span><br><span class="line">&gt;mCurrentFrame.SetPose(pKFcur-&gt;GetPose());</span><br><span class="line">&gt;mnLastKeyFrameId=mCurrentFrame.mnId;</span><br><span class="line">&gt;mpLastKeyFrame = pKFcur;</span><br><span class="line">&gt;mvpLocalKeyFrames.push_back(pKFcur)</span><br><span class="line">&gt;mvpLocalKeyFrames.push_back(pKFini);</span><br><span class="line">&gt;mvpLocalMapPoints=mpMap-&gt;GetAllMapPoints();</span><br><span class="line">&gt;mpReferenceKF = pKFcur;</span><br><span class="line">&gt;mCurrentFrame.mpReferenceKF = pKFcur;</span><br><span class="line">&gt;mLastFrame = Frame(mCurrentFrame);</span><br><span class="line">&gt;mpMap-&gt;SetReferenceMapPoints(mvpLocalMapPoints)</span><br><span class="line">&gt;mpMapDrawer-&gt;SetCurrentCameraPose(pKFcur-&gt;GetPose());</span><br><span class="line">&gt;mpMap-&gt;mvpKeyFrameOrigins.push_back(pKFini);</span><br><span class="line">&gt;mState=OK;<span class="comment">// 初始化成功，至此，初始化过程完成 </span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="跟踪部分"><a href="#跟踪部分" class="headerlink" title="跟踪部分"></a>跟踪部分</h2><h3 id="跟踪步骤1"><a href="#跟踪步骤1" class="headerlink" title="跟踪步骤1"></a>跟踪步骤1</h3><ul>
<li>局部地图激活(!mbOnlyTracking)：如果(mState==OK)，CheckReplacedInLastFrame()首先更新上一帧被替换的MapPoints，然后如果特征点匹配太少，需要匹配参考关键帧bOK = TrackReferenceKeyFrame()，否则根据匀速运动模型匹配bOK = TrackWithMotionModel()。特殊情况初始化跟踪失败需要重定位bOK = Relocalization();  </li>
<li>局部地图不工作，只跟踪当前地图中地图点：<blockquote>
<p>1.if :(mState==LOST)，需要重定位Relocalization()。<br>2.else: 当匹配特征点不够多，小于10个，使用运动模型和重定位计算两种相机位姿，如果重定位失败，保持VO结果，否则更相信重定位结果。</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span><span class="comment">//步骤2：跟踪</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// System is initialized. Track Frame.</span></span><br><span class="line">    <span class="comment">// bOK为临时变量，用于表示每个函数是否执行成功</span></span><br><span class="line">    <span class="keyword">bool</span> bOK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initial camera pose estimation using motion model or relocalization (if tracking is lost)</span></span><br><span class="line">    <span class="comment">// 在viewer中有个开关menuLocalizationMode，有它控制是否ActivateLocalizationMode，并最终管控mbOnlyTracking</span></span><br><span class="line">    <span class="comment">// mbOnlyTracking等于false表示正常VO模式（有地图更新），mbOnlyTracking等于true表示用户手动选择定位模式</span></span><br><span class="line">    <span class="keyword">if</span>(!mbOnlyTracking)<span class="comment">//mbOnlyTracking==false</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Local Mapping is activated. This is the normal behaviour, unless</span></span><br><span class="line">        <span class="comment">// you explicitly activate the "only tracking" mode.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常初始化成功</span></span><br><span class="line">        <span class="keyword">if</span>(mState==OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Local Mapping might have changed some MapPoints tracked in last frame</span></span><br><span class="line">            <span class="comment">// 检查并更新上一帧被替换的MapPoints</span></span><br><span class="line">            <span class="comment">// 更新Fuse函数和SearchAndFuse函数替换的MapPoints</span></span><br><span class="line">            CheckReplacedInLastFrame();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤2.1：跟踪上一帧或者参考帧或者重定位</span></span><br><span class="line">            <span class="comment">// 上一帧速度为0或当前帧与上一次重定位帧之间ID差大于2，跟踪关键帧</span></span><br><span class="line">            <span class="comment">// mnLastRelocFrameId上一次重定位的那一帧</span></span><br><span class="line">            <span class="keyword">if</span>(mVelocity.empty() || mCurrentFrame.mnId&lt;mnLastRelocFrameId+<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将上一帧的位姿作为当前帧的初始位姿</span></span><br><span class="line">                <span class="comment">// 通过BoW的方式在参考帧中找当前帧特征点的匹配点</span></span><br><span class="line">                <span class="comment">// 优化每个特征点都对应3D点重投影误差即可得到位姿</span></span><br><span class="line">                bOK = TrackReferenceKeyFrame();<span class="comment">//跟踪参考帧</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据恒速模型设定当前帧的初始位姿</span></span><br><span class="line">                <span class="comment">// 通过投影的方式在参考帧中找当前帧特征点的匹配点</span></span><br><span class="line">                <span class="comment">// 优化每个特征点所对应3D点的投影误差即可得到位姿</span></span><br><span class="line">                <span class="comment">// 应该只要mVelocity不为空，就优先选择TrackWithMotionModel</span></span><br><span class="line">                bOK = TrackWithMotionModel();<span class="comment">//根据固定运动速度模型预测当前帧的位姿</span></span><br><span class="line">                <span class="keyword">if</span>(!bOK)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TrackReferenceKeyFrame是跟踪参考帧，不能根据固定运动速度模型预测当前帧的位姿态，通过bow加速匹配（SearchByBow）</span></span><br><span class="line">                <span class="comment">// 最后通过优化得到优化后的位姿</span></span><br><span class="line">                    bOK = TrackReferenceKeyFrame();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//初始化失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// BOW搜索，PnP求解位姿</span></span><br><span class="line">            bOK = Relocalization();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//没有激活局部地图，只进行跟踪tracking</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Localization Mode: Local Mapping is deactivated</span></span><br><span class="line">        <span class="comment">// 步骤2.1：跟踪上一帧或者参考帧或者重定位</span></span><br><span class="line">        <span class="comment">// tracking跟丢了</span></span><br><span class="line">        <span class="keyword">if</span>(mState==LOST)</span><br><span class="line">        &#123;</span><br><span class="line">            bOK = Relocalization();<span class="comment">//判断重定位成功与否标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// mbVO是mbOnlyTracking为true时的才有的一个变量</span></span><br><span class="line">            <span class="comment">// mbVO为false表示此帧匹配了很多的MapPoints，跟踪很正常，</span></span><br><span class="line">            <span class="comment">// mbVO为true表明此帧匹配了很少的MapPoints，少于10个，要跪的节奏</span></span><br><span class="line">            <span class="keyword">if</span>(!mbVO)<span class="comment">//跟踪正常, mbVO为false则表明此帧匹配了很多的3D map点，非常好</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// In last frame we tracked enough MapPoints in the map</span></span><br><span class="line">                <span class="keyword">if</span>(!mVelocity.empty())<span class="comment">//上一帧有速度，跟踪模型</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bOK = TrackWithMotionModel();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//上一帧没速度，跟踪关键帧</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bOK = TrackReferenceKeyFrame();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//特征点不够多,小于10个</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// In last frame we tracked mainly "visual odometry" points.</span></span><br><span class="line">                <span class="comment">// We compute two camera poses, one from motion model and one doing relocalization.</span></span><br><span class="line">                <span class="comment">// If relocalization is sucessfull we choose that solution, otherwise we retain the "visual odometry" solution.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 先使用运动模型和重定位计算两种相机位姿，如果重定位失败，保持VO结果</span></span><br><span class="line">                    <span class="comment">// mbVO为1，则表明此帧匹配了很少的3D map点，少于10个，要跪的节奏，既做跟踪又做定位</span></span><br><span class="line">                <span class="keyword">bool</span> bOKMM = <span class="literal">false</span>;<span class="comment">//运动模型是否成功判断标志</span></span><br><span class="line">                <span class="keyword">bool</span> bOKReloc = <span class="literal">false</span>;<span class="comment">//重定位是否成功判断标志</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMPsMM;<span class="comment">//记录地图点</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbOutMM;<span class="comment">//记录外点</span></span><br><span class="line">                cv::Mat TcwMM;<span class="comment">//变换矩阵</span></span><br><span class="line">                <span class="keyword">if</span>(!mVelocity.empty())<span class="comment">//有速度</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bOKMM = TrackWithMotionModel();<span class="comment">//用运动模型追踪</span></span><br><span class="line">                    vpMPsMM = mCurrentFrame.mvpMapPoints;<span class="comment">//记录地图点</span></span><br><span class="line">                    vbOutMM = mCurrentFrame.mvbOutlier;<span class="comment">//记录外点</span></span><br><span class="line">                    TcwMM = mCurrentFrame.mTcw.clone();<span class="comment">//当前帧的变换矩阵</span></span><br><span class="line">                &#125;</span><br><span class="line">                bOKReloc = Relocalization();<span class="comment">//用重定位</span></span><br><span class="line">                <span class="comment">// 重定位没有成功，但是运动模型跟踪成功</span></span><br><span class="line">                <span class="keyword">if</span>(bOKMM &amp;&amp; !bOKReloc)</span><br><span class="line">                &#123;</span><br><span class="line">                    mCurrentFrame.SetPose(TcwMM);</span><br><span class="line">                    mCurrentFrame.mvpMapPoints = vpMPsMM;</span><br><span class="line">                    mCurrentFrame.mvbOutlier = vbOutMM;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(mbVO)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 更新当前帧的MapPoints被观测程度</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i] &amp;&amp; !mCurrentFrame.mvbOutlier[i])</span><br><span class="line">                            &#123;</span><br><span class="line">                                mCurrentFrame.mvpMapPoints[i]-&gt;IncreaseFound();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(bOKReloc)<span class="comment">// 只要重定位成功整个跟踪过程正常进行（定位与跟踪，更相信重定位）</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mbVO = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bOK = bOKReloc || bOKMM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 将最新的关键帧作为reference frame</span></span><br><span class="line">    mCurrentFrame.mpReferenceKF = mpReferenceKF;</span><br></pre></td></tr></table></figure>
<h4 id="void-Tracking-CheckReplacedInLastFrame"><a href="#void-Tracking-CheckReplacedInLastFrame" class="headerlink" title="void Tracking::CheckReplacedInLastFrame()"></a>void Tracking::CheckReplacedInLastFrame()</h4><p>ocal Mapping线程可能会将关键帧中某些MapPoints进行替换，由于tracking中需要用到mLastFrame，这里检查并更新上一帧中被替换的MapPoints</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::CreateInitialMapMonocular()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create KeyFrames</span></span><br><span class="line">    <span class="comment">// 创建两帧，一个为初始帧，一个为当前帧</span></span><br><span class="line">    KeyFrame* pKFini = <span class="keyword">new</span> KeyFrame(mInitialFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">    KeyFrame* pKFcur = <span class="keyword">new</span> KeyFrame(mCurrentFrame,mpMap,mpKeyFrameDB);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：将初始关键帧的描述子转为BoW</span></span><br><span class="line">    pKFini-&gt;ComputeBoW();</span><br><span class="line">    <span class="comment">// 步骤2：将当前关键帧的描述子转为BoW</span></span><br><span class="line">    pKFcur-&gt;ComputeBoW();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert KFs in the map</span></span><br><span class="line">    <span class="comment">// 步骤3：将关键帧插入到地图</span></span><br><span class="line">    <span class="comment">// 凡是关键帧，都要插入地图</span></span><br><span class="line">    mpMap-&gt;AddKeyFrame(pKFini);</span><br><span class="line">    mpMap-&gt;AddKeyFrame(pKFcur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create MapPoints and asscoiate to keyframes</span></span><br><span class="line">    <span class="comment">// 步骤4：将3D点包装成MapPoints</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;mvIniMatches.size();i++)<span class="comment">//遍历所有匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mvIniMatches[i]&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create MapPoint.</span></span><br><span class="line">        cv::<span class="function">Mat <span class="title">worldPos</span><span class="params">(mvIniP3D[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤4.1：用3D点构造MapPoint</span></span><br><span class="line">        MapPoint* pMP = <span class="keyword">new</span> MapPoint(worldPos,pKFcur,mpMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤4.2：为该MapPoint添加属性：</span></span><br><span class="line">        <span class="comment">// a.观测到该MapPoint的关键帧</span></span><br><span class="line">        <span class="comment">// b.该MapPoint的描述子</span></span><br><span class="line">        <span class="comment">// c.该MapPoint的平均观测方向和深度范围</span></span><br><span class="line">        <span class="comment">// 步骤4.3：表示该KeyFrame的哪个特征点可以观测到哪个3D点</span></span><br><span class="line">        pKFini-&gt;AddMapPoint(pMP,i);</span><br><span class="line">        pKFcur-&gt;AddMapPoint(pMP,mvIniMatches[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a.表示该MapPoint可以被哪个KeyFrame的哪个特征点观测到</span></span><br><span class="line">        pMP-&gt;AddObservation(pKFini,i);</span><br><span class="line">        pMP-&gt;AddObservation(pKFcur,mvIniMatches[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.从众多观测到该MapPoint的特征点中挑选区分读最高的描述子</span></span><br><span class="line">        pMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line">        <span class="comment">// c.更新该MapPoint平均观测方向以及观测距离的范围</span></span><br><span class="line">        pMP-&gt;UpdateNormalAndDepth();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Fill Current Frame structure</span></span><br><span class="line">        mCurrentFrame.mvpMapPoints[mvIniMatches[i]] = pMP;</span><br><span class="line">        mCurrentFrame.mvbOutlier[mvIniMatches[i]] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Add to Map</span></span><br><span class="line">        <span class="comment">// 步骤4.4：在地图中添加该MapPoint</span></span><br><span class="line">        mpMap-&gt;AddMapPoint(pMP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update Connections</span></span><br><span class="line">    <span class="comment">// 步骤5：更新关键帧间的连接关系</span></span><br><span class="line">    <span class="comment">// 在3D点和关键帧之间建立边，每个边有一个权重，边的权重是该关键帧与当前帧公共3D点的个数</span></span><br><span class="line">    pKFini-&gt;UpdateConnections();</span><br><span class="line">    pKFcur-&gt;UpdateConnections();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bundle Adjustment</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"New Map created with "</span> &lt;&lt; mpMap-&gt;MapPointsInMap() &lt;&lt; <span class="string">" points"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 步骤5：BA优化</span></span><br><span class="line">    Optimizer::GlobalBundleAdjustemnt(mpMap,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set median depth to 1</span></span><br><span class="line">    <span class="comment">// 步骤6：!!!将MapPoints的中值深度归一化到1，并归一化两帧之间变换</span></span><br><span class="line">    <span class="comment">// 评估关键帧场景深度，q=2表示中值</span></span><br><span class="line">    <span class="keyword">float</span> medianDepth = pKFini-&gt;ComputeSceneMedianDepth(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">float</span> invMedianDepth = <span class="number">1.0f</span>/medianDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(medianDepth&lt;<span class="number">0</span> || pKFcur-&gt;TrackedMapPoints(<span class="number">1</span>)&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong initialization, reseting..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Reset();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale initial baseline</span></span><br><span class="line">    cv::Mat Tc2w = pKFcur-&gt;GetPose();</span><br><span class="line">    <span class="comment">// x/z y/z 将z归一化到1</span></span><br><span class="line">    Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>) = Tc2w.col(<span class="number">3</span>).rowRange(<span class="number">0</span>,<span class="number">3</span>)*invMedianDepth;</span><br><span class="line">    pKFcur-&gt;SetPose(Tc2w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale points</span></span><br><span class="line">    <span class="comment">// 把3D点的尺度也归一化到</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpAllMapPoints = pKFini-&gt;GetMapPointMatches();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> iMP=<span class="number">0</span>; iMP&lt;vpAllMapPoints.size(); iMP++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vpAllMapPoints[iMP])</span><br><span class="line">        &#123;</span><br><span class="line">            MapPoint* pMP = vpAllMapPoints[iMP];</span><br><span class="line">            pMP-&gt;SetWorldPos(pMP-&gt;GetWorldPos()*invMedianDepth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部分和SteroInitialization()相似</span></span><br><span class="line">    mpLocalMapper-&gt;InsertKeyFrame(pKFini);</span><br><span class="line">    mpLocalMapper-&gt;InsertKeyFrame(pKFcur);</span><br><span class="line"></span><br><span class="line">    mCurrentFrame.SetPose(pKFcur-&gt;GetPose());</span><br><span class="line">    mnLastKeyFrameId=mCurrentFrame.mnId;</span><br><span class="line">    mpLastKeyFrame = pKFcur;</span><br><span class="line"></span><br><span class="line">    mvpLocalKeyFrames.push_back(pKFcur);</span><br><span class="line">    mvpLocalKeyFrames.push_back(pKFini);</span><br><span class="line">    mvpLocalMapPoints=mpMap-&gt;GetAllMapPoints();</span><br><span class="line">    mpReferenceKF = pKFcur;</span><br><span class="line">    mCurrentFrame.mpReferenceKF = pKFcur;</span><br><span class="line"></span><br><span class="line">    mLastFrame = Frame(mCurrentFrame);</span><br><span class="line"></span><br><span class="line">    mpMap-&gt;SetReferenceMapPoints(mvpLocalMapPoints);</span><br><span class="line"></span><br><span class="line">    mpMapDrawer-&gt;SetCurrentCameraPose(pKFcur-&gt;GetPose());</span><br><span class="line"></span><br><span class="line">    mpMap-&gt;mvpKeyFrameOrigins.push_back(pKFini);</span><br><span class="line"></span><br><span class="line">    mState=OK;<span class="comment">// 初始化成功，至此，初始化过程完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-TrackReferenceKeyFrame"><a href="#bool-Tracking-TrackReferenceKeyFrame" class="headerlink" title="bool Tracking::TrackReferenceKeyFrame()"></a>bool Tracking::TrackReferenceKeyFrame()</h4><p>关键帧中查找BOW相近的帧，进行匹配优化位姿</p>
<ul>
<li>1.按照关键帧进行Track的方法和运动模式恢复相机运动位姿的方法接近。首先求解当前帧的BOW向量。 </li>
<li>2.再搜索当前帧和关键帧之间的关键点匹配关系，如果这个匹配关系小于15对的话，就Track失败了。 </li>
<li>3.接着将当前帧的位置假定到上一帧的位置那里 </li>
<li>4.并通过最小二乘法优化相机的位姿。 </li>
<li>5.最后依然是抛弃无用的杂点，当match数大于等于10的时候，返回true成功。 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::TrackReferenceKeyFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compute Bag of Words vector</span></span><br><span class="line">    <span class="comment">//mCurrentFrame.ComputeBoW()将当前帧的描述子转为BOW向量，加块匹配速度</span></span><br><span class="line">    mCurrentFrame.ComputeBoW();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We perform first an ORB matching with the reference keyframe</span></span><br><span class="line">    <span class="comment">// If enough matches are found we setup a PnP solver</span></span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.7</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMapPointMatches;</span><br><span class="line">    <span class="comment">//matcher.SearchByBoW()通过特征点的BoW加快当前帧与参考帧之间的特征点匹配</span></span><br><span class="line">    <span class="keyword">int</span> nmatches = matcher.SearchByBoW(mpReferenceKF,mCurrentFrame,vpMapPointMatches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nmatches&lt;<span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    mCurrentFrame.mvpMapPoints = vpMapPointMatches;</span><br><span class="line">    <span class="comment">//mCurrentFrame.SetPose(mLastFrame.mTcw)将上一帧的位姿态作为当前帧位姿的初始值</span></span><br><span class="line">    mCurrentFrame.SetPose(mLastFrame.mTcw);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PoseOptimization通过优化3D-2D的重投影误差来获得位姿</span></span><br><span class="line">    Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discard outliers</span></span><br><span class="line">    <span class="comment">//剔除优化后的outlier匹配点（MapPoints）</span></span><br><span class="line">    <span class="keyword">int</span> nmatchesMap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[i])</span><br><span class="line">            &#123;</span><br><span class="line">                MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line"></span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">                mCurrentFrame.mvbOutlier[i]=<span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mbTrackInView = <span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mnLastFrameSeen = mCurrentFrame.mnId;</span><br><span class="line">                nmatches--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)</span><br><span class="line">                nmatchesMap++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nmatchesMap&gt;=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-TrackWithMotionModel"><a href="#bool-Tracking-TrackWithMotionModel" class="headerlink" title="bool Tracking::TrackWithMotionModel()"></a>bool Tracking::TrackWithMotionModel()</h4><p>假设匀速运动，用上一帧位姿和速度估计当前帧位姿。方法：上一帧地图点投影到当前帧，完成匹配。</p>
<ul>
<li><p>1.先通过上一帧的位姿和速度预测当前帧相机的位姿</p>
</li>
<li><p>2.通过PnP方法估计相机位姿，在将上一帧的地图点投影到当前固定大小范围的帧平面上，如果匹配点少，那么扩大两倍的采点范围。</p>
</li>
<li><p>3.然后进行一次BA算法，通过最小二乘法优化相机的位姿。</p>
</li>
<li><p>4.优化位姿之后，对当前帧的关键点和地图点，抛弃无用的杂点，剩下的点供下一次操作使用。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::TrackWithMotionModel()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.9</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Update last frame pose according to its reference keyframe</span></span><br><span class="line">    <span class="comment">// Create "visual odometry" points</span></span><br><span class="line">    <span class="comment">// 步骤1：对于双目或rgbd摄像头，根据深度值为上一关键帧生成新的MapPoints</span></span><br><span class="line">    <span class="comment">// （跟踪过程中需要将当前帧与上一帧进行特征点匹配，将上一帧的MapPoints投影到当前帧可以缩小匹配范围）</span></span><br><span class="line">    <span class="comment">// 在跟踪过程中，去除outlier的MapPoint，如果不及时增加MapPoint会逐渐减少</span></span><br><span class="line">    <span class="comment">// 这个函数的功能就是补充增加RGBD和双目相机上一帧的MapPoints数</span></span><br><span class="line">    UpdateLastFrame();</span><br><span class="line">    <span class="comment">// 根据Const Velocity Model(认为这两帧之间的相对运动和之前两帧间相对运动相同)估计当前帧的位姿</span></span><br><span class="line">    mCurrentFrame.SetPose(mVelocity*mLastFrame.mTcw);<span class="comment">//当前帧位置等于mVelocity*mLastFrame.mTcw</span></span><br><span class="line"> </span><br><span class="line">    fill(mCurrentFrame.mvpMapPoints.begin(),mCurrentFrame.mvpMapPoints.end(),<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// Project points seen in previous frame</span></span><br><span class="line">    <span class="keyword">int</span> th;</span><br><span class="line">    <span class="keyword">if</span>(mSensor!=System::STEREO)<span class="comment">//非双目搜索范围系数设为15</span></span><br><span class="line">        th=<span class="number">15</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        th=<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：根据匀速度模型进行对上一帧的MapPoints进行跟踪</span></span><br><span class="line">    <span class="comment">// 根据上一帧特征点对应的3D点投影的位置缩小特征点匹配范围</span></span><br><span class="line">    <span class="keyword">int</span> nmatches = matcher.SearchByProjection(mCurrentFrame,mLastFrame,th,mSensor==System::MONOCULAR);</span><br><span class="line">    <span class="comment">// If few matches, uses a wider window search</span></span><br><span class="line">    <span class="comment">// 如果跟踪的点少，则扩大搜索半径再来一次</span></span><br><span class="line">    <span class="keyword">if</span>(nmatches&lt;<span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fill(mCurrentFrame.mvpMapPoints.begin(),mCurrentFrame.mvpMapPoints.end(),<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>));</span><br><span class="line">        nmatches = matcher.SearchByProjection(mCurrentFrame,mLastFrame,<span class="number">2</span>*th,mSensor==System::MONOCULAR); <span class="comment">// 2*th</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(nmatches&lt;<span class="number">20</span>)<span class="comment">//如果匹配点少于20，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Optimize frame pose with all matches</span></span><br><span class="line">    <span class="comment">// 步骤3：优化位姿</span></span><br><span class="line">    Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">    <span class="comment">// Discard outliers</span></span><br><span class="line">    <span class="comment">// 步骤4：优化位姿后剔除outlier的mvpMapPoints</span></span><br><span class="line">    <span class="keyword">int</span> nmatchesMap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[i])</span><br><span class="line">            &#123;</span><br><span class="line">                MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">                mCurrentFrame.mvbOutlier[i]=<span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mbTrackInView = <span class="literal">false</span>;</span><br><span class="line">                pMP-&gt;mnLastFrameSeen = mCurrentFrame.mnId;</span><br><span class="line">                nmatches--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)</span><br><span class="line">                nmatchesMap++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(mbOnlyTracking)<span class="comment">//如果仅跟踪</span></span><br><span class="line">    &#123;</span><br><span class="line">        mbVO = nmatchesMap&lt;<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> nmatches&gt;<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nmatchesMap&gt;=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="void-Tracking-UpdateLastFrame"><a href="#void-Tracking-UpdateLastFrame" class="headerlink" title="void Tracking::UpdateLastFrame()"></a>void Tracking::UpdateLastFrame()</h5><ul>
<li>1.更新最近一帧的位姿</li>
<li>2.对于双目或rgbd摄像头，为上一帧临时生成新的MapPoints,注意这些MapPoints不加入到Map中，在tracking的最后会删除,跟踪过程中需要将将上一帧的MapPoints投影到当前帧可以缩小匹配范围，加快当前帧与上一帧进行特征点匹配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::UpdateLastFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Update pose according to reference keyframe</span></span><br><span class="line">    <span class="comment">// 步骤1：更新最近一帧的位姿</span></span><br><span class="line">    KeyFrame* pRef = mLastFrame.mpReferenceKF;</span><br><span class="line">    cv::Mat Tlr = mlRelativeFramePoses.back();</span><br><span class="line"> </span><br><span class="line">    mLastFrame.SetPose(Tlr*pRef-&gt;GetPose()); <span class="comment">// Tlr*Trw = Tlw 1:last r:reference w:world</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果上一帧为关键帧，或者单目的情况，则退出</span></span><br><span class="line">    <span class="keyword">if</span>(mnLastKeyFrameId==mLastFrame.mnId || mSensor==System::MONOCULAR)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 步骤2：对于双目或rgbd摄像头，为上一帧临时生成新的MapPoints</span></span><br><span class="line">    <span class="comment">// 注意这些MapPoints不加入到Map中，在tracking的最后会删除</span></span><br><span class="line">    <span class="comment">// 跟踪过程中需要将将上一帧的MapPoints投影到当前帧可以缩小匹配范围，加快当前帧与上一帧进行特征点匹配</span></span><br><span class="line">    <span class="comment">// Create "visual odometry" MapPoints</span></span><br><span class="line">    <span class="comment">// We sort points according to their measured depth by the stereo/RGB-D sensor</span></span><br><span class="line">    <span class="comment">// 步骤2.1：得到上一帧有深度值的特征点</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">float</span>,<span class="keyword">int</span>&gt; &gt; vDepthIdx;</span><br><span class="line">    vDepthIdx.reserve(mLastFrame.N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mLastFrame.N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> z = mLastFrame.mvDepth[i];</span><br><span class="line">        <span class="keyword">if</span>(z&gt;<span class="number">0</span>)<span class="comment">//如果深度大于0</span></span><br><span class="line">        &#123;</span><br><span class="line">            vDepthIdx.push_back(make_pair(z,i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(vDepthIdx.empty())<span class="comment">//如果没深度值则退出</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 步骤2.2：按照深度从小到大排序</span></span><br><span class="line">    sort(vDepthIdx.begin(),vDepthIdx.end());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We insert all close points (depth&lt;mThDepth)</span></span><br><span class="line">    <span class="comment">// If less than 100 close points, we insert the 100 closest ones.</span></span><br><span class="line">    <span class="comment">// 步骤2.3：将距离比较近的点包装成MapPoints</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> nPoints = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>; j&lt;vDepthIdx.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = vDepthIdx[j].second;</span><br><span class="line">        <span class="keyword">bool</span> bCreateNew = <span class="literal">false</span>;</span><br><span class="line">        MapPoint* pMP = mLastFrame.mvpMapPoints[i];</span><br><span class="line">        <span class="keyword">if</span>(!pMP)</span><br><span class="line">            bCreateNew = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pMP-&gt;Observations()&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bCreateNew = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(bCreateNew)</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这些生成MapPoints后并没有通过：</span></span><br><span class="line">            <span class="comment">// a.AddMapPoint、</span></span><br><span class="line">            <span class="comment">// b.AddObservation、</span></span><br><span class="line">            <span class="comment">// c.ComputeDistinctiveDescriptors、</span></span><br><span class="line">            <span class="comment">// d.UpdateNormalAndDepth添加属性，</span></span><br><span class="line">            <span class="comment">// 这些MapPoint仅仅为了提高双目和RGBD的跟踪成功率</span></span><br><span class="line">            cv::Mat x3D = mLastFrame.UnprojectStereo(i);</span><br><span class="line">            MapPoint* pNewMP = <span class="keyword">new</span> MapPoint(x3D,mpMap,&amp;mLastFrame,i);</span><br><span class="line">            mLastFrame.mvpMapPoints[i]=pNewMP; <span class="comment">// 添加新的MapPoint</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 标记为临时添加的MapPoint，之后在CreateNewKeyFrame之前会全部删除</span></span><br><span class="line">            mlpTemporalPoints.push_back(pNewMP);</span><br><span class="line">            nPoints++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nPoints++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vDepthIdx[j].first&gt;mThDepth &amp;&amp; nPoints&gt;<span class="number">100</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-Relocalization"><a href="#bool-Tracking-Relocalization" class="headerlink" title="bool Tracking::Relocalization()"></a>bool Tracking::Relocalization()</h4><p>重定位，从之前的关键帧中找出与当前帧之间拥有充足匹配点的候选帧，利用Ransac迭代，通过PnP求解位姿。</p>
<blockquote>
<ol>
<li>先计算当前帧的BOW值，并从关键帧数据库中查找候选的匹配关键帧</li>
<li>构建PnP求解器，标记杂点，准备好每个关键帧和当前帧的匹配点集</li>
<li>用PnP算法求解位姿，进行若干次P4P Ransac迭代，并使用非线性最小二乘优化，直到发现一个有充足inliers支持的相机位置</li>
<li>返回成功或失败</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::Relocalization()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compute Bag of Words Vector</span></span><br><span class="line">    <span class="comment">// 步骤1：计算当前帧特征点的Bow映射</span></span><br><span class="line">    mCurrentFrame.ComputeBoW();</span><br><span class="line">    <span class="comment">// Relocalization is performed when tracking is lost当跟踪丢失执行重定位</span></span><br><span class="line">    <span class="comment">// Track Lost: Query KeyFrame Database for keyframe candidates for relocalisation</span></span><br><span class="line">    <span class="comment">// 步骤2：找到与当前帧相似的候选关键帧</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpCandidateKFs = mpKeyFrameDB-&gt;DetectRelocalizationCandidates(&amp;mCurrentFrame);</span><br><span class="line">    <span class="keyword">if</span>(vpCandidateKFs.empty())<span class="comment">//如果没找到候选关键帧，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nKFs = vpCandidateKFs.size();<span class="comment">//候选关键帧个数</span></span><br><span class="line">    <span class="comment">// We perform first an ORB matching with each candidat</span></span><br><span class="line">    <span class="comment">// If enough matches are found we setup a PnP solver</span></span><br><span class="line">    <span class="comment">//我们首先执行与每个候选匹配的ORB匹配</span></span><br><span class="line">    <span class="comment">//如果找到足够的匹配，我们设置一个PNP解算器</span></span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.75</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PnPsolver*&gt; vpPnPsolvers;</span><br><span class="line">    vpPnPsolvers.resize(nKFs);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;MapPoint*&gt; &gt; vvpMapPointMatches;</span><br><span class="line">    vvpMapPointMatches.resize(nKFs);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbDiscarded;</span><br><span class="line">    vbDiscarded.resize(nKFs);</span><br><span class="line">    <span class="keyword">int</span> nCandidates=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nKFs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = vpCandidateKFs[i];</span><br><span class="line">        <span class="keyword">if</span>(pKF-&gt;isBad())</span><br><span class="line">            vbDiscarded[i] = <span class="literal">true</span>;<span class="comment">//去除不好的候选关键帧</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤3：通过BoW进行匹配</span></span><br><span class="line">            <span class="keyword">int</span> nmatches = matcher.SearchByBoW(pKF,mCurrentFrame,vvpMapPointMatches[i]);</span><br><span class="line">            <span class="keyword">if</span>(nmatches&lt;<span class="number">15</span>)<span class="comment">//如果匹配点小于15剔除</span></span><br><span class="line">            &#123;</span><br><span class="line">                vbDiscarded[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//用pnp求解</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 初始化PnPsolver</span></span><br><span class="line">                PnPsolver* pSolver = <span class="keyword">new</span> PnPsolver(mCurrentFrame,vvpMapPointMatches[i]);</span><br><span class="line">                pSolver-&gt;SetRansacParameters(<span class="number">0.99</span>,<span class="number">10</span>,<span class="number">300</span>,<span class="number">4</span>,<span class="number">0.5</span>,<span class="number">5.991</span>);</span><br><span class="line">                vpPnPsolvers[i] = pSolver;</span><br><span class="line">                nCandidates++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Alternatively perform some iterations of P4P RANSAC可选地执行P4P RANSAC的一些迭代</span></span><br><span class="line">    <span class="comment">// Until we found a camera pose supported by enough inliers直到早到符合很多内点的相机位置</span></span><br><span class="line">    <span class="keyword">bool</span> bMatch = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">ORBmatcher <span class="title">matcher2</span><span class="params">(<span class="number">0.9</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(nCandidates&gt;<span class="number">0</span> &amp;&amp; !bMatch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nKFs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vbDiscarded[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Perform 5 Ransac Iterations</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vbInliers;</span><br><span class="line">            <span class="keyword">int</span> nInliers;</span><br><span class="line">            <span class="keyword">bool</span> bNoMore;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 步骤4：通过EPnP算法估计姿态</span></span><br><span class="line">            PnPsolver* pSolver = vpPnPsolvers[i];</span><br><span class="line">            cv::Mat Tcw = pSolver-&gt;iterate(<span class="number">5</span>,bNoMore,vbInliers,nInliers);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// If Ransac reachs max. iterations discard keyframe</span></span><br><span class="line">            <span class="keyword">if</span>(bNoMore)</span><br><span class="line">            &#123;</span><br><span class="line">                vbDiscarded[i]=<span class="literal">true</span>;</span><br><span class="line">                nCandidates--;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// If a Camera Pose is computed, optimize</span></span><br><span class="line">            <span class="keyword">if</span>(!Tcw.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                Tcw.copyTo(mCurrentFrame.mTcw);</span><br><span class="line">                <span class="built_in">set</span>&lt;MapPoint*&gt; sFound;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> np = vbInliers.size();<span class="comment">//内点个数</span></span><br><span class="line"> </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;np; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(vbInliers[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        mCurrentFrame.mvpMapPoints[j]=vvpMapPointMatches[i][j];</span><br><span class="line">                        sFound.insert(vvpMapPointMatches[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        mCurrentFrame.mvpMapPoints[j]=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 步骤5：通过PoseOptimization对姿态进行优化求解</span></span><br><span class="line"> </span><br><span class="line">                <span class="keyword">int</span> nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">                <span class="keyword">if</span>(nGood&lt;<span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> io =<span class="number">0</span>; io&lt;mCurrentFrame.N; io++)</span><br><span class="line">                    <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[io])</span><br><span class="line">                        mCurrentFrame.mvpMapPoints[io]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// If few inliers, search by projection in a coarse window and optimize again</span></span><br><span class="line">                <span class="comment">// 步骤6：如果内点较少，则通过投影的方式对之前未匹配的点进行匹配，再进行优化求解</span></span><br><span class="line">                <span class="keyword">if</span>(nGood&lt;<span class="number">50</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">int</span> nadditional =matcher2.SearchByProjection(mCurrentFrame,vpCandidateKFs[i],sFound,<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">if</span>(nadditional+nGood&gt;=<span class="number">50</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);<span class="comment">//优化</span></span><br><span class="line"> </span><br><span class="line">                        <span class="comment">// If many inliers but still not enough, search by projection again in a narrower window</span></span><br><span class="line"><span class="comment">//如果许多内点仍然不够，则在较窄的窗口中再次用投影搜索</span></span><br><span class="line">                        <span class="comment">// the camera has been already optimized with many points</span></span><br><span class="line">                        <span class="keyword">if</span>(nGood&gt;<span class="number">30</span> &amp;&amp; nGood&lt;<span class="number">50</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            sFound.clear();</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> ip =<span class="number">0</span>; ip&lt;mCurrentFrame.N; ip++)</span><br><span class="line">                                <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[ip])</span><br><span class="line">                                    sFound.insert(mCurrentFrame.mvpMapPoints[ip]);</span><br><span class="line">                            nadditional =matcher2.SearchByProjection(mCurrentFrame,vpCandidateKFs[i],sFound,<span class="number">3</span>,<span class="number">64</span>);</span><br><span class="line">                            <span class="comment">// Final optimization</span></span><br><span class="line">                            <span class="keyword">if</span>(nGood+nadditional&gt;=<span class="number">50</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                nGood = Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> io =<span class="number">0</span>; io&lt;mCurrentFrame.N; io++)</span><br><span class="line">                                    <span class="keyword">if</span>(mCurrentFrame.mvbOutlier[io])</span><br><span class="line">                                       mCurrentFrame.mvpMapPoints[io]=<span class="literal">NULL</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// If the pose is supported by enough inliers stop ransacs and continue</span></span><br><span class="line">                <span class="keyword">if</span>(nGood&gt;=<span class="number">50</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bMatch = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!bMatch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mnLastRelocFrameId = mCurrentFrame.mnId;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跟踪步骤2"><a href="#跟踪步骤2" class="headerlink" title="跟踪步骤2"></a>跟踪步骤2</h3><ul>
<li>1.如果局部地图激活(!mbOnlyTracking)跟踪局部地图bOK = TrackLocalMap()，否则在重定位后特征点足够(bOK &amp;&amp; !mbVO)也会跟踪局部地图bOK = TrackLocalMap()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If we have an initial estimation of the camera pose and matching. Track the local map.</span></span><br><span class="line"><span class="keyword">if</span>(!mbOnlyTracking)<span class="comment">//不是只跟踪还插入关键帧，局部地图工作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bOK)</span><br><span class="line">        bOK = TrackLocalMap();<span class="comment">//跟踪局部地图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// mbVO true means that there are few matches to MapPoints in the map. We cannot retrieve</span></span><br><span class="line">    <span class="comment">// a local map and therefore we do not perform TrackLocalMap(). Once the system relocalizes</span></span><br><span class="line">    <span class="comment">// the camera we will use the local map again.</span></span><br><span class="line">    <span class="keyword">if</span>(bOK &amp;&amp; !mbVO) <span class="comment">// 局部地图不工作，特征点足够且重定位成功</span></span><br><span class="line">        bOK = TrackLocalMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.更新运动模型中的速度mVelocity，mVelocity = mCurrentFrame.mTcw*LastTwc</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(bOK)</span><br><span class="line">    mState = OK;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    mState=LOST;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update drawer</span></span><br><span class="line">mpFrameDrawer-&gt;Update(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If tracking were good, check if we insert a keyframe</span></span><br><span class="line"><span class="keyword">if</span>(bOK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Update motion model</span></span><br><span class="line">    <span class="keyword">if</span>(!mLastFrame.mTcw.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//// 步骤2.3：更新恒速运动模型TrackWithMotionModel中的mVelocity</span></span><br><span class="line">        cv::Mat LastTwc = cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F);</span><br><span class="line">        mLastFrame.GetRotationInverse().copyTo(LastTwc.rowRange(<span class="number">0</span>,<span class="number">3</span>).colRange(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        mLastFrame.GetCameraCenter().copyTo(LastTwc.rowRange(<span class="number">0</span>,<span class="number">3</span>).col(<span class="number">3</span>));</span><br><span class="line">        mVelocity = mCurrentFrame.mTcw*LastTwc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mVelocity = cv::Mat();</span><br><span class="line"></span><br><span class="line">    mpMapDrawer-&gt;SetCurrentCameraPose(mCurrentFrame.mTcw);</span><br></pre></td></tr></table></figure>
<ul>
<li>3.清除临时的MapPoints，这些MapPoints在TrackWithMotionModel的UpdateLastFrame函数里生成（仅双目和rgbd）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Clean VO matches</span></span><br><span class="line"><span class="comment">//步骤2.4：清除UpdateLastFrame中为当前帧临时添加的MapPoints</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">    <span class="keyword">if</span>(pMP)</span><br><span class="line">        <span class="comment">//排除UpdateLastFrame函数中为了跟踪增加的MapPoints</span></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;Observations()&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mCurrentFrame.mvbOutlier[i] = <span class="literal">false</span>;</span><br><span class="line">            mCurrentFrame.mvpMapPoints[i]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete temporal MapPoints</span></span><br><span class="line"><span class="comment">// 步骤2.5：清除临时的MapPoints，这些MapPoints在TrackWithMotionModel的UpdateLastFrame函数里生成（仅双目和rgbd）</span></span><br><span class="line"><span class="comment">// 步骤2.4中只是在当前帧中将这些MapPoints剔除，这里从MapPoints数据库中删除</span></span><br><span class="line"><span class="comment">// 这里生成的仅仅是为了提高双目或rgbd摄像头的帧间跟踪效果，用完以后就扔了，没有添加到地图中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">list</span>&lt;MapPoint*&gt;::iterator lit = mlpTemporalPoints.begin(), lend =  mlpTemporalPoints.end(); lit!=lend; lit++)</span><br><span class="line">&#123;</span><br><span class="line">    MapPoint* pMP = *lit;</span><br><span class="line">    <span class="keyword">delete</span> pMP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不仅仅是清除mlpTemporalPoints，通过delete pMP还删除了指针指向的MapPoint</span></span><br><span class="line">mlpTemporalPoints.clear();</span><br></pre></td></tr></table></figure>
<ul>
<li>4.检测（NeedNewKeyFrame()）并插入关键帧CreateNewKeyFrame()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤2.6：检测并插入关键帧，对于双目会产生新的MapPoints</span></span><br><span class="line"><span class="keyword">if</span>(NeedNewKeyFrame())</span><br><span class="line">    CreateNewKeyFrame();</span><br></pre></td></tr></table></figure>
<ul>
<li>6.保存最新一帧的数据mLastFrame = Frame(mCurrentFrame);</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!mCurrentFrame.mpReferenceKF)</span><br><span class="line">        mCurrentFrame.mpReferenceKF = mpReferenceKF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存上一帧的数据</span></span><br><span class="line">    mLastFrame = Frame(mCurrentFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7.记录位姿信息，用于轨迹复现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store frame pose information to retrieve the complete camera trajectory afterwards.</span></span><br><span class="line"><span class="keyword">if</span>(!mCurrentFrame.mTcw.empty())</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat Tcr = mCurrentFrame.mTcw*mCurrentFrame.mpReferenceKF-&gt;GetPoseInverse();</span><br><span class="line">    mlRelativeFramePoses.push_back(Tcr);</span><br><span class="line">    mlpReferences.push_back(mpReferenceKF);</span><br><span class="line">    mlFrameTimes.push_back(mCurrentFrame.mTimeStamp);</span><br><span class="line">    mlbLost.push_back(mState==LOST);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This can happen if tracking is lost</span></span><br><span class="line">    mlRelativeFramePoses.push_back(mlRelativeFramePoses.back());</span><br><span class="line">    mlpReferences.push_back(mlpReferences.back());</span><br><span class="line">    mlFrameTimes.push_back(mlFrameTimes.back());</span><br><span class="line">    mlbLost.push_back(mState==LOST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-TrackLocalMap"><a href="#bool-Tracking-TrackLocalMap" class="headerlink" title="bool Tracking::TrackLocalMap()"></a>bool Tracking::TrackLocalMap()</h4>投影，从已经生成的地图点中找到更多对应关系</li>
<li>1.更新Covisibility Graph， 更新局部关键帧 </li>
<li>2.根据局部关键帧，更新局部地图点，接下来运行过滤函数 isInFrustum </li>
<li>3.将地图点投影到当前帧上，超出图像范围的舍弃</li>
<li>4.当前视线方向v和地图点云平均视线方向n, 舍弃n*v&lt;cos(60)的点云</li>
<li>5.舍弃地图点到相机中心距离不在一定阈值内的点 </li>
<li>6.计算图像的尺度因子 isInFrustum 函数结束 </li>
<li>7.进行非线性最小二乘优化 </li>
<li>8.更新地图点的统计量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::TrackLocalMap()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We have an estimation of the camera pose and some map points tracked in the frame.</span></span><br><span class="line">    <span class="comment">// We retrieve the local map and try to find matches to points in the local map.</span></span><br><span class="line">    <span class="comment">// Update Local KeyFrames and Local Points</span></span><br><span class="line">    <span class="comment">// 步骤1：更新局部关键帧mvpLocalKeyFrames和局部地图点mvpLocalMapPoints</span></span><br><span class="line"> </span><br><span class="line">    UpdateLocalMap();</span><br><span class="line">    <span class="comment">// 步骤2：在局部地图中查找与当前帧匹配的MapPoints</span></span><br><span class="line">    SearchLocalPoints();</span><br><span class="line">    <span class="comment">// Optimize Pos</span></span><br><span class="line">    <span class="comment">// 在这个函数之前，在Relocalization、TrackReferenceKeyFrame、TrackWithMotionModel中都有位姿优化，</span></span><br><span class="line">    <span class="comment">// 步骤3：更新局部所有MapPoints后对位姿再次优化</span></span><br><span class="line">    Optimizer::PoseOptimization(&amp;mCurrentFrame);</span><br><span class="line">    mnMatchesInliers = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update MapPoints Statistics</span></span><br><span class="line">    <span class="comment">// 步骤3：更新当前帧的MapPoints被观测程度，并统计跟踪局部地图的效果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 由于当前帧的MapPoints可以被当前帧观测到，其被观测统计量加1</span></span><br><span class="line">            <span class="keyword">if</span>(!mCurrentFrame.mvbOutlier[i])</span><br><span class="line">            &#123;</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]-&gt;IncreaseFound();</span><br><span class="line">                <span class="keyword">if</span>(!mbOnlyTracking)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 该MapPoint被其它关键帧观测到过</span></span><br><span class="line">                    <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)</span><br><span class="line">                        mnMatchesInliers++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 记录当前帧跟踪到的MapPoints，用于统计跟踪效果</span></span><br><span class="line">                    mnMatchesInliers++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mSensor==System::STEREO)</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i] = <span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Decide if the tracking was succesful</span></span><br><span class="line">    <span class="comment">//More restrictive if there was a relocalization recently</span></span><br><span class="line">    <span class="comment">// 步骤4：决定是否跟踪成功</span></span><br><span class="line">    <span class="keyword">if</span>(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; mnMatchesInliers&lt;<span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(mnMatchesInliers&lt;<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="void-Tracking-UpdateLocalMap"><a href="#void-Tracking-UpdateLocalMap" class="headerlink" title="void Tracking::UpdateLocalMap()"></a>void Tracking::UpdateLocalMap()</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::UpdateLocalMap()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is for visualization</span></span><br><span class="line">    <span class="comment">// 这行程序放在UpdateLocalPoints函数后面是不是好一些</span></span><br><span class="line">    mpMap-&gt;SetReferenceMapPoints(mvpLocalMapPoints);</span><br><span class="line">    <span class="comment">// Update</span></span><br><span class="line">    <span class="comment">// 更新局部关键帧和局部MapPoints</span></span><br><span class="line">    UpdateLocalKeyFrames();</span><br><span class="line">    UpdateLocalPoints();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="void-Tracking-UpdateLocalKeyFrames"><a href="#void-Tracking-UpdateLocalKeyFrames" class="headerlink" title="void Tracking::UpdateLocalKeyFrames()"></a>void Tracking::UpdateLocalKeyFrames()</h6><p>遍历当前帧的MapPoints，将观测到这些MapPoints的关键帧和相邻的关键帧取出，更新mvpLocalKeyFrames<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新局部关键帧，called by UpdateLocalMap()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 遍历当前帧的MapPoints，将观测到这些MapPoints的关键帧和相邻的关键帧取出，更新mvpLocalKeyFrames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> Tracking::UpdateLocalKeyFrames()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Each map point vote for the keyframes in which it has been observed</span></span><br><span class="line">    <span class="comment">// 步骤1：遍历当前帧的MapPoints，记录所有能观测到当前帧MapPoints的关键帧</span></span><br><span class="line">    <span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">int</span>&gt; keyframeCounter;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">        &#123;</span><br><span class="line">            MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">            <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 能观测到当前帧MapPoints的关键帧</span></span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt; observations = pMP-&gt;GetObservations();</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">size_t</span>&gt;::const_iterator it=observations.begin(), itend=observations.end(); it!=itend; it++)</span><br><span class="line">                    keyframeCounter[it-&gt;first]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mCurrentFrame.mvpMapPoints[i]=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(keyframeCounter.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    KeyFrame* pKFmax= <span class="keyword">static_cast</span>&lt;KeyFrame*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 步骤2：更新局部关键帧（mvpLocalKeyFrames），添加局部关键帧有三个策略</span></span><br><span class="line">    <span class="comment">// 先清空局部关键帧</span></span><br><span class="line">    mvpLocalKeyFrames.clear();</span><br><span class="line">    mvpLocalKeyFrames.reserve(<span class="number">3</span>*keyframeCounter.size());</span><br><span class="line">    <span class="comment">// All keyframes that observe a map point are included in the local map. Also check which keyframe shares most points</span></span><br><span class="line">    <span class="comment">// V-D K1: shares the map points with current frame</span></span><br><span class="line">    <span class="comment">// 策略1：能观测到当前帧MapPoints的关键帧作为局部关键帧</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;KeyFrame*,<span class="keyword">int</span>&gt;::const_iterator it=keyframeCounter.begin(), itEnd=keyframeCounter.end(); it!=itEnd; it++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(pKF-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second&gt;max)</span><br><span class="line">        &#123;</span><br><span class="line">            max=it-&gt;second;</span><br><span class="line">            pKFmax=pKF;</span><br><span class="line">        &#125;</span><br><span class="line">        mvpLocalKeyFrames.push_back(it-&gt;first);</span><br><span class="line">        <span class="comment">// mnTrackReferenceForFrame防止重复添加局部关键帧</span></span><br><span class="line">        pKF-&gt;mnTrackReferenceForFrame = mCurrentFrame.mnId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Include also some not-already-included keyframes that are neighbors to already-included keyframes</span></span><br><span class="line">    <span class="comment">// V-D K2: neighbors to K1 in the covisibility graph</span></span><br><span class="line">    <span class="comment">// 策略2：与策略1得到的局部关键帧共视程度很高的关键帧作为局部关键帧</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator itKF=mvpLocalKeyFrames.begin(), itEndKF=mvpLocalKeyFrames.end(); itKF!=itEndKF; itKF++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Limit the number of keyframes</span></span><br><span class="line">        <span class="keyword">if</span>(mvpLocalKeyFrames.size()&gt;<span class="number">80</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        KeyFrame* pKF = *itKF;</span><br><span class="line">        <span class="comment">// 策略2.1:最佳共视的10帧</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;KeyFrame*&gt; vNeighs = pKF-&gt;GetBestCovisibilityKeyFrames(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator itNeighKF=vNeighs.begin(), itEndNeighKF=vNeighs.end(); itNeighKF!=itEndNeighKF; itNeighKF++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pNeighKF = *itNeighKF;</span><br><span class="line">            <span class="keyword">if</span>(!pNeighKF-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// mnTrackReferenceForFrame防止重复添加局部关键帧</span></span><br><span class="line">                <span class="keyword">if</span>(pNeighKF-&gt;mnTrackReferenceForFrame!=mCurrentFrame.mnId)</span><br><span class="line">                &#123;</span><br><span class="line">                    mvpLocalKeyFrames.push_back(pNeighKF);</span><br><span class="line">                    pNeighKF-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 策略2.2:自己的子关键帧</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;KeyFrame*&gt; spChilds = pKF-&gt;GetChilds();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;KeyFrame*&gt;::const_iterator sit=spChilds.begin(), send=spChilds.end(); sit!=send; sit++)</span><br><span class="line">        &#123;</span><br><span class="line">            KeyFrame* pChildKF = *sit;</span><br><span class="line">            <span class="keyword">if</span>(!pChildKF-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pChildKF-&gt;mnTrackReferenceForFrame!=mCurrentFrame.mnId)</span><br><span class="line">                &#123;</span><br><span class="line">                    mvpLocalKeyFrames.push_back(pChildKF);</span><br><span class="line">                    pChildKF-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 策略2.3:自己的父关键帧</span></span><br><span class="line">        KeyFrame* pParent = pKF-&gt;GetParent();</span><br><span class="line">        <span class="keyword">if</span>(pParent)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// mnTrackReferenceForFrame防止重复添加局部关键帧</span></span><br><span class="line">           <span class="keyword">if</span>(pParent-&gt;mnTrackReferenceForFrame!=mCurrentFrame.mnId)</span><br><span class="line">           &#123;</span><br><span class="line">                mvpLocalKeyFrames.push_back(pParent);</span><br><span class="line">                pParent-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// V-D Kref： shares the most map points with current frame</span></span><br><span class="line">    <span class="comment">// 步骤3：更新当前帧的参考关键帧，与自己共视程度最高的关键帧作为参考关键帧</span></span><br><span class="line">    <span class="keyword">if</span>(pKFmax)</span><br><span class="line">    &#123;</span><br><span class="line">        mpReferenceKF = pKFmax;</span><br><span class="line">       mCurrentFrame.mpReferenceKF = mpReferenceKF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="void-Tracking-UpdateLocalPoints"><a href="#void-Tracking-UpdateLocalPoints" class="headerlink" title="void Tracking::UpdateLocalPoints()"></a>void Tracking::UpdateLocalPoints()</h6><p>局部关键帧mvpLocalKeyFrames的MapPoints，更新mvpLocalMapPoints<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 更新局部关键点，called by UpdateLocalMap()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 局部关键帧mvpLocalKeyFrames的MapPoints，更新mvpLocalMapPoints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> Tracking::UpdateLocalPoints()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 步骤1：清空局部MapPoints</span></span><br><span class="line">    mvpLocalMapPoints.clear();</span><br><span class="line">    <span class="comment">// 步骤2：遍历局部关键帧mvpLocalKeyFrames</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;KeyFrame*&gt;::const_iterator itKF=mvpLocalKeyFrames.begin(), itEndKF=mvpLocalKeyFrames.end(); itKF!=itEndKF; itKF++)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyFrame* pKF = *itKF;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;MapPoint*&gt; vpMPs = pKF-&gt;GetMapPointMatches();</span><br><span class="line">        <span class="comment">// 步骤2：将局部关键帧的MapPoints添加到mvpLocalMapPoints</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::const_iterator itMP=vpMPs.begin(), itEndMP=vpMPs.end(); itMP!=itEndMP; itMP++)</span><br><span class="line">        &#123;</span><br><span class="line">           MapPoint* pMP = *itMP;</span><br><span class="line">            <span class="keyword">if</span>(!pMP)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// mnTrackReferenceForFrame防止重复添加局部MapPoint</span></span><br><span class="line">            <span class="keyword">if</span>(pMP-&gt;mnTrackReferenceForFrame==mCurrentFrame.mnId)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                mvpLocalMapPoints.push_back(pMP);</span><br><span class="line">                pMP-&gt;mnTrackReferenceForFrame=mCurrentFrame.mnId;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="void-Tracking-SearchLocalPoints"><a href="#void-Tracking-SearchLocalPoints" class="headerlink" title="void Tracking::SearchLocalPoints()"></a>void Tracking::SearchLocalPoints()</h5><p>在局部地图中查找在当前帧视野范围内的点，将视野范围内的点和当前帧的特征点进行投影匹配</p>
<blockquote>
<p>1.遍历当前帧的mvpMapPoints，标记这些MapPoints不参与之后的搜索<br>2.将所有局部MapPoints投影到当前帧，判断是否在视野范围内，然后进行投影匹配<br>3.对于双目或rgbd摄像头，为当前帧生成新的MapPoints</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::SearchLocalPoints()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do not search map points already matched</span></span><br><span class="line">    <span class="comment">// 步骤1：遍历当前帧的mvpMapPoints，标记这些MapPoints不参与之后的搜索</span></span><br><span class="line">    <span class="comment">// 因为当前的mvpMapPoints一定在当前帧的视野中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::iterator vit=mCurrentFrame.mvpMapPoints.begin(), vend=mCurrentFrame.mvpMapPoints.end(); vit!=vend; vit++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = *vit;</span><br><span class="line">        <span class="keyword">if</span>(pMP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            &#123;</span><br><span class="line">                *vit = <span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新能观测到该点的帧数加1</span></span><br><span class="line">                pMP-&gt;IncreaseVisible();</span><br><span class="line">                <span class="comment">// 标记该点被当前帧观测到</span></span><br><span class="line">                pMP-&gt;mnLastFrameSeen = mCurrentFrame.mnId;</span><br><span class="line">                <span class="comment">// 标记该点将来不被投影，因为已经匹配过</span></span><br><span class="line">                pMP-&gt;mbTrackInView = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nToMatch=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Project points in frame and check its visibility</span></span><br><span class="line">    <span class="comment">// 步骤2：将所有局部MapPoints投影到当前帧，判断是否在视野范围内，然后进行投影匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;MapPoint*&gt;::iterator vit=mvpLocalMapPoints.begin(), vend=mvpLocalMapPoints.end(); vit!=vend; vit++)</span><br><span class="line">    &#123;</span><br><span class="line">        MapPoint* pMP = *vit;</span><br><span class="line">        <span class="comment">// 已经被当前帧观测到MapPoint不再判断是否能被当前帧观测到</span></span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;mnLastFrameSeen == mCurrentFrame.mnId)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(pMP-&gt;isBad())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// Project (this fills MapPoint variables for matching)</span></span><br><span class="line">        <span class="comment">// 步骤2.1：判断LocalMapPoints中的点是否在在视野内</span></span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.isInFrustum(pMP,<span class="number">0.5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 观测到该点的帧数加1，该MapPoint在某些帧的视野范围内</span></span><br><span class="line">            pMP-&gt;IncreaseVisible();</span><br><span class="line">            <span class="comment">// 只有在视野范围内的MapPoints才参与之后的投影匹配</span></span><br><span class="line">            nToMatch++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nToMatch&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ORBmatcher <span class="title">matcher</span><span class="params">(<span class="number">0.8</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> th = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mSensor==System::RGBD)</span><br><span class="line">            th=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// If the camera has been relocalised recently, perform a coarser search</span></span><br><span class="line">        <span class="comment">// 如果不久前进行过重定位，那么进行一个更加宽泛的搜索，阈值需要增大</span></span><br><span class="line">        <span class="keyword">if</span>(mCurrentFrame.mnId&lt;mnLastRelocFrameId+<span class="number">2</span>)</span><br><span class="line">            th=<span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 步骤2.2：对视野范围内的MapPoints通过投影进行特征点匹配</span></span><br><span class="line">        matcher.SearchByProjection(mCurrentFrame,mvpLocalMapPoints,th);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bool-Tracking-NeedNewKeyFrame"><a href="#bool-Tracking-NeedNewKeyFrame" class="headerlink" title="bool Tracking::NeedNewKeyFrame()"></a>bool Tracking::NeedNewKeyFrame()</h4><p>判断是否需要生成新的关键帧，确定关键帧的标准</p>
<blockquote>
<ul>
<li>1.在上一次进行重定位之后，过了20帧数据，或关键帧数小于20个，不满足不能生成</li>
<li>2.在上一个关键帧插入之后，过了20帧，或局部建图是空闲状态，不满足不能生成。</li>
<li>3.当前帧跟踪到大于若干个点，不满足不能生成</li>
<li>4.当前帧的跟踪点数小于90%的参考关键帧跟踪点数，并且当前帧跟踪点数大于15，不满足不能生成</li>
<li>5.初始化后跟踪失败,重新Reset</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Tracking::NeedNewKeyFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 步骤1：如果用户在界面上选择重定位，那么将不插入关键帧</span></span><br><span class="line">    <span class="comment">// 由于插入关键帧过程中会生成MapPoint，因此用户选择重定位后地图上的点云和关键帧都不会再增加</span></span><br><span class="line">    <span class="keyword">if</span>(mbOnlyTracking)<span class="comment">//如果仅跟踪，不选关键帧</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//If Local Mapping is freezed by a Loop Closure do not insert keyframes</span></span><br><span class="line">    <span class="comment">// 如果局部地图被闭环检测使用，则不插入关键帧</span></span><br><span class="line">    <span class="keyword">if</span>(mpLocalMapper-&gt;isStopped() || mpLocalMapper-&gt;stopRequested())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nKFs = mpMap-&gt;KeyFramesInMap();<span class="comment">//关键帧数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Do not insert keyframes if not enough frames have passed from last relocalisation</span></span><br><span class="line">    <span class="comment">// 步骤2：判断是否距离上一次插入关键帧的时间太短</span></span><br><span class="line">    <span class="comment">// mCurrentFrame.mnId是当前帧的ID</span></span><br><span class="line">    <span class="comment">// mnLastRelocFrameId是最近一次重定位帧的ID</span></span><br><span class="line">    <span class="comment">// mMaxFrames等于图像输入的帧率</span></span><br><span class="line">    <span class="comment">// 如果关键帧比较少，则考虑插入关键帧</span></span><br><span class="line">    <span class="comment">// 或距离上一次重定位超过1s，则考虑插入关键帧</span></span><br><span class="line">    <span class="keyword">if</span>(mCurrentFrame.mnId&lt;mnLastRelocFrameId+mMaxFrames &amp;&amp; nKFs&gt;mMaxFrames)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Tracked MapPoints in the reference keyframe</span></span><br><span class="line">    <span class="comment">// 步骤3：得到参考关键帧跟踪到的MapPoints数量</span></span><br><span class="line">    <span class="comment">// 在UpdateLocalKeyFrames函数中会将与当前关键帧共视程度最高的关键帧设定为当前帧的参考关键帧</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> nMinObs = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(nKFs&lt;=<span class="number">2</span>)</span><br><span class="line">        nMinObs=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> nRefMatches = mpReferenceKF-&gt;TrackedMapPoints(nMinObs);<span class="comment">//获取参考关键帧跟踪到的MapPoints数量</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Local Mapping accept keyframes?</span></span><br><span class="line">    <span class="comment">// 步骤4：查询局部地图管理器是否繁忙</span></span><br><span class="line">    <span class="keyword">bool</span> bLocalMappingIdle = mpLocalMapper-&gt;AcceptKeyFrames();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Stereo &amp; RGB-D: Ratio of close "matches to map"/"total matches"</span></span><br><span class="line">    <span class="comment">//双目和RGBD：比率接近地图匹配数/总匹配数</span></span><br><span class="line">    <span class="comment">// "total matches = matches to map + visual odometry matches"</span></span><br><span class="line">    <span class="comment">//总匹配数=地图匹配数+视觉里程计匹配数</span></span><br><span class="line">    <span class="comment">// Visual odometry matches will become MapPoints if we insert a keyframe.</span></span><br><span class="line">    <span class="comment">// This ratio measures how many MapPoints we could create if we insert a keyframe.</span></span><br><span class="line">    <span class="comment">//这个比率测量如果我们插入一个关键帧，我们可以创建多少个MapPoints</span></span><br><span class="line">    <span class="comment">// 步骤5：对于双目或RGBD摄像头，统计总的可以添加的MapPoints数量和跟踪到地图中的MapPoints数量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> nMap = <span class="number">0</span>;<span class="comment">//地图匹配数</span></span><br><span class="line">    <span class="keyword">int</span> nTotal= <span class="number">0</span>;<span class="comment">//总匹配数</span></span><br><span class="line">    <span class="keyword">if</span>(mSensor!=System::MONOCULAR)<span class="comment">// 双目或rgbd</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)<span class="comment">//遍历当前帧所有匹配点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mCurrentFrame.mvDepth[i]&gt;<span class="number">0</span> &amp;&amp; mCurrentFrame.mvDepth[i]&lt;mThDepth)<span class="comment">//map点的速度在合理范围内</span></span><br><span class="line">            &#123;</span><br><span class="line">                nTotal++;<span class="comment">// 总的可以添加mappoints数</span></span><br><span class="line">                <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i])</span><br><span class="line">                    <span class="keyword">if</span>(mCurrentFrame.mvpMapPoints[i]-&gt;Observations()&gt;<span class="number">0</span>)<span class="comment">//mappoint能被观测</span></span><br><span class="line">                        nMap++;<span class="comment">// 被关键帧观测到的mappoints数，即观测到地图中的MapPoints数量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// There are no visual odometry matches in the monocular case</span></span><br><span class="line">        nMap=<span class="number">1</span>;</span><br><span class="line">        nTotal=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ratioMap = (<span class="keyword">float</span>)nMap/(<span class="keyword">float</span>)(<span class="built_in">std</span>::max(<span class="number">1</span>,nTotal));</span><br><span class="line">    <span class="comment">// 步骤6：决策是否需要插入关键帧</span></span><br><span class="line">    <span class="comment">// Thresholds</span></span><br><span class="line">    <span class="comment">// 设定inlier阈值，和之前帧特征点匹配的inlier比例</span></span><br><span class="line">    <span class="keyword">float</span> thRefRatio = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">if</span>(nKFs&lt;<span class="number">2</span>)</span><br><span class="line">        thRefRatio = <span class="number">0.4f</span>;<span class="comment">// 关键帧只有一帧，那么插入关键帧的阈值设置很低</span></span><br><span class="line">    <span class="keyword">if</span>(mSensor==System::MONOCULAR)</span><br><span class="line">        thRefRatio = <span class="number">0.9f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MapPoints中和地图关联的比例阈值</span></span><br><span class="line">    <span class="keyword">float</span> thMapRatio = <span class="number">0.35f</span>;</span><br><span class="line">    <span class="keyword">if</span>(mnMatchesInliers&gt;<span class="number">300</span>)</span><br><span class="line">        thMapRatio = <span class="number">0.20f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Condition 1a: More than "MaxFrames" have passed from last keyframe insertion</span></span><br><span class="line">    <span class="comment">// 很长时间没有插入关键帧</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c1a = mCurrentFrame.mnId&gt;=mnLastKeyFrameId+mMaxFrames;</span><br><span class="line">    <span class="comment">// Condition 1b: More than "MinFrames" have passed and Local Mapping is idle</span></span><br><span class="line">    <span class="comment">// localMapper处于空闲状态</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c1b = (mCurrentFrame.mnId&gt;=mnLastKeyFrameId+mMinFrames &amp;&amp; bLocalMappingIdle);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Condition 1c: tracking is weak</span></span><br><span class="line">    <span class="comment">// 跟踪要跪的节奏，0.25和0.3是一个比较低的阈值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c1c =  mSensor!=System::MONOCULAR &amp;&amp; (mnMatchesInliers&lt;nRefMatches*<span class="number">0.25</span> || ratioMap&lt;<span class="number">0.3f</span>) ;</span><br><span class="line">    <span class="comment">// Condition 2: Few tracked points compared to reference keyframe. Lots of visual odometry compared to map matches.</span></span><br><span class="line">    <span class="comment">// 阈值比c1c要高，与之前参考帧（最近的一个关键帧）重复度不是太高</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> c2 = ((mnMatchesInliers&lt;nRefMatches*thRefRatio || ratioMap&lt;thMapRatio) &amp;&amp; mnMatchesInliers&gt;<span class="number">15</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>((c1a||c1b||c1c)&amp;&amp;c2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If the mapping accepts keyframes, insert keyframe.</span></span><br><span class="line">        <span class="comment">// Otherwise send a signal to interrupt BA</span></span><br><span class="line">        <span class="comment">//如果mapping接受关键帧，则插入关键帧，否则发送信号到中断BA</span></span><br><span class="line">        <span class="keyword">if</span>(bLocalMappingIdle)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mpLocalMapper-&gt;InterruptBA();<span class="comment">//中断BA</span></span><br><span class="line">            <span class="keyword">if</span>(mSensor!=System::MONOCULAR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 队列里不能阻塞太多关键帧</span></span><br><span class="line">                <span class="comment">// tracking插入关键帧不是直接插入，而且先插入到mlNewKeyFrames中，</span></span><br><span class="line">                <span class="comment">// 然后localmapper再逐个pop出来插入到mspKeyFrames</span></span><br><span class="line">                <span class="keyword">if</span>(mpLocalMapper-&gt;KeyframesInQueue()&lt;<span class="number">3</span>)<span class="comment">//队列中关键帧小于3</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reset if the camera get lost soon after initialization</span></span><br><span class="line"><span class="comment">// 跟踪失败，并且relocation也没有搞定，只能重新Reset</span></span><br><span class="line"><span class="keyword">if</span>(mState==LOST)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mpMap-&gt;KeyFramesInMap()&lt;=<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Track lost soon after initialisation, reseting..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        mpSystem-&gt;Reset();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="void-Tracking-CreateNewKeyFrame"><a href="#void-Tracking-CreateNewKeyFrame" class="headerlink" title="void Tracking::CreateNewKeyFrame()"></a>void Tracking::CreateNewKeyFrame()</h4><p>创建新的关键帧，在这里将关键帧插入了LocalMapper的候选关键帧队列，​​​​​​​这样就进入到了局部构图线程。</p>
<blockquote>
<ul>
<li>1.将当前帧构造成关键帧</li>
<li>2.将当前关键帧设置为当前帧的参考关键帧</li>
<li>3.对于双目或rgbd摄像头，为当前帧生成新的MapPoints</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Tracking::CreateNewKeyFrame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mpLocalMapper-&gt;SetNotStop(<span class="literal">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 步骤1：将当前帧构造成关键帧</span></span><br><span class="line">    KeyFrame* pKF = <span class="keyword">new</span> KeyFrame(mCurrentFrame,mpMap,mpKeyFrameDB);</span><br><span class="line">    <span class="comment">// 步骤2：将当前关键帧设置为当前帧的参考关键帧</span></span><br><span class="line">    <span class="comment">// 在UpdateLocalKeyFrames函数中会将与当前关键帧共视程度最高的关键帧设定为当前帧的参考关键帧</span></span><br><span class="line">    mpReferenceKF = pKF;</span><br><span class="line">    mCurrentFrame.mpReferenceKF = pKF;</span><br><span class="line">    <span class="comment">// 这段代码和UpdateLastFrame中的那一部分代码功能相同</span></span><br><span class="line">    <span class="comment">// 步骤3：对于双目或rgbd摄像头，为当前帧生成新的MapPoints</span></span><br><span class="line">    <span class="keyword">if</span>(mSensor!=System::MONOCULAR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据Tcw计算mRcw、mtcw和mRwc、mOw</span></span><br><span class="line">        mCurrentFrame.UpdatePoseMatrices();</span><br><span class="line">        <span class="comment">// We sort points by the measured depth by the stereo/RGBD sensor.</span></span><br><span class="line">        <span class="comment">// We create all those MapPoints whose depth &lt; mThDepth.</span></span><br><span class="line">        <span class="comment">// If there are less than 100 close points we create the 100 closest.</span></span><br><span class="line">        <span class="comment">// 步骤3.1：得到当前帧深度小于阈值的特征点</span></span><br><span class="line">        <span class="comment">// 创建新的MapPoint, depth &lt; mThDepth</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">float</span>,<span class="keyword">int</span>&gt; &gt; vDepthIdx;</span><br><span class="line">        vDepthIdx.reserve(mCurrentFrame.N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mCurrentFrame.N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">float</span> z = mCurrentFrame.mvDepth[i];</span><br><span class="line">            <span class="keyword">if</span>(z&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vDepthIdx.push_back(make_pair(z,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!vDepthIdx.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步骤3.2：按照深度从小到大排序</span></span><br><span class="line">            sort(vDepthIdx.begin(),vDepthIdx.end());</span><br><span class="line">            <span class="comment">// 步骤3.3：将距离比较近的点包装成MapPoints</span></span><br><span class="line">            <span class="keyword">int</span> nPoints = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>; j&lt;vDepthIdx.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">int</span> i = vDepthIdx[j].second;</span><br><span class="line">                <span class="keyword">bool</span> bCreateNew = <span class="literal">false</span>;</span><br><span class="line">                MapPoint* pMP = mCurrentFrame.mvpMapPoints[i];</span><br><span class="line">                <span class="keyword">if</span>(!pMP)</span><br><span class="line">                   bCreateNew = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pMP-&gt;Observations()&lt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bCreateNew = <span class="literal">true</span>;</span><br><span class="line">                    mCurrentFrame.mvpMapPoints[i] = <span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(bCreateNew)</span><br><span class="line">                &#123;</span><br><span class="line">                    cv::Mat x3D = mCurrentFrame.UnprojectStereo(i);</span><br><span class="line">                    MapPoint* pNewMP = <span class="keyword">new</span> MapPoint(x3D,pKF,mpMap);</span><br><span class="line">                    <span class="comment">// 这些添加属性的操作是每次创建MapPoint后都要做的</span></span><br><span class="line">                    pNewMP-&gt;AddObservation(pKF,i);</span><br><span class="line">                    pKF-&gt;AddMapPoint(pNewMP,i);</span><br><span class="line">                    pNewMP-&gt;ComputeDistinctiveDescriptors();</span><br><span class="line">                    pNewMP-&gt;UpdateNormalAndDepth();</span><br><span class="line">                    mpMap-&gt;AddMapPoint(pNewMP);</span><br><span class="line">                    mCurrentFrame.mvpMapPoints[i]=pNewMP;</span><br><span class="line">                    nPoints++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nPoints++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里决定了双目和rgbd摄像头时地图点云的稠密程度</span></span><br><span class="line">                <span class="comment">// 但是仅仅为了让地图稠密直接改这些不太好，</span></span><br><span class="line">                <span class="comment">// 因为这些MapPoints会参与之后整个slam过程</span></span><br><span class="line">                <span class="keyword">if</span>(vDepthIdx[j].first&gt;mThDepth &amp;&amp; nPoints&gt;<span class="number">100</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mpLocalMapper-&gt;InsertKeyFrame(pKF);</span><br><span class="line">    mpLocalMapper-&gt;SetNotStop(<span class="literal">false</span>);</span><br><span class="line">    mnLastKeyFrameId = mCurrentFrame.mnId;</span><br><span class="line">    mpLastKeyFrame = pKF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="Tracking.cc%E7%A8%8B%E5%BA%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89https://blog.csdn.net/qq_20123207/article/details/82587130">ORB-SLAM2从理论到代码实现（六）</a></p>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAM2——系统入口System</title>
    <url>/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E5%85%A5%E5%8F%A3System/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191104191938848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">
 </p><p>在主函数中，我们创建了一个ORB_SLAM2::System的对象SLAM，这个时候就会进入到SLAM系统的主接口System.cc。这个代码是所有调用SLAM系统的主入口。</p><h1 id="system-h"><a href="#system-h" class="headerlink" title="system.h"></a>system.h</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Input sensor</span></span><br><span class="line">    <span class="keyword">enum</span> eSensor&#123;</span><br><span class="line">        MONOCULAR=<span class="number">0</span>,</span><br><span class="line">        STEREO=<span class="number">1</span>,</span><br><span class="line">        RGBD=<span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the SLAM system. It launches the Local Mapping, Loop Closing and Viewer threads.</span></span><br><span class="line">    System(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strVocFile, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingsFile, <span class="keyword">const</span> eSensor sensor, <span class="keyword">const</span> <span class="keyword">bool</span> bUseViewer = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracking函数:输出相机位姿</span></span><br><span class="line">    <span class="comment">// Proccess the given stereo frame. Images must be synchronized and rectified.</span></span><br><span class="line">    <span class="comment">// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line">    <span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">    cv::<span class="function">Mat <span class="title">TrackStereo</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;imLeft, <span class="keyword">const</span> cv::Mat &amp;imRight, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process the given rgbd frame. Depthmap must be registered to the RGB frame.</span></span><br><span class="line">    <span class="comment">// Input image: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line">    <span class="comment">// Input depthmap: Float (CV_32F).</span></span><br><span class="line">    <span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">    cv::<span class="function">Mat <span class="title">TrackRGBD</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> cv::Mat &amp;depthmap, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proccess the given monocular frame</span></span><br><span class="line">    <span class="comment">// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line">    <span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">    cv::<span class="function">Mat <span class="title">TrackMonocular</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This stops local mapping thread (map building) and performs only camera tracking.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ActivateLocalizationMode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// This resumes local mapping thread and performs SLAM again.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeactivateLocalizationMode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if there have been a big map change (loop closure, global BA)</span></span><br><span class="line">    <span class="comment">// since last call to this function</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">MapChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the system (clear map)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All threads will be requested to finish.</span></span><br><span class="line">    <span class="comment">// It waits until all threads have finished.</span></span><br><span class="line">    <span class="comment">// This function must be called before saving the trajectory.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save camera trajectory in the TUM RGB-D dataset format.</span></span><br><span class="line">    <span class="comment">// Only for stereo and RGB-D. This method does not work for monocular.</span></span><br><span class="line">    <span class="comment">// Call first Shutdown()</span></span><br><span class="line">    <span class="comment">// See format details at: http://vision.in.tum.de/data/datasets/rgbd-dataset</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveTrajectoryTUM</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save keyframe poses in the TUM RGB-D dataset format.</span></span><br><span class="line">    <span class="comment">// This method works for all sensor input.</span></span><br><span class="line">    <span class="comment">// Call first Shutdown()</span></span><br><span class="line">    <span class="comment">// See format details at: http://vision.in.tum.de/data/datasets/rgbd-dataset</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveKeyFrameTrajectoryTUM</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save camera trajectory in the KITTI dataset format.</span></span><br><span class="line">    <span class="comment">// Only for stereo and RGB-D. This method does not work for monocular.</span></span><br><span class="line">    <span class="comment">// Call first Shutdown()</span></span><br><span class="line">    <span class="comment">// See format details at: http://www.cvlibs.net/datasets/kitti/eval_odometry.php</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveTrajectoryKITTI</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Save/Load functions</span></span><br><span class="line">    <span class="comment">// SaveMap(const string &amp;filename);</span></span><br><span class="line">    <span class="comment">// LoadMap(const string &amp;filename);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Information from most recent processed frame</span></span><br><span class="line">    <span class="comment">// You can call this right after TrackMonocular (or stereo or RGBD)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTrackingState</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MapPoint*&gt; GetTrackedMapPoints();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::KeyPoint&gt; GetTrackedKeyPointsUn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Input sensor</span></span><br><span class="line">    eSensor mSensor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ORB vocabulary used for place recognition and feature matching.</span></span><br><span class="line">    ORBVocabulary* mpVocabulary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KeyFrame database for place recognition (relocalization and loop detection).</span></span><br><span class="line">    KeyFrameDatabase* mpKeyFrameDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map structure that stores the pointers to all KeyFrames and MapPoints.</span></span><br><span class="line">    Map* mpMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracker. It receives a frame and computes the associated camera pose.</span></span><br><span class="line">    <span class="comment">// It also decides when to insert a new keyframe, create some new MapPoints and</span></span><br><span class="line">    <span class="comment">// performs relocalization if tracking fails.</span></span><br><span class="line">    Tracking* mpTracker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local Mapper. It manages the local map and performs local bundle adjustment.</span></span><br><span class="line">    LocalMapping* mpLocalMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop Closer. It searches loops with every new keyframe. If there is a loop it performs</span></span><br><span class="line">    <span class="comment">// a pose graph optimization and full bundle adjustment (in a new thread) afterwards.</span></span><br><span class="line">    LoopClosing* mpLoopCloser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The viewer draws the map and the current camera pose. It uses Pangolin.</span></span><br><span class="line">    Viewer* mpViewer;</span><br><span class="line"></span><br><span class="line">    FrameDrawer* mpFrameDrawer;</span><br><span class="line">    MapDrawer* mpMapDrawer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// System threads: Local Mapping, Loop Closing, Viewer.</span></span><br><span class="line">    <span class="comment">// The Tracking thread "lives" in the main execution thread that creates the System object.</span></span><br><span class="line">    <span class="built_in">std</span>::thread* mptLocalMapping;</span><br><span class="line">    <span class="built_in">std</span>::thread* mptLoopClosing;</span><br><span class="line">    <span class="built_in">std</span>::thread* mptViewer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset flag</span></span><br><span class="line">    <span class="built_in">std</span>::mutex mMutexReset;</span><br><span class="line">    <span class="keyword">bool</span> mbReset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change mode flags</span></span><br><span class="line">    <span class="built_in">std</span>::mutex mMutexMode;</span><br><span class="line">    <span class="keyword">bool</span> mbActivateLocalizationMode;</span><br><span class="line">    <span class="keyword">bool</span> mbDeactivateLocalizationMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracking state</span></span><br><span class="line">    <span class="keyword">int</span> mTrackingState;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MapPoint*&gt; mTrackedMapPoints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::KeyPoint&gt; mTrackedKeyPointsUn;</span><br><span class="line">    <span class="built_in">std</span>::mutex mMutexState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="构造函数ORB-SLAM2-System"><a href="#构造函数ORB-SLAM2-System" class="headerlink" title="构造函数ORB_SLAM2::System"></a>构造函数ORB_SLAM2::System</h1><blockquote>
<ol>
<li>系统参数设置文件读取</li>
<li>ORB词袋文件读取(txt)</li>
<li>创建关键帧数据库mpKeyFrameDatabase</li>
<li>创建地图对象mpMap</li>
<li>创建两个显示窗口mpFrameDrawer， mpMapDrawer</li>
<li>初始化Tracking对象mpTracker</li>
<li>初始化Local Mapping对象mpLocalMapper并发布Local Mapping线程mptLocalMapping       </li>
<li>初始化Loop Closing对象mpLoopCloser，并开启线程运行mptLoopClosing</li>
<li>初始化窗口，开启线程显示图像和地图点                    </li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//创建ORB_SLAM系统对象</span></span><br><span class="line">    <span class="comment">//ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::STEREO,true);</span></span><br><span class="line">System::System(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strVocFile, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingsFile, <span class="keyword">const</span> eSensor sensor,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">bool</span> bUseViewer):mSensor(sensor), mpViewer(<span class="keyword">static_cast</span>&lt;Viewer*&gt;(<span class="literal">NULL</span>)), mbReset(<span class="literal">false</span>),mbActivateLocalizationMode(<span class="literal">false</span>),</span><br><span class="line">        mbDeactivateLocalizationMode(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Output welcome message</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">    <span class="string">"ORB-SLAM2 Copyright (C) 2014-2016 Raul Mur-Artal, University of Zaragoza."</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">    <span class="string">"This program comes with ABSOLUTELY NO WARRANTY;"</span> &lt;&lt; <span class="built_in">endl</span>  &lt;&lt;</span><br><span class="line">    <span class="string">"This is free software, and you are welcome to redistribute it"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">    <span class="string">"under certain conditions. See LICENSE.txt."</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input sensor was set to: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mSensor==MONOCULAR)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Monocular"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mSensor==STEREO)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stereo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mSensor==RGBD)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"RGB-D"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check settings file</span></span><br><span class="line">    <span class="comment">//1.读取参数文件，内参、帧率、基线、深度, XXX.yaml</span></span><br><span class="line">    cv::<span class="function">FileStorage <span class="title">fsSettings</span><span class="params">(strSettingsFile.c_str(), cv::FileStorage::READ)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!fsSettings.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open settings file at: "</span> &lt;&lt; strSettingsFile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Load ORB Vocabulary</span></span><br><span class="line">    <span class="comment">//2.下载ORB词袋  .txt</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Loading ORB Vocabulary. This could take a while..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    mpVocabulary = <span class="keyword">new</span> ORBVocabulary();</span><br><span class="line">    <span class="keyword">bool</span> bVocLoad = mpVocabulary-&gt;loadFromTextFile(strVocFile);</span><br><span class="line">    <span class="keyword">if</span>(!bVocLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Wrong path to vocabulary. "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Falied to open at: "</span> &lt;&lt; strVocFile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Vocabulary loaded!"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create KeyFrame Database</span></span><br><span class="line">    <span class="comment">//3.创建关键帧数据库</span></span><br><span class="line">    mpKeyFrameDatabase = <span class="keyword">new</span> KeyFrameDatabase(*mpVocabulary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create the Map</span></span><br><span class="line">    <span class="comment">//4.创建地图</span></span><br><span class="line">    mpMap = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create Drawers. These are used by the Viewer</span></span><br><span class="line">    <span class="comment">//创建两个显示窗口</span></span><br><span class="line">    mpFrameDrawer = <span class="keyword">new</span> FrameDrawer(mpMap);</span><br><span class="line">    mpMapDrawer = <span class="keyword">new</span> MapDrawer(mpMap, strSettingsFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Tracking thread</span></span><br><span class="line">    <span class="comment">//5.1初始化 Tracking</span></span><br><span class="line">    <span class="comment">//(it will live in the main thread of execution, the one that called this constructor)</span></span><br><span class="line">    mpTracker = <span class="keyword">new</span> Tracking(<span class="keyword">this</span>, mpVocabulary, mpFrameDrawer, mpMapDrawer,</span><br><span class="line">                             mpMap, mpKeyFrameDatabase, strSettingsFile, mSensor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Local Mapping thread and launch</span></span><br><span class="line">    <span class="comment">//5.2初始化并发布 Local Mapping 线程</span></span><br><span class="line">    mpLocalMapper = <span class="keyword">new</span> LocalMapping(mpMap, mSensor==MONOCULAR);</span><br><span class="line">    mptLocalMapping = <span class="keyword">new</span> thread(&amp;ORB_SLAM2::LocalMapping::Run,mpLocalMapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Loop Closing thread and launch</span></span><br><span class="line">    <span class="comment">//5.3初始化并发布 Loop Closing 线程</span></span><br><span class="line">    mpLoopCloser = <span class="keyword">new</span> LoopClosing(mpMap, mpKeyFrameDatabase, mpVocabulary, mSensor!=MONOCULAR);</span><br><span class="line">    mptLoopClosing = <span class="keyword">new</span> thread(&amp;ORB_SLAM2::LoopClosing::Run, mpLoopCloser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Viewer thread and launch</span></span><br><span class="line">    <span class="comment">//5.4初始化并发布 Viewer 线程</span></span><br><span class="line">    <span class="comment">//初始化窗口，开启线程显示图像和地图点</span></span><br><span class="line">    <span class="keyword">if</span>(bUseViewer)</span><br><span class="line">    &#123;</span><br><span class="line">        mpViewer = <span class="keyword">new</span> Viewer(<span class="keyword">this</span>, mpFrameDrawer,mpMapDrawer,mpTracker,strSettingsFile);</span><br><span class="line">        mptViewer = <span class="keyword">new</span> thread(&amp;Viewer::Run, mpViewer);</span><br><span class="line">        mpTracker-&gt;SetViewer(mpViewer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set pointers between threads</span></span><br><span class="line">    mpTracker-&gt;SetLocalMapper(mpLocalMapper);</span><br><span class="line">    mpTracker-&gt;SetLoopClosing(mpLoopCloser);</span><br><span class="line"></span><br><span class="line">    mpLocalMapper-&gt;SetTracker(mpTracker);</span><br><span class="line">    mpLocalMapper-&gt;SetLoopCloser(mpLoopCloser);</span><br><span class="line"></span><br><span class="line">    mpLoopCloser-&gt;SetTracker(mpTracker);</span><br><span class="line">    mpLoopCloser-&gt;SetLocalMapper(mpLocalMapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="System-TrackStereo"><a href="#System-TrackStereo" class="headerlink" title="System::TrackStereo"></a>System::TrackStereo</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat System::TrackStereo(<span class="keyword">const</span> cv::Mat &amp;imLeft, <span class="keyword">const</span> cv::Mat &amp;imRight, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mSensor!=STEREO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: you called TrackStereo but input sensor was not set to STEREO."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check mode change</span></span><br><span class="line">    &#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lock(mMutexMode);</span><br><span class="line">        <span class="keyword">if</span>(mbActivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpLocalMapper-&gt;RequestStop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until Local Mapping has effectively stopped</span></span><br><span class="line">            <span class="keyword">while</span>(!mpLocalMapper-&gt;isStopped())</span><br><span class="line">            &#123;</span><br><span class="line">                usleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">true</span>);</span><br><span class="line">            mbActivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mbDeactivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">false</span>);</span><br><span class="line">            mpLocalMapper-&gt;Release();</span><br><span class="line">            mbDeactivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check reset</span></span><br><span class="line">    &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(mMutexReset);</span><br><span class="line">    <span class="keyword">if</span>(mbReset)</span><br><span class="line">    &#123;</span><br><span class="line">        mpTracker-&gt;Reset();</span><br><span class="line">        mbReset = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat Tcw = mpTracker-&gt;GrabImageStereo(imLeft,imRight,timestamp);</span><br><span class="line"></span><br><span class="line">    unique_lock&lt;mutex&gt; lock2(mMutexState);</span><br><span class="line">    mTrackingState = mpTracker-&gt;mState;</span><br><span class="line">    mTrackedMapPoints = mpTracker-&gt;mCurrentFrame.mvpMapPoints;</span><br><span class="line">    mTrackedKeyPointsUn = mpTracker-&gt;mCurrentFrame.mvKeysUn;</span><br><span class="line">    <span class="keyword">return</span> Tcw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="System-SaveTrajectoryKITTI"><a href="#System-SaveTrajectoryKITTI" class="headerlink" title="System::SaveTrajectoryKITTI"></a>System::SaveTrajectoryKITTI</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> System::SaveTrajectoryKITTI(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Saving camera trajectory to "</span> &lt;&lt; filename &lt;&lt; <span class="string">" ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(mSensor==MONOCULAR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: SaveTrajectoryKITTI cannot be used for monocular."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpKFs = mpMap-&gt;GetAllKeyFrames();<span class="comment">//获得所有关键帧</span></span><br><span class="line">    sort(vpKFs.begin(),vpKFs.end(),KeyFrame::lId);<span class="comment">//对关键帧排序，闭环检测后第一关键帧可能就不在起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform all keyframes so that the first keyframe is at the origin.</span></span><br><span class="line">    <span class="comment">// After a loop closure the first keyframe might not be at the origin.</span></span><br><span class="line">    cv::Mat Two = vpKFs[<span class="number">0</span>]-&gt;GetPoseInverse();<span class="comment">//获得第一帧相对于世界坐标系的位姿</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有帧</span></span><br><span class="line">    ofstream f;</span><br><span class="line">    f.open(filename.c_str());</span><br><span class="line">    f &lt;&lt; fixed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Frame pose is stored relative to its reference keyframe (which is optimized by BA and pose graph).</span></span><br><span class="line">    <span class="comment">// We need to get first the keyframe pose and then concatenate the relative transformation.</span></span><br><span class="line">    <span class="comment">// Frames not localized (tracking failure) are not saved.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each frame we have a reference keyframe (lRit), the timestamp (lT) and a flag</span></span><br><span class="line">    <span class="comment">// which is true when tracking failed (lbL).</span></span><br><span class="line">    <span class="built_in">list</span>&lt;ORB_SLAM2::KeyFrame*&gt;::iterator lRit = mpTracker-&gt;mlpReferences.begin();<span class="comment">//参考关键帧迭代器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator lT = mpTracker-&gt;mlFrameTimes.begin();<span class="comment">//时间戳迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;cv::Mat&gt;::iterator lit=mpTracker-&gt;mlRelativeFramePoses.begin(), lend=mpTracker-&gt;mlRelativeFramePoses.end();lit!=lend;lit++, lRit++, lT++)</span><br><span class="line">    &#123;</span><br><span class="line">        ORB_SLAM2::KeyFrame* pKF = *lRit;</span><br><span class="line"></span><br><span class="line">        cv::Mat Trw = cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//追踪成功但是关键帧不好，则获取当前关键帧相对于上一帧的位姿，并将上一帧设为关键帧，依次不断的判断关键帧的质量，直到选取合适的关键帧</span></span><br><span class="line">        <span class="keyword">while</span>(pKF-&gt;isBad())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//  cout &lt;&lt; "bad parent" &lt;&lt; endl;</span></span><br><span class="line">            Trw = Trw*pKF-&gt;mTcp;</span><br><span class="line">            pKF = pKF-&gt;GetParent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trw = Trw*pKF-&gt;GetPose()*Two;<span class="comment">//将关键帧的位姿乘第一帧相对于世界坐标的位姿得到关键帧相对于世界坐标的位姿</span></span><br><span class="line"></span><br><span class="line">        cv::Mat Tcw = (*lit)*Trw;<span class="comment">////在将关键帧相对于世界坐标的位姿乘当前帧相对于关键帧的位姿得到当前帧相对于世界坐标的位姿</span></span><br><span class="line">        cv::Mat Rwc = Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).colRange(<span class="number">0</span>,<span class="number">3</span>).t();<span class="comment">//求旋转矩阵R</span></span><br><span class="line">        cv::Mat twc = -Rwc*Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).col(<span class="number">3</span>);<span class="comment">//求平移矩阵t</span></span><br><span class="line">        <span class="comment">// 变换矩阵f</span></span><br><span class="line">        f &lt;&lt; setprecision(<span class="number">9</span>) &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">1</span>)  &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">2</span>) &lt;&lt; <span class="string">" "</span>  &lt;&lt; twc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">             Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>)  &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">" "</span>  &lt;&lt; twc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">             Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">1</span>)  &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="string">" "</span>  &lt;&lt; twc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f.close();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"trajectory saved!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAM2——整体框架</title>
    <url>/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191104184711727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p> ORB_SLAM2由3+1个平行线程组成，包括跟踪、局部建图、回环检测以及在回环检测后的全局BA优化。之所以说是3+1，因为第四个线程仅在回环检测并确认后才执行。</p><p>三个主要并行线程：<br>Tracking：寻找局部地图特征点并进行匹配，运用纯运动BA最小化重投影误差，定位每帧相机位姿。<br>Local Mapping：运用局部BA算法优化相机位姿和特征点云。<br>Loop Closing：检测回环并通过位姿图优化消除累计漂移误差。在位姿图优化后会启动第4个线程执行全局BA算法，计算整个系统最优结构和运动结果。</p><a id="more"></a>


<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>以双目stereo_kitti.cc这个主程序来看整个代码：</p>
<ol>
<li>首先使用LoadImages读取图片目录和时间戳文件 </li>
<li>创建ORB_SLAM2::System对象 </li>
<li>循环读取数据<br>3.1 读取图片<br>3.2 读取时间戳<br>3.3 将图片传给SLAM系统 </li>
<li>将相机轨线保存到硬盘中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Usage: ./stereo_kitti path_to_vocabulary path_to_settings path_to_sequence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve paths to images</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstrImageLeft;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstrImageRight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vTimestamps;</span><br><span class="line">    LoadImages(<span class="built_in">string</span>(argv[<span class="number">3</span>]), vstrImageLeft, vstrImageRight, vTimestamps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nImages = vstrImageLeft.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create SLAM system. It initializes all system threads and gets ready to process frames.</span></span><br><span class="line">    ORB_SLAM2::<span class="function">System <span class="title">SLAM</span><span class="params">(argv[<span class="number">1</span>],argv[<span class="number">2</span>],ORB_SLAM2::System::STEREO,<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vector for tracking time statistics</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; vTimesTrack;</span><br><span class="line">    vTimesTrack.resize(nImages);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"-------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Start processing sequence ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Images in the sequence: "</span> &lt;&lt; nImages &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    cv::Mat imLeft, imRight;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ni=<span class="number">0</span>; ni&lt;nImages; ni++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Read left and right images from file</span></span><br><span class="line">        imLeft = cv::imread(vstrImageLeft[ni],CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">        imRight = cv::imread(vstrImageRight[ni],CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">        <span class="keyword">double</span> tframe = vTimestamps[ni];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(imLeft.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Failed to load image at: "</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">string</span>(vstrImageLeft[ni]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t1 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t1 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass the images to the SLAM system</span></span><br><span class="line">        SLAM.TrackStereo(imLeft,imRight,tframe);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t2 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t2 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ttrack= <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(t2 - t1).count();</span><br><span class="line"></span><br><span class="line">        vTimesTrack[ni]=ttrack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait to load the next frame</span></span><br><span class="line">        <span class="keyword">double</span> T=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ni&lt;nImages<span class="number">-1</span>)</span><br><span class="line">            T = vTimestamps[ni+<span class="number">1</span>]-tframe;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ni&gt;<span class="number">0</span>)</span><br><span class="line">            T = tframe-vTimestamps[ni<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ttrack&lt;T)</span><br><span class="line">            usleep((T-ttrack)*<span class="number">1e6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop all threads</span></span><br><span class="line">    SLAM.Shutdown();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracking time statistics</span></span><br><span class="line">    sort(vTimesTrack.begin(),vTimesTrack.end());</span><br><span class="line">    <span class="keyword">float</span> totaltime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ni=<span class="number">0</span>; ni&lt;nImages; ni++)</span><br><span class="line">    &#123;</span><br><span class="line">        totaltime+=vTimesTrack[ni];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"median tracking time: "</span> &lt;&lt; vTimesTrack[nImages/<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mean tracking time: "</span> &lt;&lt; totaltime/nImages &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save camera trajectory</span></span><br><span class="line">    SLAM.SaveTrajectoryKITTI(<span class="string">"CameraTrajectory.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>LoadImages()函数</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadImages</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strPathToSequence, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vstrImageLeft,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vstrImageRight, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;vTimestamps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fTimes;</span><br><span class="line">    <span class="built_in">string</span> strPathTimeFile = strPathToSequence + <span class="string">"/times.txt"</span>;</span><br><span class="line">    fTimes.open(strPathTimeFile.c_str());</span><br><span class="line">    <span class="keyword">while</span>(!fTimes.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//strstream类同时可以支持C风格的串流的输入输出操作</span></span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        getline(fTimes,s);</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; s;<span class="comment">//输入</span></span><br><span class="line">            <span class="keyword">double</span> t;</span><br><span class="line">            ss &gt;&gt; t;<span class="comment">//输出</span></span><br><span class="line">            vTimestamps.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> strPrefixLeft = strPathToSequence + <span class="string">"/image_0/"</span>;</span><br><span class="line">    <span class="built_in">string</span> strPrefixRight = strPathToSequence + <span class="string">"/image_1/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nTimes = vTimestamps.size();</span><br><span class="line">    vstrImageLeft.resize(nTimes);<span class="comment">//改变当前使用数据的大小</span></span><br><span class="line">    vstrImageRight.resize(nTimes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; i;</span><br><span class="line">        vstrImageLeft[i] = strPrefixLeft + ss.str() + <span class="string">".png"</span>;</span><br><span class="line">        vstrImageRight[i] = strPrefixRight + ss.str() + <span class="string">".png"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="https://blog.csdn.net/hzy925/article/details/85488031" target="_blank" rel="noopener">ORB-SLAM2 程序解读</a><br><a href="https://blog.csdn.net/zxcqlf/article/details/80198298" target="_blank" rel="noopener">ORB-SLAM2论文解读与总结</a></p>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习（1）——vector</title>
    <url>/2019/11/04/C-%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94vector/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是vector？"><a href="#一、什么是vector？" class="headerlink" title="一、什么是vector？"></a>一、什么是vector？</h1><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 </p><h1 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h1><ol>
<li><p>顺序序列</p>
<p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p>
</li>
</ol><a id="more"></a>

<ol>
<li><p>动态数组</p>
<p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p>
</li>
<li><p>能够感知内存分配器的（Allocator-aware）</p>
<p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p>
</li>
</ol>
<h1 id="三、基本函数实现"><a href="#三、基本函数实现" class="headerlink" title="三、基本函数实现"></a>三、基本函数实现</h1><p>1.构造函数</p>
<blockquote>
<p>vector():创建一个空vector<br>   vector(int nSize):创建一个vector,元素个数为nSize<br>   vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>   vector(const vector&amp;):复制构造函数<br>   vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p>
</blockquote>
<p>2.增加函数</p>
<blockquote>
<p> void push_back(const T&amp; x):向量尾部增加一个元素X<br> iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>     iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>     iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p>
</blockquote>
<p>3.删除函数</p>
<blockquote>
<p>  iterator erase(iterator it):删除向量中迭代器指向元素<br>      iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>      void pop_back():删除向量中最后一个元素<br>      void clear():清空向量中所有元素</p>
</blockquote>
<p>4.遍历函数</p>
<blockquote>
<p>   reference at(int pos):返回pos位置元素的引用<br>       reference front():返回首元素的引用<br>       reference back():返回尾元素的引用<br>       iterator begin():返回向量头指针，指向第一个元素<br>       iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>       reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>       reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</p>
</blockquote>
<p>5.判断函数</p>
<blockquote>
<p>bool empty() const:判断向量是否为空，若为空，则向量中无元素</p>
</blockquote>
<p>6.大小函数</p>
<blockquote>
<p>  int size() const:返回向量中元素的个数<br>      int capacity() const:返回当前向量张红所能容纳的最大元素值<br>      int max_size() const:返回最大可允许的vector元素数量值</p>
</blockquote>
<p>7.其他函数</p>
<blockquote>
<p>  void swap(vector&amp;):交换两个同类型向量的数据<br>      void assign(int n,const T&amp; x):设置向量中第n个元素的值为x<br>      void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p>
</blockquote>
<p>8.看着清楚</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>push_back 在数组的最后添加一个数据</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>pop_back 去掉数组的最后一个数据</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>at 得到编号位置的数据</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>begin 得到数组头的指针</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>end 得到数组的最后一个单元+<span class="number">1</span>的指针</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>．front 得到数组头的引用</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>back 得到数组的最后一个单元的引用</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>max_size 得到<span class="type">vector</span>最大可以是多大</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>capacity 当前<span class="type">vector</span>分配的大小</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>size 当前使用数据的大小</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span>resize 改变当前使用数据的大小</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span>reserve 改变当前vecotr所分配空间的大小</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span>erase 删除指针指向的数据项</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span>clear 清空当前的<span class="type">vector</span></span><br><span class="line"></span><br><span class="line"><span class="number">15.</span>rbegin 将<span class="type">vector</span>反转后的开始指针返回(其实就是原来的end<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span>rend 将<span class="type">vector</span>反转构的结束指针返回(其实就是原来的begin<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span>empty 判断<span class="type">vector</span>是否为空</span><br><span class="line"></span><br><span class="line"><span class="number">18.</span>swap 与另一个<span class="type">vector</span>交换数据</span><br></pre></td></tr></table></figure>
<h1 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p><strong>eg：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; veci;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		veci.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (it = veci.begin(); it != veci.end(); )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it = veci.erase(it);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; veci.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"========将vector值传递给其他参数，同时判断是否满足删除要求========"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itc = veci.begin();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecTemp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size(),itc!=veci.end();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vecTemp.push_back(veci.at(i));</span><br><span class="line">		<span class="keyword">if</span> (*itc % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			itc = veci.erase(itc);</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++itc;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; veci.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTemp.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; vecTemp.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190903112647360.png"><br><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">参考：https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>27.二叉树的镜像</title>
    <url>/2019/11/04/27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>输入描述:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    <span class="number">8</span></span><br><span class="line">    	   /  \</span><br><span class="line">    	  <span class="number">6</span>   <span class="number">10</span></span><br><span class="line">    	 / \  / \</span><br><span class="line">    	<span class="number">5</span>  <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    <span class="number">8</span></span><br><span class="line">    	   /  \</span><br><span class="line">    	  <span class="number">10</span>   <span class="number">6</span></span><br><span class="line">    	 / \  / \</span><br><span class="line">    	<span class="number">11</span> <span class="number">9</span> <span class="number">7</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先序遍历这棵树的每个结点，如果遍历到的结点有子结点，则交换它的两个子结点。当交换完所有非叶子结点的左右子结点之后，就得到了树的镜像。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>递归：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left==<span class="literal">NULL</span> &amp;&amp; pRoot-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode *temp=pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left=pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right=temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left)</span><br><span class="line">            Mirror(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;right)</span><br><span class="line">            Mirror(pRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>循环：</p>
<p>利用栈的“后进先出”特性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">stack</span>&lt;TreeNode*&gt; stackTreeNode;</span><br><span class="line">	stackTreeNode.push(pRoot);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (stackTreeNode.size() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode *parent = stackTreeNode.top();</span><br><span class="line">		stackTreeNode.pop();</span><br><span class="line"> </span><br><span class="line">		TreeNode *Temp = parent-&gt;left;</span><br><span class="line">		parent-&gt;left= parent-&gt;right;</span><br><span class="line">		parent-&gt;right = Temp;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;left)</span><br><span class="line">		&#123;</span><br><span class="line">			stackTreeNode.push(parent-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;right)</span><br><span class="line">		&#123;</span><br><span class="line">			stackTreeNode.push(parent-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>26.树的子结构</title>
    <url>/2019/11/04/26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>注意检测空指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1!=<span class="literal">NULL</span>&amp;&amp; pRoot2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(pRoot1-&gt;val-pRoot2-&gt;val)&lt;<span class="number">1e-8</span>)</span><br><span class="line">                result=Tree1HaveTree2(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Tree1HaveTree2</span><span class="params">(TreeNode* pRoot1,TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(pRoot1-&gt;val-pRoot2-&gt;val)&gt;=<span class="number">1e-8</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Tree1HaveTree2(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>25.合并两个排序的链表表</title>
    <url>/2019/11/03/25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果有一个链表为空，则直接返回另外一个链表；否则就对两个链表的每个元素进行大小判断，建立一个新的合并链表，把元素依次放进去，直到一个链表为空，这时把另外一个链表的剩余部分添加到合并链表的尾部即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><a id="more"></a>

<p><strong>法1：循环</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* pHead3=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//利用了构造方法创建一个链表</span></span><br><span class="line">        ListNode* root=pHead3;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">NULL</span> &amp;&amp; pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead1;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead1=pHead1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead2;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead2=pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pHead3=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个链表中哪个头结点的值小，就以此作为新链表的头结点</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;=pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead1;</span><br><span class="line">            pHead1=pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead2;</span><br><span class="line">            pHead2=pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* head=pHead3;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">NULL</span> &amp;&amp; pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead1;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead1=pHead1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead2;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead2=pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pHead3-&gt;next=pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>
<p><strong>法2：递归</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pHead3=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead1;</span><br><span class="line">            pHead3-&gt;next=Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead2;</span><br><span class="line">            pHead3-&gt;next=Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pHead3;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>24.反转链表</title>
    <url>/2019/11/03/24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191103101356721.png#pic_center"><br>在调整节点i的next指针，需要知道节点i的前一个节点h，事先还要保存i的下一个节点j，以防止链表断开。需要定定义三个指针</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* pRversedHead=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pNode=pHead;</span><br><span class="line">        ListNode* pPrev=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* pNext=pNode-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pNext==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pRversedHead=pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pNode-&gt;next=pPrev;</span><br><span class="line">            pPrev=pNode;</span><br><span class="line">            pNode=pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRversedHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>22.链表中倒数第k个结点</title>
    <url>/2019/11/02/22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>先统计链表节点的个数n，再从头遍历到第n-k+1个节点</li>
<li>为了实现只遍历一次，可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动，从第k步开始，第二个指针也开始从链表的头指针开始遍历</li>
</ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>思维全面，注意代码的鲁棒性 。</p><a id="more"></a>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* Ahead=pListHead;</span><br><span class="line">        ListNode* Behind=pListHead;</span><br><span class="line">        <span class="keyword">if</span>(pListHead==<span class="literal">NULL</span> || k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Ahead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">                Ahead=Ahead-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Ahead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ahead=Ahead-&gt;next;</span><br><span class="line">            Behind=Behind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Behind;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>题目：求链表的中间节点，如果节点的总数为奇数，则返回中间节点，若节点的总数为偶数，返回中间两个节点的任意一个。</p>
<p>思路：定义两个指针，一个指针一次走一步，一个指针一次走两部</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>C ++ 学习（16）——&的用法</title>
    <url>/2019/11/02/C-%E5%AD%A6%E4%B9%A0%EF%BC%8816%EF%BC%89%E2%80%94%E2%80%94-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二进制的位与运算。"><a href="#二进制的位与运算。" class="headerlink" title="二进制的位与运算。"></a>二进制的位与运算。</h1><p>例如 二进制数字 100 &amp; 111 = 100；</p><h1 id="表示取地址。"><a href="#表示取地址。" class="headerlink" title="表示取地址。"></a>表示取地址。</h1><p>eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用，顾名思义是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价</p><a id="more"></a>


<p>   <strong>注意：</strong></p>
<p> ==引用的类型必须和其所绑定的变量的类型相同==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=<span class="number">10.3</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b=a;<span class="comment">//错误，引用的类型必须和其所绑定的变量的类型相同</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>  ==声明引用的同时必须对其初始化==</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;a;<span class="comment">//错误，声明引用的同时必须对其初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==引用相当于变量或对象的别名，因此不能再将已有的引用名作为其他变量或对象的名字或别名==<br>==引用不是定义一个新的变量或对象，因此内存不会为引用开辟新的空间存储这个引用==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;new_value=value;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"value在内存中的地址:"</span>&lt;&lt;&amp;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"new_value在内存中的地址:"</span>&lt;&lt;&amp;new_value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190927105109522.png#pic_center"></p>
<p><strong>引用作为函数的参数</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a ,<span class="keyword">int</span> &amp;b)</span></span>&#123;<span class="comment">//引用作为函数的形参</span></span><br><span class="line">    <span class="keyword">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>当用引用作为函数的参数时，其==效果和用指针作为函数参数的效果相当==。当调用函数时，==函数中的形参就会被当成实参变量或对象的一个别名来使用==，也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参。</li>
<li>通常函数调用时，系统采用值传递的方式将实参变量的值传递给函数的形参变量。此时，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，也就是说形参变量只是实参变量的副本而已；并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象。而使用引用作为函数的形参时，由于此时==形参只是要传递给函数的实参变量或对象的别名而非副本==，故==系统不会耗费时间来在内存中开辟空间来存储形参==。因此如果参数传递的数据较大时，==建议使用引用作为函数的形参，这样会提高函数的时间效率，并节省内存空间==。</li>
<li>使用指针作为函数的形参虽然达到的效果和使用引用一样，但==当调用函数时仍需要为形参指针变量在内存中分配空间，而引用则不需要这样==，故在C++中推荐使用引用而非指针作为函数的参数</li>
<li><p>如果在编程过程中既希望通过让引用作为函数的参数来提高函数的编程效率，又希望保护传递的参数使其在函数中不被改变，则此时应当使用对常量的引用作为函数的参数。</p>
</li>
<li><p>数组的引用作为函数的参数：C++的数组类型是带有长度信息的，==引用传递时如果指明的是数组则必须指定数组的长度==</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(&amp;a) [<span class="number">5</span>])</span></span>&#123;<span class="comment">//数组引用作为函数的参数，必须制定数组的长度</span></span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常引用</strong><br>语法：const 类型 &amp;引用名=目标变量名；<br>==常引用不允许通过该引用对其所绑定的变量或对象进行修改==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;new_a=a;</span><br><span class="line">new_a=<span class="number">11</span>;<span class="comment">//错误，不允许通过常引用对其所绑定的变量或对象进行修改</span></span><br></pre></td></tr></table></figure>
<p><strong>引用作为函数的返回值</strong><br>语法：类型 &amp;函数名（形参列表）{ 函数体 }</p>
<p>注意：<br>==引用作为函数的返回值时，必须在定义函数时在函数名前将&amp;==</p>
<p>==用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">fn1</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123;</span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">float</span> &amp;<span class="title">fn2</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123; <span class="comment">//&amp;说明返回的是temp的引用，换句话说就是返回temp本身</span></span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a=fn1(<span class="number">5.0</span>); <span class="comment">//case 1：返回值</span></span><br><span class="line">    <span class="comment">//float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type 'float&amp;' from an rvalue of type 'float'</span></span><br><span class="line">                           <span class="comment">//（有些编译器可以成功编译该语句，但会给出一个warning） </span></span><br><span class="line">   <span class="keyword">float</span> c=fn2(<span class="number">5.0</span>);<span class="comment">//case 3：返回引用</span></span><br><span class="line">   <span class="keyword">float</span> &amp;d=fn2(<span class="number">5.0</span>);<span class="comment">//case 4：用函数返回的引用作为新引用的初始化值</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;b&lt;&lt;endl;//78.5</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用引用实现多态</strong><br>在C++中，引用是除了指针外另一个可以产生多态效果的手段。也就是说一个基类的引用可以用来绑定其派生类的实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>;</span><span class="comment">//基类（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>：<span class="title">public</span> <span class="title">Father</span>&#123;</span>.....&#125;<span class="comment">//Son是Father的派生类</span></span><br><span class="line">Son son;<span class="comment">//son是类Son的一个实例</span></span><br><span class="line">Father &amp;ptr=son;<span class="comment">//用派生类的对象初始化基类对象的使用</span></span><br></pre></td></tr></table></figure>
<p>ptr只能用来访问派生类对象中从基类继承下来的成员。如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li><p>在引用的使用中，单纯给某个变量去别名是毫无意义的，引用的目的主要用于在函数参数的传递中，解决大块数据或对象的传递效率和空间不如意的问题</p>
</li>
<li><p>用引用传递函数的参数，能保证参数在传递的过程中不产生副本，从而提高传递效率，同时通过const的使用，还可以保证参数在传递过程中的安全性</p>
</li>
<li><p>引用本身是目标变量或对象的别名，对引用的操作本质上就是对目标变量或对象的操作。因此能使用引用时尽量使用引用而非指针</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>21.调整数组顺序使奇数位于偶数前面</title>
    <url>/2019/11/02/21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul>
<li>最简单从头遍历，每碰到一个偶数，拿出这个数字，把位于这个偶数后面的所有数字往前移一位，再把这个数字放在数组末尾，时间复杂度$O(n^2)$</li>
<li><p>需要两个指针分别指向数组的头和尾，依次比较。</p>
<ol>
<li>如果头指针指向的数组位置为奇数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则头指针后移一个位置，如果是偶数，则尾指针前移一个位置。</li>
<li>如果头指针指向的数组位置为偶数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则交换头尾指针指向的数组元素，如果是偶数，则尾指针前移一个位置。</li>
</ol>
</li>
</ul><a id="more"></a>

<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_1</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin，直到它指向偶数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; <span class="number">0x1</span>) != <span class="number">0</span>)</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd，直到它指向奇数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_2</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reorder(pData, length, isEven);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; !func(*pBegin))</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; func(*pEnd))</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>vector表示</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> reOrderArray(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> j=<span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">array</span>[i]&amp;<span class="number">0x1</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>((<span class="built_in">array</span>[j]&amp;<span class="number">0x1</span>)==<span class="number">0</span>)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp=<span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i]=<span class="built_in">array</span>[j];</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并==保证奇数和奇数，偶数和偶数之间的相对位置不变==。</p>
<p>时间复杂度$O(n)$,空间复杂度$O(n)$</p>
<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时间：3ms,占用内存：492k</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1,vec2 ;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&amp; <span class="number">0x1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vec1.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vec2.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">array</span>.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">            <span class="built_in">array</span>.push_back(vec1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="built_in">array</span>.push_back(vec2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时间：3ms,占用内存：484k</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录第一个为奇数的位置</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&amp;<span class="number">0x1</span>)<span class="comment">//找到第一个奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="built_in">array</span>[i];<span class="comment">//记录第一个奇数</span></span><br><span class="line">                <span class="keyword">int</span> k=i;</span><br><span class="line">                <span class="keyword">for</span>(;k&gt;j;k--)<span class="comment">//将奇数之前的所有元素往后移一个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">array</span>[k]=<span class="built_in">array</span>[k<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>ORB-SLAM——论文翻译（ORB-SLAM:a Versatile and Accurate Monocular SLAM System）</title>
    <url>/2019/11/01/ORB-SLAM%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88ORB-SLAM-a-Versatile-and-Accurate-Monocular-SLAM-System%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><center>ORB-SLAM：一种通用的(全能的)精确的单目SLAM系统<center></center></center></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文提出了ORB-SLAM，在大小场景、室内室外环境下都可以实时操作的一种基于特征的单目SLAM系统。系统对复杂的剧烈运动具有鲁棒性，允许宽基线的闭环和重定位，且包含完整的自动初始化。基于最近几年的优秀算法之上，我们从头开始设计了一种新颖的系统，它对所有SLAM任务使用相同的特征：追踪、建图、重定位和闭环。合适策略的存在使得选择的重建点和关键帧具有很好的鲁棒性，并能够生成紧凑的可追踪的地图，只有当场景内容发生变化地图才改变，从而允许长时间操作。本文从最受欢迎的数据集中提供了27个序列的详尽评估。相对于其他最先进的单目SLAM方法，ORB-SLAM实现了前所未有的性能。为了社会的利益，我们将源代码公开。</p><a id="more"></a>

<p>关键字：持续建图，定位，单目视觉，识别，同时定位和制图（SLAM）。</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>BA提供相机定位的精确估计以及稀疏几何重建[1,2]，并且提供了强烈的匹配网络和良好的初始猜测。一段长的时间，这种方法被认为不符合实时性的应用，如视觉VSLAM。VSLAM系统在构建环境的同时需要估计相机的轨迹。现在，我们为了不以过高的计算成本获得准确的结果，实时SLAM算法必须向BA提供以下信息。</p>
<ul>
<li>在候选图像帧子集中（关键帧）匹配观测的场景特征（地图云点）</li>
<li>由于关键帧数量的增长，需要做筛选避免冗余</li>
<li>关键帧和云点的网络配置可以产生精确的结果，也就是，分布良好的关键帧集合和有明显视差、大量回环匹配的观测云点</li>
<li>关键帧和云点位置的初始估计，采用非线性优化的方法</li>
<li>在构建局部地图的过程中，优化的关键是获得良好的稳定性</li>
<li>本系统可以实时执行快速全局优化（比如位姿图）以实现闭环回路</li>
</ul>
<p>BA第一次实时应用是在Mouragon等人[13]提出的视觉里程计算法中，其次是在Klein和Murray的突破性工作PTAM[4]算法中。尽管受制于小场景的应用，PTAM算法对关键帧的选择，特征匹配，点的三角化，相机位姿估计，追踪失败后的重定位非常有效。然而，由于缺少闭环检测和对遮挡场景的处理，再加上其视图不变性差，在地图初始化时需要人工干预等多个因素，使得PTAM算法的应用收到了严重的限制。</p>
<p>在本文中，我们基于PTAM算法的主要框架，采用Gálvez-López和Tardós提出的place recognition（场景/位置识别）算法，Strasdat等人提出的scale-aware loop closing（具备尺度感知的闭环检测）算法以及文献[7][8]中的大尺度操作中Covisibility信息的使用，重新设计了一种新的单目SLAM系统ORB-SLAM，本文的贡献主要包括：</p>
<ul>
<li>对所有的任务采用相同的特征：追踪、地图构建、重定位和闭环检测。这使得我们的系统更有效率、简单可靠。采用的ORB特征[9]在没有GPU的情况下也有很好的实时性，且具有旋转不变性和光照不变性。</li>
<li>算法支持在宽阔环境中实时操作。由于covisibility graph的使用，特征点的跟踪与构图主要集中在局部共视区域，而与全局地图的大小无关。</li>
<li>使用Essential Graph来优化位姿实现回环检测。构建生成树，并由系统、闭环检测链接和covisibility graph的强边缘进行维护。</li>
<li>算法的实时相机重定位具有明显的旋转不变特性和光照不变性。这就使得点跟踪丢失后可以恢复，增强了地图的重用性。</li>
<li>提出了一种合适的方法来选择地图点云和关键帧，通过严格删选关键帧和地图点，剔除冗余信息，使得特征点的跟踪具备了更好的稳定性，从而增强算法的可持续操作性。好的挑选方法可以增强追踪的鲁棒性，同时舍弃多余的关键帧加强系统长时间操作性</li>
</ul>
<p>我们在公共数据集上对算法的性能在室内和室外环境下进行了评估，包括手持设备、汽车和机器人。值得一提的是，与目前最新的直接SLAM算法[10]相比——直接SLAM方法通过直接对像素点的灰度进行优化而不是最小化特征重投影误差，我们的方法能够实现更精确的摄像头定位精度。我们在文章的第IX-B部分还讨论了基于特征的SLAM方法定位比直接法更准确的原因。</p>
<p>闭环检测和重定位的方法是基于我们之前的论文[11]。系统最初的版本是论文[12]。本文中我们添加了初始化的方法，Essential graph ，并完善其他模块。我们详细了描述了系统的各个板块，并且开展了实验验证。<br>据我们所知，这是目前最完整最可靠的单目SLAM系统，为了使更多人获益，我们将源代码开放。视频演示和源代码放在我们的项目网站上。</p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h2 id="A、位置识别"><a href="#A、位置识别" class="headerlink" title="A、位置识别"></a>A、位置识别</h2><p>Williams等人在综述[13]中比较了几种基于景象的位置识别方法，即图像到图像的匹配，这种方法在大环境下比地图到地图或图像到地图的方法更准确。在景象匹配方法中，bags of words（词袋）[14]的使用以其效率很高而脱颖而出，比如概率方法FAB-MAP[15]算法,。DBoW2方法[5]则首次使用了BRIEF描述子[16]生成的二进制词袋和非常高效的FAST特征检测算法[17]与SURF和SIFT相比，FAST算法的运时间减小了至少一个数量级。然而，尽管系统运行效率高、鲁棒性好，采用BRIEF描述子不具有旋转不变性和尺度不变性，系统只能运行在同一平面内（否则会造成尺度变化）  ，闭环检测也只能从相似的视角中进行。在我们之前的工作[11]中，我们提出了一个使用ORB特征检测子的DBoW2位置识别器。ORB特征是具有旋转不变和尺度不变特性的二进制特征，因此，用它生成的快速识别器具有较好的视角不变性。我们在4组不同的数据集上演示了位置识别功能，从10K图像数据库中提取一个候选闭合回路的运算时间少于39毫秒。在本文的工作中，我们提出了一种改进版本的位置识别方法，采用covisibility信息，在检索数据库时返回几个假设情况而不是最好的匹配。</p>
<h2 id="B、地图初始化"><a href="#B、地图初始化" class="headerlink" title="B、地图初始化"></a>B、地图初始化</h2><p>单目SLAM系统需要设计专门的策略来生成初始化地图，因为单幅图像不具备深度信息。解决这个问题的一种方法是一开始跟踪一个已知结构的对象，正如文献[20]。另一个方法是用一个具有高不确定度的逆深度参数[21]来初始化点的深度信息，理想情况下，该参数会在后期逐渐收敛到真值。最近Engel提出的半稠密方法[10]中就采用类似的方法将像素的深度信息初始化为一个随机数值。</p>
<p>如果是从两个视角来初始化特征，就可以采用以下方法：一种是假设局部场景在同一平面内[4]，[22]，然后利用Faugeras等人论文[23]中的单应性来重构摄像头相对位姿。第二种是将场景建模为通用情况（不一定为平面），通过Nister提出的五点算法[26]来计算本征矩阵[24],[25]，但该方法存在多解的问题。这两种摄像头位姿重构方法在低视差下都没有很好的约束，如果平面场景内的所有点都靠近摄像机的中心，则结果会出现双重歧义[27]。另一方面，非平面场景可以通过线性8点算法[2]来计算基础矩阵，相机的相对位姿就可以无歧义的重构出来。</p>
<p>针对这一问题，我们在本文的第四部分提出了一个新的基于模型选择的自动初始化方法，对平面场景算法选择单应性矩阵，而对于非平面场景，算法选择基础矩阵。模型选择的综述方法可参见Torr等人的论文[28]。基于类似的理论，我们设计了一种启发式初始化算法，算法考虑到在接近退化情况（比如：平面，近平面，或是低视差）下选择基础矩阵进行位姿估计可能存在的问题，则选择单应性计算。在平面的情况下，为了保险起见，如果最终存在双重歧义，则算法避免进行初始化，因为可能会因为错误选择而导致算法崩溃。因此，我们会延迟初始化过程，直到所选的模型在明显的视差下产生唯一的解。</p>
<h2 id="C、单目SLAM"><a href="#C、单目SLAM" class="headerlink" title="C、单目SLAM"></a>C、单目SLAM</h2><p>单目SLAM最初采用滤波框架[20],[21],[29],[30]来建模。在该类方法中，每一帧都通过滤波器联合估计地图特征位置和相机位姿。这样做带来的问题是在处理连续帧图像上对计算资源的浪费和线性误差的累积。而另外一种SLAM框架是基于关键帧的，即采用少数筛选过的图像（关键帧）来构建地图，因为构图不再与帧率相关联，因此基于关键帧的SLAM方法不但节省了计算资源，还可以进行高精度的BA优化。Strasdar等人在论文[31]中证明了基于关键帧的单目SLAM方法比滤波器方法在相同的运算代价上定位结果更精确。</p>
<p>基于关键帧的SLAM系统最具代表性可能是由Klein和Murray等人提出的PTAM算法[4]。它第一次将相机追踪和地图构建拆分成两个并行的线程运行，并成功用于小环境的实时增强现实中。后来文献[32]引入边缘特征对PTAM算法进行了改进，在跟踪过程中增加了旋转估计步骤，实现了更好的重定位效果。由于PTAM中的地图云点通过图像区块与FAST角点匹配，因此仅适合于特征跟踪并不适合用于后期的位置识别。而实际上，PTAM算法并没有进行大闭环检测，其重定位也仅是基于关键帧低分辨率缩略图的相关性进行的，因此视角不变性较差。</p>
<p>Strasdat等人在文献[6]中提出了一个基于GPU实现的大尺度单目SLAM系统，该系统前端采用光流算法，其次用FAST特征匹配和运动BA；后端是基于滑动窗口的BA。闭环检测通过具有相似性约束（7自由度）的位姿图优化来进行，该方法可以矫正在单目SLAM系统中出现的尺度偏移问题。在本文中，我们也将采用这种7自由度的位姿图优化方法，并将其应用到我们的Essential Graph中，更多细节将在第三部分D节里面描述。</p>
<p>Strasdat等人在文献[7]中采用了PTAM的前端，但其跟踪部分仅在一个从covisibility graph提取的局部图中进行。他们提出了一个双窗口优化后端，在内部窗口中连续进行BA，在有限大小的外部窗口中构建位姿图。然而， 只有当外部窗口尺寸足够大到可以包含整个闭环回路的情况下，闭环检测才能起作用。在我们的算法中，我们利用了Strasdat等人提出的基于covisibility的局部地图的优势，并且通过covisibility map来构建位姿图，同时重新设计前端和后端。另一个区别是，我们并没有用特别的特征提取方法做闭合回路检测（比如SURF方法），而是基于相同的追踪和建图的特征进行位置识别，获得具有鲁棒性的重定位和闭环检测。</p>
<p>在Pirker等人的论文[33]中作者提出了CD-SLAM方法，一个非常复杂的系统，包括闭环检测，重定位，大尺度操作以及对算法在动态环境运行所做的改进。但文中并没有提及地图初始化。因此不利于后期读者对算法的复现，也致使我们没法对其进行精确性、鲁棒性和大场景下的测试对比。</p>
<p>Song等人在论文[34]提出的视觉里程计方法中使用了ORB特征做追踪和处理BA后端滑动窗口。相比之下，我们的方法更加全面，因为他们的算法中没有涉及全局重定位，闭环回路检测，而且地图也不能重用。他们也使用了相机到地面的真实距离来限制单目SLAM算法的尺度漂移。Lim等人在我们提交本文最初的版本[12]之后发表了论文[25]，他们也采用相同的特征进行跟踪，地图构建和闭环检测。但是，由于Lim等人的算法选择的BRIEF描述子不具备尺度不变性，因此其算法运行受限在平面轨迹上。他们的算法仅从上一帧关键帧开始跟踪特征点，因此访问过的地图不能重用，这样的处理方式与视觉里程计很像，存在系统无限增长的问题。我们在第三部分E小节里面与该算法进行了定性比较。</p>
<p>Engel等人在最近的论文[10]里提出了LSD-SLAM算法，其可以构建大场景的半稠密地图。算法并没有采用特征提取和BA方法，而是选择直接法（优化也是直接通过图像像素灰度进行）。算法的结果让人印象深刻，其在没有GPU加速的情况下实时构建了一个半稠密地图，相比基于特征的稀疏地图SLAM系统而言，LSD-SLAM方法在机器人领域有更大的应用潜力。然而，该算法的运行仍然需要基于特征做闭环检测，且相机定位的精度也明显低于PTAM和我们的算法，相关实验结果我们将在第8部分的B小节中展示，对该结果的讨论在文章IX部分B小节进行。</p>
<p>Forster等人在论文[22]中提出了介于直接方式和基于特征的方法之间的半直接视觉里程计算法SVO方法。该方法不需要对每帧图像都提取特征点，且可以以很高的帧率运行，在四轴飞行器上取得了令人惊叹的定位效果。然而，SVO算法没有进行闭环检测，且目前主要基于下视摄像头运行。</p>
<p>最后，我们想讨论一下目前关键帧的选择方法。由于所有的视觉SLAM算法选择所有的云点和图像帧运行BA是不可行的。因此，在论文[31]中，Strasdat等人证明最合理的选择是保留尽可能多地点云和非冗余关键帧。PTAM方法非常谨慎插入关键帧避免运算量增长过大。然而，这种严格限制关键帧插入的策略在算法运行困难的情况下可能会导致追踪失败。在本文中，为了达到更好的稳定性，我们选择一种更为合适的关键帧插入策略，当算法运行困难的时候算法选择尽快的插入关键帧，然后在后期将冗余的关键帧删除以避免额外的计算成本。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="A、特征选择"><a href="#A、特征选择" class="headerlink" title="A、特征选择"></a>A、特征选择</h2><p>我们系统设计的中心思想是对SLAM系统的构图、跟踪、重定位以及闭环检测等模块都采用相同的特征，这将使得我们的系统更有效率，避免了像以往文章[6],[7]一样还需要额外插入一些额外的识别性强的特征以用于后期的闭环检测。我们每张图像的特征提取远少于33毫秒，远小于目前的SIFT算法（~300ms）,SURF算法(~300ms)，或最近提出的A-KAZE（~100ms）算法。为了使算法的位置识别能力能更加通用化，我们需要提取的特征具备旋转不变性，而BRIEF和LDB不具备这样的特性。</p>
<p>为此，我们选择了ORB[9]特征，其是具有256位描述符的带方向的多尺度FAST角点。他们计算和匹配的速度非常快，同时对视角具有旋转不变的特性。这样可以在更宽的基准线上匹配他们，增强了BA的精度。我们已经在论文[11]中演示了基于ORB特征的位置识别性能。需要申明的是，虽然本文的方案中采用ORB算法，但所提出的技术并不仅限于该特征。</p>
<h2 id="B、三个线程：追踪、局部地图构建和闭环检测"><a href="#B、三个线程：追踪、局部地图构建和闭环检测" class="headerlink" title="B、三个线程：追踪、局部地图构建和闭环检测"></a>B、三个线程：追踪、局部地图构建和闭环检测</h2><blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101155613105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">&gt;图1 ORB-SLAM系统框架，图中显示了算法的三个线程——跟踪、局部构图与闭环检测的所有步骤。另外还有场景识别和地图的主要组成部分。</p>
</blockquote>
<p>我们的系统框架如图1所示，包括三个并行的线程：跟踪、局部地图构建和闭环回路检测。跟踪线程负责对每帧图像的相机位置进行定位，并决定什么时候插入新的关键帧。我们首先通过与前一帧图像匹配得到初始特征点，然后采用运动BA优化摄像头位姿。如果特征跟丢（比如由于遮挡或是突然运动），则由位置识别模块进行全局重定位。一旦获得最初的相机位姿估计和特征匹配，则使用由系统维护的关键帧的covisibility graph提取一个局部可视化地图，如图2(a),图2(b)所示。然后通过重投影方法搜索当前帧与局部地图点对应的匹配点，并利用所有的匹配点优化当前相机位姿。最后，跟踪线程决定是否插入新的关键帧。所有的跟踪步骤将在第5部分详细阐述。创建初始化地图的新方法将在第4部分进行说明。</p>
<p>局部地图构建模块负责处理新的关键帧，对周围的相机位姿进行局部BA以优化重构。在covisibility graph已连接的关键帧中搜索新的关键帧中ORB特征的匹配点，然后三角化新的地图点。有时尽管已经创建了新的点云，但基于跟踪线程过程中新收集的信息，为了保证点云的高质量，可能会根据点云筛选策略临时删除一些点。局部地图构建模块也负责删除冗余的关键帧。我们将在第6章详细说明局部地图构建的步骤。</p>
<p>对每个新的关键帧都要进行闭环搜索，以确认是否形成闭环。如果闭环被侦测到，我们就计算相似变换来查看闭环的累积误差。这样闭环的两端就可以对齐，重复的云点就可以被融合。最后，为了确保全局地图的一致性，利用相似性约束[6]对位姿图进行优化。这里值得一提的是，本文主要对Essential Graph进行优化，它是一个covisibility graph中的一个更稀疏的子图，更多细节将在第三部分D小节描述。闭环检测和校验步骤将在第7部分详细描述。</p>
<p>我们使用g2o[37]库中的Levenverg-Marquardt算法执行所有的优化。我们在附录中描述了每个优化的误差，计算成本和变量。</p>
<h2 id="C、地图点云、关键帧及其选择标准"><a href="#C、地图点云、关键帧及其选择标准" class="headerlink" title="C、地图点云、关键帧及其选择标准"></a>C、地图点云、关键帧及其选择标准</h2><p>对每个地图点云pi保存以下信息：</p>
<ul>
<li>它在世界坐标系中的3D坐标$X_{w.i}$</li>
<li>视图方向$n_i$，即所有视图方向的平均单位向量（该方向是指连接该点云和其对应观测关键帧光心的射线方向）</li>
<li>ORB特征描述子$D_i$，与其他所有能观测到该点云的关键帧中ORB描述子相比，该描述子的汉明距离最小</li>
<li>根据ORB特征尺度不变性约束，可观测的点云的最大距离$d_{max}$和最小距离$d_{min}$</li>
</ul>
<p>对每个关键帧$K_i$保存以下信息：</p>
<ul>
<li>相机位姿$T_(i,w)$，从世界坐标系转换到相机坐标系下的变换矩阵</li>
<li>相机内参，包括主点和焦距</li>
<li>从图像帧提取的所有ORB特征，不管其是否已经关联了地图云点， 这些ORB特征点都经过畸变模型矫正过</li>
</ul>
<p>地图点云和关键帧的创建条件较为宽松，但是之后则会通过一个非常严格苛刻的删选机制进行挑选，该机制会检测出冗余的关键帧和匹配错误的或不可跟踪的云点进行删除。这样做的好处在于地图在构建过程中具有一定的弹性，在外界条件比较困难的情况下（比如：旋转，相机快速运动），算法仍然可以实现鲁棒的跟踪，而与此同时，当相机对同一个环境重访问时，地图的尺度大小是可控的，这就利于该系统的长期工作。另外，与PTAM算法相比，我们构建的地图中基本不包含局外点，因为秉持的原则是很苛刻的，宁缺毋滥。地图云点和关键帧的筛选过程将在第6部分B节和E节分别解释。</p>
<h2 id="D、Covisibility-Graph和Essential-Graph"><a href="#D、Covisibility-Graph和Essential-Graph" class="headerlink" title="D、Covisibility Graph和Essential Graph"></a>D、Covisibility Graph和Essential Graph</h2><p>关键帧之间的Covisibility信息在本文的SLAM系统中几个模块上都非常有用，像论文[7]一样，我们将其表示成一个间接的权重图。图中每个节点代表一个关键帧，如果两个关键帧都能同时观测到地图云点中至少15个点，则这两个关键帧之间用一条边线相连，我们用权重θ表示两个关键帧能共同观测到的云点数量</p>
<p>为了矫正闭环回路，我们像论文[6]那样做位姿图优化，优化方法延着位姿图将闭环回路的误差进行分散。考虑到covisibility graph可能非常密集的边缘，我们提出构建一个（Essential Graph），该图中保留了covisibility graph的所有节点（关键帧），但是边缘更少，仍旧保持一个强大的网络以获得精确的结果。系统从初始关键帧开始增量式地构建一个生成树，它是一个边缘数量最少的covisibility graph的子图像。当插入新的关键帧时，则判断其与树上的关键帧能共同观测到多少云点，然后将其与共同观测点最多的关键帧相连反之，当一个关键帧通过筛选策略被删除时，系统会重新更新与其相关的连接。Essential Graph包含了一个生成树，一个高covisibility（θmin=100）的covisibility graph边缘子集，以及闭环回路的边缘，这样的组合共同构建了一个强大的相机网络。图2展示了一个covisibility graph，生成树和相关的essential graph的例子。在本文第8部分第E节的实验里，当算法运行位姿图优化时，结果可以达到非常高的精度以至于即便是全局BA优化都很难达到。。essential graph的效用和θmin对算法的影响将在第8部分E节的最后讨论。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160115593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">&gt;图2 对TUM RGB-D标准库[38]中fr3_long_office_household图像序列进行重构以及本文用到的各种姿态图的例子</p>
</blockquote>
<h2 id="E、基于图像词袋模型的位置识别"><a href="#E、基于图像词袋模型的位置识别" class="headerlink" title="E、基于图像词袋模型的位置识别"></a>E、基于图像词袋模型的位置识别</h2><p>为了实现闭环检测与重定位，系统嵌入了基于DBoW2[5]算法来执行闭环检测和重定位。视觉词汇（Visual words）是一个离散化的特征描述子空间，被称为视觉词典。这部视觉词典是通过从大量图像中提取ORB描述子离线创建的。如果图像的通用性强，则同一部视觉词典在不同的环境下也能获得很好的性能，正如我们之前的论文[11]那样。SLAM系统增量式地构建一个数据库，该数据库中包含了一个反向指针，用于存储每个视觉词典里的视觉单词，关键帧可以通过这个数据库查询视觉词典，从而实现高效检索。当一个关键帧通过筛选程序删除时，数据库也会相应更新。</p>
<p>由于关键帧之间可能会存在视图上的重叠，因此检索数据库时，可能返回的结果不止一个高分值的关键帧。原版的DBoW2认为是图像重叠的问题，就将时间上接近的图像的分值相加。但这并没有包括观测同一地点但在不同时间插入的关键帧。为了解决这一问题，我们将这些与covisibility graph相连的关键帧进行分类。另外，我们的数据库返回的是分值高于最好分值75%的所有关键帧。<br>用词袋模型来表示特征匹配的另外一个优势在论文[5]里有详细介绍。如果我们想计算两个ORB特征的对应关系，我们可以强制匹配视觉字典树上某一层（我们在6层里面选第2层）的相同节点（关键帧）里的特征，这可以加快搜索速度。在本文中，我们就利用这个小技巧来搜索匹配的特征点，用于三角化新的点云，闭环检测和重定位。我们还引入一个方向一致性测试来改进匹配点，具体如论文[11]，这可以去掉无效数据，保证所有对应匹配点的旋转方向一致。</p>
<h1 id="IV-地图自动初始化"><a href="#IV-地图自动初始化" class="headerlink" title="IV. 地图自动初始化"></a>IV. 地图自动初始化</h1><p>地图初始化的目的是计算两帧图像之间的相对位姿来三角化一组初始的地图云点。这个方法应该与场景无关（平面的或一般的）而且不需要人工干预去选择良好的双视图配置，比如两幅图应具有明显的视差。本文算法提出并行计算两个几何模型，一个是面向平面视图的单映矩阵，另一个是面向非平面视图的基础矩阵。然后，采用启发式的方法选择模型，并使用所选的模型从两图像的相对位姿中对地图点云进行重构。本文算法只有当两个视图之间的视差达到安全阈值时，才进行地图初始化。如果检测到低视差的情况或已知两视图模糊的情况（如论文[27]所示），则为了避免生成一个有缺陷的地图而推迟初始化。算法的步骤是：</p>
<ul>
<li>1.查找初始的匹配点对：<br>从当前帧中提取ORB特征$F_c$（只在最好的尺度上），与在参考帧$Ｆ_r$搜索匹配点对 $x_c\leftrightarrow x_r$。如果找不到足够的匹配点对，就重置参考帧。</li>
<li>2.并行计算两个模型：<br>在两个线程上并行计算单应矩阵$H_{cr}$和基础矩阵$F_{cr}$ ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160909286.png#pic_center"><br>在文献[2]中详细解释了基于RANSAC的归一化DLT算法和8点算法计算原理。为了使两个模型的计算流程尽量一样，将两个模型的迭代循环次数预先设置成一样，每次迭代的特征点数目也预先设置好，基础矩阵是8个特征点对，单映矩阵是4个特征点对。每次迭代中，我们给每个模型M（H表示单映射，F表示基本矩阵）计算一个分值SM：</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160949854.png#pic_center"></p>
<p>其中，$d_{cr}^2$和$d_{rc}^2$是帧到帧之间的对称传递误差，其计算方法参见文献[2]。$T_M$是无效数据的排除阈值，它的依据是$\chi ^2$测试的95%（$T_H=5.99, T_F=3.84$，假设在测量误差上有1个像素的标准偏差）。 等于$T_H$，这样两个模型在有效数据上对于同一误差d的分值相同，同样使得运算流程保持一致。<br>我们从单应矩阵和基本矩阵的计算中选择分值最高的，但如果两个模型分值都不高（没有足够的局内点），则算法流程重启，从step1开始重新计算。</p>
<ul>
<li><p>3.模型选择：</p>
<p>如果场景是平面，近平面或存在低视差的情况，则可以通过单映矩阵来求解。同样地，我们也可以找到一个基础矩阵，但问题是基础矩阵不能够很好的约束该问题[2]，而且从基础矩阵中计算得到的运动结果是错误的。在这种情况下，我们应该选择单映矩阵才能保证地图初始的正确性，或者如果检测到低视差的情况则不进行初始化工作。另一方面，对于非平面场景且有足够的视差的情况则可以通过基础矩阵来计算，而在这种情况下单映矩阵只有基于平面点或者低视差的匹配点才能找到。因此，在这种情况下我们应该选择基础矩阵。我们利用如下强大的启发式进行计算：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161616755.png#pic_center"><br>如果$R_H&gt;0.45$ , 这表示二维平面和低视差的情况，我们将选择计算单应矩阵。其他的情况，我们选择基础矩阵。</p>
</li>
<li>4.运动和从运动到结构的重构</li>
<li>一旦选择好模型，我们就可以获得相应的运动状态。如果选择单映矩阵，我们按照Faugeras等人发表的论文[23]中提到的方法，提取8种运动假设，该方法提出用cheriality测试来选择有效解。然而，如果在低视差的情况下，这些测试就会失效，因为云点很容易在相机的前面或后面移动，会导致选解错误。我们提出的方法是直接按这8种解将二维点三角化，然后检查是否有一种解可以使得所有的云点都位于两个相机的前面，且重投影误差较小。如果没有一个明确的解胜出，我们就不执行初始化，重新从第一步开始。这种方法使初始化程序在低视差和两个交叉的视图情况下更具鲁棒性，这也是我们整个算法体现鲁棒性的关键所在。<br>在基本矩阵的情况下，我们使用标定矩阵K用下式将其转换为本质矩阵：．<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161803488.png#pic_center"><br>然后用文献[2]中的奇异值分解方法计算4个运动解，然后就像上文中叙述的一样，我们将四个解用于三角化特征点，以选择正解。</li>
<li>C5.Bundle adjustment<br>最后我们执行一个全局BA，详细优化过程参见附录，以优化初始重构得到的点云地图。<br>如图3所示是对论文[39]中的室外NewCollege机器人图像序列进行地图初始化的例子，室外环境下初始化工作具有很大挑战性。从图中可以看出，PTAM算法和LSD-SLAM算法对位于同一平面上的所有点都进行了初始化，而我们的方法是当两幅图像有足够视差之后才进行初始化，并基于基础矩阵得到了正确的结果。<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161919724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图3 基于NewCollege图像序列[39]进行地图初始化，最上面一行：PTAM算法,中间一行：LSD-SLAM算法，底下一行：ORB-SLAM算法。其中，PTAM算法和LSD-SLAM算法初始化了一个错误的平面地图，而我们的方法自动选择在两帧图像存在足够视差的情况下再利用基础矩阵初始化。如果人工选择关键帧，则PTAM算法也能够初始化得很好。</p>
<h1 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h1><p>在这一部分，我们将详细介绍跟踪线程在相机每帧图像上执行的步骤。在几个步骤中都提到的相机位姿优化，包括运动BA，将在附录部分进行阐述。</p>
<h2 id="A、ORB特征提取"><a href="#A、ORB特征提取" class="headerlink" title="A、ORB特征提取"></a>A、ORB特征提取</h2><p>我们在8层图像金字塔上提取FAST角点，金字塔图像尺度因子为1.2。如果图像分辨率从512<em>384到752</em>480，我们发现提取1000个角点比较合适，如果分辨率提高，如KITTI数据集[40]，则提取2000个角点。为了确保特征点均匀分布，我们将每层图像分成网格，每格提取至少5个角点。然后检测每格角点，如果角点数量不够，就调整阈值。如果某些单元格内检测不出角点，则其对应提取的角点数量也相应减少。最后，根据保留的FAST的角点计算方向和ORB特征描述子。ORB特征描述子将用于算法后续所有的特征匹配，而不是像PTAM算法中那样根据图像区块的相关性进行搜索。</p>
<h2 id="B、通过前一图像帧估计相机的初始位姿"><a href="#B、通过前一图像帧估计相机的初始位姿" class="headerlink" title="B、通过前一图像帧估计相机的初始位姿"></a>B、通过前一图像帧估计相机的初始位姿</h2><p>如果上一帧图像跟踪成功，我们就用运动速率恒定模型来预测当前相机的位置（即认为摄像头处于匀速运动），然后搜索上一帧图像中的特征点在地图中的对应云点与当前帧图像的匹配点，最后利用搜索到的匹配点对当前相机的位姿进一步优化。但是，如果没有找到足够的匹配点（比如，运动模型失效，非匀速运动），我们就加大搜索范围，搜索地图云点附近的点在当前帧图像中是否有匹配点，然后通过寻找到的对应匹配点对来优化当前时刻的相机位姿。</p>
</blockquote>
</li>
</ul>
<h2 id="C、通过全局重定位来初始化位姿"><a href="#C、通过全局重定位来初始化位姿" class="headerlink" title="C、通过全局重定位来初始化位姿"></a>C、通过全局重定位来初始化位姿</h2><p>如果扩大了搜索范围还是跟踪不到特征点，（那么运动模型已经失效），则计算当前帧图像的词袋（BoW）向量,并利用BoW词典选取若干关键帧作为备选匹配帧（这样可以加快匹配速度）；然后，在每个备选关键帧中计算与地图云点相对应的ORB特征，就如第三部分E节所描述的。接着，对每个备选关键帧轮流执行PnP算法[41]计算当前帧的位姿（RANSAC迭代求解）。如果我们找到一个姿态能涵盖足够多的有效点，则搜索该关键帧对应的更多匹配云点。最后，基于找到的所有匹配点对相机位置进一步优化，如果有效数据足够多，则跟踪程序将持续执行。</p>
<h2 id="D、跟踪局部地图"><a href="#D、跟踪局部地图" class="headerlink" title="D、跟踪局部地图"></a>D、跟踪局部地图</h2><p>一旦我们获得了初始相机位姿和一组初始特征匹配点，我们就可以将更多的地图云点投影到图像上以寻找更多的匹配点。为了降低大地图的复杂性，我们只映射局部地图。该局部地图包含一组关键帧K1，它们和当前关键帧有共同的地图云点，还包括与关键帧K1在covisibility graph中相邻的一组关键帧K2。这个局部地图中有一个参考关键帧$K_{ref}∈K1$，它与当前帧具有最多共同的地图云点。现在对K1, K2中可见的每个地图云点，在当前帧中进行如下搜索：</p>
<ul>
<li>1.计算地图云点在当前帧图像中的投影点x。如果投影位置超出图像边缘，就将对应的地图云点删除</li>
<li>2.计算当前视图射线v和地图云点平均视图方向n的夹角。如果n&lt;cos(60o)，就删除对应云点</li>
<li>3.计算地图云点到相机中心的距离d。如果它不在地图云点的尺度不变区间内，即d∉[dmin,dmax]，就删除该云点</li>
<li>4.计算每帧图像的尺度比d/dmin</li>
<li>5.对比地图云点的特征描述子D和当前帧中还未匹配的ORB特征，在预测的尺度层和靠近x的云点作最优匹配</li>
</ul>
<p>相机位姿最后通过当前帧中获得所有的地图云点进行优化。（这个环节的目的是在当前帧和局部地图之间找到更多的匹配点对，来优化当前帧的位姿）。</p>
<h2 id="新关键帧的判断"><a href="#新关键帧的判断" class="headerlink" title="新关键帧的判断"></a>新关键帧的判断</h2><p>最后一步是决定当前帧是否可以作为关键帧。由于局部地图构建的过程中有一个机制去筛选冗余的关键帧，所以我们需要尽快地插入新的关键帧以保证跟踪线程对相机的运动更具鲁棒性，尤其是对旋转运动。我们根据以下要求插入新的关键帧：</p>
<ul>
<li>1.距离上一次全局重定位后需要超过20帧图像。</li>
<li>2.局部地图构建处于空闲状态，或距上一个关键帧插入后，已经有超过20帧图像。</li>
<li>3.当前帧跟踪少于50个地图云点。</li>
<li>4.当前帧跟踪少于参考关键帧K_ref云点的90%。</li>
</ul>
<p>与PTAM中用关键帧之间的距离作为判断标准不同，我们加入一个最小的视图变换，如条件4。条件1 确保一个好的重定位，条件3保证好的跟踪。如果局部地图构建处于忙状态（条件2的后半部分）的时候插入关键帧，就会发信号去暂停局部BA，这样就可以尽可能快地去处理新的关键帧。</p>
<h1 id="局部建图"><a href="#局部建图" class="headerlink" title="局部建图"></a>局部建图</h1><p>这章我们将描述根据每个新的关键帧$K_i$构建局部地图的步骤。</p>
<h2 id="A、关键帧插入"><a href="#A、关键帧插入" class="headerlink" title="A、关键帧插入"></a>A、关键帧插入</h2><p>首先更新covisibility graph，具体包括：添加一个关键帧节点$K_i$，检查与$K_i$有共同云点的其他关键帧，用边线连接。然后，更新生成树上与$K_i$有最多共享点的其他关键帧的链接。计算表示该关键帧的词袋，并利用三角法生成新的地图云点。</p>
<h2 id="地图点云筛选"><a href="#地图点云筛选" class="headerlink" title="地图点云筛选"></a>地图点云筛选</h2><p>三角化的云点为了已知保留在地图中，必须在其创建后的头三个关键帧中通过一个严格的测试，该测试确保留下的云点都是能被跟踪的，不是由于错误的数据而被三角化的。一个云点必须满足如下条件：</p>
<ul>
<li>1.跟踪线程必须在超过25%的图像中找到该特征点。</li>
<li>2.如果创建地图云点经过了多个关键帧，那么它必须至少是能够被其他3个关键帧观测到。</li>
</ul>
<p>一旦一个地图云点通过测试，它只能在被少于3个关键帧观测到的情况下移除。这样的情况在关键帧被删除以及局部BA排除异值点的情况下发生。这个策略使得我们的地图包含很少的无效数据。</p>
<h2 id="C、新地图点云创建"><a href="#C、新地图点云创建" class="headerlink" title="C、新地图点云创建"></a>C、新地图点云创建</h2><p>新的地图云点的创建是通过对covisibility graph中连接的关键帧Kc中的ORB特征点进行三角化实现的。对Ki中每个未匹配的ORB特征，我们在其他关键帧的未匹配云点中进行查找，看是否有匹配上的特征点。这个匹配过程在第三部分第E节中有详细阐述，然后将那些不满足对级约束的匹配点删除。ORB特征点对三角化后，需要对其在摄像头坐标系中的深度信息，视差，重投影误差和尺度一致性进行审查，通过后则将其作为新点插入地图。起初，一个地图云点通过2个关键帧观测，但它在其他关键帧中也有对应匹配点，所以它可以映射到其他相连的关键帧中，搜索算法的细则在本文第5部分D节中有讲述。</p>
<h2 id="D、局部BA"><a href="#D、局部BA" class="headerlink" title="D、局部BA"></a>D、局部BA</h2><p>局部BA主要对当前处理的关键帧$K_i$,以及在covisibility graph中与$K_i$连接的其他关键帧$K_c$，以及这些关键帧观测到的地图云点进行优化所有其他能够观测到这些云点的关键帧但没有连接$K_i$的会被保留在优化线程中，但保持不变。优化期间以及优化后，所有被标记为无效的观测数据都会被丢弃，附录有详细的优化细节。</p>
<h2 id="E、局部关键帧筛选"><a href="#E、局部关键帧筛选" class="headerlink" title="E、局部关键帧筛选"></a>E、局部关键帧筛选</h2><p>为了使重构保持简洁，局部地图构建尽量检测冗余的关键帧，删除它们。这样对BA过程会有很大帮助，因为随着关键帧数量的增加，BA优化的复杂度也随之增加。当算法在同一场景下运行时，关键帧的数量则会控制在一个有限的情况下，只有当场景内容改变了，关键帧的数量才会增加，这样一来，就增加了系统的可持续操作性。如果关键帧Kc中90%的点都可以被其他至少三个关键帧同时观测到，那认为Kc的存在是冗余的，我们则将其删除。尺度条件保证了地图点以最准确的方式保持它们对应的关键帧（这句翻译没理解透：The scale condition ensures that map points maintain keyframes from which they are measured with most accuracy.）这个策略受Tan等人的工作[24]的启发，在这项工作中，作者在经过一系列变化检测后即将关键帧删除。</p>
<h1 id="闭环检测"><a href="#闭环检测" class="headerlink" title="闭环检测"></a>闭环检测</h1><p>闭环检测线程抽取$K_i$——最后一帧局部地图关键帧，用于检测和闭合回环。具体步骤如下：</p>
<h2 id="A、候选关键帧"><a href="#A、候选关键帧" class="headerlink" title="A、候选关键帧"></a>A、候选关键帧</h2><p>我们先计算Ki的词袋向量和它在covisibility graph中相邻图像（θmin=30）的相似度，保留最低分值Smin。然后，我们检索图像识别数据库，丢掉那些分值低于Smin的关键帧。这和DBoW2中均值化分值的操作类似，可以获得好的鲁棒性，DBoW2中计算的是前一帧图像，而我们是使用的covisibility信息。另外，所有连接到Ki的关键帧都会从结果中删除。为了获得候选回环，我们必须检测3个一致的候选回环（covisibility graph中相连的关键帧）。如果对Ki来说环境样子都差不多，就可能有几个候选回环。</p>
<h2 id="B、计算相似变换"><a href="#B、计算相似变换" class="headerlink" title="B、计算相似变换"></a>B、计算相似变换</h2><p>单目SLAM系统有7个自由度，3个平移，3个旋转，1个尺度因子 [6]。因此，闭合回环，我们需要计算从当前关键帧Ki到回环关键帧Kl的相似变换，以获得回环的累积误差。计算相似变换也可以作为回环的几何验证。</p>
<p>我们先计算ORB特征关联的当前关键帧的地图云点和回环候选关键帧的对应关系，具体步骤如第3部分E节所示。此时，对每个候选回环，我们有了一个3D到3D的对应关系。我们对每个候选回环执行RANSAC迭代，通过Horn方法（如论文[42]）找到相似变换。如果我们用足够的有效数据找到相似变换Sil，我们就可以优化它，并搜索更多的对应关系。如果Sil有足够的有效数据，我们再优化它，直到Kl回环被接受。</p>
<h2 id="C、回环融合"><a href="#C、回环融合" class="headerlink" title="C、回环融合"></a>C、回环融合</h2><p>回环矫正的第一步是融合重复的地图云点，在covisibility graph中插入与回环相关的的新边缘。先通过相似变换Sil矫正当前关键帧位姿Tiw，这种矫正方法应用于所有与Ki相邻的关键帧，这样回环两端就可以对齐。然后，回环关键帧及其近邻能观测到的所有地图云点都映射到Ki及其近邻中，并在映射的区域附近小范围内搜索它的对应匹配点，如第5部分D节所述。所有匹配的地图云点和计算Sil过程中的有效数据进行融合。融合过程中所有的关键帧将会更新它们在covisibility graph中的边缘，创建的新边缘将用于回环检测。</p>
<h2 id="D、Essential-Graph优化"><a href="#D、Essential-Graph优化" class="headerlink" title="D、Essential Graph优化"></a>D、Essential Graph优化</h2><p>为了有效地闭合回环，我们通过Essential Graph优化位姿图，如第三部分D节所示，这样可以将回环闭合的误差分散到图像中去。优化程序通过相似变换校正尺度偏移，如论文[6]。误差和成本计算如附录所示。优化过后，每一个地图云点都根据关键帧的校正进行变换。</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>我们采用NewCollege[39]的大场景机器人图像序列对本文提出的系统进行了较全面的实验评估，首先采用TUM的室内16个手持RGB-D数据集[38]对系统的总体性能进行了评估，包括算法的定位精度，重定位和程序运行能力；然后，用KITTI的10个汽车户外图像数据集[40]，评估算法在实时大场景下的操作及其定位精度和位姿图的优化效率。</p>
<p>算法运行在Intel Core i7-4700MQ （4核@2.40GHz）和8GB RAM的实验平台上，运算速率可达到实时，且以帧率对图像进行准确处理。ORB-SLAM有3个主线程，它们和其他ROS线程并行运行，由于引入了ROS操作系统，因此算法结果具有一定的随机性，针对这个原因，我们在一些实验中公布了算法运行的中间结果。</p>
<h2 id="A、基于Newcollege数据集测试系统性能"><a href="#A、基于Newcollege数据集测试系统性能" class="headerlink" title="A、基于Newcollege数据集测试系统性能"></a>A、基于Newcollege数据集测试系统性能</h2><p>NewCollege数据集[39]包含了一个2.2公里的校园的机器人图像序列。它是由双目相机拍摄，帧率为20fps，分辨率512x38。图像序列中包含几个回环和快速的旋转，这对单目视觉定位非常具有挑战性。据我们所知，目前没有单目系统可以处理整个图像序列。例如论文[7]，尽管其算法可以实现回环检测，也可以应用于大场景环境，但只有小部分序列图像能够显示单目结果。.<br>如图4显示的是我们的算法检测到的闭合回路，从图中可以看出，我们选择的有效数据点都支持相似性变换。图5则对比了回环闭合前后的环境地图重构状况。其中，红色标注的是局部地图，回环检测后可以看到其两端扩展到连接整个运行轨迹。图6是以实时帧率速度运行整个图像序列后的全局地图，从图中可以看出，后边的大回环并没有完全闭合，它从另外一个方向穿过，位置识别程序没能发现闭合回路。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164011644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201911011640368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164055751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>我们统计了ORB_SLAM算法每个线程所用的时间。表1显示了算法跟踪和局部构图的时间。可以看出，跟踪的帧率大概在25-30Hz，这是跟踪局部地图所需的最多时间。如果需要的话，这个时间还可以更快，只要减少局部地图中所包含的关键帧数量即可。局部地图构建线程中需时最高的是局部BA优化。局部BA的时间根据机器人探索环境的状态变动，即在未探索环境下所需时间多，在已经探索过的环境下运行所需时间少，因为在未知环境中如果跟踪线程插入一个新的关键帧，BA优化会被中断，如第5部分E节所示。如果不需要插入新的关键帧，局部BA优化则会执行大量已经设置的迭代程序。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164133928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>表2显示了6个闭合回路的结果。可以看到回环检测是如何亚线性地随关键帧数量的增多而增加。这主要是由于高效的数据库检索，表2中只比较了具有相同图像单词的图像子集，由此可见用于位置识别词袋模型的潜力。我们的Essential Graoh中包含的边缘是关键帧数量的5倍，它是一个稀疏图。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164204706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B、基于TUM-RGB-D标准库的定位精度"><a href="#B、基于TUM-RGB-D标准库的定位精度" class="headerlink" title="B、基于TUM RGB-D标准库的定位精度"></a>B、基于TUM RGB-D标准库的定位精度</h2><p>TUM RGB-D数据集[38]是一个用于估计摄像头定位精度的优秀数据库，它提供了许多图像序列，还包括外部运动捕捉系统提供的对应轨迹真值。我们去掉那些不适合纯单目SLAM系统的图像序列，这些序列包含强烈的旋转，没有纹理或没有运动。</p>
</blockquote>
<p>为了验证算法性能，我们选择了最近提出的直接法半稠密LSD-SLAM（论文[10]）和经典算法PTAM（论文[4]）作为对比。除此之外，我们还比较了由RGBD-SLAM（论文[43]）算法生成的轨迹。为了在相同的基准下比较ORB-SLAM，LSD-SLAM和PTAM，我们用相似变换对齐关键帧轨迹，在尺度未知的情况下，检测轨迹的绝对误差（论文[38]）。对RGBD-SLAM算法，我们通过相机坐标变换来对齐轨迹，也采用同样的方法检测尺度是否重构良好。LSD-SLAM从随机深度值开始初始化，然后随机值逐渐收敛，因此与基准对比的时候，我们会丢掉前10个关键帧。对于PTAM算法，我们从一个好的初始化中，手动选择两个关键帧。表3 是对我们选择的16个图像序列运行5次的中间结果。<br>TUM RGB-D数据集[38]是一个用于估计摄像头定位精度的优秀数据库，它提供了许多图像序列，还包括外部运动捕捉系统提供的对应轨迹真值。我们去掉那些不适合纯单目SLAM系统的图像序列，这些序列包含强烈的旋转，没有纹理或没有运动。</p>
<p>为了验证算法性能，我们选择了最近提出的直接法半稠密LSD-SLAM（论文[10]）和经典算法PTAM（论文[4]）作为对比。除此之外，我们还比较了由RGBD-SLAM（论文[43]）算法生成的轨迹。为了在相同的基准下比较ORB-SLAM，LSD-SLAM和PTAM，我们用相似变换对齐关键帧轨迹，在尺度未知的情况下，检测轨迹的绝对误差（论文[38]）。对RGBD-SLAM算法，我们通过相机坐标变换来对齐轨迹，也采用同样的方法检测尺度是否重构良好。LSD-SLAM从随机深度值开始初始化，然后随机值逐渐收敛，因此与基准对比的时候，我们会丢掉前10个关键帧。对于PTAM算法，我们从一个好的初始化中，手动选择两个关键帧。表3 是对我们选择的16个图像序列运行5次的中间结果。</p>
<p>从表中可以看出，ORB-SLAM可以处理所有的图像序列，除了fr3 nostructure texture far (fr3 nstr tex far)以外。这是一个平面的场景，相机的轨迹在这种情况下有两种可能，正如论文[27]中的描述的。我们的初始化方法检测到这种模棱两可的情况，为了保证算法的安全运行选择不进行初始化。PTAM初始化有时会选择对的方案，有些可能会选择错的方案，且导致的错误可能不能接受。我们没有注意到LSD-SLAM的2种不同的重构方案，但在这个图像序列出现的错误非常多。针对其他的图像序列，PTAM和LSD-SLAM算法的鲁棒性都比我们的方法差，且分别有八组序列和三组序列中地图点容易跟踪丢失。</p>
<p>关于精度问题，没有回环检测期间，ORB-SLAM和PTAM算法的定位精度相当，但回环检测成功后，ORB-SLAM算法将达到更高的定位精度，正如在图像序列fr3 nostructure texture near withloop (fr3 nstr tex near)中表现的。非常意外的一个结果是PTAM和ORB-SLAM都非常明显地表现出精度高于LSD-SLAM和RGBD-SLAM。一个可能的原因是它们将地图的优化过程简化为一个单纯的姿态图优化过程，这样就造成了传感器测量信息的丢失，但在我们的算法中，采用BA优化，同时通过传感器测量优化相机的姿态和地图的云点位置，这是解决运动到结构[2]的经典标准算法。。我们将在第9部分B节进一步讨论了这个结果。另一个有趣的结果是在图像序列fr2 desk with person 和 fr3 walking xyz中，LSD-SLAM对动态物体的鲁棒性相比ORB-SLAM差一些。</p>
<p>我们注意到RGBD-SLAM在图像序列fr2上尺度上有一个偏差，用7自由度对齐轨迹则误差明显减少。最后我们注意到Engle等人在论文[10]中提出在f2_xyz上PTAM的精度比LSD-SLAM算法低，RMSE是24.28cm。然而，论文没有给出足够的细节说明如何获得这些结果的，因此我们没有办法复现它。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164359174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="C、基于TUM-RGB-D标准数据库的重定位"><a href="#C、基于TUM-RGB-D标准数据库的重定位" class="headerlink" title="C、基于TUM RGB-D标准数据库的重定位"></a>C、基于TUM RGB-D标准数据库的重定位</h2><p>我们在TUM RGB-D数据集上进行了两组重定位实验。在第一个实验中，我们选择fr2_xyz图像序列，通过前30秒构建了一个地图，然后对后来的每一帧图像都进行全局重定位，并评估重构出来的相机位姿精度。我们对PTAM算法进行了相同的实验。如图7所示是创建初始地图的关键帧，重定位的图像帧位姿和这些帧对应的真值。从图中可以看出PTAM算法只能够对重定位关键帧附近的图像帧，这是因为其算法中重定位方法并不具备不变形导致的。表4显示了PTAM算法和ORB_SLAM算法相对地面真值的误差。从表中数据可以看出，ORB-SLAM比PTAM可以更精准地多定位2倍的图像帧。在第2个实验中，我们采用fr3_sitting_xyz图像序列来初始化地图，然后用fr3_walking_xyz图像序列重定位所有的图像帧。这是一个颇具挑战性的实验，由于图像中有人移动，会造成图像局部区域的遮挡。在该试验中，PTAM并没有实现重定位，而ORB-SLAM重定位了78%的图像帧，如表4所示。图8显示了ORB-SLAM重定位的一些实验图例。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164542153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164634243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164649369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="D、基于TUM-RGB-D标准数据集测试算法的运行生命"><a href="#D、基于TUM-RGB-D标准数据集测试算法的运行生命" class="headerlink" title="D、基于TUM RGB-D标准数据集测试算法的运行生命"></a>D、基于TUM RGB-D标准数据集测试算法的运行生命</h2></blockquote>
<p>之前的重定位实验表明我们的系统可以从非常不同的视角定位地图，在中等动态环境中的鲁棒性也较好。这个特性和关键帧筛选程序使得算法在不同的视角和局部动态环境中能够一直运行到图像结束。</p>
<p>在全静态场景情况下，即使相机从不同视角观测场景，ORB-SLAM也可以使关键帧数量保持在一个有限的水平内。我们在一个自定义的图像序列中验证了这一点，手持相机在93秒以内都拍摄同一张桌子，但视角一直变换，形成一个轨迹。我们对比了我们地图的关键帧数量和PTAM生成的关键帧，如图9所示。可以看到PTAM一直都在插入关键帧，而ORB-SLAM会删除冗余的关键帧，将其总数保持在一个稳定的范围内。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164757407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>当然，在整个程序运行过程中，静态环境下的正常操作是任何SLAM系统的一个基本要求，更引人关注的是动态环境下的状况。我们在几个fr3的图像序列中分析了ORB-SLAM系统的状况，图像序列有：sitting xyz, sitting halfsphere, sitting rpy, walking xyz, walking halfspehere 和walking rpy。所有的视频中，相机都对着桌子，但运动轨迹不同，拍摄场景中有人在移动，椅子也被移动了。如图10（a）所示是ORB_SLAM算法生成的地图中所有关键帧的总数量，图10（b）显示从图像帧中创建或删除关键帧，从中可以看出从关键帧到地图构建需要多久时间。可以看到前2个图像序列中新看到（增加）场景时地图的大小一直在增加。图10（b）是前2个视频中创建的关键帧。在视频sitting_rpy和walking_xyz中，地图没有增加，地图是通过已有场景创建。相反，在最后两个视频中，有更多的关键帧插入但没有在场景中表示出来，可能由于场景的动态变化。图10（C）是关键帧的柱状图，它们是从视频中挑选出来的。大部分的关键帧被筛选程序删除了，只有一小部分留下来了。ORB-SLAM有大量关键帧的生成策略，在未知环境下非常有用；后面系统会生成一个小的子集来代表这些关键帧。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164845644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>在整个实验中，我们系统的地图根据场景上内容来增加，而不是根据时间，它可以存储场景的动态变化，对场景的理解非常有用。</p>
<h2 id="E、基于KITTI数据集测试算法在大场景大回环下的性能对比"><a href="#E、基于KITTI数据集测试算法在大场景大回环下的性能对比" class="headerlink" title="E、基于KITTI数据集测试算法在大场景大回环下的性能对比"></a>E、基于KITTI数据集测试算法在大场景大回环下的性能对比</h2><p>KITTI数据集中里程计的数据包括11个视频，它的获取是在一个住宅区驾驶汽车，基准精度非常高，有一个GPS和一个Velodyne Laser Scanner。这个数据集对单目系统非常有挑战性，因为视频中有快速旋转，区域内有大量树叶，这使数据关联变得更困难，而且车速相对较快，视频记录的频率为10fps。除了视频01外，ORB-SLAM可以处理其他所有的视频，01是高速路上的视频，可追踪的物体非常少。视频00,02,05,06,07,09，有闭环回路，系统可以检测到，并使它闭合。其中视频09的闭环只能在视频的最后几个图像帧里检测到，并不是每次都能成功检测到（结果显示的是针对其被检测到的运行情况）。<br>对于轨迹与基准的定性比较如图11和12所示。在TUM RGB-D数据集中，我们可以通过相似变换对齐轨迹的关键帧和基准。图11是定性比较的结果，图12是论文[25]中的最新单目SLAM在视频00,05,06,07和08上执行的结果。除了08有一些偏移以外，ORB-SLAM在这些视频上的轨迹都很精准。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165216473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165258286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>表5显示了每个视频的关键帧轨迹中间的RMSE误差。我们基于地图尺寸提供了轨迹的误差。结果表明我们的轨迹误差是地图尺寸的1%左右。大致范围低的是视频03的0.3%高的是视频08的5%。视频08中没有闭环，漂移也没办法纠正，因为闭环控制需要获得更精确的重构。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165353994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>在本次实验中，我们还确认了到底全局BA的20层迭代最终能优化多少地图重构，相关细节如附录所示。我们还注意到全局BA优化可以稍微增加闭环轨迹的精度，但这对开环轨迹有负面影响，这意味着我们的系统已经非常精确了。在有些应用中，如果需要非常精确的结果我们的算法会提供一组匹配，需要定义一个比较强的相机网络，一个初始估计，这样全局BA优化迭代次数就会变少。</p>
<p>最后讲一下我们算法的闭环检测和用于essential graph边缘的θmin的效率。我们选择视频09（一段非常长的图像序列，在最后有一个闭环），然后评估不同的闭环检测算法。表6是关键帧轨迹RMSE和不同情况下没有闭环检测优化所用的时间，表中的相关内容包括：如果直接采用全局BA优化（20层或100层迭代）的情况，如果只用位姿图优化（10层迭代不同数量的边缘）的情况，如果先用位姿图优化再执行全局BA优化的情况。结果表明，在闭环检测之前，算法的RMSE误差较大，以至于BA优化没办法收敛，即便是迭代100次之后后误差仍旧非常大。另一方面，essential graph优化收敛速度很快，而且结果也更精确。θmin对精度影响并不大，减少边缘的数量会明显降低精度。位姿图优化后再执行一个BA优化则可以增加精度，但时间也增加了。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019110116552977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="结论和讨论"><a href="#结论和讨论" class="headerlink" title="结论和讨论"></a>结论和讨论</h1><h2 id="A、结论"><a href="#A、结论" class="headerlink" title="A、结论"></a>A、结论</h2><p>本文中，我们提出了一个新的单目SLAM系统，并详细介绍了其组成模块，最后基于公共数据库对其性能进行了全方位的测试。通过实验得知，我们的系统可以处理室内与室外的图像序列，能够用于汽车、机器人和手持设备上。其定位精度在室内小场景中约为1厘米，室外大场景的应用是几米（前提是我们与真实轨迹尺度对齐的情况下）。</p>
</blockquote>
<p>由Klein和Murray[4]提出的PTAM算法被认为是目前最精准的单目实时SLAM方法。PTAM后端是BA优化，这是众所周知的离线SFM（从运动到结构）问题[2]的经典解法。PTAM算法和Mouragnon[3]早期作品的主要贡献是将BA算法引入到机器人SLAM框架下，并具有良好的实时性。而本文的主要贡献是将PTAM算法的适用性进一步扩展，使其可以应用于原来不可应用的场景下。为了实现这一目标，我们整合了前面几年的优秀作品，引入新的想法和算法，从头设计了一种新的单目SALM系统所用到的技术包括Gálvez-López和Tardós提出的论文[5]中的闭环检测，Strasdat等人在论文[6],[7]中提出的的闭环检测程序和covisibility graph，Kuemmerle等人在论文[37]中提出的g2o优化框架以及Rubble等人提出的ORB特征[9]。到目前为止就我们所知，本文提出的ORB_SLAM方法的定位精度最高，也是最可靠最完整的单目SLAM系统。我们提出的新的生成和删除关键帧策略，允许每个几帧就创建一个关键帧，然后当关键帧冗余时则删除。这样的构图方式很灵活，在外界条件很差的情况下可以保证系统正常运行，比如相机作纯旋转运动或快速移动时。当算法在相同场景下运行时，地图在只有拍摄到新内容的情况下才会增长，可以从我们的长期构图结果中看到这个特性。</p>
<p>最后，我们还展示了ORB特征具有很好的识别能力，可识别剧烈视角变换情况下的场景信息。此外，它们能够被非常快速的提取和匹配（不需要多线程或GPU加速），这就使得跟踪和地图构建更加实时精确。</p>
<h2 id="B、离散-特征SLAM方法与稠密-直接SLAM方法对比"><a href="#B、离散-特征SLAM方法与稠密-直接SLAM方法对比" class="headerlink" title="B、离散/特征SLAM方法与稠密/直接SLAM方法对比"></a>B、离散/特征SLAM方法与稠密/直接SLAM方法对比</h2><p>最近，DTAM[44]和LSD-SLAM[10]提出了一种实时单目SALM算法，算法直接利用图像像素的亮度信息进行摄像头的定位与优化，并重构稠密或半稠密的环境地图。这类方法即为直接法，直接方法不需要特征提取，可以避免人工匹配。他们对图像模糊，弱纹理环境和像论文[45]这样的高频纹理环境的鲁棒性更好。与由稀疏点构建的地图相比，比如ORB-SLAM或PTAM算法，稠密/直接法SLAM对相机定位之外的其他应用任务可能更有用途。</p>
<p>部分重译： 然而，直接方法有他们自己的局限。首先，这些方法假设真实场景中的物体的像是由该物体本身的表面反射模型产生的，因此，算法采用的光度一致性寻找匹配点的思路就限制了匹配点之间的基线距离，通常都比特征匹配点的基线要窄。这对重构的精度影响很大，因为重构需要较宽的基线来减少深度的不确定性。如果直接建模不准确，则可能会受到快门，自动增益和自动曝光的影响（如TUM RGB-D 的对比测试）。最后，由于直接方法计算要求较高，因此为了满足计算速度，DTAM算法采用地图增量式扩张的方法，而LSD-SLAM则丢掉传感器测量信息，将地图优化降低为对位姿图的优化。</p>
<p>相反，基于特征的方法可以在更宽的基线上匹配特征，主要得益于特征匹配算法较好地视图不变特性。BA优化和相机位姿优化，地图云点通过传感器测量进行融合。在运动结构估计中，论文[46]已经指出了基于特征的方法相比直接方法的优势。在我们的实验第8部分B节中也直接提供了证据，，表明基于特征的定位精度更高。未来单目SLAM应该会整合两种最好的方法。</p>
<h2 id="C、后续"><a href="#C、后续" class="headerlink" title="C、后续"></a>C、后续</h2><p>我们系统的精度可以通过结合无限远点跟踪来进一步增强。这些在视图中看不到的平行线交点，并没有包含在本文算法构建的地图中，但对相机的旋转非常有用[21]。</p>
<p>另外一种方法是将稀疏地图更新到一个更加稠密的地图。由于我们关键帧的选择机制，关键帧组成了一个紧凑的地图，地图具有非常高精度的位姿信息和丰富的covisibility信息。所以，ORB-SLAM稀疏地图是一个非常优秀的初始估计框架，比稠密地图更好。这个方向的首次尝试在论文[47]中有详细描述。</p>
<h1 id="附录：非线性优化"><a href="#附录：非线性优化" class="headerlink" title="附录：非线性优化"></a>附录：非线性优化</h1><ul>
<li><p>Bundle Adjustment (BA)<br>地图云点3D位置 $X_{w,j}∈R^3$，关键帧位姿$T_{iw}∈SE(3)$，w表示世界坐标，通过匹配的关键点$X_{i,j}∈R^2$减少重投影误差。地图云点j在关键帧i中的误差是：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165938350.png#pic_center"><br>其中$π_i$是影射函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101170009868.png#pic_center"><br>其中，$R_{iw}∈SO(3)$，$t_{iw}∈R3$，分别表示$T_{iw}$的旋转和平移部分，$f_{i,u} , f_{i,v}）$，$（c_{i,u} , c_{i,v}）$分别是相机i的焦点距离和主点。<br>代价函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101170602738.png#pic_center"><br>$ρ_h$是Huber鲁棒损失函数，$Ω_{i,j}=δ_{i,j}^2I_{2x2}$是协方差矩阵，与检测关键点的尺度有关。在全局BA中（用于地图初始化，请参见第IV节在第VIII-E节），我们优化了所有点和关键帧。但第一个关键帧除外，这些关键帧保持为原点。在局部BA中（请参见VI-D节），局部区域中包含的所有点均得到优化，而关键帧的子集是固定的。 在姿态优化，或者motion-only BA，（见V）将所有点固定，仅将优化相机姿态。</p>
</li>
<li><p>Sim（3）约束下的姿势图优化[6]：给定二进制边的姿势图（请参阅第VII-D节）我们将误差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101171244797.png#pic_center"></p>
<p>其中，$S_{ij}$是在姿势图优化并将比例因子设置为1之前，从SE（3）姿势计算出的两个关键帧之间的相对Sim（3）变换。在闭环边的情况下，该相对变换通过Horn角[42]的方法。 $log_{Sim3}$ [48]转换为切线空间，因此误差是$R^7$维的向量。 目标是“优化Sim（3）关键帧姿势，以最小化损失”功能：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101171657388.png#pic_center"></p>
<p>其中$Λ_{i; j}$是边缘的信息矩阵，如[48]所示，我们将其设置为恒等式。 我们修复了回路闭合关键帧，以修复7度规的自由度。 尽管“此方法”是完整BA的粗略近似，但我们在VIII-E节中通过实验证明，它比BA具有显着更快和更好的收敛性。</p>
</li>
</ul>
<ul>
<li>Relative Sim(3) Optimization<br>给定关键帧1和关键帧2之间的一组n个匹配$i\leftrightarrow j$（关键点及其关联的3D映射点），我们要优化相对Sim（3）变换$S_{12}$（请参见VII-B部分），以最大程度地减小图像间重投影误差：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101172300914.png#pic_center"><br>最小化损失函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101172336172.png#pic_center"><br>其中$Ω_{1; i}$和$Ω_{2; i}$是与比例相关的协方差矩阵，与图像1和图像2中的关键点的方差有关。 在此优化中点是固定的。</li>
</ul>
<blockquote>
<p>参考：<br><a href="http://www.jintiankansha.me/t/SlssOSIu57" target="_blank" rel="noopener">【泡泡机器人翻译专栏】ORB-SLAM：精确多功能单目SLAM系统(一)</a><br><a href="https://www.sohu.com/a/161346283_715754" target="_blank" rel="noopener">【泡泡机器人翻译专栏】ORB-SLAM：精确多功能单目SLAM系统(二)</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAMB2——论文翻译（ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras）</title>
    <url>/2019/10/31/ORB-SLAMB2%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>ORB-SLAM2是基于单目，双目和RGB-D相机的一套完整的SLAM方案。它能够实现地图重用，回环检测和重新定位的功能。无论是在室内的小型手持设备，还是到工厂环境的无人机和城市里驾驶的汽车，ORB-SLAM2都能够在标准的CPU上进行实时工作。ORB-SLAM2在后端上采用的是基于单目和双目的光束法平差优化（BA）的方式，这个方法允许米制比例尺的轨迹精确度评估。此外，ORB-SLAM2包含一个轻量级的定位模式，该模式能够在允许零点漂移的条件下，利用视觉里程计来追踪未建图的区域并且匹配特征点。我们用29个广泛使用的公共数据测试的结果显示，在大多数情况下，本文方案比此前方案精度更高，此外，我们开源了ORB-SLAM2源代码，不仅仅是为了整个SLAM领域，同时也希望能够为其他领域研究者提供一套SLAM的解决方案。</p><a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>SLAM（同时定位与地图重建）在过去的20年中，一直是计算机视觉和机器人领域的热门话题，同时也吸引了很多高科技公司的关注。SLAM技术是在未知的环境当中建立一个地图并且能够在地图当中实时的定位。在不同类型的传感器当中，相机十分廉价，并且能够提供丰富的环境信息，受到研究者的青睐。相机提供的图像信息可以用作鲁棒的和精确的位置识别。位置识别是SLAM系统中回环检测的关键模块（例如，当传感器检测到一个已经建好图的位置的时候，可以进行修正在探索过程中的误差）以及，能够修正由于剧烈的震动或者在系统进行初始化的时候在相机跟踪失败后的重新定位。因此以相机为核心的视觉SLAM在过去的一年中得到快速的发展。 </p>
<p>   视觉SLAM仅仅通过一个单目相机就能够完成。单目相机也是最便宜也是最小巧的传感器设备。然而深度信息无法从单目相机中观测到，地图的尺度和预测轨迹是未知的。此外，由于不能从第一帧当中进行三角测量化，单目视觉SLAM系统的启动往往需要多个视角或者滤波技术才能产生一个初始化的地图。最后，单目SLAM可能会造成尺度漂移,以及在探索的过程中执行纯旋转的时候可能会失败。通过使用一个双目或者RGB-D相机将会解决这些问题，并且能够成为一种更加有效的视觉SLAM的解决方案。</p>
<p> 在这篇文章当中，我们在单目ORB-SLAM[1]的基础上提出ORB-SLAM2，有以下贡献：</p>
<pre><code>1. 这是首个基于单目，双目和RGB-D相机的开源SLAM方案，这个方案包括，回环检测，地图重用和重定位。
2. 我们的RGB-D结果说明，光速法平差优化（BA）比ICP或者光度和深度误差最小方法的更加精确。
3. 通过匹配远处和近处的双目匹配的点和单目观测，我们的双目的结果比直接使用双目系统更加精确。
4. 针对无法建图的情况，提出了一个轻量级的定位模式 ，能够更加有效的重用地图。
</code></pre><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031172843722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图1中显示的是双目和RGB输入下的ORBSLAM2的输出。双目例子显示的是最后轨迹和稀疏重建的地图。这里的数据集来源于KITTI的Sequence00数据集。这个城市数据集是ORB-SLAM2多次成功提取特征，并且回环检测而来。RGB-D例子是来源于TUM 的RGB-D 数据库中的fr1_room的数据集，并且进行关键帧的位姿评估而来。通过评估关键帧的位姿，映射深度图，最终形成一个稠密的点云图。指的注意的一点是，ORB-SLAM2虽不像Kinect Fusion一样进行数据融合，但是却能够很精确的估计关键帧的位姿。更多的例子在附件视频中展示。<br>在余下的篇章当中，我们将会在第二部分讨论相关的工作。在第三部分谈论ORB-SLAM2系统框架。第四部分评价ORB-SLAM2，第五部分得出结论。</p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>在这个章节，我们将会讨论双目和RGB-D SLAM的相关工作。评估部分我们放在第四部分，本章我们主要讨论的是SLAM的方法。</p>
<h2 id="A-双目SLAM"><a href="#A-双目SLAM" class="headerlink" title="A.双目SLAM"></a>A.双目SLAM</h2><p>最早研究双目SLAM方案的是Paz 等人，基于条件独立分割和扩展SLAM，其显著特点是能够在大场景中运行。更重要的是，这是第一个使用近特征点和远特征点（例如，由于双目相机差异较小，导致点的深度不能准确的估计）的双目SLAM系统，使用一个逆深度参数进行估计。经验值表明如果深度小于40倍双目的基线，那么这个点就能被三角测量化。我们就是跟随的这样思想来处理远近不同的特征点，具体解释放在第三部分。<br>最早研究双目SLAM方案的是Paz 等人[5]，基于条件独立分割和扩SLAM，其显著特点是能够在大场景中运行。更重要的是，这是第一个使用近特征点和远特征点（例如，由于双目相机差异较小，导致点的深度不能准确的估计）的双目SLAM系统，使用一个逆深度参数进行估计。经验值表明如果深度小于40倍双目的基线，那么这个点就能被三角测量化。我们就是跟随的这样思想来处理远近不同的特征点，具体解释放在第三部分。Engel等人[11]提出邻近双目LSD-SLAM方案，采用的是一种直接的半稠密方法，最小化高梯度的图像区域中的光度误差。这种方法希望能够在不依赖特征提取的条件下，能够在纹理不清或者模糊运动的过程中获得更高的鲁棒性。然而，直接法的性能会由于滚动（卷帘）快门，或者非朗伯反射的未建模的因素影响而下降。</p>
<h1 id="B-RGB-D-SLAM"><a href="#B-RGB-D-SLAM" class="headerlink" title="B.RGB-D SLAM"></a>B.RGB-D SLAM</h1><p>最早和最著名的RGB-DSLAM系统是有Newcombe等人[4]提出的KinectFusion，这种方法将深度数据进行融合，深度数据来源于传感器到深度模型，常常使用ICP算法来跟踪相机的位姿。由于体积的表现形式和缺乏回环检测，这种算法只能工作在小的工作空间。Whelan 等人[12]提出的Kintinuous能够在大环境中运行。它通过使用一个滚动循环缓冲器和包括使用位置定位和位姿优化来达到回环检测的目的。</p>
<p>或许第一个开源的RGB-DSLAM方案是由Endres[13]提出的，这是一种基于特征点提取的系统，他的前端采用提取和匹配特征点和ICP来计算帧与帧之间的运动。后端采用位姿图优化的方式，回环检测约束条件来源于一个启发式搜索。相似的是，Kerl 等人[14]提出的DVO-SLAM，是在关键帧与关键帧之间的优化位姿图，视觉里程计通过计算最小化光度和深度误差来计算约束条件。DVO-SLAM同时在以前的所有帧当中，搜索回环的候选者，而不依赖于位置识别。</p>
<p>Whelan等人[15]提出的邻近ElasticFusion算法，是建立在基于确定环境的地图。这是一种以地图为中心的方法。这种方法忽略了非刚性形变地图的位姿和回环检测的性能，也是不是一个标准的位姿图优化。这种方法在重建和定位的精度都是十分优秀的，但是目前的应用十分有限对于一个房间大小的地图，由于在地图当中面元的数量影响计算的复杂程度。</p>
<p>Strasdat等人[8]提出ORB-SLAM2这种方法，这个方法使用深度信息去合成一个三维坐标，能够精确的提取到一副图像的信息。ORB-SLAM2能够处理来自双目和RGB-D的图像，与上述方法不同的是，我们的后端是用的BA算法，来建立一个全局的稀疏的地图重建，因此我们的方法更加轻量级并且能够在标准的CPU上面运行。我们的目标是长时间并且全局精准定位，而不是建立一个有很多细节的稠密地图。然而，高精度的关键帧的位姿，能够融合深度图像以及在计算中得到精准的重建，或者能够处理所有的关键帧和深度图，以及所有的BA并且得到一个精准的3D模型。</p>
<h1 id="ORBSLAM2"><a href="#ORBSLAM2" class="headerlink" title="ORBSLAM2"></a>ORBSLAM2</h1><p>针对双目相机和RGB-D相机的ORB-SLAM2建立在单目ORB-SLAM的基础上，它的核心组件，如图2所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031210057222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图2 ORB-SLAM2由三个平行的线程组成，跟踪，局部建图和回环检测。在一次回环检测后，会执行第四个线程，去执行BA优化。跟踪的线程在双目或者RGB-D输入之前进行，因此剩下的系统模块能够跟传感器模块独立运行。单目的ORB-SLAM2工作图也是这幅图。</p>
<p>这个系统主要有3个并行的线程：</p>
<blockquote>
<p>1、通过寻找对局部地图的特征，并且进行匹配，以及只运用BA算法来最小化重投影误差，进行跟踪和定位每帧的相机。<br>2、运用局部的BA算法设置局比地图并且优化。<br>3、回环检测检能够通过执行位姿图的优化来更正累计漂移误差。在位姿优化之后，会启动第四个线程来执行全局BA算法，来计算整个系统最优结构和运动的结果。<br>这个系统是一个基于DBoW2[16]的嵌入式位置识别模型，来达到重定位，防止跟踪失败（如遮挡），或者已知地图的场景重初始化，和回环检测的目的。这个系统产生关联可见的图[8]，连接两个关键帧的共同点，连接所有关键帧的最小生成树方面。这些关键帧的图结构能够得到一个关键帧的局部的窗口，以便于跟踪和局部建图，并且在大型的环境当中的回环检测部分，作为一种图优化的结构。</p>
</blockquote>
<p>这个系统使用相同的ORB特征进行跟踪，建图和位置识别的任务。这些特征在旋转不变和尺度不变性上有良好的鲁棒性，同时对相机的自动增益，曝光和光线的变化表现出良好的稳定性。并且能够迅速的提取特征和进行匹配，能够满足实时操作的需求，能够在基于词袋的位置识别过程中，显示出良好的精度[18]。</p>
<p>在本章的剩下的部分当中，我将会展示双目或者深度信息是如何利用，和到底会影响系统中的那些部分。对每个系统块更详尽的描述，可参见论文[1]</p>
<h2 id="单目、近处双目和远处双目特征点"><a href="#单目、近处双目和远处双目特征点" class="headerlink" title="单目、近处双目和远处双目特征点"></a>单目、近处双目和远处双目特征点</h2><p>ORB-SLAM2作为一种基于特征提取的方法，在一些关键的位置上的提取进行预处理，如图2b所示，系统的所有运行都是基于输入图像的特征展开，而不依赖于双目或者RGB-D的相机。我们的系统处理单目或者双目的特征点，分成远处特征点和近处特征点两类。</p>
<p>双目特征点 通过三个坐标$x_s=(u_L,v_L,u_R)$定义，$(u_L,v_L)$是这个左边图像的坐标，$u_R$是右图当中的水平坐标。对于双目相机而言，我们提取两幅图像当中的ORB特征，对于每个左边的ORB特征我们对其匹配到右边的图像中。这对于建设双目图像校正十分有效，因此极线是水平的。之后我们会在左边的图像产生双目的ORB特征点，和一条水平的线向右边的图像进行匹配，通过修补相关性来重新定义亚像素。对于RGB-D相机，正如Strasdat等人[8]所言，我们提取在RGB图像上提取ORB特征点，d对于每个特征坐标$(u_L,v_L)$，我们将其深度值d转换为实际正确的坐标<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031213345404.png#pic_center"><br>这里$f_x$是水平焦距，b是结构光投影器和红外相机的基线<br>我们估计kinect和华硕 Xtion 基线长大约是8cm。深度传感器的不确定性由实际右坐标的不确定性表示，这样，立体声和RGB-D输入的特征由系统的其余部分均等地处理。</p>
<p>近双目特征点的定义是：匹配的深度值小于40倍双目或者RGB-D的基线，否则的话，是远特征点。近的特征点能够从一帧的深度值能够三角测量化，是精确的估计，并且能够提供尺度，平移和旋转的信息。另外一方面，远的特征点，能够提供精确的旋转信息，但是很少的尺度和平移信息。当提供多视图的时候，我们才能三角化那些远的点。</p>
<p>单目的特征点通过右边图像的两个坐标$x_m=(u_L,v_L)$定义，必须保证所有的ORB特征是一致的，否则双目特征点的提取将不能够完整，或者在RGB-D的情况下，有产生一个无效的深度值。这些点仅能够从多视图中三角测量化并且不能够提供尺度信息，但是可以提供旋转和平移的估计信息。</p>
<h2 id="系统引导"><a href="#系统引导" class="headerlink" title="系统引导"></a>系统引导</h2><p>使用双目和RGB-D相机的主要优势在于，我们可以直接获得深度信息，我们不需要像单目情况中那样做一个特定的SFM初始化。在系统初始化的时候，我们就创造了一个关键帧（也就是第一帧），将他的位姿进行初始化，从所有的立体点中创造一个初始化地图。</p>
<p>3.3 使用单目或者双目光束优化法</p>
<p>我们的系统采用光束优化法（BA），优化在跟踪过程（纯运动BA）中相机的位姿，优化本地窗口的关键帧和局部地图的特征点（局部BA），并且在回环检测之后优化所有的关键帧和特征点（全局BA）。我们在g2o当中使用Levenberg-Marquadt方法[19]。</p>
<p>纯运动BA，优化相机旋转矩阵R和位置t，最小化世界坐标系下匹配3D点云$X^i$和特征点$x^i$（单目的或双目的，其中）的重投影误差,要么<br>单目m∈R2或双目xi s∈R3，其中i∈X是所有匹配集合</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031214735118.png#pic_center"><br>在这个式子当中，$\rho$是强健的Huber的cost函数，$\sum$是协方差矩阵，与关键点的规模有关。投影函数$\pi(.)$，单目的时候使用$\pi_m$，修正双目的时候用$\pi_s$，他们的定义如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101092309550.png#pic_center"><br>在这个式子$(f_x,f_y)$是焦距，$(c_x,c_y)$是主点，b是基线，所有的这些参数都是通过标定获得。<br>局部BA优化一系列可见的关键帧$\K_L$和所有在这些关键帧$P_L$的可见点，所有的其他关键帧$K_F$是，不在$K_L$，$P_L$观测点用于代价函数，但是在优化中是固定的。 将$X_k$定义为点之间的匹配集，这些点在$P_L$和关键帧k中的关键点上，优化问题如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101093927765.png#pic_center"><br>全局BA是局部光束法的一个特例，这个方法除了固定的来消除随机化的初始帧，所有的关键帧和地图中的点都会被优化</p>
<h2 id="闭环检测和全局BA"><a href="#闭环检测和全局BA" class="headerlink" title="闭环检测和全局BA"></a>闭环检测和全局BA</h2><p>回环检测有两步：首先，一个回环信息被确定检测到，然后利用这个回环纠正和优化位姿图。相比于单目的ORB-SLAM中可能出现尺度漂移的地方[20]，这个双目或者深度的信息将会使得尺度信息可观测。并且，几何校验和位姿图优化将不再需要处理尺度漂移，而且是基于刚体变换的，而不是基于相似性。<br>在ORB-SLAM2的位姿优化后，我们包含一个全局的BA优化，为了实现一个优化方案，我们必须采用一个独立的线程，允许系统能够持续的建图，并且检测到回环信息。但是这将会再次触发全局BA优化与当前地图的合成。如果在优化运行时检测到新的回环，我们将中止优化并继续关闭循环，这将再次启动全局的BA优化。当完整的BA结束时，我们需要将更新的关键帧子集和由完整BA优化的点与未更新的关键帧和在优化运行时插入的点合并。最后通过更新更新关键帧校正（例如，这个变换从未优化到已优化）到一个未更新关键帧通过生成树当中。根据校正参考帧来改造呢些未更新的特征点。</p>
<h2 id="关键帧的插入"><a href="#关键帧的插入" class="headerlink" title="关键帧的插入"></a>关键帧的插入</h2><p>ORB-SLAM2遵循在单目ORB-SLAM中提的法则，即经常插入关键帧并且剔除上一帧的冗余。在远近特征点的差异为我们插入一个新的关键帧提供了条件，这在大场景的条件下是至关重要的，如图3所示。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101095206294.png#pic_center"><br>图3 ＫITTI 01数据集的跟踪点。绿色的特征点深度小于40倍双目的基线，蓝色特征点大于40倍双目的基线，在这种数据集当中，需要插入大量的关键帧，以便于能够让近处的特征点更加精确的估计平移和尺度，远处的特征点来估计方向，但是不能够计算平移和尺度。</p>
</blockquote>
<p>在这样的环境中，我们需要一个大量的近点用以精确估计平移，因而如果这个被跟踪近点小于$\tau _t$并且这个帧将会创造$\tau _c$个新邻近特征点，这个系统将会插入一个新的关键帧，我们经验值认为，当$\tau _t=100$和$\tau _c=70$的条件下我们效果最好。</p>
<h2 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h2><p>ORB-SLAM2包括一个定位模式，该模式适用于轻量级以及在地图已知情况下长期运行，只要那个环境没有发生剧烈变化。在该模式中，局部建图和回环检测的线程中是停用的，并且这个相机始终都是在通过追踪进行重定位。在这个模式下，追踪模块使用视觉里程计进行匹配图像的点云。视觉里程计匹配在当前帧的ORB算子和由双目或者深度相机收集的3D点云。这些匹配使得在没有地图的区域也能够精确重新定位，但是漂移将会被累加。地图点云匹配要确保在一个已经存在的地图当中零漂移定位，这个模型在附带的video当中会显示。</p>
<h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>我们使用三个著名的数据集来评估ORB-SLAM2的算法的性能。我们在一台16G的RAM，Intel Core i7-4790的台式机运行，以低于传感器的帧率，对处理跟踪时间求平均。我们运行数据集5次，取中间值，来消除多线程系统的不确定性。我们开源了在运行这几个系统的数据集的方法包括标定具体操作实现。</p>
<h2 id="KITTI数据集"><a href="#KITTI数据集" class="headerlink" title="KITTI数据集"></a>KITTI数据集</h2><p>KITTI数据集包含双目数据，这些数据从一个正在高速公路上行驶的车上采集到的。这个双目传感器有约54厘米的基线并且在在1392*512像素上，以10Hz的采样速率进行采样，其中序列00,02,05,06，和09包含回环。我们的ORB-SLAM2能够检测出回环并且能够地图重用，除了09序列以外，09序列的回环只发生在尾端少数的几帧当中。表1显示在11个训练数据的结果，这是一个公开的真实数据，对比于原先的LSD-SLAM算法，我们展示了的双目SLAM系统测试数据结果。我们使用两个不同的米制，均方根误差(RMSE)$t_{abs}$在论文[3]中提到，并且取平均相关平移$t_{rel$和旋转误差$r_{rel}$在论文[2]，我们的系统在数据集大多数序列中都优于双目LSD-SLAM，并且总体而言，相对误差低于1％。序列01（参见图3）是训练集中唯一的高速公路序列，平移误差稍差一些。 由于高速和低帧频，很难追踪到几乎所有的闭合点，因此在数据集这个序列中很难估计平移。。然而这个方向能够被精确的评估，获得的误差是每100米做0.21度。很多较远的点能够被检测，如图4所示，显示了一些评估的例子。</p>
<blockquote>
<p>表一 KITTI数据集精度的比较<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101101839858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101102024770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图4 在KITTE数据集01,05,07和08，估计轨迹（黑色线）和以及实际运动（红色线）</p>
</blockquote>
<p>与[1]中提出的单目结果相比，提出的双目版本能够处理单目系统处理失败的序列01。 在此高速公路序列中，请参见图3，仅在几帧的情况下才能看到近点。 双目版本有仅从一个双目关键帧创建点的能力，而不是通过在两个关键帧的匹配而导致的单目延迟初始化的能力，在此序列中至关重要，不能丢失跟踪。 而且，双目系统以公制比例尺估计地图和轨迹，并且不会受到比例尺偏移的影响，如图5所示。</p>
<blockquote>
<p>在KITTI数据集08估计轨迹（黑色线）和以及实际运动（红色线）左：单目ORB-SLAM [1]，右：ORB-SLAM2（双目）。 单目ORBSLAM在此序列中有严重的标度漂移，尤其是在转弯处。 相比之下，提出的双目版本能够估计轨迹和地图的真实比例，而不会出现比例漂移。<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101103033691.png#pic_center"></p>
<h2 id="EuRoC-数据集"><a href="#EuRoC-数据集" class="headerlink" title="EuRoC 数据集"></a>EuRoC 数据集</h2><p>EuRoC 数据集包含了11个双目的序列，通过一个微型飞行器（MAV）采集到的数据，飞行在两个不同的房间和大量的工业环境。这个双目传感器有一个约11cm的基线和能够提供20HZ的WVGA格式的图像，这个序列分成，简单、中等、和困难，这取决于MAV（微型飞行器）的速度，照明和场景的纹理。在所有的序列当中，MAV（微型飞行器）再次访问这个环境的时候，ORB-SLAM2能够重用地图，回环检测当有必要时。这个表格2显示的是ORB-SLAM2的最小均方误差(RMSE)的绝对值变换，对于所有序列而言。相比较对双目的LSD-SLAM的结果。ORB-SLAM2能够实现一个厘米级精准的定位，并且比双目的LSD-SLAM更加的精确。由于一些运动模糊，在V2_ 03_ difficul序列中跟踪丢失。在论文[22]]，这个序列在处理过程中是使用IMU信息，如图5所示，显示的一些相比实际运动的估计轨迹的例子。<br>表2 EUROC数据集<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101103818187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104359603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>在EuRoCV1_02_medium, V2_02_medium, MH_03_medium, and MH_05_difficult数据集测试的估计轨迹（黑色线）和以及实际运动（红色线）</p>
<h2 id="TUM-RGB-D-Dataset"><a href="#TUM-RGB-D-Dataset" class="headerlink" title="TUM RGB-D Dataset"></a>TUM RGB-D Dataset</h2><p>TUM RGB-D数据集包含一些室内的序列，在不同的纹理下，不同的光照和不同的结构条件，从RGB-D传感器采集到的数据中分别去评估物体的重建和SLAM/视觉里程计的性能。和大多数RGB-DSLAM方法一样，我们将实验结果展示在一个序列子集当中，在表格3当中，我们比较我们的精准性和其他方法，例如ElasticFusion，Kintinuous，DVO-SLAM以及RGB-DSLAM，ORB-SLAM2是唯一一种基于光束流差法，并且比其他的方法都更加优秀。我们已经注意到RGB-DSLAM，深度地图对于freiburg2序列有一个4%的尺度误差，误差可能来自错误的标定，我们已经在运行过程中，进行了一定程度的补偿。这能够部分解释我们取得好的结果的原因。图6显示的点云的结果来源于后端映射的传感器深度的地图，从计算关键帧的位姿在四个序列当中。实验的结果显示，ORB-SLAM2很好的展示了桌子和海报的轮廓线，以及高精度的重定位。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104655260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104722466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图6 TUM RGB-D数据的fr3office, fr1 room, fr2 desk and fr3 nst 序列的通过评估关键帧的位姿和深度图进行稠密的点云重建图</p>
</blockquote>
<h2 id="时序结果"><a href="#时序结果" class="headerlink" title="时序结果"></a>时序结果</h2><p>为了完成对所提出系统的评估，我们在表IV中列出了三个时序的时序结果，这些时序具有不同的图像分辨率和传感器。显示了每个线程任务的平均值和两个标准偏差范围。由于这些序列包含一个循环，因此全局BA和回环检测线程的某些任务仅执行一次，并且仅报告一次测量。每帧的平均跟踪时间低于每个序列的相机帧频的倒数，这意味着我们的系统能够实时工作。由于将双目图像中的ORB提取并行化，因此可以看出，在V2_02的立体声WVGA图像中提取1000个ORB特征类似于在fr3_office的单个VGA图像通道中提取相同数量的特征。回环中关键帧的数量显示为与回环检测有关的时间的参考。虽然KITTI 07中的回环包含更多关键帧，但为室内fr3_office构建的可见性图更加密集，因此，回环融合，姿态图优化和全局BA任务更加昂贵。可见性图的较高密度使本地地图包含更多关键帧和点，因此，本地地图跟踪和局部BA也更加昂贵。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019110111103884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文呈现了一个基于于单目，双目和RGB-D传感器的完整SLAM框架，在实时和标准的CPU的前提下能够进行重新定位和回环检测，以及地图的重用。在实验当中，我们关心的是在大场景中建立可用的地图和长期的定位。所提出的具有系统重新定位功能的定位模式可为已知环境提供一种非常健壮，零漂移和轻量级的定位方法。此模式对于某些应用程序可能很有用，例如在映射良好的空间中跟踪虚拟现实中的用户视点。与最新技术的比较表明，ORB-SLAM2在大多数情况下都可以达到最高的精度。</p>
<p> 与最新技术的比较表明，ORB-SLAM2在大多数情况下都可以达到最高的精度。在KITTI视觉里程表测试中，ORB-SLAM2是目前最佳的双目SLAM解决方案。至关重要的是，与近年来兴起的立体视觉测距法相比，ORB-SLAM2在已经构建的地图中实现了零漂移定位。</p>
<p>出乎意料的是，我们的RGB-D结果表明，如果相机的定位精度更好，则BA性能要优于直接法或ICP，并且具有计算成本更低，不需要GPU处理实时运行的额外优势。</p>
<p>我们已经发布了系统的源代码，包括示例和说明，以便其他研究人员可以轻松使用。就我们所知，ORB-SLAM2是第一个可与单目，双目和RGB-D使用的开源视觉SLAM系统。此外，我们的源代码包含一个使用单目相机的增强现实应用程序2，以展示我们解决方案的潜力。<br>举例来说，将来的发展可能包括不重叠的多相机，鱼眼镜头或全景相机，大规模稠密融合，协作建图或增强的运动模糊鲁棒性</p>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>VINs-Mono——闭环检测</title>
    <url>/2019/10/31/VINs-Mono%E2%80%94%E2%80%94%E9%97%AD%E7%8E%AF%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>18.删除链表中的节点</title>
    <url>/2019/10/31/18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在O(1)时间删除链表结点。</p><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表节点与函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>删除一个节点的两种方法：</p><a id="more"></a>



<p>比如删除链表中的的节点i，j为i的下一个节点</p>
<ol>
<li><p>先从链表中的头结点遍历到i前面的一个节点，把h的m_pNext指向i的下一个节点j,再删除节点i，时间复杂度$O(n)$</p>
</li>
<li><p>把节点j的内容复制覆盖节点i，接下里再把节点i的m_pNext指向j的下一个节点，再删除节点j（把j移到i)，时间复杂度$O(1)$</p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">三种情况： </span><br><span class="line"><span class="number">1.</span> 节点是头节点且只有这一个节点                          </span><br><span class="line"><span class="number">2.</span> 节点是尾节点                          </span><br><span class="line"><span class="number">3.</span> 节点是链表中的某个节点</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">        *pListHead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;            </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">description</span></span><br><span class="line"><span class="string">    题目： 删除链表中的节点</span></span><br><span class="line"><span class="string">    1.在O（1）时间内删除链表节点</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这里我们首先定义一个链表的类</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, next = None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = next</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_node_in_o1_time</span><span class="params">(self, p, head)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param p: linknode</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        这里一共有三种情况： 节点是头节点且只有这一个节点</span></span><br><span class="line"><span class="string">                          节点是尾节点</span></span><br><span class="line"><span class="string">                          节点是链表中的某个节点</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> p == head <span class="keyword">and</span> p.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> p.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            q = head</span><br><span class="line">            <span class="keyword">while</span> q.next <span class="keyword">is</span> <span class="keyword">not</span> p:</span><br><span class="line">                q = q.next</span><br><span class="line">            q.next = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        q = p.next</span><br><span class="line">        p.value = q.value</span><br><span class="line">        p.next = q.next</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_lnode</span><span class="params">(self, lst)</span>:</span></span><br><span class="line">        head = linkNode(lst[<span class="number">0</span>])</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)):</span><br><span class="line">            p.next = linkNode(lst[i])</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_lnode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(p.value)</span><br><span class="line">            p = p.next </span><br><span class="line"> </span><br><span class="line">s = Solution()</span><br><span class="line">head = s.gen_lnode([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">p = head.next.next</span><br><span class="line">s.delete_node_in_o1_time(p, head)</span><br><span class="line">s.print_lnode(head)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>高斯分布与边缘化</title>
    <url>/2019/10/30/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E8%BE%B9%E7%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h1><p>高斯分布有两种表达方式：</p><ul>
<li>协方差矩阵+均值</li>
<li>信息矩阵+信息矢量</li>
</ul><p>协方差矩阵+均值的方式比较常见，如下</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152615298.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152644545.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152656564.png#pic_center"></p><p>左边常数项记为$η$，$p(x)$可以记为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200301827.png"></p><p>其中对称正定矩阵$Σ$为随机变量x的协方差矩阵，μ为x的均值，简记为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200243950.png"></p><p>信息矩阵+信息矢量的形式可以由上式推导而来</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200156360.png"></p><p>现在定义信息矩阵$Ω=Σ^{−1}$ ，信息矢量$ξ=Σ^{−1}μ=Ωμ$，则</p><a id="more"></a>











<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200137498.png"></p>
<h1 id="联合高斯分布的分解"><a href="#联合高斯分布的分解" class="headerlink" title="联合高斯分布的分解"></a>联合高斯分布的分解</h1><p>设随机变量$x_a,x_b$满足联合高斯分布$p(x_a,x_b)$<br>由条件概率公式可知</p>
<script type="math/tex; mode=display">p(x_a,x_b)=p(x_a)p(x_b∣x_a)</script><p>联合高斯函数的分解就是根据$p(x_a,x_b)$求出上式中的$p(x_a)$和$p(x_b∣x_a)$</p>
<h2 id="协方差矩阵-均值"><a href="#协方差矩阵-均值" class="headerlink" title="协方差矩阵+均值"></a>协方差矩阵+均值</h2><p>假设多元变量x服从高斯分布，且由两部分组成： $x = [x_a \  x_b]^T$，变量x的概率分布为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204045547.png#pic_center"></p>
<p>其密度函数可写为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204101961.png#pic_center"></p>
<p>利用舒尔补对高斯分布进行分解：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204114634.png#pic_center"></p>
<p>将上式带入$p(x_a,x_b)$的概率密度函数，并注意到对任意矩阵<em>K</em>，有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020412790.png#pic_center"></p>
<p>可以得到:</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204144966.png#pic_center"></p>
<p>其中:</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204202528.png#pic_center"></p>
<p>由此可看出，$p(x_a)$是均值为$μ_a$，协方差矩阵为$Σ_{aa}$的高斯分布，记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204216952.png#pic_center"></p>
<p>同时，$p(x_b∣x_a)$是均值为$μ_b+Σ_{ba}Σ_{aa}^{−1}(x_a−μ_a)$，协方差矩阵为$Θ_{bb}$的高斯分布，记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204250870.png#pic_center"></p>
<h2 id="信息矩阵-信息矢量"><a href="#信息矩阵-信息矢量" class="headerlink" title="信息矩阵+信息矢量"></a>信息矩阵+信息矢量</h2><p>$p(x_a,x_b)$以信息矩阵+信息矢量的形式给出，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204311535.png#pic_center"></p>
<p>通过信息矢量与信息矩阵，可以计算出该分布的均值</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204324848.png#pic_center"></p>
<p>因此该分布的概率密度函数可写为（注意到信息矩阵与协方差矩阵为互逆关系）</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204348310.png#pic_center"></p>
<p>为了求出$p(x_a)$和$p(x_b∣x_a)$的表达式，需要再次用到舒尔补（Schur Complement），不过作用对象与之前不同，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204403932.png#pic_center"></p>
<p>将上式带入$p(x_a,x_b)$的密度函数中，并令$Ω_{aa}−Ω_{ab}Ω_{bb}^−1Ω_{ba}=Λ_{aa}$，可得</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204423266.png#pic_center"></p>
<ul>
<li><p>$p(x_a)$是一个均值为$μ_a$，协方差矩阵为$Λ_{aa}^{−1}$的高斯分布</p>
</li>
<li><p>$p(x_b∣x_a)$是一个均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，协方差矩阵为$Ω_{bb}^{−1}%$的高斯分布。</p>
</li>
</ul>
<p>$p(x_a)$的均值为$μ_a$，信息矩阵为$Λ_{aa}$，对应的信息矢量为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910302044559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>所以$p(x_a)$完全使用信息矩阵+信息矢量的形式可记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020452532.png#pic_center"></p>
<p>同理：</p>
<p>$p(x_b∣x_a)$均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，信息矩阵为$Ω_{bb}$的高斯分布，对应的信息矢量为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204543853.png#pic_center"><br>$p(x_b∣x_a)$完全使用信息矩阵+信息矢量的形式可以记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204557435.png#pic_center"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。表格总结如下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204611958.png#pic_center"></p>
<p>根据协方差矩阵与信息矩阵的互逆关系，从上表还可以得出如下一组关系</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204627632.png#pic_center"></p>
<h2 id="边缘化与条件化"><a href="#边缘化与条件化" class="headerlink" title="边缘化与条件化"></a>边缘化与条件化</h2><p>所谓边缘化，就是求某个联合概率分布的边缘分布。比如对于联合概率$p(x_a,x_b)$，对$x_b$进行边缘化，就是对$x_b$在整个空间中积分，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204650325.png#pic_center"></p>
<p>由贝叶斯公式可知</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204702487.png#pic_center"></p>
<p>伴随着边缘化，$p(x_b∣x_a)$就是$p(x_a,x_b)$对$x_a$的条件化。</p>
<p>在信息矩阵+信息矢量的表示方式下，边缘化和条件化与最小二乘法有密切关系。在许多基于最小二乘的优化问题中，常有如下形式的优化目标：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204718621.png#pic_center"></p>
<p>为了寻找上式的最小值，常使用迭代优化的方法，每一次迭代都会寻找一个增量Δx使目标函数减小。为了求增量，往往会将e(x)在当前<em>x</em>x处展开为一阶近似（这种处理方式即Gauss-Newton Method），即<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204730880.png"></p>
<p>则优化的目标变为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020474264.png#pic_center"></p>
<p>这是关于Δx的二次函数，对Δx求导，并令导数等于0，有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204755898.png#pic_center"></p>
<p>即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204808181.png#pic_center"></p>
<p>令$J(x)^TW^{−1}J(x)=Ω$，表示变量Δ<em>x</em>Δx的信息矩阵，令−$J(x)^TW^{−1}e(x)=ξ$，表示信息矢量，则有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204822240.png#pic_center"></p>
<p>以上就是非线性优化时，每次都要求解的线性方程。</p>
<p>在很多优化问题中，待优化的变量有明确意义，比如在SLAM或者SfM问题中，要优化的是所有相机的位姿<em>p</em>p以及地图中所有三维点的坐标<em>m</em>m，设Δ<em>x</em>Δx由这两个分量的增量构成，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204837435.png#pic_center"></p>
<p>同时设</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204848663.png#pic_center"></p>
<p>则有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204900849.png"></p>
<p>为了简化以上方程的求解，往往使用高斯消元法，具体的，对以上方程等式两边左乘</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204917817.png"></p>
<p>可得</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204930919.png#pic_center"></p>
<p>于是原方程可以转换为两个独立方程</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204940320.png#pic_center"></p>
<p>可以发现，Δp的系数矩阵和等号右边的结果，与上文中高斯分布$p(x_a)$的信息矩阵和信息矢量有相同的形式。而Δm的系数矩阵和等号右边的结果，则与高斯分布$p(x_b∣x_a)$的信息矩阵和信息向量有相同形式</p>
<p>也就是说，这里的高斯消元法，等价于对变量Δx做了边缘化，先将Δm边缘化掉，单独求Δp，然后再在Δp已知的情况下求Δm。</p>
<p>参考：<a href="https://blog.csdn.net/AIchipmunk/article/details/86185248" target="_blank" rel="noopener">高斯分布与边缘化</a> </p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>舒尔补</title>
    <url>/2019/10/30/%E8%88%92%E5%B0%94%E8%A1%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>舒尔补定义<br>给定任意的矩阵块 M，如下所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030155959352.png"><ul>
<li>如果矩阵块 D 是可逆的，则$A − BD^{−1}C$称之为D关于M的舒尔补</li>
<li>如果矩阵块 A 是可逆的，则$D − CA^{−1}B$称之为A关于 M的舒尔补</li>
</ul>
</li>
</ul><p>将 M 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160209537.png"></p><p>其中：$∆A=D − CA^{−1}B$。联合起来，将 M 变形成对角形：</p><a id="more"></a>



<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160250360.png"></p>
<p>矩阵 M 的逆为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160322364.png"></p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——后端优化</title>
    <url>/2019/10/29/VINs-Mono%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="状态向量"><a href="#状态向量" class="headerlink" title="状态向量"></a>状态向量</h1><p>VIO 紧耦合方案的主要思路就是通过将基于视觉构造的残差项和基于 IMU 构造的残差项放在一起构造成一个联合优化的问题，整个优化问题的最优解即可认为是比较准确的状态估计。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192151582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>为了限制优化变量的数目， VINS-Mono 采用了滑动窗口的形式， 滑动窗口中的全状态量包括滑动窗口内的n+1个关键帧时刻 IMU 坐标系的位置、姿态、姿态（旋转）、加速度计偏置、陀螺仪偏置， Camera 到 IMU 的外参， m +1个 3D 路标点的逆深度：</p><a id="more"></a>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192802133.png#pic_center"></p>
<p>优化过程中的误差状态量为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192821349.png#pic_center"></p>
<h1 id="代价函数（Minimize-residuals-from-all-sensors）"><a href="#代价函数（Minimize-residuals-from-all-sensors）" class="headerlink" title="代价函数（Minimize residuals from all sensors）"></a>代价函数（Minimize residuals from all sensors）</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192917433.png#pic_center"></p>
<p>其中$P^{b_{k}}_{b_{k+1}}$ 为 IMU 预积分噪声项的协方差矩阵， $P^{c_j}_l$ 为视觉观测噪声的协方差矩阵。<br>三个残差项即误差项分别为边缘化的先验信息、 IMU 测量残差、视觉的重投影残差。三种残差都是用马氏距离表示。<br>根据高斯牛顿法求优化过程中最为核心的增量方程，以 IMU 测量残差为例，先将$r_{b}(\hat z^{b_k}_{b_{k+1}},\chi )$进行一阶泰勒展开</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194020513.png#pic_center"></p>
<p>其中$H^{b_k}_{b_{k+1}}$是雅可比矩阵</p>
<p>等号右边关于$\delta x$的导数，并令其为 0，得到增量方程：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194351591.png#pic_center"></p>
<p>那么可以写出函数对应的增量方程：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195011958.png#pic_center"></p>
<p>增量方程可进一步简化为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195045773.png#pic_center"></p>
<p>其中$\wedge _p$，$\wedge _B$，$\wedge _C$为（近似的） Hessian 矩阵，上述方程称之为增量方程。</p>
<h1 id="IMU-测量约束"><a href="#IMU-测量约束" class="headerlink" title="IMU 测量约束"></a>IMU 测量约束</h1><h2 id="IMU-测量残差"><a href="#IMU-测量残差" class="headerlink" title="IMU 测量残差"></a>IMU 测量残差</h2><p>根据上面的 IMU 预积分，得到 IMU <strong>预积分残差（估计值 - 测量值）</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195522934.png#pic_center"></p>
<p>其中$[q]_{xyz}$表示提取四元数q的虚部，$[\hat \alpha^{b_k}_{b_{k+1}},\hat \beta ^{b_k}_{b_{k+1}},\hat \gamma ^{b_k}_{b_{k+1}}]^T$为关键帧$b_k$和关键帧$b_{k+1}$时间间隔内，仅仅使用含有噪声的加速度计和陀螺仪数据计算的预积分 IMU 测量项，$\delta \theta^{b_k}_{b_{k+1}}$是四元数误差的三维表示。</p>
<h2 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h2><p>对于两帧之间的 IMU 测量残差，待优化变量为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029200304722.png#pic_center"></p>
<h2 id="雅克比矩阵"><a href="#雅克比矩阵" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>高斯迭代优化过程中会用到 IMU 测量残差对状态量的雅克比矩阵，但此处我们是对误差状<br>态量求偏导</p>
<ul>
<li>对k时刻$[\delta p^w_{b_k},\delta \theta^w_{b_k}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201345442.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta v^w_{b_k},\delta b_{a_k},\delta \theta b_{w_{k}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201641707.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta p^w_{b_{k+1}},\delta \theta^w_{b_{k+1}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201652448.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta v^w_{b_{k+1}},\delta b_{a_{k+1}},\delta \theta b_{w_{k+1}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201704647.png#pic_center"></p>
<p>上面公式在代码中对应： class IMUFactor : public ceres::SizedCostFunction<15, 9 7, 9,>对于 Evaluate 输入 double const <em>const </em>parameters, parameters[0], parameters[1], parameters[2],parameters[3]分别对应 4 个输入参数, 它们的长度依次是 7,9,7,9， 分别对应 4 个优化变量的参数块。<br>代码 IMUFactor::Evaluate()中 residual 还乘以一个信息矩阵 sqrt_info， 这是因为真正的优化项其实是 Mahalanobis 距离： $d=r^TP^{−1}r$，P 是协方差，又因为 Ceres 只接受最小二乘优化， 也就是$min(e^Te)$所以把𝑃−1做 LLT 分解， 即$LL^T=P^{-1}$, 则有：</15,></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202424429.png#pic_center"></p>
<p>令$r’=L^Tr$作为新的优化误差, 这样就能用 Ceres 求解了。 Mahalanobis 距离其实相当于一个残差加权, 协方差大的加权小, 协方差小的加权大, 着重优化那些比较确定的残差。若写成“sqrt_info.setIdentity()”相当于不加权</p>
<h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>IMU 协方差 P 为前面推导的 IMU 预积分中迭代出来的 IMU 增量误差的协方差。</p>
<h1 id="视觉测量残差"><a href="#视觉测量残差" class="headerlink" title="视觉测量残差"></a>视觉测量残差</h1><p>视觉测量残差即 特征点的重投影误差，视觉残差和雅克比矩阵计算的对应代码在ProjectionFactor::E<br>函数中。</p>
<h2 id="重投影误差（视觉测量残差）"><a href="#重投影误差（视觉测量残差）" class="headerlink" title="重投影误差（视觉测量残差）"></a>重投影误差（视觉测量残差）</h2><p>对于第 i 帧中的特征点, 它投影到第 j 帧相机坐标系下的值为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202633785.png#pic_center"></p>
<p>拆写成三维形式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202722447.png"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202739798.png#pic_center"></p>
<p>为了后面方便求导Jacobian，对$P_{c_j}$拆解，定义如下变量</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202916771.png"></p>
<p>视觉测量残差为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203023784.png#pic_center"></p>
<h2 id="优化变量-1"><a href="#优化变量-1" class="headerlink" title="优化变量"></a>优化变量</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203801125.png#pic_center"></p>
<h2 id="雅克比矩阵-1"><a href="#雅克比矩阵-1" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>根据视觉残差公式，我们可以得到相对于各优化变量的 Jacobian</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203923600.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203934216.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203946932.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102920400339.png"></p>
<h2 id="协方差矩阵-1"><a href="#协方差矩阵-1" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>视觉约束的噪声协方差与标定相机内参时的重投影误差，也就是偏离几个像素有关， 代<br>码对应为 ProjectionTdFactor::sqrt_info， 这里取的 1.5 个像素，信息矩阵取根号后为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029204041242.png#pic_center"></p>
<h1 id="边缘化和FEJ"><a href="#边缘化和FEJ" class="headerlink" title="边缘化和FEJ"></a>边缘化和FEJ</h1><h2 id="Marginalization"><a href="#Marginalization" class="headerlink" title="Marginalization"></a>Marginalization</h2><p>然而，将 pose 移出 windows 时，有些约束会被丢弃掉，这样势必会导致求解的精度下降，而<br>且当 MAV 进行一些退化运动 (如: 匀速运动) 时，没有历史信息做约束的话是无法求解的。所以，<br>在移出位姿或特征的时候，需要将相关联的约束转变成一个约束项作为 prior 放到优化问题中，这<br>就是 marginalization 要做的事情。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029213408596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>边缘化的过程就是将滑窗内的某些较旧或者不满足要求的视觉帧剔除的过程，所以边缘化也被描述为将联合概率分布分解为边缘概率分布和条件概率分布的过程 (就是利用 shur 补减少优化参数的过程)。</p>
<p>直接进行边缘化而不加入先验条件的后果：</p>
<blockquote>
<ol>
<li>无故地移除这些 pose 和 feature 会丢弃帧间约束，会降低了优化器的精度，所以在移除 pose和 feature 的时候需要将相关联的约束转变为一个先验的约束条件作为 prior 放到优化问题中</li>
<li>在边缘化的过程中，不加先验的边缘化会导致系统尺度的缺失 (参考 [6])，尤其是系统在进行退化运动时 (如无人机的悬停和恒速运动)。一般来说 只有两个轴向的加速度不为 0 的时候，才能保证尺度可观，而退化运动对于无人机或者机器人来说是不可避免的。所以在系统处于退化运动的时候，要加入先验信息保证尺度的可观</li>
</ol>
</blockquote>
<p>VINS 根据次新帧是否为关键帧，分为两种边缘化策略：</p>
<blockquote>
<ol>
<li>当次新帧为关键帧时，我们将 marg 掉最老帧，及其看到的路标点和相关联的 IMU<br>数据，将其转化为先验信息加到整体的目标函数中；</li>
<li>当次新帧不是关键帧时，我们将直接扔掉次新帧及它的视觉观测边，而不对次新帧进行 marg， 因为我们认为当前帧和次新帧很相似，也就是说当前帧跟路标点之间的约束和次新帧与路标点的约束很接近，直接丢弃并不会造成整个约束关系丢失过多信息。 但是值得注意的是，我们要保留次新帧的 IMU 数据，从而保证 IMU 预积分的连贯性</li>
</ol>
</blockquote>
<p>VINS 中的先验残差项的构造可以分为以下几个步骤： </p>
<blockquote>
<ol>
<li>把上一次先验项中的残差项传递给当前先验项，并从中去除需要丢弃的状态量</li>
<li>添加与当前需要丢弃的状态量相关的约束项；</li>
<li>通过函数 MarginalizationInfo::preMarginalize()得到每个残差项(cost_function)对应<br>的参数块(parameter_blocks)，雅可比矩阵(jacobians)，残差值(residuals)；</li>
<li>通过函数 MarginalizationInfo::marginalize()将步骤 3 中得到的雅可比矩阵和残差值<br>进行组合，得到整个先验项的参数块，雅可比矩阵和残差值</li>
</ol>
</blockquote>
<p>通过以上四步先验项就算构造完成了，在对滑动窗口内的状态量进行优化时，把它与IMU 残差项和视觉残差项放在一起优化，从而得到不丢失历史信息的最新状态估计的结果。</p>
<h2 id="边缘化和舒尔补"><a href="#边缘化和舒尔补" class="headerlink" title="边缘化和舒尔补"></a>边缘化和舒尔补</h2><p>根据前面讨论的基于高斯牛顿的非线性优化理论可知， 𝐻𝛿𝑥 = 𝑏可写成如下形式：</p>
<p><img alt="1572437838552" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437838552.png"></p>
<p>INS 中则真正需要边缘化掉滑动窗口中的最老帧或者次新帧，目的是希望不再计算这一帧的位姿或者与其相关的路标点，但是希望保留该帧对窗口内其他帧的约束关系。</p>
<p>上式中的$x_a$是我们要 marg 的变量，比如一个相机的 pose，因此我们更关心如何只去求解我们希望保留的变量$x_b$，而不再求解$x_a$，但是我们也希望直接将$x_a$和与其相关的路标点直接删除，因为这样会减少约束，丢失信息。因此，采用如下 Schur 进行消元：</p>
<p><img alt="1572437967596" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437967596.png"></p>
<p>其中，$ Λ^𝑇_𝑏Λ^{-1}_𝑎Λ_𝑏$就称为Λ𝑎在Λ𝑏中的 Schur 项，那么有了上面式子，我们就可以直接计算$𝛿x_b$了：</p>
<p><img alt="1572438049891" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438049891.png"></p>
<p>上面的公式即为要保留变量𝑥𝑏的先验信息。</p>
<h2 id="滑动窗口中的-FEJ-算法"><a href="#滑动窗口中的-FEJ-算法" class="headerlink" title="滑动窗口中的 FEJ 算法"></a>滑动窗口中的 FEJ 算法</h2><p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</p>
<p>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量</p>
<p>滑动窗口算法大致流程</p>
<ol>
<li>增加新的变量进入最小二乘系统优化</li>
<li>如果变量数目达到了一定的维度，则移除老的变量。</li>
<li>SLAM 系统 不断循环前面两步</li>
</ol>
<p>利用边际概率移除老的变量</p>
<p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量。</p>
<p><strong>example：</strong></p>
<p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量</p>
<p><img alt="1572438273296" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438273296.png"></p>
<p>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</p>
<p><img alt="1572438402148" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438402148.png"></p>
<p><img alt="1572438422145" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438422145.png"></p>
<p>marg 前，变量 $x_m$ 以及对应测量$S_m$ 构建的最小二乘信息矩阵为：</p>
<p><img alt="1572438479585" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438479585.png"></p>
<p>marg 后，变量$x_m$的测量信息传递给了变量 $x_r$:</p>
<p><img alt="1572438555840" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438555840.png"></p>
<p>下标 p 表示 prior. 即这些信息将构建一个关于$x_r$ 的先验信息。</p>
<p><img alt="1572438612496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438612496.png"></p>
<p><strong>新测量信息和旧测量信息构建新的系统</strong></p>
<p><img alt="1572438683496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438683496.png"></p>
<p><img alt="1572438702531" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438702531.png"></p>
<p><img alt="1572438724298" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438724298.png"></p>
<p><img alt="1572438749984" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438749984.png"></p>
<p>参考：<br><a href="https://blog.csdn.net/weixin_44580210/article/details/95748091" target="_blank" rel="noopener">VINS-Mono关键知识点总结——边缘化marginalization理论和代码详解</a><br><a href="https://blog.csdn.net/weixin_44580210/article/details/93377806" target="_blank" rel="noopener">VINS-Mono关键知识点总结——预积分和后端优化IMU部分</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——初始化</title>
    <url>/2019/10/29/VINS-Mono%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="估计器初始化"><a href="#估计器初始化" class="headerlink" title="估计器初始化"></a>估计器初始化</h1><ul>
<li>初始化的原因是单目惯性紧耦合系统是一个非线性程度很高的系统，首先单目是无法获得空间中的绝对尺度，而IMU又必然存在偏置，在后面进行求解的时候还需要用到重力加速度（包括大小和方向），对于速度比较敏感的条件下，比如说无人机，又要精确的速度信息，因此，如何有效的在紧耦合系统处理之前计算出这些量，对整个紧耦合系统的鲁棒性有着重大的意义</li>
<li>初始化要做的事其实说起来很简单，就是计算出绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li>
<li>VINS-Mono 的初始化采用松组合（loosely coupled）的方式获取初始值。 首先用 SFM求解滑动窗口内所有帧的位姿（以第一帧作为参考坐标系）和所有路标点的 3D 位置。然后将 SFM 的结果与 IMU 预积分的值进行对齐，实现对陀螺仪偏置的校正，再求解每一帧对应的速度，求解重力向量方向，恢复单目相机的尺度因子。</li>
<li>需要注意的是，在初始化过程中，并没有对加速度计的偏置进行校正，这是因为重力是初始化过程中待求的量，而加速度计偏置与重力耦合，而且系统的加速度相对于重力加速度很小，所以加速度计偏置在初始化过程中很难观测，因此初始化过程中不考虑加速度计偏置的校正。</li>
</ul><a id="more"></a>
<h2 id="滑动窗口-Sliding-Window-纯视觉SfM"><a href="#滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="滑动窗口(Sliding Window)纯视觉SfM"></a>滑动窗口(Sliding Window)纯视觉SfM</h2><p>首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，使用五点法恢复这两个帧之间的相对旋转和尺度平移。否则，将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c_0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}_{c_k}，q^{c0}_{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。</p>
<p>纯视觉初始化时，我们采用第一帧 c0 作为基准坐标系，若要转化为从 body 坐标系到 c0坐标系，可以进行如下变换，其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"></p>
<p>上式推导如下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185549508.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185607797.png#pic_center"></p>
<h2 id="B-视觉惯性校准（Visual-Inertial-Alignment"><a href="#B-视觉惯性校准（Visual-Inertial-Alignment" class="headerlink" title="B. 视觉惯性校准（Visual-Inertial Alignment)"></a>B. 视觉惯性校准（Visual-Inertial Alignment)</h2><h3 id="陀螺仪偏置标定"><a href="#陀螺仪偏置标定" class="headerlink" title="陀螺仪偏置标定"></a>陀螺仪偏置标定</h3><p>这 一 部 分 的 内 容 对 应 于 VINS-Mono 代 码 initial_aligment.cpp 中 的<br>solveGyroscopeBias()函数。<br>考虑滑动窗口中连续两帧$b_k$和$b_{k+1}$，我们从视觉sfM中得到旋转$q^{c0}_{b_k}$和$q^{c0}_{b_{k+1}}$，从IMU预积分得到的相对约束$γ^{b_k}_{b_{k+1}}$。<br>陀螺仪的误差有两部分测量噪声和陀螺仪偏置，噪声暂时可以忽略（毕竟太小），而视觉的误差就只有观测噪声（也可以忽略不管），因此两者差值的绝对值就是陀螺仪偏置，将整个滑动窗口的所有的旋转做差构成了一个最小化误差模型：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"></p>
<p>其中B代表窗口的所有帧。<br>$q^{c0}_{b_k}$$q^{c0}_{b_{k+1}}$：相机从$b_k$到$b_{k+1}$下的相对旋转<br>$γ^{b_k}_{b_{k+1}}$：陀螺仪从$b_{k+1}$到$b_k$下的相对旋转<br>第二个式子给出了$γ^{b_k}_{b_{k+1}}$对陀螺仪偏置的一阶近似。</p>
<p>因为四元数最小值为单位四元数 [1; 0v]T，所以</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171134242.png#pic_center"></p>
<p>只考虑虚部，则有：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171213618.png#pic_center"></p>
<p>然后取最小二乘，当然也可以使用SVD分解等方法求解，得到了陀螺仪偏置$b_w$的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}_{b_{k+1}}、\hat β^{b_k}_{b_{k+1}}、\hat γ^{b_k}_{b_{k+1}}$ 。</p>
<h3 id="速度、重力向量和尺度初始化："><a href="#速度、重力向量和尺度初始化：" class="headerlink" title="速度、重力向量和尺度初始化："></a>速度、重力向量和尺度初始化：</h3><p>这一部分的内容对应于 VINS-Mono 代码 initial_aligment.cpp 中的 LinearAlignment()<br>函数<br>在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"></p>
<p>其中，$v^{b_k}_{b_k}$是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。<br>在$c_0$坐标系的预积分：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180200742.png#pic_center"></p>
<p>$p^{c_0}_{b_{k+1}}$和$p^{c_0}_{b_{k}}$可由视觉 SFM 获得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180301129.png#pic_center"></p>
<p>将此式带入上式得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180458901.png#pic_center"></p>
<p>将等式中速度都转换到$c_0$ 坐标系下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181635823.png#pic_center"></p>
<p>将上式转换成$Hx=b$ 的形式，这样便于利用 cholesky 进行求解，由$s\bar p^{c_0}_{b_k}=p^{c_0}_{c_k}-R^{c_0}_{c_k}p_c^b$，带入上式得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181106531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>联力等式：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181609102.png#pic_center"></p>
<p>即： $H^{6×10}X_I^{\ 10×1} = b^{6×1}$<br>H矩阵一定是一个正定对称矩阵，以采用快速的 Cholosky 分解下面方程求解$X_I$：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028182207166.png#pic_center"></p>
<p>可以得到滑动窗口中所有关键帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及单目尺度因子 s 。</p>
<h3 id="修正重力矢量"><a href="#修正重力矢量" class="headerlink" title="修正重力矢量"></a>修正重力矢量</h3><p>这里计算的重力吸收了重力加速度计的偏置，虽然不需要计算重力加速度计的偏置，但重力还是需要优化的，说到优化重力加速度，肯定包含两个量，大小和方向，也就是三个维度，但是一般来说大小是确定已知的（这里设为9.8），因此其实我们要做的就是优化方向，是一个两维的向量，下图是优化重力的方法以及b1,b2单位向量的方向确定模型。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>将重力向量重新参数化：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183144674.png#pic_center"></p>
<p>其中g是已知的重力大小，$\bar {\hat g}$是表示重力方向的单位向量，b1、 b2为重力向量正切空间的一对<br>正交基 ，如图所示，w1和w2分别是在b1和b2上的对应位移。<br>将上式代入前面式子中，重新整理可得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183424735.png#pic_center"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183439415.png"></p>
<p>这样，可以用 Cholosky 分解下面方程求解$X_I$：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183526590.png#pic_center"></p>
<p>完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028160032562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>直接从estimator.cpp中的 if (solver_flag == INITIAL) 开始</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (solver_flag == INITIAL) &#123;</span><br><span class="line">    <span class="comment">// 滑窗中的Keyframe达到指定大小的时候，才开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (frame_count == WINDOW_SIZE) &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_EXTRINSIC != <span class="number">2</span> &amp;&amp; (header.stamp.toSec() - initial_timestamp) &gt; <span class="number">0.1</span>) &#123;</span><br><span class="line">            result = initialStructure(); <span class="comment">//! 初始化</span></span><br><span class="line">            initial_timestamp = header.stamp.toSec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            solver_flag = NON_LINEAR;</span><br><span class="line">            solveOdometry();</span><br><span class="line">            slideWindow();</span><br><span class="line">            f_manager.removeFailures();</span><br><span class="line">            ROS_INFO(<span class="string">"Initialization finish!"</span>);</span><br><span class="line">            last_R = Rs[WINDOW_SIZE];</span><br><span class="line">            last_P = Ps[WINDOW_SIZE];</span><br><span class="line">            last_R0 = Rs[<span class="number">0</span>];</span><br><span class="line">            last_P0 = Ps[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            slideWindow();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        frame_count++;</span><br></pre></td></tr></table></figure>
<h3 id="initialStructure-视觉惯性联合初始化"><a href="#initialStructure-视觉惯性联合初始化" class="headerlink" title="initialStructure() 视觉惯性联合初始化"></a>initialStructure() 视觉惯性联合初始化</h3><ul>
<li>1.通过计算线加速度的标准差，检测IMU的可观性，以进行初始化<br>注意这里并没有算上all_image_frame的第一帧，所以求均值和标准差的时候要减一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 通过计算预积分加速度的标准差，检测IMU的可观性</span></span><br><span class="line"><span class="comment">//check imu observibility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算均值</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it;</span><br><span class="line">    Vector3d sum_g;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        sum_g += tmp_g;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector3d aver_g = sum_g * <span class="number">1.0</span> / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方差</span></span><br><span class="line">    <span class="keyword">double</span> var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        var += (tmp_g - aver_g).transpose() * (tmp_g - aver_g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算标准差</span></span><br><span class="line">    var = <span class="built_in">sqrt</span>(var / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//ROS_WARN("IMU variation %f!", var);</span></span><br><span class="line">    <span class="keyword">if</span>(var &lt; <span class="number">0.25</span>) <span class="comment">//! 以标准差判断可观性</span></span><br><span class="line">    &#123;</span><br><span class="line">        ROS_INFO(<span class="string">"IMU excitation not enouth!"</span>);</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.将f_manager中的所有feature保存到vector<sfmfeature> sfm_f中，SFMFeature数组中包含了特征点状态（是否被三角化），id，2d点，3d坐标以及深度，将特征管理器中的特征信息保存到SFMFeature对象sfm_f中sfm_f.push_back(tmp_feature)。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SFMFeature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> state;<span class="comment">//状态（是否被三角化）</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,Vector2d&gt;&gt; observation;<span class="comment">//所有观测到该特征点的图像帧ID和图像坐标</span></span><br><span class="line">    <span class="keyword">double</span> position[<span class="number">3</span>];<span class="comment">//3d坐标</span></span><br><span class="line">    <span class="keyword">double</span> depth;<span class="comment">//深度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历滑窗内所有的Features，以vector&lt;SFMFeature&gt;形式保存滑窗内所有特征点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;SFMFeature&gt; sfm_f;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> imu_j = it_per_id.start_frame - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    SFMFeature tmp_feature;</span><br><span class="line">    tmp_feature.state = <span class="literal">false</span>;</span><br><span class="line">    tmp_feature.id = it_per_id.feature_id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_frame : it_per_id.feature_per_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        imu_j++;</span><br><span class="line">        Vector3d pts_j = it_per_frame.point;</span><br><span class="line">        tmp_feature.observation.push_back(make_pair(imu_j, Eigen::Vector2d&#123;pts_j.x(), pts_j.y()&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sfm_f.push_back(tmp_feature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sfmfeature></li>
<li>3.relativePose()恢复出R、t</li>
</ul>
<blockquote>
<p> 1.先通过 FeatureManager::getCorresponding()获取滑动窗口中第i帧和最后一帧的特征匹配corres<br> 2.如果第i帧和最后一帧的特征匹配数corres大于20，且所有匹配的特征点的平均视差大于一定阈值，通过solveRelativeRT（定义在solv_5pts.cpp类中）用五点法求本质矩阵cv::findFundamentalMat 计算出当前帧到参考帧的 T</p>
<p> 值得注意：relativePose得到的位姿是第l帧的，第l帧的筛选是从第一帧开始到滑动窗口所有帧中一开始满足平均视差足够大的帧，这里的第l帧会作为参考帧到下面的全局SFM使用。这样得到图像的特征点2d坐标的提取，相机第l帧和最后一帧之间的旋转和平移</p>
</blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!relativePose(relative_R, relative_T, l))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"Not enough features or parallax; Move device around"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>bool relativePose(relative_R, relative_T, l)</strong><br>   该函数判断每帧到窗口最后一帧对应特征点的平均视差大于30，且内点数目大于12则可进行初始化，同时返回当前帧到第l帧的坐标系变换R和T<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::relativePose(Matrix3d &amp;relative_R, Vector3d &amp;relative_T, <span class="keyword">int</span> &amp;l) &#123;</span><br><span class="line">    <span class="comment">// find previous frame which contians enough correspondance and parallex with newest frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在滑窗内寻找与最新的关键帧共视点超过20(像素点)的关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WINDOW_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">        <span class="comment">//获取第i帧和最后一帧的特征匹配corres</span></span><br><span class="line">        corres = f_manager.getCorresponding(i, WINDOW_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共视的Features应该大于20</span></span><br><span class="line">        <span class="keyword">if</span> (corres.size() &gt; <span class="number">20</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取匹配的特征点在图像上的视差和(归一化平面上)</span></span><br><span class="line">            <span class="keyword">double</span> sum_parallax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(corres.size()); j++) &#123;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_0</span><span class="params">(corres[j].first(<span class="number">0</span>), corres[j].first(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_1</span><span class="params">(corres[j].second(<span class="number">0</span>), corres[j].second(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="keyword">double</span> parallax = (pts_0 - pts_1).norm();</span><br><span class="line">                sum_parallax = sum_parallax + parallax;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取所有匹配的特征点的平均视差</span></span><br><span class="line">            <span class="keyword">double</span> average_parallax = <span class="number">1.0</span> * sum_parallax / <span class="keyword">int</span>(corres.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视差大于一定阈值，并且能够有效地求解出变换矩阵</span></span><br><span class="line">            <span class="keyword">if</span> (average_parallax * <span class="number">460</span> &gt; <span class="number">30</span> &amp;&amp; m_estimator.solveRelativeRT(corres, relative_R, relative_T)) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">                ROS_DEBUG(<span class="string">"average_parallax %f choose l %d and newest frame to triangulate the whole structure"</span>,</span><br><span class="line">                          average_parallax * <span class="number">460</span>, l);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>FeatureManager::getCorresponding()</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; FeatureManager::getCorresponding(<span class="keyword">int</span> frame_count_l, <span class="keyword">int</span> frame_count_r) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : feature) &#123;</span><br><span class="line">        <span class="comment">// 保证两帧的id大于当前特征点的起始id小于当前特征点的终止id</span></span><br><span class="line">        <span class="keyword">if</span> (it.start_frame &lt;= frame_count_l &amp;&amp; it.endFrame() &gt;= frame_count_r) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx_l = frame_count_l - it.start_frame;</span><br><span class="line">            <span class="keyword">int</span> idx_r = frame_count_r - it.start_frame;</span><br><span class="line"></span><br><span class="line">            Vector3d a = it.feature_per_frame[idx_l].point;</span><br><span class="line">            Vector3d b = it.feature_per_frame[idx_r].point;</span><br><span class="line"></span><br><span class="line">            corres.push_back(make_pair(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> corres;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>solveRelativeRT()</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> MotionEstimator::solveRelativeRT(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; &amp;corres, Matrix3d &amp;Rotation, Vector3d &amp;Translation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (corres.size() &gt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! Step1：提取匹配完的Features</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; ll, rr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(corres.size()); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll.push_back(cv::Point2f(corres[i].first(<span class="number">0</span>), corres[i].first(<span class="number">1</span>)));</span><br><span class="line">            rr.push_back(cv::Point2f(corres[i].second(<span class="number">0</span>), corres[i].second(<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::Mat mask;</span><br><span class="line">        <span class="comment">//! Step2：利用Ransac算法计算本质矩阵，内外点的阈值距离设定为0.3 / 460</span></span><br><span class="line">        cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, <span class="number">0.3</span> / <span class="number">460</span>, <span class="number">0.99</span>, mask);</span><br><span class="line"></span><br><span class="line">        cv::Mat cameraMatrix = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step3：计算变换矩阵并得到内点个数</span></span><br><span class="line">        cv::Mat rot, trans;</span><br><span class="line">        <span class="keyword">int</span> inlier_cnt = cv::recoverPose(E, ll, rr, cameraMatrix, rot, trans, mask);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "inlier_cnt " &lt;&lt; inlier_cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 得到变换矩阵 ll ==&gt; rr</span></span><br><span class="line">        Eigen::Matrix3d R;</span><br><span class="line">        Eigen::Vector3d T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            T(i) = trans.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                R(i, j) = rot.at&lt;<span class="keyword">double</span>&gt;(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step4：得到旋转矩阵和平移量 rr ==&gt; ll</span></span><br><span class="line">        Rotation    =  R.transpose();</span><br><span class="line">        Translation = -R.transpose() * T;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 判断求取的内点个数是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(inlier_cnt &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4.对窗口中每个图像帧求解sfm问题，调用sfm.construct(frame_count + 1, Q, T,l,relative_R, relative_T,sfm_f, sfm_tracked_points)估计slidingwindow中所有图像帧相对于参考帧（这里以第l帧作为参考帧）的旋转四元数Q、平移向量T和特征点坐标sfm_tracked_points。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三角化恢复滑窗内的Features</span></span><br><span class="line">GlobalSFM sfm;</span><br><span class="line">Quaterniond Q[frame_count + <span class="number">1</span>];</span><br><span class="line">Vector3d    T[frame_count + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; sfm_tracked_points;</span><br><span class="line"><span class="keyword">if</span>(!sfm.construct(frame_count + <span class="number">1</span>, Q, T, l, relative_R, relative_T, sfm_f, sfm_tracked_points))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"global SFM failed!"</span>);</span><br><span class="line">    marginalization_flag = MARGIN_OLD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool GlobalSFM::construct()</strong><br>函数位于inital_sfm.cpp文件中<br>纯视觉sfm，求解窗口中所有图像帧的位姿QT（相对于第l帧）和特征点坐标sfm_tracked_points<br>frame_num=frame_count + 1=11，frame_num-1表示当前帧</p>
<blockquote>
<p>1.把第l帧看作参考坐标系，根据当前帧到第l帧的relative_R，relative_T，得到当前帧在参考坐标系下的位姿，之后的pose[i]表示第l帧到第i帧的变换矩阵[R|T]<br>2.三角化第l帧（参考帧）与第frame_num-1帧（当前帧）的路标点<br>3.pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中，并与当前帧进行三角化<br>4.对第l帧与从第l+1到frame_num-2的每一帧再进行三角化<br>5.PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化<br>6.三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标<br>7.使用cares进行全局BA优化<br>8.得到的是第l帧坐标系到各帧的变换矩阵，将其转变为每一帧在第l帧坐标系上的位姿<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> GlobalSFM::construct(<span class="keyword">int</span> frame_num, Quaterniond* q, Vector3d* T, <span class="keyword">int</span> l,</span><br><span class="line">			  <span class="keyword">const</span> Matrix3d relative_R, <span class="keyword">const</span> Vector3d relative_T,</span><br><span class="line">			  <span class="built_in">vector</span>&lt;SFMFeature&gt; &amp;sfm_f, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; &amp;sfm_tracked_points)</span><br><span class="line">&#123;</span><br><span class="line">	feature_num = sfm_f.size();</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "set 0 and " &lt;&lt; l &lt;&lt; " as known " &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">// have relative_r relative_t</span></span><br><span class="line">	<span class="comment">// intial two view</span></span><br><span class="line">	q[l].w() = <span class="number">1</span>;</span><br><span class="line">	q[l].x() = <span class="number">0</span>;</span><br><span class="line">	q[l].y() = <span class="number">0</span>;</span><br><span class="line">	q[l].z() = <span class="number">0</span>;</span><br><span class="line">	T[l].setZero();</span><br><span class="line">	q[frame_num - <span class="number">1</span>] = q[l] * Quaterniond(relative_R);</span><br><span class="line">	T[frame_num - <span class="number">1</span>] = relative_T;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "init q_l " &lt;&lt; q[l].w() &lt;&lt; " " &lt;&lt; q[l].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "init t_l " &lt;&lt; T[l].transpose() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//rotate to cam frame</span></span><br><span class="line">	Matrix3d c_Rotation[frame_num];</span><br><span class="line">	Vector3d c_Translation[frame_num];</span><br><span class="line">	Quaterniond c_Quat[frame_num];</span><br><span class="line">	<span class="keyword">double</span> c_rotation[frame_num][<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">double</span> c_translation[frame_num][<span class="number">3</span>];</span><br><span class="line">	Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">4</span>&gt; Pose[frame_num];</span><br><span class="line"></span><br><span class="line">	c_Quat[l] = q[l].inverse();</span><br><span class="line">	c_Rotation[l] = c_Quat[l].toRotationMatrix();</span><br><span class="line">	c_Translation[l] = <span class="number">-1</span> * (c_Rotation[l] * T[l]);</span><br><span class="line">	Pose[l].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[l];</span><br><span class="line">	Pose[l].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[l];</span><br><span class="line"></span><br><span class="line">	c_Quat[frame_num - <span class="number">1</span>] = q[frame_num - <span class="number">1</span>].inverse();</span><br><span class="line">	c_Rotation[frame_num - <span class="number">1</span>] = c_Quat[frame_num - <span class="number">1</span>].toRotationMatrix();</span><br><span class="line">	c_Translation[frame_num - <span class="number">1</span>] = <span class="number">-1</span> * (c_Rotation[frame_num - <span class="number">1</span>] * T[frame_num - <span class="number">1</span>]);</span><br><span class="line">	Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[frame_num - <span class="number">1</span>];</span><br><span class="line">	Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[frame_num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1: trangulate between l ----- frame_num - 1</span></span><br><span class="line">	<span class="comment">//2: solve pnp l + 1; trangulate l + 1 ------- frame_num - 1; </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; frame_num - <span class="number">1</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// solve pnp</span></span><br><span class="line">		<span class="comment">//pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; l)</span><br><span class="line">		&#123;</span><br><span class="line">			Matrix3d R_initial = c_Rotation[i - <span class="number">1</span>];</span><br><span class="line">			Vector3d P_initial = c_Translation[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			c_Rotation[i] = R_initial;</span><br><span class="line">			c_Translation[i] = P_initial;</span><br><span class="line">			c_Quat[i] = c_Rotation[i];</span><br><span class="line">			Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">			Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// triangulate point based on the solve pnp result</span></span><br><span class="line">		triangulateTwoFrames(i, Pose[i], frame_num - <span class="number">1</span>, Pose[frame_num - <span class="number">1</span>], sfm_f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3: triangulate l-----l+1 l+2 ... frame_num -2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; frame_num - <span class="number">1</span>; i++)</span><br><span class="line">		triangulateTwoFrames(l, Pose[l], i, Pose[i], sfm_f);</span><br><span class="line">	<span class="comment">//4: solve pnp l-1; triangulate l-1 ----- l</span></span><br><span class="line">	<span class="comment">//             l-2              l-2 ----- l</span></span><br><span class="line">	<span class="comment">//PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//solve pnp</span></span><br><span class="line">		Matrix3d R_initial = c_Rotation[i + <span class="number">1</span>];</span><br><span class="line">		Vector3d P_initial = c_Translation[i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		c_Rotation[i] = R_initial;</span><br><span class="line">		c_Translation[i] = P_initial;</span><br><span class="line">		c_Quat[i] = c_Rotation[i];</span><br><span class="line">		Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">		Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">		<span class="comment">//triangulate</span></span><br><span class="line">		triangulateTwoFrames(i, Pose[i], l, Pose[l], sfm_f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5: triangulate all other points</span></span><br><span class="line">	<span class="comment">//三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; feature_num; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sfm_f[j].state == <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">int</span>)sfm_f[j].observation.size() &gt;= <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Vector2d point0, point1;</span><br><span class="line">			<span class="keyword">int</span> frame_0 = sfm_f[j].observation[<span class="number">0</span>].first;</span><br><span class="line">			point0 = sfm_f[j].observation[<span class="number">0</span>].second;</span><br><span class="line">			<span class="keyword">int</span> frame_1 = sfm_f[j].observation.back().first;</span><br><span class="line">			point1 = sfm_f[j].observation.back().second;</span><br><span class="line">			Vector3d point_3d;</span><br><span class="line">			triangulatePoint(Pose[frame_0], Pose[frame_1], point0, point1, point_3d);</span><br><span class="line">			sfm_f[j].state = <span class="literal">true</span>;</span><br><span class="line">			sfm_f[j].position[<span class="number">0</span>] = point_3d(<span class="number">0</span>);</span><br><span class="line">			sfm_f[j].position[<span class="number">1</span>] = point_3d(<span class="number">1</span>);</span><br><span class="line">			sfm_f[j].position[<span class="number">2</span>] = point_3d(<span class="number">2</span>);</span><br><span class="line">			<span class="comment">//cout &lt;&lt; "trangulated : " &lt;&lt; frame_0 &lt;&lt; " " &lt;&lt; frame_1 &lt;&lt; "  3d point : "  &lt;&lt; j &lt;&lt; "  " &lt;&lt; point_3d.transpose() &lt;&lt; endl;</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		q[i] = c_Rotation[i].transpose(); </span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "solvePnP  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		Vector3d t_tmp;</span></span><br><span class="line"><span class="comment">		t_tmp = -1 * (q[i] * c_Translation[i]);</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "solvePnP  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; t_tmp.x() &lt;&lt;"  "&lt;&lt; t_tmp.y() &lt;&lt;"  "&lt;&lt; t_tmp.z() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="comment">//full BA</span></span><br><span class="line">	<span class="comment">//使用cares进行全局BA优化</span></span><br><span class="line">	ceres::Problem problem;</span><br><span class="line">	ceres::LocalParameterization* local_parameterization = <span class="keyword">new</span> ceres::QuaternionParameterization();</span><br><span class="line">	<span class="comment">//cout &lt;&lt; " begin full BA " &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//double array for ceres</span></span><br><span class="line">		c_translation[i][<span class="number">0</span>] = c_Translation[i].x();</span><br><span class="line">		c_translation[i][<span class="number">1</span>] = c_Translation[i].y();</span><br><span class="line">		c_translation[i][<span class="number">2</span>] = c_Translation[i].z();</span><br><span class="line">		c_rotation[i][<span class="number">0</span>] = c_Quat[i].w();</span><br><span class="line">		c_rotation[i][<span class="number">1</span>] = c_Quat[i].x();</span><br><span class="line">		c_rotation[i][<span class="number">2</span>] = c_Quat[i].y();</span><br><span class="line">		c_rotation[i][<span class="number">3</span>] = c_Quat[i].z();</span><br><span class="line">		problem.AddParameterBlock(c_rotation[i], <span class="number">4</span>, local_parameterization);</span><br><span class="line">		problem.AddParameterBlock(c_translation[i], <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span> (i == l)</span><br><span class="line">		&#123;</span><br><span class="line">			problem.SetParameterBlockConstant(c_rotation[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == l || i == frame_num - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			problem.SetParameterBlockConstant(c_translation[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; feature_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sfm_f[i].state != <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(sfm_f[i].observation.size()); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> l = sfm_f[i].observation[j].first;</span><br><span class="line">			ceres::CostFunction* cost_function = ReprojectionError3D::Create(</span><br><span class="line">												sfm_f[i].observation[j].second.x(),</span><br><span class="line">												sfm_f[i].observation[j].second.y());</span><br><span class="line"></span><br><span class="line">    		problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, c_rotation[l], c_translation[l], </span><br><span class="line">    								sfm_f[i].position);	 </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	ceres::Solver::Options options;</span><br><span class="line">	options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line">	<span class="comment">//options.minimizer_progress_to_stdout = true;</span></span><br><span class="line">	options.max_solver_time_in_seconds = <span class="number">0.2</span>;</span><br><span class="line">	ceres::Solver::Summary summary;</span><br><span class="line">	ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; summary.BriefReport() &lt;&lt; "\n";</span></span><br><span class="line">	<span class="keyword">if</span> (summary.termination_type == ceres::CONVERGENCE || summary.final_cost &lt; <span class="number">5e-03</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "vision only BA converge" &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "vision only BA not converge " &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q[i].w() = c_rotation[i][<span class="number">0</span>]; </span><br><span class="line">		q[i].x() = c_rotation[i][<span class="number">1</span>]; </span><br><span class="line">		q[i].y() = c_rotation[i][<span class="number">2</span>]; </span><br><span class="line">		q[i].z() = c_rotation[i][<span class="number">3</span>]; </span><br><span class="line">		q[i] = q[i].inverse();</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "final  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第l帧坐标系到各帧的变换矩阵，应将其转变为每一帧在第l帧坐标系上的位姿</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		T[i] = <span class="number">-1</span> * (q[i] * Vector3d(c_translation[i][<span class="number">0</span>], c_translation[i][<span class="number">1</span>], c_translation[i][<span class="number">2</span>]));</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "final  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; T[i](0) &lt;&lt;"  "&lt;&lt; T[i](1) &lt;&lt;"  "&lt;&lt; T[i](2) &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)sfm_f.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(sfm_f[i].state)</span><br><span class="line">			sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[<span class="number">0</span>], sfm_f[i].position[<span class="number">1</span>], sfm_f[i].position[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>对于所有的图像帧，包括不在滑动窗口中的，提供初始的RT估计，然后solvePnP进行优化</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solve pnp for all frame</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt;::iterator it;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it = all_image_frame.begin( );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; frame_it != all_image_frame.end( ); frame_it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// provide initial guess</span></span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) == Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        frame_it-&gt;second.is_key_frame = <span class="literal">true</span>;</span><br><span class="line">        frame_it-&gt;second.R = Q[i].toRotationMatrix() * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">        frame_it-&gt;second.T = T[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) &gt; Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将滑窗内第i帧的变换矩阵当做初始值</span></span><br><span class="line">    Matrix3d R_inital = (Q[i].inverse()).toRotationMatrix();</span><br><span class="line">    Vector3d P_inital = - R_inital * T[i];</span><br><span class="line">    cv::Mat rvec, t, tmp_r;</span><br><span class="line">    cv::eigen2cv(R_inital, tmp_r);</span><br><span class="line">    cv::Rodrigues(tmp_r, rvec);</span><br><span class="line">    cv::eigen2cv(P_inital, t);</span><br><span class="line"></span><br><span class="line">    frame_it-&gt;second.is_key_frame = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point3f&gt; pts_3_vector;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point2f&gt; pts_2_vector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;id_pts : frame_it-&gt;second.points)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> feature_id = id_pts.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i_p : id_pts.second)</span><br><span class="line">        &#123;</span><br><span class="line">            it = sfm_tracked_points.find(feature_id);</span><br><span class="line">            <span class="keyword">if</span>(it != sfm_tracked_points.end())</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3d world_pts = it-&gt;second;</span><br><span class="line">                cv::<span class="function">Point3f <span class="title">pts_3</span><span class="params">(world_pts(<span class="number">0</span>), world_pts(<span class="number">1</span>), world_pts(<span class="number">2</span>))</span></span>;</span><br><span class="line">                pts_3_vector.push_back(pts_3);</span><br><span class="line"></span><br><span class="line">                Vector2d img_pts = i_p.second.head&lt;<span class="number">2</span>&gt;();</span><br><span class="line">                cv::<span class="function">Point2f <span class="title">pts_2</span><span class="params">(img_pts(<span class="number">0</span>), img_pts(<span class="number">1</span>))</span></span>;</span><br><span class="line">                pts_2_vector.push_back(pts_2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pts_3_vector.size() &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pts_3_vector size "</span> &lt;&lt; pts_3_vector.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ROS_DEBUG(<span class="string">"Not enough points for solve pnp !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat K = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat D;</span><br><span class="line">    <span class="keyword">if</span> (! cv::solvePnP(pts_3_vector, pts_2_vector, K, D, rvec, t, <span class="literal">true</span>)) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve pnp fail!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PnP求解出的位姿要取逆</span></span><br><span class="line">    MatrixXd R_pnp;</span><br><span class="line">    MatrixXd T_pnp;</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat r;</span><br><span class="line">        cv::Rodrigues(rvec, r);</span><br><span class="line">        MatrixXd tmp_R_pnp;</span><br><span class="line">        cv::cv2eigen(r, tmp_R_pnp);</span><br><span class="line">        R_pnp = tmp_R_pnp.transpose();</span><br><span class="line"></span><br><span class="line">        cv::cv2eigen(t, T_pnp);</span><br><span class="line">        T_pnp = R_pnp * (-T_pnp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换到IMU坐标系下</span></span><br><span class="line">    frame_it-&gt;second.R = R_pnp * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">    frame_it-&gt;second.T = T_pnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6.进行视觉惯性联合初始化，imu与视觉对齐，获取绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视觉与IMU对齐</span></span><br><span class="line"><span class="keyword">if</span> (visualInitialAlign())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"misalign visual structure with IMU"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool Estimator::visualInitialAlign()</strong><br>该函数主要实现了陀螺仪的偏置校准(加速度偏置没有处理)，计算速度V[0:n]、重力g、尺度s。<br>同时更新了Bgs后，IMU测量量需要repropagate；得到尺度s和重力g的方向后，需更新所有图像帧在世界坐标系下的Ps、Rs、Vs。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::visualInitialAlign()</span><br><span class="line">&#123;</span><br><span class="line">    TicToc t_g;</span><br><span class="line"></span><br><span class="line">    VectorXd x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve scale</span></span><br><span class="line">    <span class="comment">// 要注意这个地方求解出的g是在C0坐标系下</span></span><br><span class="line">    <span class="comment">//1.计算陀螺仪偏置，尺度，重力加速度和速度</span></span><br><span class="line">    <span class="keyword">bool</span> result = VisualIMUAlignment(all_image_frame, Bgs, g, x);</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve g failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change state</span></span><br><span class="line">    <span class="comment">//2.获取所有图像帧的位姿Ps、Rs，并将其置为关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix3d Ri = all_image_frame[Headers[i].stamp.toSec()].R;</span><br><span class="line">        Vector3d Pi = all_image_frame[Headers[i].stamp.toSec()].T;</span><br><span class="line">        Ps[i] = Pi;</span><br><span class="line">        Rs[i] = Ri;</span><br><span class="line">        all_image_frame[Headers[i].stamp.toSec()].is_key_frame = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有特征点的深度置为-1</span></span><br><span class="line">    VectorXd dep = f_manager.getDepthVector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dep.size(); i++)</span><br><span class="line">        dep[i] = <span class="number">-1</span>;</span><br><span class="line">    f_manager.clearDepth(dep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//triangulat on cam pose , no tic</span></span><br><span class="line">    <span class="comment">//3.重新计算特征点的深度</span></span><br><span class="line">    Vector3d TIC_TMP[NUM_OF_CAM];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">        TIC_TMP[i].setZero();</span><br><span class="line">    ric[<span class="number">0</span>] = RIC[<span class="number">0</span>];</span><br><span class="line">    f_manager.setRic(ric);</span><br><span class="line">    f_manager.triangulate(Ps, &amp;(TIC_TMP[<span class="number">0</span>]), &amp;(RIC[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> s = (x.tail&lt;<span class="number">1</span>&gt;())(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4.陀螺仪的偏置bgs改变，重新计算预积分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= WINDOW_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre_integrations[i]-&gt;repropagate(Vector3d::Zero(), Bgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.将Ps、Vs、depth尺度s缩放后转变为相对于第0帧图像坐标系下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = frame_count; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        Ps[i] = s * Ps[i] - Rs[i] * TIC[<span class="number">0</span>] - (s * Ps[<span class="number">0</span>] - Rs[<span class="number">0</span>] * TIC[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> kv = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_i;</span><br><span class="line">    <span class="keyword">for</span> (frame_i = all_image_frame.begin(); frame_i != all_image_frame.end(); frame_i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(frame_i-&gt;second.is_key_frame)</span><br><span class="line">        &#123;</span><br><span class="line">            kv++;</span><br><span class="line">            Vs[kv] = frame_i-&gt;second.R * x.segment&lt;<span class="number">3</span>&gt;(kv * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">    &#123;</span><br><span class="line">        it_per_id.used_num = it_per_id.feature_per_frame.size();</span><br><span class="line">        <span class="keyword">if</span> (!(it_per_id.used_num &gt;= <span class="number">2</span> &amp;&amp; it_per_id.start_frame &lt; WINDOW_SIZE - <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        it_per_id.estimated_depth *= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转矩阵rot_diff</span></span><br><span class="line">    Matrix3d R0 = Utility::g2R(g);</span><br><span class="line">    <span class="keyword">double</span> yaw = Utility::R2ypr(R0 * Rs[<span class="number">0</span>]).x();</span><br><span class="line">    R0 = Utility::ypr2R(Eigen::Vector3d&#123;-yaw, <span class="number">0</span>, <span class="number">0</span>&#125;) * R0;</span><br><span class="line">    g = R0 * g;</span><br><span class="line">    <span class="comment">//Matrix3d rot_diff = R0 * Rs[0].transpose();</span></span><br><span class="line">    Matrix3d rot_diff = R0;</span><br><span class="line">    <span class="comment">//7.所有变量从参考坐标系c0旋转到世界坐标系w</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Ps[i] = rot_diff * Ps[i];</span><br><span class="line">        Rs[i] = rot_diff * Rs[i];</span><br><span class="line">        Vs[i] = rot_diff * Vs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"g0     "</span> &lt;&lt; g.transpose());</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"my R0  "</span> &lt;&lt; Utility::R2ypr(Rs[<span class="number">0</span>]).transpose()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<br><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719531" target="_blank" rel="noopener">VINS理论与代码详解4——初始化</a></p>
</blockquote>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>17.打印从1到最大的n位数</title>
    <url>/2019/10/29/17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h1><p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>用一个循环从1开始逐个打印，但当n很大时，有可能用整型(int)或长整型(long)都会溢出。</p>
</li>
<li><p>字符串模拟运算的解法，<strong>用字符串或者数组表达大数</strong></p>
<blockquote>
<p>把字符串中的每一个数字都初始化为’0’<br>每一次为字符串表示的数字加1，再打印出来</p>
</blockquote>
</li>
</ol><a id="more"></a>

<p>这题对我来说有点难，只是看懂了，python代码以后在整理.</p>
<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">'0'</span>, n);</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Increment(number))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[]number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，在 number上增加1</span></span><br><span class="line"><span class="comment">// 如果做加法溢出，则返回true；否则为false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTakeOver = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nSum = number[i] - <span class="string">'0'</span> + nTakeOver;</span><br><span class="line">        <span class="keyword">if</span> (i == nLength - <span class="number">1</span>)</span><br><span class="line">            nSum++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nSum &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                isOverflow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nSum -= <span class="number">10</span>;</span><br><span class="line">                nTakeOver = <span class="number">1</span>;</span><br><span class="line">                number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>16.数组的整数次方</title>
    <url>/2019/10/29/16.%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>当指数exponent为正</p>
</li>
<li><p>当指数为负，可以先对指数取绝对值，算出次方的结果后取倒数，要讨论底数是否为0</p>
<blockquote>
<p>底数base不为0</p>
<p>底数base为0，对0求倒数，导致程序出错，需要进行特殊处理，这里采用全局变量</p>
<p><img alt="1572402654504" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572402654504.png"></p>
</blockquote>
</li>
</ol><a id="more"></a>


<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p>
<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Exponent;i++)</span><br><span class="line">            result*=base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<p>位运算效率比乘除法及求余运算符（%）的效率高很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span> base;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//用右移运算符代替除以2</span></span><br><span class="line">         <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,Exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">         result*=result;</span><br><span class="line">         <span class="comment">//求余运算符（%）判断一个数是奇数还是偶数</span></span><br><span class="line">         <span class="keyword">if</span>(Exponent &amp; <span class="number">0x1</span>==<span class="number">1</span>)</span><br><span class="line">             result*=base;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent&lt;<span class="number">0</span>:</span><br><span class="line">            exponent=-exponent</span><br><span class="line">            flag=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        temp=base</span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(exponent):</span><br><span class="line">            <span class="keyword">if</span> exponent &amp; <span class="number">1</span>:</span><br><span class="line">                res*=temp</span><br><span class="line">            temp*=temp</span><br><span class="line">            exponent=exponent&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>15.二进制中1的个数</title>
    <url>/2019/10/29/15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="二进制的5种位运算"><a href="#二进制的5种位运算" class="headerlink" title="二进制的5种位运算"></a>二进制的5种位运算</h1><blockquote>
<p>与（&amp;）</p>
<p>或（|）</p>
<p>异或（^)</p>
<p>左移(&lt;&lt;)  ：左移n位时，做左边的n位被丢弃，最右边不是那个补上n个0</p>
<p>右移(&gt;&gt;)  ：右移n位时，最右边的n位被丢弃,左边分两种情况</p>
<blockquote>
<p>1.如果数字为正，右移最左边补n个0</p>
<p>2.如果数字为负，右移最左边补n个1      </p>
</blockquote>
</blockquote><a id="more"></a>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>先判断整数二进制最右边是不是1，接着把输入的整数右移一位，再判断是不是1，直到这个整数变为0为止</p>
</li>
<li><p>怎么判断一个整数为1？</p>
<blockquote>
<ol>
<li><p>把整数与1做与运算，但当输入是负数时，如果一直右移运算，最终的数字会变成oxFFFFFFFF陷入死循环</p>
</li>
<li><p>为避免死循环，首先把n与1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算，就能判断n的次地位是不是1,反复左移……</p>
</li>
<li><p>把一个整数减去1，再和原整数做与运算，会把整个整数最右边的1变为0</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p>
<p>法1：</p>
<p>一个int为8位，所以负数的情况中需要<strong>判断32个字节中</strong>1的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">                 result++;</span><br><span class="line">             flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)</span><br><span class="line">         &#123;</span><br><span class="line">             result++;<span class="comment">//一个非0数字至少有一个1</span></span><br><span class="line">             n=(n<span class="number">-1</span>)&amp;n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<p>法1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> n &amp; flag:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n &amp;= <span class="number">0xffffffff</span> <span class="comment">#获取负数补码</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>14.剪绳子</title>
    <url>/2019/10/29/14-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul>
<li>$O(n^2)$时间和$O(n)$空间的动态规划</li>
<li>$O(1)$时间和空间的贪婪算法</li>
</ul><a id="more"></a>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>第一步：确定最优策略，使得剪掉绳子的几段乘积最大。最后一步：乘积最大。子问题：假设该绳子剪成两段，剪完的两个部分都必须是最大乘积。</p>
<p>第二步：状态转移方程： dp[i] = max{ dp[i - j]<em>dp[j]} ,这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。更好的办法是按照<em>*从下而上</em></em>的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。</p>
<p>第三步：确定初始值和边界：dp[0] = 0,dp[1] = 1, dp[2] = 1</p>
<p>第四步：计算顺序，从dp[3]开始到dp[n]</p>
</blockquote>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product)</span><br><span class="line">                max = product;</span><br><span class="line"></span><br><span class="line">            products[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[length];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self,length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp=[<span class="number">0</span>]*length</span><br><span class="line">    <span class="comment">#dp = [0 for i in range(number + 1)]</span></span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">    dp[<span class="number">3</span>]=<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,length+<span class="number">1</span>):</span><br><span class="line">        cout=<span class="number">0</span></span><br><span class="line">        j=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;=i//<span class="number">2</span>:</span><br><span class="line">            cout=max(dp[i-j]*dp[j],cout)</span><br><span class="line">            dp[i]=cout</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[lentgh]</span><br></pre></td></tr></table></figure>
<h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>按如下策略来剪绳子</p>
<ul>
<li>当n&gt;=5，尽可能多剪长度为3的绳子</li>
<li>当剩下的绳子长度为4，把绳子剪成两段为2的绳子</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽可能多地减去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。</span></span><br><span class="line">    <span class="comment">// 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。</span></span><br><span class="line">    <span class="keyword">if</span>(length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        timesOf3 -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3)) * (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法——排序</title>
    <url>/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="术语说明："><a href="#术语说明：" class="headerlink" title="术语说明："></a>术语说明：</h1><ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ul><a id="more"></a>
<h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类:"></a>算法分类:</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204533683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204455511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];	<span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></span><br><span class="line">	<span class="keyword">int</span> length;			<span class="comment">/* 用于记录顺序表的长度 */</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> temp=L-&gt;r[i]; </span><br><span class="line">	L-&gt;r[i]=L-&gt;r[j]; </span><br><span class="line">	L-&gt;r[j]=temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>依次比较相邻两元素，若前一元素大于后一元素则交换之，直至最后一个元素即为最大；然后重新从首元素开始重复同样的操作，直至倒数第二个元素即为次大元素；依次类推。如同水中的气泡，依次将最大或最小元素气泡浮出水面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)  <span class="comment">/* 注意j是从后往前循环 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>]) <span class="comment">/* 若前者大于后者（注意这里与上一算法的差异）*/</span></span><br><span class="line">			&#123;</span><br><span class="line">				 swap(L,j,j+<span class="number">1</span>);<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作改进冒泡算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	Status flag=TRUE;			<span class="comment">/* flag用来作为标记 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag;i++) <span class="comment">/* 若flag为true说明有过数据交换，否则停止循环 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag=FALSE;				<span class="comment">/* 初始为False */</span></span><br><span class="line">		<span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				 swap(L,j,j+<span class="number">1</span>);	<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">				 flag=TRUE;		<span class="comment">/* 如果有数据交换，则flag为true */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 O(n)。</p>
<h2 id="2-简单选择排序"><a href="#2-简单选择排序" class="headerlink" title="2.简单选择排序"></a>2.简单选择排序</h2><p>首先初始化最小元素索引值为首元素，依次遍历待排序数列，若遇到小于该最小索引位置处的元素则刷新最小索引为该较小元素的位置，直至遇到尾元素，结束一次遍历，并将最小索引处元素与首元素交换；然后，初始化最小索引值为第二个待排序数列元素位置，同样的操作，可得到数列第二个元素即为次小元素；以此类推。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作简单选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,min;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		min = i;						<span class="comment">/* 将当前下标定义为最小值下标 */</span></span><br><span class="line">		<span class="keyword">for</span> (j = i+<span class="number">1</span>;j&lt;=L-&gt;length;j++)<span class="comment">/* 循环之后的数据 */</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[min]&gt;L-&gt;r[j])	<span class="comment">/* 如果有小于当前最小值的关键字 */</span></span><br><span class="line">                min = j;				<span class="comment">/* 将此关键字的下标赋值给min */</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(i!=min)						<span class="comment">/* 若min不等于i，说明找到最小值，交换 */</span></span><br><span class="line">			swap(L,i,min);				<span class="comment">/* 交换L-&gt;r[i]与L-&gt;r[min]的值 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n)，但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h2><p>数列前面部分看为有序，依次将后面的无序数列元素插入到前面的有序数列中，初始状态有序数列仅有一个元素，即首元素。在将无序数列元素插入有序数列的过程中，采用了逆序遍历有序数列，相较于顺序遍历会稍显繁琐，但当数列本身已近排序状态效率会更高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i<span class="number">-1</span>]) <span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/* 设置哨兵 */</span></span><br><span class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="number">0</span>];j--)</span><br><span class="line">				L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j]; <span class="comment">/* 记录后移 */</span></span><br><span class="line">			L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/* 插入到正确位置 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n)，直接插入排序法比冒炮和简单选择排序的性能要好一些。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> increment=L-&gt;length;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		increment=increment/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">/* 增量序列 */</span></span><br><span class="line">		<span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i-increment])<span class="comment">/*  需将L-&gt;r[i]插入有序增量子表 */</span> </span><br><span class="line">			&#123; </span><br><span class="line">				L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/*  暂存在L-&gt;r[0] */</span></span><br><span class="line">				<span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)</span><br><span class="line">					L-&gt;r[j+increment]=L-&gt;r[j]; <span class="comment">/*  记录后移，查找插入位置 */</span></span><br><span class="line">				L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/*  插入 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"	第%d趟排序结果: "</span>,++k);</span><br><span class="line">		print(*L);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度：通常认为是O($N^{3/2}$) ，未验证　　稳定性：不稳定</p>
<h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h2><blockquote>
<p>堆是具有下列性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值,称为大顶堆 或者每个结点的值都小于或等于其左右孩子结点的值,称为小顶堆。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151257333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151926815.png">堆排序 (Heap 80忱) 就是利用堆(假设利用大顶堆)进行排序的方法。它的基本思想是, 将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根结点。将官移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值) .然后将剩余的 n - 1 个序列重新构造成一个堆,这样就刽寻到 n 个元素中的次小值。如此反复执行 , 便能得到一个有序序列了 。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(i=L-&gt;length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span>   <span class="comment">/*把L中的r构建成一个大顶堆*/</span></span></span><br><span class="line"><span class="function">        <span class="title">HeadAdjust</span><span class="params">(L,i,L-&gt;length)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L,<span class="number">1</span>,i);             <span class="comment">/*将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></span><br><span class="line">        heapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);     <span class="comment">/*将当前的根结点重新调整为大顶堆 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,j;</span><br><span class="line">    temp=L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;m;j*=<span class="number">2</span>)    <span class="comment">/*沿关键字较大的孩子结点向下筛选*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            ++j;           <span class="comment">/*j为关键字中较大的记录的下标*/</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=L-&gt;r[j])   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        L-&gt;r[s]=L-&gt;r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(NlogN) 　　稳定性：不稳定<br>由于初始构建队所需的比较次数较多，并不适合待排序序列个数较少的情况。</p>
<h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h2><ul>
<li>归并排序 ( Merging Sort) 就是利用归并的思想实现的排序方法。色的原理是假设初始序列含有 n 个记录 , 则可 以看成是 n 个有序的子序列,每个子序列的长度为1 ,然后两两归并,得到[[n/2] ( [x]表示不小于 x 的最小整数)个长度为 2或1的有序子序列;再两两归并 ,……,如此重复 , 直至得到 一个长度为 n 的有序序列为止 ,这种排序方法称为2路归并排序 。<h3 id="递归实现归并排序"><a href="#递归实现归并排序" class="headerlink" title="递归实现归并排序"></a>递归实现归并排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span> <span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MSort (L-&gt;r,L-&gt;r,L-&gt;length) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">MSort (<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR1[],<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> TR2[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s==t)</span><br><span class="line">        TR1[s]=SR[s]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=(s+t)/<span class="number">2</span>;         <span class="comment">/*将SR (S..t]平分为 SR [s..m]和SR[m+1..t] */</span></span><br><span class="line">        MSort(SR,TR2,s,m); <span class="comment">/*递归将SR[s..m]归并为有序的 TR2[s..m]*/</span></span><br><span class="line">        MSort(SR,TR2,m+<span class="number">1</span>,t);<span class="comment">/*递归将SR[m+1..t]归并为有序TR2[m+1..t] */</span></span><br><span class="line">        Merge(TR2,TR1,s,m,t);<span class="comment">/*将TR2[s..m]和TR2[m+1..t]归并到TR1【s..t] */</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将有序的 SR[i..m1 和 $R [m+l..0] 归并为有序的T.R[i..n] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k,i;</span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SR[i]&lt;SR[j])</span><br><span class="line">            TR[k]=SR[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TR[k=SR[j++]]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=m-i;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;n-j;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设现在要对数组{50,1 0,90,30, 70.40,80, 60 ,20}进行排序, L.length=9 ,现来看看 MSort 的实现。MSort 被调用时, SR与TR1都是{50, 10,90, 30,70,40,80,60,20} , s=1 , t=9 ,最终我们的目的就是要将TR1中的数组排好顺序。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724171640203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
</blockquote>
</li>
<li><p><strong>时间复杂度</strong>为：O(nlogn) </p>
</li>
<li><p><strong>空间复杂度</strong>：O(n+Iogn) ，由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为 Iog2 n 的横空间。</p>
<p>归并排序是一种<strong>稳定的排序算法</strong>，因为 Merge 函数 中有 if (SR[i]&lt;SR[j])语句,这就说明它需要两两比较,不存在跳跃。</p>
<h3 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h3><p>归并排序大量’引用了递归,尽管在代码上比较清晰,容易理解,但这会造成时间和空间上的性能损耗。排序追求的就是效率,<strong>将递归转化成迭代</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 非递归法 */</span></span><br><span class="line"><span class="comment">/* 对顺序表L作归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	MSort(L-&gt;r,L-&gt;r,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作归并非递归排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* TR=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(L-&gt;length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">/* 申请额外空间 */</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k&lt;L-&gt;length)</span><br><span class="line">	&#123;</span><br><span class="line">		MergePass(L-&gt;r,TR,k,L-&gt;length);</span><br><span class="line">		k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span></span><br><span class="line">		MergePass(TR,L-&gt;r,k,L-&gt;length);</span><br><span class="line">		k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span>       </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</span><br><span class="line">	&#123;<span class="comment">/* 两两归并 */</span></span><br><span class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</span><br><span class="line">		i=i+<span class="number">2</span>*s;        </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>) <span class="comment">/* 归并最后两个序列 */</span></span><br><span class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 若最后只剩下单个子序列 */</span></span><br><span class="line">		<span class="keyword">for</span>(j =i;j &lt;= n;j++)</span><br><span class="line">			TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h2><p>快速排序 ( Quick Sort) 的基本思想是:通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></span><br><span class="line"><span class="comment">/* 此时在它之前(后)的记录均不大(小)于它。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line">	pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">			high--;</span><br><span class="line">		 swap(L,low,high);<span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">			low++;</span><br><span class="line">		 swap(L,low,high);<span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)</span><br><span class="line">	&#123;</span><br><span class="line">			pivot=Partition(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">			QSort(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line">			QSort(L,pivot+<span class="number">1</span>,high);		<span class="comment">/*  对高子表递归排序 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSort(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Partition 函数，其实就是将选取的pivotkey 不断交换，将比它小的换到它的左边，比它大的换到它的右边，包也在交换中不断更改自己的位置，直到完全满足这个要求为止。</p>
<p>时间复杂度：最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)　<br>空间复杂度： O(logn)<br>由于关键字的比较和交换是跳跃进行的，因此，<strong>快速排序是一种不稳定</strong>的排序方法</p>
<p><strong>三数取中法</strong>。即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数， 也可以随机选取。 这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中中间数位于较为中间的值的可能性就大大提高了 。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 改进后快速排序******************************** */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>; <span class="comment">/* 计算数组中间的元素的下标 */</span>  </span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])			</span><br><span class="line">		swap(L,low,high);	<span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[high])</span><br><span class="line">		swap(L,high,m);		<span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[low])</span><br><span class="line">		swap(L,m,low);		<span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></span><br><span class="line">	</span><br><span class="line">	pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">	L-&gt;r[<span class="number">0</span>]=pivotkey;  <span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">			high--;</span><br><span class="line">		 L-&gt;r[low]=L-&gt;r[high];</span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">			low++;</span><br><span class="line">		 L-&gt;r[high]=L-&gt;r[low];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high)</span><br><span class="line">		&#123;</span><br><span class="line">			pivot=Partition1(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">			QSort1(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line">			<span class="comment">/* QSort(L,pivot+1,high);		/*  对高子表递归排序 */</span></span><br><span class="line">			low=pivot+<span class="number">1</span>;	<span class="comment">/* 尾递归 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort1</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSort1(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法——查找</title>
    <url>/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查找定义：查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><blockquote>
<p>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。</p>
</blockquote><p>查找又根据操作方式不同分为静态查找和动态查找两种，前者是仅获取数据不进行其他操作，后者则需要动态改变数据，比如在查找过程中插入新数据，或者删除某个已存在的数据。</p><a id="more"></a>


<h1 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h1><ul>
<li>定义：<br>从线性表的一段开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</li>
<li>时间复杂度：O(N）</li>
<li><p>优缺点：</p>
<blockquote>
<p>优点：对数据元素的存储没有需求，顺序存储或链式存储皆可；对表中记录的有序性也没有要求，无论记录是否按关键码有序，均可应用<br>缺点：当n较大时，平均查找长度较大，效率低</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]==key)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入哨兵的目的是使得函数内的循环不用每次都判断数组是否会越界，即不需要每次让 i与 n 作比较<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	a[<span class="number">0</span>]=key;</span><br><span class="line">	i=n;</span><br><span class="line">	<span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">	&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;<span class="comment">/*返回 0 则说明查找失败*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h1><h2 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>在有序的顺序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域元记录，查找失败为止。</p>
</blockquote>
</li>
<li>时间复杂度：O(logN）</li>
<li><p>优缺点：</p>
<blockquote>
<p>优点：折半查找的时间复杂度为O(logn)，远远优于顺序查找的O(n)，<br>缺点：二分查找的效率高，但是要求表关键字有序</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;	<span class="comment">/* 折半 */</span></span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])		<span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line">			high=mid<span class="number">-1</span>;		<span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line">			low=mid+<span class="number">1</span>;		<span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>基于二分查找算法，将查找点的选择改进为自适应选择，mid=low+(key-a[low])/(a[high]-a[low])*(high-low)<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014201459952.png#pic_center"></p>
</blockquote>
</li>
<li>时间复杂度：O(logN）</li>
<li>优缺点：<blockquote>
<p>优点：对于表长较大 且关键字分布又比较均匀的查找表，插值查找算法的平均性能比折半查找要好得多<br>缺点：极端不均匀的数据，用插值查找未必是很合适的选择</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插值查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Interpolation_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])		<span class="comment">/* 若查找值比插值小 */</span></span><br><span class="line">			high=mid<span class="number">-1</span>;		<span class="comment">/* 最高下标调整到插值下标小一位 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比插值大 */</span></span><br><span class="line">			low=mid+<span class="number">1</span>;		<span class="comment">/* 最低下标调整到插值下标大一位 */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>1.斐波那契实在二分查找基础上，用斐波那契数列来进行分割<br>2.在斐波那契数列上找一个略大于查找元素表个数的值f(n)<br>3.将查找元素表个数扩充到f(n) 如果要补充元素用最后一个元素补充<br>4.完成后对f(n)个元素进行斐波那契分割,即分割成 前面f(n-1)个元素,后面f(n-2)个元素<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014205901920.png#pic_center"><br>5.对要查找元素的那个部分进行递归 </p>
</blockquote>
</li>
<li><p>时间复杂度：O(logN）</p>
</li>
<li><p>优缺点：</p>
<blockquote>
<p> 就平均性能而言 优于折半查找 但是若一直在左边长半区查找则低于折半查找                      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid,i,k=<span class="number">0</span>;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)</span><br><span class="line">		k++;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">		a[i]=a[n];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			high=mid<span class="number">-1</span>;		</span><br><span class="line">			k=k<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			low=mid+<span class="number">1</span>;		</span><br><span class="line">			k=k<span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line">				<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1></blockquote>
</li>
<li>索引:就是把一个关键字与它对应的记录相关联的过程。一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</li>
<li>索引按照结构可以分为线性索引，树形索引和多级索引。</li>
<li>线性索引是将索引项集合组织为线性结构，也称为索引表。包括稠密索引、分块索引、倒排索引。<h2 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h2><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211157380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
<li>稠密索引是指在线性表中，将数据集中的每个记录对应一个索引项。对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</li>
<li>优缺点：<blockquote>
<p>优点：索引项有序也就意味着，我们要查找关键字时，可以用折半，插值及斐波那契等有序查找算法。<br>缺点：如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模。对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能大大下降。</p>
</blockquote>
</li>
</ul>
<h2 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h2><ul>
<li><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p>
<blockquote>
<ul>
<li>块内无序，即每一块内的记录宋不要求有序，有序更好，代价比较大</li>
<li>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记景的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字</li>
</ul>
</blockquote>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。</p>
</li>
<li><p>定义的分块索引的索引项结构分三个数据项 :</p>
<blockquote>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>
<li>存储了块中的记录个数，以便于循环时使用</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记景进行遍历。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211843755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
</ul>
</blockquote>
</li>
<li>分块索引表中查找，就是分两步进行:<blockquote>
<ul>
<li>在分块索引表中查找要查的关键字所在块。由于分块索引表是块间有序的，很容易利用折半插值等算法得到结果。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，只能顺序查找。</li>
</ul>
</blockquote>
</li>
<li>分块索引的平均查找长度：<blockquote>
<p>n 个记录的数据集被平均分成 m块，每个块中有 t 条记录，显然 n=m x t<br>Lb 为查找索引表的平均查找长，Lw为块中查找记录的平均查找长度<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213115831.png#pic_center"></p>
</blockquote>
</li>
</ul>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><ul>
<li>最基础的搜索技术<blockquote>
<p>样例:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101421402779.png#pic_center"><br>忽略大小写和复数，得出单词表，找到他们分别出现在哪篇文章中<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213725806.png#pic_center"><br>这张单词表就是索引衰， 索引项的通用结构是:</p>
<ul>
<li>次关键码.例如上面的”英文单词” </li>
<li>记录号表，例如上面的”文章编号”</li>
</ul>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字) 。 这样的索引方法就是倒排索引 (invered index)</p>
</blockquote>
</li>
<li>优缺点：<blockquote>
<ul>
<li>优点：显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果<br>缺点：是这个记录号不定长</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><ul>
<li>定义：二叉排序树 ( Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。.</li>
</ul>
<blockquote>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值 </li>
<li>若它的右子树不空 ，则右子树上所有结点的值均大于宫的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
</blockquote>
<p>   通过<strong>中序遍历</strong>即可得出<strong>有序的序列</strong>， 构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。</p>
<ul>
<li>二叉排序树的查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>	/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;<span class="comment">//BiTNode是该结构体的变量名,*BiTree是该结构体的类型的地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归查找二叉排序树T中是否存在key, */</span></span><br><span class="line"><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span></span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line"><span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span> (!T)	<span class="comment">/*  查找不成功 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		*p = f;  </span><br><span class="line">		<span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key==T-&gt;data) <span class="comment">/*  查找成功 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		*p = T;  </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data) </span><br><span class="line">		<span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);  <span class="comment">/*  在左子树中继续查找 */</span></span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">		<span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);  <span class="comment">/*  在右子树中继续查找 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */</span></span><br><span class="line"><span class="comment">/*  插入key并返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	BiTree p,s;</span><br><span class="line">	<span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line">    <span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line">	<span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		s-&gt;data = key;  </span><br><span class="line">		s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;  </span><br><span class="line">		<span class="keyword">if</span> (!p) </span><br><span class="line">			*T = s;			<span class="comment">/*  插入s为新的根结点 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;p-&gt;data) </span><br><span class="line">			p-&gt;lchild = s;	<span class="comment">/*  插入s为左孩子 */</span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			p-&gt;rchild = s;  <span class="comment">/*  插入s为右孩子 */</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> FALSE;  <span class="comment">/*  树中已有关键字相同的结点，不再插入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除<blockquote>
<p>对删除结点三种情况的分析:</p>
<ul>
<li>叶子结点</li>
<li>仅有左或右子树的结点 </li>
<li>左右子树都有的结点</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree q,s;</span><br><span class="line">	<span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; *p=(*p)-&gt;lchild; <span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">/* 只需重接它的右子树 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; *p=(*p)-&gt;rchild; <span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; s=(*p)-&gt;lchild;</span><br><span class="line">		<span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span></span><br><span class="line">		&#123;</span><br><span class="line">			q=s;</span><br><span class="line">			s=s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		(*p)-&gt;data=s-&gt;data; <span class="comment">/*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span></span><br><span class="line">		<span class="keyword">if</span>(q!=*p)</span><br><span class="line">			q-&gt;rchild=s-&gt;lchild; <span class="comment">/*  重接q的右子树 */</span> </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q-&gt;lchild=s-&gt;lchild; <span class="comment">/*  重接q的左子树 */</span></span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span></span><br><span class="line"><span class="comment">/* 并返回TRUE；否则返回FALSE。 */</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span> </span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (key==(*T)-&gt;data) <span class="comment">/* 找到关键字等于key的数据元素 */</span> </span><br><span class="line">			<span class="keyword">return</span> Delete(T);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;(*T)-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h1><ul>
<li>平衡二叉树(Balanced Binary Tree)(简称平衡树，AVL)也是二叉排序树的一种，其特点在于，左右子树的高度之差的绝对值不超过1，左右子树高度之差被称为平衡因子，每次插入一个新的值的时候，都要检查二叉树的平衡，也就是平衡调整</li>
<li>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balanoe Factor)，平衡因乎只可能是-1、0和 1</li>
</ul>
<ul>
<li>基本思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。 在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>	/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="keyword">int</span> bf; <span class="comment">/*  结点的平衡因子 */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以p为根的二叉排序树作右旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree L;</span><br><span class="line">	L=(*P)-&gt;lchild; <span class="comment">/*  L指向P的左子树根结点 */</span> </span><br><span class="line">	(*P)-&gt;lchild=L-&gt;rchild; <span class="comment">/*  L的右子树挂接为P的左子树 */</span> </span><br><span class="line">	L-&gt;rchild=(*P);</span><br><span class="line">	*P=L; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以P为根的二叉排序树作左旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree R;</span><br><span class="line">	R=(*P)-&gt;rchild; <span class="comment">/*  R指向P的右子树根结点 */</span> </span><br><span class="line">	(*P)-&gt;rchild=R-&gt;lchild; <span class="comment">/* R的左子树挂接为P的右子树 */</span> </span><br><span class="line">	R-&gt;lchild=(*P);</span><br><span class="line">	*P=R; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">/*  左高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0  <span class="comment">/*  等高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">/*  右高 */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</span></span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree L,Lr;</span><br><span class="line">	L=(*T)-&gt;lchild; <span class="comment">/*  L指向T的左子树根结点 */</span> </span><br><span class="line">	<span class="keyword">switch</span>(L-&gt;bf)</span><br><span class="line">	&#123; <span class="comment">/*  检查T的左子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line">		 <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */</span> </span><br><span class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">			R_Rotate(T);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		 <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的左孩子的右子树上，要作双旋处理 */</span> </span><br><span class="line">			Lr=L-&gt;rchild; <span class="comment">/*  Lr指向T的左孩子的右子树根 */</span> </span><br><span class="line">			<span class="keyword">switch</span>(Lr-&gt;bf)</span><br><span class="line">			&#123; <span class="comment">/*  修改T及其左孩子的平衡因子 */</span> </span><br><span class="line">				<span class="keyword">case</span> LH: (*T)-&gt;bf=RH;</span><br><span class="line">						 L-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EH: (*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> RH: (*T)-&gt;bf=EH;</span><br><span class="line">						 L-&gt;bf=LH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Lr-&gt;bf=EH;</span><br><span class="line">			L_Rotate(&amp;(*T)-&gt;lchild); <span class="comment">/*  对T的左子树作左旋平衡处理 */</span> </span><br><span class="line">			R_Rotate(T); <span class="comment">/*  对T作右旋平衡处理 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */</span> </span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree R,Rl;</span><br><span class="line">	R=(*T)-&gt;rchild; <span class="comment">/*  R指向T的右子树根结点 */</span> </span><br><span class="line">	<span class="keyword">switch</span>(R-&gt;bf)</span><br><span class="line">	&#123; <span class="comment">/*  检查T的右子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line">	 <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */</span> </span><br><span class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">			  L_Rotate(T);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的右孩子的左子树上，要作双旋处理 */</span> </span><br><span class="line">			  Rl=R-&gt;lchild; <span class="comment">/*  Rl指向T的右孩子的左子树根 */</span> </span><br><span class="line">			  <span class="keyword">switch</span>(Rl-&gt;bf)</span><br><span class="line">			  &#123; <span class="comment">/*  修改T及其右孩子的平衡因子 */</span> </span><br><span class="line">				<span class="keyword">case</span> RH: (*T)-&gt;bf=LH;</span><br><span class="line">						 R-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EH: (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> LH: (*T)-&gt;bf=EH;</span><br><span class="line">						 R-&gt;bf=RH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			  Rl-&gt;bf=EH;</span><br><span class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); <span class="comment">/*  对T的右子树作右旋平衡处理 */</span> </span><br><span class="line">			  L_Rotate(T); <span class="comment">/*  对T作左旋平衡处理 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */</span> </span><br><span class="line"><span class="comment">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */</span> </span><br><span class="line"><span class="comment">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BiTree *T,<span class="keyword">int</span> e,Status *taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span>(!*T)</span><br><span class="line">	&#123; <span class="comment">/*  插入新结点，树“长高”，置taller为TRUE */</span> </span><br><span class="line">		 *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="literal">NULL</span>; (*T)-&gt;bf=EH;</span><br><span class="line">		 *taller=TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e==(*T)-&gt;data)</span><br><span class="line">		&#123; <span class="comment">/*  树中已存在和e有相同关键字的结点则不再插入 */</span> </span><br><span class="line">			*taller=FALSE; <span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (e&lt;(*T)-&gt;data)</span><br><span class="line">		&#123; <span class="comment">/*  应继续在T的左子树中进行搜索 */</span> </span><br><span class="line">			<span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			<span class="keyword">if</span>(*taller) <span class="comment">/*   已插入到T的左子树中且左子树“长高” */</span> </span><br><span class="line">				<span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，需要作左平衡处理 */</span> </span><br><span class="line">							LeftBalance(T);	*taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因左子树增高而使树增高 */</span> </span><br><span class="line">							(*T)-&gt;bf=LH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，现左、右子树等高 */</span>  </span><br><span class="line">							(*T)-&gt;bf=EH; *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; <span class="comment">/*  应继续在T的右子树中进行搜索 */</span> </span><br><span class="line">			<span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			<span class="keyword">if</span>(*taller) <span class="comment">/*  已插入到T的右子树且右子树“长高” */</span> </span><br><span class="line">				<span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，现左、右子树等高 */</span> </span><br><span class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因右子树增高而使树增高  */</span></span><br><span class="line">							(*T)-&gt;bf=RH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，需要作右平衡处理 */</span> </span><br><span class="line">							RightBalance(T); *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	BiTree T=<span class="literal">NULL</span>;</span><br><span class="line">	Status taller;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"本样例建议断点跟踪查看平衡二叉树结构"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="散列表查找-哈希表"><a href="#散列表查找-哈希表" class="headerlink" title="散列表查找(哈希表)"></a>散列表查找(哈希表)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>定义：散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。这种对应关系f称为散列函数， 又称为哈希( Hash) 函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。</p>
</li>
<li><p>散列技术既是一种存储方法，也是一种查找方法。两个关键字key1≠key2，但是却有f(key1)=f(key2) ，这种现象我们称为冲突(collision) ，并把key1 和key2 称为这个散列函数的同义词(synonym) 。</p>
</li>
</ul>
<h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>取关键字的某个线性函数值为散列地址：</p>
<script type="math/tex; mode=display">f(key)=key×a+b(a、b为常数)</script><p>适合查找表较小且连续的情况。</p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>对关键字的平方后取中间部分的值。比较适合子不知道关键字的分布，而位数又不是很大的情况。</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为:</p>
<script type="math/tex; mode=display">f(key)=key \ mod\ p(p⩽m)</script><p>mod 是取模(求余数)的意思 ，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。<br>若散列表表长为m， 通常p为小于或等于表长(最好接近m ) 的最小质数或不包含小子20质因子的合数。</p>
<h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一个随机数，取关键字的随机函数值为它的散列地址:</p>
<script type="math/tex; mode=display">f(key)=random(key)</script><h2 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>一旦发生了冲突， 就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<script type="math/tex; mode=display">fi(key)=(f(key)+di)\ MOD\ m(di=1,2,3,..,m−1)</script><p>为了不让关键字都聚集在某一块区域,一般增加平方运算：</p>
<script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)\ MOD\ m(di=12,−12,22,−22,..,q2,−q2,q⩽m/2)</script><p>在冲突时，对于位移量$d_i$，采用随机函数计算得到，我们称之为随机探测法:</p>
<script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)MODm(di是一个随机数列)</script><h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>我们事先准备多个散列函数。</p>
<script type="math/tex; mode=display">fi(key)=RHi(key)(i=1,2,3,..,k)</script><p>这里RHi就是不同的散列函数。这种方法能够使得关键字不产生聚集，但也增加了计算的时间。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>
<p>它提供了绝不会出现找不到地址的保障，但也带来了查找时需要遍历单链装的性能损耗。</p>
<h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p>为所有冲突的关键字建立了一个公共的溢出区来存放。在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功； 如果不相等，则到溢出表去进行顺序查找。</p>
<h2 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12 <span class="comment">/* 定义散列表长为数组的长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY -32768</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem; <span class="comment">/* 数据元素存储基址，动态分配数组 */</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">/*  当前数据元素个数 */</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>; <span class="comment">/* 散列表表长，全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m=HASHSIZE;</span><br><span class="line">    H-&gt;count=m;</span><br><span class="line">    H-&gt;elem=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        H-&gt;elem[i]=NULLKEY;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m; <span class="comment">/* 除留余数法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入关键字进散列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key); <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = (addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;elem[addr] = key; <span class="comment">/* 直到有空位后插入关键字 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);  <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span>(H.elem[*addr] != key) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) <span class="comment">/* 如果循环回到原点 */</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;	<span class="comment">/* 则说明关键字不存在 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[HASHSIZE]=&#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,p,key,result;</span><br><span class="line">    HashTable H;</span><br><span class="line"></span><br><span class="line">    key=<span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">    InitHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(&amp;H,arr[i]);</span><br><span class="line"></span><br><span class="line">    result=SearchHash(H,key,&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 失败。\n"</span>,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        key=arr[i];</span><br><span class="line">        SearchHash(H,key,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027131236947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>VINS-Mono——预积分</title>
    <url>/2019/10/25/VINS-Mono%E2%80%94%E2%80%94%E9%A2%84%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了加深理解，参考崔华坤的《VINS论文推导及代码解析》，把相关公式推到一遍。</p><p>intergration_base.h：IMU预积分<br>imu_factor.h：IMU残差、雅可比</p><h1 id="IMU-测量方程"><a href="#IMU-测量方程" class="headerlink" title="IMU 测量方程."></a>IMU 测量方程.</h1><p>忽略地球旋转， IMU 测量方程为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214341590.png#pic_center"></p><h1 id="预积分方程"><a href="#预积分方程" class="headerlink" title="预积分方程"></a>预积分方程</h1><h2 id="IMU-integration-in-world-frame"><a href="#IMU-integration-in-world-frame" class="headerlink" title="IMU integration in world frame"></a>IMU integration in world frame</h2><p>将第 k 帧和第 k+1 帧之间的所有 IMU 进行积分，可得第 k+1 帧的位置、速度和旋转<br>（PVQ），作为视觉估计的初始值，这里的旋转采用的四元数。</p><a id="more"></a>




<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214621188.png#pic_center"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214759817.png#pic_center"></p>
<h1 id="IMU-integration-in-the-body-frame-of-first-pose-of-interests"><a href="#IMU-integration-in-the-body-frame-of-first-pose-of-interests" class="headerlink" title="IMU integration in the body frame of first pose of interests"></a>IMU integration in the body frame of first pose of interests</h1><p>为避免重新传播 IMU 观测值，选用 IMU 预积分模型，从世界坐标系转为本体坐标</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215210690.png#pic_center"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215228467.png#pic_center"></p>
<p>则 IMU 预积分模型（预积分估计值）为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152209217.png#pic_center"></p>
<p>离散状态下采用 中值积分 (mid-point) 的预积分方程（预积分测量值）为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102815225757.png#pic_center"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152316969.png#pic_center"></p>
<p>midPointIntegration中的相关代码（没有考虑噪声）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector3d un_gyr = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">result_delta_q  = delta_q * Quaterniond(<span class="number">1</span>, un_gyr(<span class="number">0</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">1</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">2</span>) * _dt / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Vector3d un_acc_0 =        delta_q * (_acc_0 - linearized_ba);</span><br><span class="line">Vector3d un_acc_1 = result_delta_q * (_acc_1 - linearized_ba);</span><br><span class="line">Vector3d un_acc   = <span class="number">0.5</span> * (un_acc_0 + un_acc_1);</span><br><span class="line"></span><br><span class="line">result_delta_p = delta_p + delta_v * _dt + <span class="number">0.5</span> * un_acc * _dt * _dt;</span><br><span class="line">result_delta_v = delta_v + un_acc * _dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预积分的过程中Bias没有发生改变</span></span><br><span class="line">result_linearized_ba = linearized_ba;</span><br><span class="line">result_linearized_bg = linearized_bg;</span><br></pre></td></tr></table></figure>
<p>当 bias 估计轻微改变时，我们可以使用如下的一阶近似 对中值积分得到的预积分测量值进矫正，而不重传播，从而得到 更加精确的预积分测量值（bias 修正的线性模型）</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028145945699.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150116815.png#pic_center"></p>
<p>上式可由误差项雅克比矩阵的迭代公式$J_{b_{k+1}}$得出：<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O_P = 0 , O_R = 3 , O_V = 6 , O_BA = 9 , O_BG = 12</span></span><br><span class="line">           Eigen::Matrix3d dp_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BA);</span><br><span class="line">            Eigen::Matrix3d dp_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BG);</span><br><span class="line">            Eigen::Matrix3d dq_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_R, O_BG);</span><br><span class="line">            Eigen::Matrix3d dv_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BA);</span><br><span class="line">            Eigen::Matrix3d dv_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BG);</span><br></pre></td></tr></table></figure>
<h1 id="误差状态方程"><a href="#误差状态方程" class="headerlink" title="误差状态方程"></a>误差状态方程</h1><p>状态误差传递的线性递推关系可以通过两种方式实现</p>
<ul>
<li>基于误差随时间变化的递推方程</li>
<li>基于一阶泰勒展开的误差递推方程<br>本文用的第一种方法；我们还可以通过第二种方法：已知 IMU 预积分（中值积分）测量方程，通过求导计算出 F ′ 和 G′。</li>
</ul>
<h2 id="连续形式下-PVQ-增量误差的协方差及-Jacobian"><a href="#连续形式下-PVQ-增量误差的协方差及-Jacobian" class="headerlink" title="连续形式下 PVQ 增量误差的协方差及 Jacobian"></a>连续形式下 PVQ 增量误差的协方差及 Jacobian</h2><p>IMU 在每一个时刻积分出来的值是有误差的，下面我们对误差进行分析。首先我们直接给出在 t 时刻误差项的导数为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150603823.png#pic_center"><br>那么根据导数的定义有上一时刻推导下一时刻的误差如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150704700.png#pic_center"><br>上式恰好给出了如 EKF 一般对非线性系统线性化的过程，这里的意义是表示下一个时刻的 IMU 测量误差与上一个时刻的成线性关系，这样我们根据当前时刻的值，可以预测出下一个时刻的均值和协方差，而公式给出的是均值预测，协方差预测公式如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150752961.png#pic_center"><br>上式给出了协方差的迭代公式，初始值$P^{b_k}_{b_k}$ = 0。其中， Q 为表示噪声项的对角协方差<br>矩阵：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150935869.png#pic_center#pic_center"><br>由上式可获得误差项的 Jacobian 的迭代公式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151013604.png#pic_center"><br>其中 Jacobian 的初始值为$J_{b_k}=I$。</p>
<h2 id="离散形式的-PVQ-增量误差的-Jacobian-和协方差"><a href="#离散形式的-PVQ-增量误差的-Jacobian-和协方差" class="headerlink" title="离散形式的 PVQ 增量误差的 Jacobian 和协方差"></a>离散形式的 PVQ 增量误差的 Jacobian 和协方差</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151537536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>其中:</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151600894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>可以简写为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151718610.png#pic_center"></p>
<p>则 Jacobian 的迭代公式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151808834.png#pic_center"></p>
<p>其中， Jacobian 的初始值为𝐽𝑘 = 𝐼。 这里计算出来的𝐽𝑘+1只是为了给后面提供对 bias 的Jacobian。<br>协方差的迭代公式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151831375.png#pic_center"></p>
<p>其中， 初始值𝑃𝑘 = 0。 Q 为表示噪声项的对角协方差矩阵：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151847412.png#pic_center"></p>
<p>相关代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(update_jacobian)<span class="comment">//否更新雅克比矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3d w_x   = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">        Vector3d a_0_x = _acc_0 - linearized_ba;</span><br><span class="line">        Vector3d a_1_x = _acc_1 - linearized_ba;</span><br><span class="line"></span><br><span class="line">        Matrix3d R_w_x, R_a_0_x, R_a_1_x;</span><br><span class="line"></span><br><span class="line">        R_w_x&lt;&lt;     <span class="number">0</span>, -w_x(<span class="number">2</span>),  w_x(<span class="number">1</span>),</span><br><span class="line">                w_x(<span class="number">2</span>),      <span class="number">0</span>, -w_x(<span class="number">0</span>),</span><br><span class="line">               -w_x(<span class="number">1</span>), w_x(<span class="number">0</span>),       <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_0_x&lt;&lt;        <span class="number">0</span>, -a_0_x(<span class="number">2</span>),  a_0_x(<span class="number">1</span>),</span><br><span class="line">                  a_0_x(<span class="number">2</span>),         <span class="number">0</span>, -a_0_x(<span class="number">0</span>),</span><br><span class="line">                 -a_0_x(<span class="number">1</span>),  a_0_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_1_x&lt;&lt;        <span class="number">0</span>, -a_1_x(<span class="number">2</span>),  a_1_x(<span class="number">1</span>),</span><br><span class="line">                  a_1_x(<span class="number">2</span>),         <span class="number">0</span>, -a_1_x(<span class="number">0</span>),</span><br><span class="line">                 -a_1_x(<span class="number">1</span>),  a_1_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        MatrixXd F = MatrixXd::Zero(<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>)   = <span class="number">-0.25</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt * _dt +</span><br><span class="line">                                <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>)   = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>)   = <span class="number">-0.25</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">12</span>)  = <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>)   = Matrix3d::Identity() - R_w_x * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">12</span>)  = <span class="number">-1.0</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>)   = <span class="number">-0.5</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt +</span><br><span class="line">                                <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>)   = <span class="number">-0.5</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">12</span>)  = <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">9</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">12</span>) = Matrix3d::Identity();</span><br><span class="line"></span><br><span class="line">        MatrixXd V = MatrixXd::Zero(<span class="number">15</span>,<span class="number">18</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) =  <span class="number">0.25</span> * delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) =  <span class="number">0.25</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>) =  <span class="number">0.25</span> *  result_delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">9</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) =  <span class="number">0.5</span> * delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>) =  <span class="number">0.5</span> *  result_delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">12</span>)  = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">15</span>) = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step_jacobian = F;</span></span><br><span class="line">        <span class="comment">//step_V = V;</span></span><br><span class="line">        jacobian   = F * jacobian;</span><br><span class="line">        covariance = F * covariance * F.transpose() + V * noise * V.transpose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过预积分误差的递推公式确实可以求出来从$b_k$帧到$b_{k+1}$帧的累积出来的误差大小，但是这个值并没有用，我们在后端需要的是误差对$b_k$ 帧和$b_{k+1}$帧的导数，而误差对$b_k$帧的导数却可以通过上式的雅克比矩阵直接计算出来，至于协方差矩阵是我们进行后端优化计算残差时用马氏距离需要用到。</p>
<p>公式推导：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181407525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181458844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521325497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521324273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213150727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213209259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/86290941" target="_blank" rel="noopener">VINS-Mono理论学习——IMU预积分 Pre-integration （Jacobian 协方差）</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16下Github+Hexo搭建博客教程</title>
    <url>/2019/10/23/Ubuntu16%E4%B8%8BGithub+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿博客网址</p><p>==<a href="https://xiao-hu.com.cn/">https://xiao-hu.com.cn/</a>==</p><h1 id="安装git、nodejs"><a href="#安装git、nodejs" class="headerlink" title="安装git、nodejs"></a>安装git、nodejs</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>升级nodejs版本，目前的最新版本v10.6.0<br>参考：<a href="https://blog.csdn.net/u010277553/article/details/80938829" target="_blank" rel="noopener">Ubuntu16 升级nodejs版本</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line"></span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><br>加速下载：<a href="https://blog.csdn.net/ibmall/article/details/81390639" target="_blank" rel="noopener">npm 安装 hexo 卡住问题解决</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hexo init xiaohu</span><br><span class="line"><span class="built_in">cd</span> xiaohu </span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹目录下有：</p>
<blockquote>
<p>   node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p>
</blockquote>
<p>再次输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hexo g <span class="comment">#生成静态页面</span></span><br><span class="line">sudo hexo server <span class="comment">#启动服务器</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这时候就可以用浏览器打开网址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 来进行预览了。</p>
<h1 id="github创建"><a href="#github创建" class="headerlink" title="github创建"></a>github创建</h1><p>以前创好了：<a href="https://mp.csdn.net/mdeditor/94998475#" target="_blank" rel="noopener">Ubuntu16.04 git安装与配置</a></p>
<h1 id="创建repo"><a href="#创建repo" class="headerlink" title="创建repo"></a>创建repo</h1><p>在github上面创建一个项目，名为Xiao-Hu-Z+github.io </p>
<h1 id="将hexo部署到github"><a href="#将hexo部署到github" class="headerlink" title="将hexo部署到github"></a>将hexo部署到github</h1><p>打开站点配置文件_config.yml，翻到最后，进行修改。其中YourgithubName就是你的GitHub账户。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br>deploy时要你输入username和password。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在站点目录下输入下面的插件安装</span></span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo generate</span><br><span class="line">sudo hexo deploy</span><br></pre></td></tr></table></figure>
<p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p>
<p>输入：<a href="https://Xiao-Hu-Z.github.io/看到自己的博客" target="_blank" rel="noopener">https://Xiao-Hu-Z.github.io/看到自己的博客</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://Xiao-Hu-Z.github.io/</span><br></pre></td></tr></table></figure>
<h1 id="绑定域名："><a href="#绑定域名：" class="headerlink" title="绑定域名："></a>绑定域名：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping Xiao-Hu-Z.github.io</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/e3169b681038" target="_blank" rel="noopener">[Hexo个人博客]域名绑定 简明教程（小白篇）</a></p>
</blockquote>
<p>参考：<a href="https://blog.csdn.net/zxwsbg/article/details/97487666" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://blog.csdn.net/wang_da_bing/article/details/82818445" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://www.cnblogs.com/yangzhaonan/p/9351838.html" target="_blank" rel="noopener">使用GitHub+Hexo建立个人网站，并绑定自己的域名（Ubuntu环境下）</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——视觉前段处理</title>
    <url>/2019/10/23/VINS-Mono%E2%80%94%E2%80%94%E8%A7%86%E8%A7%89%E5%89%8D%E6%AE%B5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h1><p>每当进入新的图像，都会使用KLT稀疏光流法进行跟踪，同时提取100-300个角点信息，我的理解是角点是用来建立图像，光流跟踪是用来快速定位。同时在这里还进行了关键帧的选取（注意这一过程在代码中是由vins_estimate文件中实现的），主要是两个剔除关键帧的策略，分别是平均视差法和跟踪质量法。平均视差法：如果当前帧的和上一个关键帧跟踪点的平均视差超出了一个设定的阈值，就将当前帧设为关键帧。这里有一个问题，就是旋转和平移都会产生视差（不只是平移哦），当出现纯旋转的时候特征点无法被三角化，无法计算出旋转值，也就无法计算跟踪点间的平均视差，为了解决这一问题，采用短时的陀螺仪观测值来补偿旋转，从而计算出视差，这一过程只应用到平均视差的计算，不会影响真实的旋转结果。</p><a id="more"></a>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023190400778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="节点概览"><a href="#节点概览" class="headerlink" title="节点概览"></a>节点概览</h1><p>该节点的功能是：接收图像数据，进行角点提取和光流跟踪，输出跟踪的特征点（角点）。feature_tracker_node的消息订阅发布如下表：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023221410832.png"></p>
<h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>主要负责图像角点提取和光流跟踪，主要是三个源程序，分别是feature_tracker、feature_tracker_node以及parameters。feature_tracker_node是特征跟踪线程的系统入口，feature_tracker是特征跟踪算法的具体实现，parameters是设备等参数的读取和存放。</p>
<h2 id="程序入口main-函数"><a href="#程序入口main-函数" class="headerlink" title="程序入口main()函数"></a>程序入口main()函数</h2><ul>
<li>1、ros初始化和设置句柄，设置logger级别</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"feature_tracker"</span>);</span><br><span class="line">ros::<span class="function">NodeHandle <span class="title">n</span><span class="params">(<span class="string">"~"</span>)</span></span>;</span><br><span class="line">ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info);</span><br></pre></td></tr></table></figure>
<ul>
<li>2、readParameters(n);读取参数，如config-&gt;euroc-&gt;euroc_config.yaml中的一些配置参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">readParameters(n);</span><br></pre></td></tr></table></figure>
<ul>
<li>3、读取每个相机实例读取对应的相机内参，NUM_OF_CAM=1为单目</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++) </span><br><span class="line">       trackerData[i].readIntrinsicParameter(CAM_NAMES[i]);</span><br></pre></td></tr></table></figure>
<p>节点在启动时会先读取相机内参，根据config_file文件中model_type的值决定采用何种相机模型，并创建相应模型的对象指针，读取在该模型下需要的参数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readIntrinsicParameter(<span class="keyword">const</span> <span class="built_in">string</span> &amp;calib_file)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"reading paramerter of camera %s"</span>, calib_file.c_str());</span><br><span class="line">    m_camera = CameraFactory::instance()-&gt;generateCameraFromYamlFile(calib_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CameraPtr</span><br><span class="line">CameraFactory::generateCameraFromYamlFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span><br><span class="line">&#123;</span><br><span class="line">    cv::<span class="function">FileStorage <span class="title">fs</span><span class="params">(filename, cv::FileStorage::READ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fs.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> CameraPtr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Camera::ModelType modelType = Camera::MEI;</span><br><span class="line">    <span class="keyword">if</span> (!fs[<span class="string">"model_type"</span>].isNone())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sModelType;</span><br><span class="line">        fs[<span class="string">"model_type"</span>] &gt;&gt; sModelType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//卡特鱼眼相机</span></span><br><span class="line">        <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"kannala_brandt"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::KANNALA_BRANDT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"mei"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::MEI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"scaramuzza"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::SCARAMUZZA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"pinhole"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::PINHOLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"# ERROR: Unknown camera model: "</span> &lt;&lt; sModelType &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> CameraPtr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (modelType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> Camera::KANNALA_BRANDT:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">EquidistantCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> EquidistantCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        EquidistantCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::PINHOLE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">PinholeCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> PinholeCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        PinholeCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::SCARAMUZZA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">OCAMCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> OCAMCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        OCAMCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::MEI:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">CataCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> CataCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        CataCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CameraPtr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、判断是否加入鱼眼mask来去除边缘噪声</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(FISHEYE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//FISHEYE_MASK  fisheye_mask.jpg 路径</span></span><br><span class="line">        trackerData[i].fisheye_mask = cv::imread(FISHEYE_MASK, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!trackerData[i].fisheye_mask.data)</span><br><span class="line">        &#123;</span><br><span class="line">            ROS_INFO(<span class="string">"load mask fail"</span>);</span><br><span class="line">            ROS_BREAK();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ROS_INFO(<span class="string">"load mask success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、订阅话题IMAGE_TOPIC(如/cam0/image_raw)，执行回调函数img_callback，对新来的图像进行特征点追踪、处理和发布<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros::Subscriber sub_img = n.subscribe(IMAGE_TOPIC, <span class="number">100</span>, img_callback);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>单目时：FeatureTracker::readImage() 函数读取图像数据进行处理<br>单目i=0<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readImage(<span class="keyword">const</span> cv::Mat &amp;_img, <span class="keyword">double</span> _cur_time)</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat img;</span><br><span class="line">    TicToc t_r;</span><br><span class="line">    cur_time = _cur_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (EQUALIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">        cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">        TicToc t_c;</span><br><span class="line">        clahe-&gt;apply(_img, img);</span><br><span class="line">        ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        img = _img;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">        prev_img = cur_img = forw_img = img;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forw_img = img;</span><br><span class="line"></span><br><span class="line">    forw_pts.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_pts.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TicToc t_o;</span><br><span class="line">        <span class="built_in">vector</span>&lt;uchar&gt; status;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; err;</span><br><span class="line">        cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">            <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">                status[i] = <span class="number">0</span>;</span><br><span class="line">        reduceVector(prev_pts, status);</span><br><span class="line">        reduceVector(cur_pts, status);</span><br><span class="line">        reduceVector(forw_pts, status);</span><br><span class="line">        reduceVector(ids, status);</span><br><span class="line">        reduceVector(cur_un_pts, status);</span><br><span class="line">        reduceVector(track_cnt, status);</span><br><span class="line">        ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : track_cnt)</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectWithF();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">        TicToc t_m;</span><br><span class="line">        setMask();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">        TicToc <span class="keyword">t_t</span>;</span><br><span class="line">        <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">        <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mask.empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n_pts.clear();</span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">        TicToc t_a;</span><br><span class="line">        addPoints();</span><br><span class="line">        ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    prev_img = cur_img;</span><br><span class="line">    prev_pts = cur_pts;</span><br><span class="line">    prev_un_pts = cur_un_pts;</span><br><span class="line">    cur_img = forw_img;</span><br><span class="line">    cur_pts = forw_pts;</span><br><span class="line">    undistortedPoints();</span><br><span class="line">    prev_time = cur_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6、发布feature，实例feature_points，跟踪的特征点，给后端优化用<br>发布feature_img，实例ptr，跟踪的特征点图，给RVIZ用和调试用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pub_img = n.advertise&lt;sensor_msgs::PointCloud&gt;(<span class="string">"feature"</span>, <span class="number">1000</span>);</span><br><span class="line">pub_match = n.advertise&lt;sensor_msgs::Image&gt;(<span class="string">"feature_img"</span>,<span class="number">1000</span>);</span><br><span class="line">pub_restart = n.advertise&lt;std_msgs::Bool&gt;(<span class="string">"restart"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="回调函数img-callback"><a href="#回调函数img-callback" class="headerlink" title="回调函数img_callback()"></a>回调函数img_callback()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">img_callback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;img_msg)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数是ROS的回调函数，主要功能包括：readImage()函数对新来的图像使用光流法进行特征点跟踪，并将追踪的特征点封装成feature_points发布到pub_img的话题下，将图像封装成ptr发布在pub_match下。</p>
<ul>
<li>1、判断是否是第一帧</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为第一帧</span></span><br><span class="line"><span class="keyword">if</span>(first_image_flag)</span><br><span class="line">&#123;</span><br><span class="line">    first_image_flag = <span class="literal">false</span>;</span><br><span class="line">    first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    last_image_time  = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、判断时间间隔是否正确，有问题则restart</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (img_msg-&gt;header.stamp.toSec() - last_image_time &gt; <span class="number">1.0</span> || img_msg-&gt;header.stamp.toSec() &lt; last_image_time)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_WARN(<span class="string">"image discontinue! reset the feature tracker!"</span>);</span><br><span class="line">    first_image_flag = <span class="literal">true</span>; </span><br><span class="line">    last_image_time = <span class="number">0</span>;</span><br><span class="line">    pub_count = <span class="number">1</span>;</span><br><span class="line">    std_msgs::Bool restart_flag;</span><br><span class="line">    restart_flag.data = <span class="literal">true</span>;</span><br><span class="line">    pub_restart.publish(restart_flag);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、发布频率控制，并不是每读入一帧图像，就要发布特征点，通过判断间隔时间内的发布次数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> tmp_freq = <span class="number">1.0</span> * pub_count / (img_msg-&gt;header.stamp.toSec() - first_image_time);</span><br><span class="line"> <span class="keyword">if</span> (round(tmp_freq) &lt;= FREQ)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//PUB_THIS_FRAME 是否需要发布特征点</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">// // 时间间隔内的发布频率十分接近设定频率时，更新时间间隔起始时刻，并将数据发布次数置0</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp_freq - FREQ) &lt; <span class="number">0.01</span> * FREQ)</span><br><span class="line">     &#123;</span><br><span class="line">         first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">         pub_count = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、将图像编码8UC1转换为mono8</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv_bridge::CvImageConstPtr ptr;</span><br><span class="line"><span class="keyword">if</span> (img_msg-&gt;encoding == <span class="string">"8UC1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将图像编码8UC1转换为mono8</span></span><br><span class="line">    sensor_msgs::Image img;</span><br><span class="line">    img.header = img_msg-&gt;header;</span><br><span class="line">    img.height = img_msg-&gt;height;</span><br><span class="line">    img.width = img_msg-&gt;width;</span><br><span class="line">    img.is_bigendian = img_msg-&gt;is_bigendian;</span><br><span class="line">    img.step = img_msg-&gt;step;</span><br><span class="line">    img.data = img_msg-&gt;data;</span><br><span class="line">    img.encoding = <span class="string">"mono8"</span>;</span><br><span class="line">    ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);</span><br></pre></td></tr></table></figure>
<ul>
<li>5、单目时：FeatureTracker::readImage() 函数读取图像数据进行处理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"processing camera %d"</span>, i);</span><br><span class="line">    <span class="comment">//双目跟踪则为1,单目false</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span> || !STEREO_TRACK) <span class="comment">// 针对单目相机读入图像，进入KLT跟踪阶段</span></span><br><span class="line">        <span class="comment">//ROW = fsSettings["image_height"]  rowRange和colRange函数可以获取某些范围内行或列的指针</span></span><br><span class="line">        trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure>
<ul>
<li>6、更新特征点ID</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> completed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_OF_CAM; j++)</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span> || !STEREO_TRACK)</span><br><span class="line">                <span class="comment">////更新特征点id</span></span><br><span class="line">                completed |= trackerData[j].updateID(i);</span><br><span class="line">        <span class="keyword">if</span> (!completed)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始FeatureTracker::n_id = 0;id初始化-1</span></span><br><span class="line"><span class="keyword">bool</span> FeatureTracker::updateID(<span class="keyword">unsigned</span> <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; ids.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ids[i] == <span class="number">-1</span>)</span><br><span class="line">            ids[i] = n_id++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7、如果PUB_THIS_FRAME=1则进行发布<blockquote>
<ul>
<li>将特征点id，矫正后归一化平面的3D点(x,y,z=1)，像素2D点(u,v)，像素的速度(vx,vy)，封装成sensor_msgs::PointCloudPtr类型的feature_points实例中,发布到pub_img;</li>
<li>将图像封装到cv_bridge::cvtColor类型的ptr实例中发布到pub_match</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="图像特征跟踪FeatureTracker-readImage"><a href="#图像特征跟踪FeatureTracker-readImage" class="headerlink" title="图像特征跟踪FeatureTracker::readImage()"></a>图像特征跟踪FeatureTracker::readImage()</h2><ul>
<li>1、通过EQUALIZE值判断是否进行自适应直方图均衡化，如果EQUALIZE=1（表示太亮或则太暗)，调用cv::CLAHE对图像做直方图均衡化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果EQUALIZE=1，表示太亮或则太暗</span></span><br><span class="line"><span class="keyword">if</span> (EQUALIZE)<span class="comment">//判断是否进行直方图均衡化处理</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">    cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">    TicToc t_c;</span><br><span class="line">    clahe-&gt;apply(_img, img);</span><br><span class="line">    ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    img = _img;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、 区分是否为第一次读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">    <span class="comment">//如果当前帧的图像数据forw_img为空，说明当前是第一次读入图像数据</span></span><br><span class="line">    <span class="comment">//将读入的图像赋给前帧forw_img</span></span><br><span class="line">    <span class="comment">//同时，还将读入的图像赋给prev_img、cur_img，这是为了避免后面使用到这些数据时，它们是空的</span></span><br><span class="line">    prev_img = cur_img = forw_img = img;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则，说明之前就已经有图像读入</span></span><br><span class="line">    <span class="comment">//所以只需要更新前帧forw_img的数据</span></span><br><span class="line">    forw_img = img;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、calcOpticalFlowPyrLK() 从cur_pts到forw_pts做LK金字塔光流法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用cv::calcOpticalFlowPyrLK()对前一帧的特征点cur_pts进行LK金字塔光流跟踪，得到forw_pts</span></span><br><span class="line"><span class="comment">//status标记了从前一帧cur_img到forw_img特征点的跟踪状态，无法被追踪到的点标记为0</span></span><br><span class="line">cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>4、根据status，把跟踪失败的和位于图像边界外的点剔除，剔除时不仅要从当前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts、cur_pts，记录特征点id的ids，和记录特征点被跟踪次数的track_cnt中剔除；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//将位于图像边界外的点标记为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">        <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">            status[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据status,把跟踪失败的点剔除</span></span><br><span class="line">    <span class="comment">//不仅要从前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts和cur_pts中剔除</span></span><br><span class="line">    <span class="comment">//prev_pts和cur_pts中的特征点是一一对应的</span></span><br><span class="line">    <span class="comment">//记录特征点id的ids，和记录特征点被跟踪次数的track_cnt也要剔除</span></span><br><span class="line">    reduceVector(prev_pts, status);</span><br><span class="line">    reduceVector(cur_pts, status);</span><br><span class="line">    reduceVector(forw_pts, status);</span><br><span class="line">    reduceVector(ids, status);</span><br><span class="line">    reduceVector(cur_un_pts, status);</span><br><span class="line">    reduceVector(track_cnt, status);</span><br><span class="line">    ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、根据PUB_THIS_FRAME是否发布特征，<ul>
<li>如果不需要发布特征点,则到这步就完了,把当前帧forw赋给上一帧cur, 然后退出 </li>
<li>如果发布特征：<blockquote>
<p>1、先调用rejectWithF()对prev_pts和forw_pts做ransac剔除outlier.(实际就是调用了findFundamentalMat函数), 在光流追踪成功就记被追踪+1，数值代表被追踪的次数，数值越大，说明被追踪的就越久<br>2、调用setMask(), 先对跟踪点forw_pts按跟踪次数降排序, 然后依次选点, 选一个点, 在mask中将该点周围一定半径的区域设为0, 后面不再选取该区域内的点. 有点类似与non-max suppression, 但区别是这里保留track_cnt最高的点<br>3、在mask中不为0的区域,调用goodFeaturesToTrack() 寻找新的特征点(shi-tomasi角点)，添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点<br>4、通过addPoints()函数push到forw_pts中, id初始化-1,track_cnt初始化为1.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//主要是通过基本矩阵（F）去除外点outliers</span></span><br><span class="line">    rejectWithF();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">    TicToc t_m;</span><br><span class="line">    <span class="comment">//对跟踪点进行排序并去除密集点。</span></span><br><span class="line">    setMask();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">    TicToc <span class="keyword">t_t</span>;</span><br><span class="line">    <span class="comment">//计算是否需要提取新的特征点,MAX_CNT:特征点最大个数150</span></span><br><span class="line">    <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">    <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MIN_DIST:特征点之间的最小间隔30</span></span><br><span class="line">        <span class="comment">//寻找新的特征点(shi-tomasi角点),添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点</span></span><br><span class="line">        cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">    &#125;</span><br><span class="line">                  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n_pts.clear();</span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">    TicToc t_a;</span><br><span class="line">    <span class="comment">//添将新检测到的特征点n_pts添加到forw_pts中，id初始化-1,track_cnt初始化为1.</span></span><br><span class="line">    addPoints();</span><br><span class="line">    ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>6、undistortedPoints() 对特征点的图像坐标根据不同的相机模型进行去畸变矫正和深度归一化，计算每个角点的速度</li>
</ul>
<p>待写！！！</p>
<p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/85797156" target="_blank" rel="noopener">VINS-Mono代码解读——视觉跟踪 feature_trackers</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719401" target="_blank" rel="noopener">VINS理论与代码详解2——单目视觉跟踪</a><br><a href="https://blog.csdn.net/q597967420/article/details/76099425" target="_blank" rel="noopener">VINS-Mono源码解析（二）前端：特征跟踪</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo4.0 - Next7.2.4 主题优化配置</title>
    <url>/2019/10/23/hexo4.0%20-%20Next7.2.4%20%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Next主题的安装"><a href="#Next主题的安装" class="headerlink" title="Next主题的安装"></a>Next主题的安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo_blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后设置站点配置文件_config.yml，Hexo博客主题替换为Next主题。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022101546332.png#pic_center">.</p><h1 id="Next主题优化配置"><a href="#Next主题优化配置" class="headerlink" title="Next主题优化配置"></a>Next主题优化配置</h1><h2 id="1-Next主题风格："><a href="#1-Next主题风格：" class="headerlink" title="1.Next主题风格："></a>1.Next主题风格：</h2><a id="more"></a>

<p>Next提供了四中主题风格scheme，可以在主题配置文件blog/themes/next/_config.yml文件中进行选择，分别是Muse、Mist、Pisces、Gemini：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022102034549.png#pic_center"></p>
<ul>
<li>Next主题一般配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation. Introduced in NexT v6.0.0.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment">#表示添加缓存功能，这样浏览器后续打开我们的博客网站会更快</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons / item badges.</span></span><br><span class="line">menu_settings:</span><br><span class="line">  icons: <span class="literal">true</span>  <span class="comment">#是否显示各个页面的图标</span></span><br><span class="line">  badges: <span class="literal">false</span> <span class="comment">#是否显示分类/标签/归档页的内容量</span></span><br></pre></td></tr></table></figure>
<p>相应的站点配置blog/_config.yml文件的基本配置为：</p>
<h2 id="2-添加博客自定义图标"><a href="#2-添加博客自定义图标" class="headerlink" title="2.添加博客自定义图标"></a>2.添加博客自定义图标</h2><p>选择或者创建相应大小的图标文件，放置在blog/themes/next/sources/images目录下，并在主题配置文件中进行如下配置，只需要设置small和medium两个就可以：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022104457616.png#pic_center"></p>
<h2 id="3-添加动态背景"><a href="#3-添加动态背景" class="headerlink" title="3.添加动态背景"></a>3.添加动态背景</h2><p>打开 next/layout/_layout.swig<br>在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件，打开 /next/_config.yml,在里面添加如下代码：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022145253296.png#pic_center">.</p>
<h2 id="4-添加看板娘"><a href="#4-添加看板娘" class="headerlink" title="4.添加看板娘"></a>4.添加看板娘</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>下载模型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install live2d-widget-model-wanko</span><br></pre></td></tr></table></figure>
<h2 id="5-鼠标点击特效"><a href="#5-鼠标点击特效" class="headerlink" title="5.鼠标点击特效"></a>5.鼠标点击特效</h2><p>鼠标的点击红心特效<br>在/themes/next/source/js/src下新建文件clicklove.js ，接着把下面的代码拷贝粘贴到 love.js 文件中：<br>7.4 next没有src文件夹，先建一个src文件夹<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span>(e,t,a)&#123;<span class="keyword">function</span> <span class="function"><span class="title">n</span></span>()&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="keyword">function</span> <span class="function"><span class="title">r</span></span>()&#123;<span class="keyword">for</span>(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="keyword">function</span> <span class="function"><span class="title">o</span></span>()&#123;var t=<span class="string">"function"</span>==typeof e.onclick&amp;&amp;e.onclick;e.onclick=<span class="keyword">function</span>(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="keyword">function</span> i(e)&#123;var a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;<span class="keyword">function</span> c(e)&#123;var a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[0].appendChild(a)&#125;<span class="keyword">function</span> <span class="function"><span class="title">s</span></span>()&#123;<span class="built_in">return</span><span class="string">"rgb("</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">")"</span>&#125;var d=[];e.requestAnimationFrame=<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="keyword">function</span>(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure></p>
<p>在\themes\next\layout_layout.swig文件末尾添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clicklove.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="6-设置头像"><a href="#6-设置头像" class="headerlink" title="6.设置头像"></a>6.设置头像</h2><p>在主题配置文件中设置头像，将其放置到 themes/next/source/images/avatar.png 路径，rounded是否设置成圆形，rotated是否设置成可旋转的。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022134436646.png#pic_center"></p>
<h2 id="7-设置RSS订阅"><a href="#7-设置RSS订阅" class="headerlink" title="7.设置RSS订阅"></a>7.设置RSS订阅</h2><p>博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>打开根目录配置文件_config.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure>
<p>然后设置主题配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>
<h2 id="8-侧边栏社交小图标设置"><a href="#8-侧边栏社交小图标设置" class="headerlink" title="8.侧边栏社交小图标设置"></a>8.侧边栏社交小图标设置</h2><p>打开主题配置文件_config.yml，command+f搜索 Social，将你有的社交账号前面的 # 号去掉。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022135427340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="9-Tag-标签前图标修改"><a href="#9-Tag-标签前图标修改" class="headerlink" title="9.Tag 标签前图标修改"></a>9.Tag 标签前图标修改</h2><p>文章标签的显示默认前面“#”号，可以通过设置将“#”换为图标。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tag_icon: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="10-访问量统计"><a href="#10-访问量统计" class="headerlink" title="10.访问量统计"></a>10.访问量统计</h2><ul>
<li>打开themes/next/下的_config.yml，查找busuanzi<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</li>
<li>打开/themes/next/layout/_partials/footer.swig，在最后添加如下内容：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span><br><span class="line">  本站访问次数：&lt;span class=<span class="string">"busuanzi-value"</span> id=<span class="string">"busuanzi_value_site_pv"</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-实现文章统计功能"><a href="#11-实现文章统计功能" class="headerlink" title="11.实现文章统计功能"></a>11.实现文章统计功能</h2><p>统计字数和阅读分钟数<br>安装 hexo-symbols-count-time，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件 hexo _config.yaml添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  time: <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  total_symbols: <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  total_time: <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  exclude_codeblock: <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>
<p>具体可查看：<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a><br>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022142919746.png#pic_center"></p>
<h2 id="12-添加网页顶部进度加载条"><a href="#12-添加网页顶部进度加载条" class="headerlink" title="12.添加网页顶部进度加载条"></a>12.添加网页顶部进度加载条</h2><p>下载安装Progress module，如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure></p>
<p>编辑主题配置文件，command+F 搜索 pace，将其值改为 ture 就可以了。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022144354865.png#pic_center"></p>
<h2 id="13-添加站内搜索"><a href="#13-添加站内搜索" class="headerlink" title="13.添加站内搜索"></a>13.添加站内搜索</h2><p>安装 hexo-generator-search<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><br>安装 hexo-generator-searchdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>编辑站点配置文件，添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure><br>编辑主题配置文件，设置 local_search为 ture<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102215014852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="14-Footer-页脚设置"><a href="#14-Footer-页脚设置" class="headerlink" title="14.Footer / 页脚设置"></a>14.Footer / 页脚设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  icon:</span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    name: user</span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="comment">## 图标的一个动画效果，类似于心跳</span></span><br><span class="line">    animated: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="comment"># 图标颜色，可格局需要自行修改</span></span><br><span class="line">    color: <span class="string">"#808080"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo 字样，不喜欢可以设置为 false</span></span><br><span class="line">  powered:</span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 主题字样，不喜欢可以 false</span></span><br><span class="line">  theme:</span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="comment"># 备案信息，如果网站有备案号，可以在这里填写备案号</span></span><br><span class="line">  beian:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">    icp:</span><br></pre></td></tr></table></figure>
<h2 id="15-Creative-Commons-文章版权"><a href="#15-Creative-Commons-文章版权" class="headerlink" title="15.Creative Commons / 文章版权"></a>15.Creative Commons / 文章版权</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-nd</span><br><span class="line">  post: <span class="literal">true</span></span><br><span class="line">  language: deed.zh</span><br></pre></td></tr></table></figure>
<p>在文章 .md 文件中的上部，添加 copyright: true。</p>
<h2 id="16-设置阅读全文"><a href="#16-设置阅读全文" class="headerlink" title="16.设置阅读全文"></a>16.设置阅读全文</h2><p>打开主题配置文件，修改auto_excerpt:字段为true，length表示显示文本的长度<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022151038529.png#pic_center"><br>在想要隐藏的位置加入以下代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="17-开启文章目录"><a href="#17-开启文章目录" class="headerlink" title="17.开启文章目录"></a>17.开启文章目录</h2><p>修改主题配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line">toc:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  number: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  wrap: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  expand_all: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure>
<h2 id="18-GitHub-Fork-Me"><a href="#18-GitHub-Fork-Me" class="headerlink" title="18.GitHub Fork Me"></a>18.GitHub Fork Me</h2><p>修改主题配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line">github_banner:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  permalink: https://github.com/Xiao-Hu-Z</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022161748244.png#pic_center"></p>
<h2 id="19-bookmark"><a href="#19-bookmark" class="headerlink" title="19.bookmark"></a>19.bookmark</h2><p>Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bookmark:	</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.	</span></span><br><span class="line">  color: <span class="string">"#222"</span>	</span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.	</span></span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure>
<h2 id="20-添加lazyload"><a href="#20-添加lazyload" class="headerlink" title="20. 添加lazyload"></a>20. 添加lazyload</h2><p>对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-jquery-lazyload <span class="built_in">source</span>/lib/jquery_lazyload</span><br></pre></td></tr></table></figure><br>主题配置文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Vanilla JavaScript plugin for lazyloading images.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/ApoorvSaxena/lozad.js</span></span><br><span class="line">lazyload: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="21-代码复制"><a href="#21-代码复制" class="headerlink" title="21.代码复制"></a>21.代码复制</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line">copy_button:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="22-SEO支持"><a href="#22-SEO支持" class="headerlink" title="22.SEO支持"></a>22.SEO支持</h2><p>SEO(Search Engine Optimization)意为搜索引擎优化,利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</p>
<ul>
<li>安装站点地图(sitemap)插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<ul>
<li>站点配置文件修改/添加</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SEO </span></span><br><span class="line">sitemap: </span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>启用百度推送功能，博客会自动将网址推送到百度，这对搜索引擎优化非常有帮助。<br>主题配置文件修改 baidu_push: true</p>
<h2 id="23-显示当前浏览进度"><a href="#23-显示当前浏览进度" class="headerlink" title="23.显示当前浏览进度"></a>23.显示当前浏览进度</h2><p>打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true ，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Scroll percent label in b2t button.# # 是否显示页面浏览百分比</span><br><span class="line">scrollpercent: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h1><h2 id="1-支持数学公式"><a href="#1-支持数学公式" class="headerlink" title="1.支持数学公式"></a>1.支持数学公式</h2><p>可能在一些情况下我们需要写一个公式，makdown是支持的，next也支持。</p>
<p>Next 主题提供了两个渲染引擎，分别是 mathjax 和katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations。" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/math-equations。</a></p>
<p>这里选择 mathjax ,通过修改配置即可启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>注意：使用的时候需要在 文章开头加上mathjax: true</p>
<ul>
<li><h1 id="解决语义冲突"><a href="#解决语义冲突" class="headerlink" title="解决语义冲突"></a>解决语义冲突</h1><p>由于LaTeX与markdown语法有语义冲突，在markdown中，斜体和加粗可以用<em>或者_表示，在这里我们修改变量，将_用于LaTeX，而使用</em>表示markdown中的斜体和加粗。<br>在博客根目录下，进入node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>
<p>同时把第20行的em变量也要做相应的修改:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">//  em: /^<span class="symbol">\b</span>_((?:__|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br><span class="line">em: /^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure>
<p>修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line"><span class="attr">  mathjax:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line"><span class="attr">    mhchem:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-添加APlayer音乐播放器"><a href="#2-添加APlayer音乐播放器" class="headerlink" title="2.添加APlayer音乐播放器"></a>2.添加APlayer音乐播放器</h2><p>为博客添加音乐播放器功能</p>
<p><strong>download</strong><br>点击访问Aplayer源码：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">GitHub Aplayer</a>。下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下。</p>
<p><strong>music.js</strong><br>新建themes\next\source\dist\music.js文件，添加内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const ap = new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(<span class="string">'aplayer'</span>),</span><br><span class="line">    fixed: <span class="literal">true</span>,</span><br><span class="line">    autoplay: <span class="literal">true</span>,</span><br><span class="line">    audio: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"暗涌"</span>,</span><br><span class="line">        artist: <span class="string">'王菲'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/52980.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/w8RFsMH8VJfPsBmVudYGsA==/109951163020569833.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Wonderful U'</span>,</span><br><span class="line">        artist: <span class="string">'AGA'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/51181.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Blb_Gi0AJTWIEBLr189F4A==/18791753232142320.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'浮夸'</span>,</span><br><span class="line">        artist: <span class="string">'陈奕迅'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/49639.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Bl1hEdJbMSj5YJsTqUjr-w==/109951163520311175.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>源码参数解释<a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">APlayer 中文文档</a></p>
<p>audio对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：<a href="http://up.mcyt.net/" target="_blank" rel="noopener">http://up.mcyt.net/</a> ，搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。</p>
<p><strong>_layout.swig</strong><br>打开themes\next\layout_layout.swig文件,在<body><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body> 里面添加以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"aplayer"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/APlayer.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/music.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>重新生成，访问页面，就能看到左下角的音乐播放器了。</p>
<h2 id="3-DaoVoice在线联系功能"><a href="#3-DaoVoice在线联系功能" class="headerlink" title="3.DaoVoice在线联系功能"></a>3.DaoVoice在线联系功能</h2><p><a href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/" target="_blank" rel="noopener">https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/</a></p>
<h1 id="自定义样式支持"><a href="#自定义样式支持" class="headerlink" title="自定义样式支持"></a>自定义样式支持</h1><h2 id="1-文章末尾统一添加“本文结束”标记"><a href="#1-文章末尾统一添加“本文结束”标记" class="headerlink" title="1.文章末尾统一添加“本文结束”标记"></a>1.文章末尾统一添加“本文结束”标记</h2><p>主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  postBodyEnd: <span class="built_in">source</span>/_data/post-body-end.swig</span><br></pre></td></tr></table></figure>
<p>接着打开\themes\next\layout_macro\post.swig文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在路径 /source/_data 下创建/修改 post-body-end.swig文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------本文结束&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-主题及标题栏背景图"><a href="#2-主题及标题栏背景图" class="headerlink" title="2.主题及标题栏背景图"></a>2.主题及标题栏背景图</h2><p>首先主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>
<p> 在路径~/hexo_blog/source/_data创建/修改 styles.styl文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line">body &#123;</span><br><span class="line">      background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址</span><br><span class="line">      background-size: cover;</span><br><span class="line">      background-repeat: no-repeat;</span><br><span class="line">      background-attachment: fixed;</span><br><span class="line">      background-position: 50% 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 标题栏背景</span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: 20px 0;</span><br><span class="line">    color: <span class="comment">#fff;</span></span><br><span class="line">    background: <span class="variable">$blue</span>;</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:center;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 修改主体透明度</span><br><span class="line">.main-inner&#123;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    opacity: 0.95;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改菜单栏透明度，会引起本地搜索菜单bug</span><br><span class="line">//.header-inner &#123;</span><br><span class="line">//    opacity: 0.95;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 主页文章添加阴影效果</span><br><span class="line">.post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-修改主副标题字体颜色"><a href="#3-修改主副标题字体颜色" class="headerlink" title="3.修改主副标题字体颜色"></a>3.修改主副标题字体颜色</h2><p>继续在/source/_data/styles.styl文件中添加，帮你挑选颜色的网站： <a href="https://www.color-hex.com/" target="_blank" rel="noopener">color-hex</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主标题颜色</span></span><br><span class="line">.brand&#123;</span><br><span class="line">    color: $white</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//副标题颜色</span></span><br><span class="line">.site-subtitle &#123;</span><br><span class="line">    margin-top: <span class="number">10</span>px;</span><br><span class="line">    font-size: <span class="number">13</span>px;</span><br><span class="line">    color: <span class="meta">#ffffff;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-修改按钮，选择区域，代码块，表格等样式"><a href="#4-修改按钮，选择区域，代码块，表格等样式" class="headerlink" title="4.修改按钮，选择区域，代码块，表格等样式"></a>4.修改按钮，选择区域，代码块，表格等样式</h2><p>首先主题配置文件取消注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/variables.styl</span><br></pre></td></tr></table></figure>
<p>在路径 /source/_data 下创建/修改 variables.styl文件（相当于修改主题文件 next/source/css/_variables/base.styl），并添加以下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buttons</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$btn-<span class="keyword">default</span>-bg                 = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-color              = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-font-size          = $font-size-small;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-width       = <span class="number">2</span>px;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-color       = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-bg           = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-color        = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-border-color = #<span class="number">49b</span>1f5;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Selection</span></span><br><span class="line">$selection-bg                 = #<span class="number">49b</span>1f5;</span><br><span class="line">$selection-color              = white;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code &amp; Code Blocks</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$code-font-family               = $font-family-monospace;</span><br><span class="line">$code-border-radius             = <span class="number">3</span>px;</span><br><span class="line">$code-foreground                = $black-light;</span><br><span class="line">$code-background                = #edf1ff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Table</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$table-width                    = normal;  <span class="comment">//next默认100%</span></span><br><span class="line">$table-border-color             = $gray-lighter;</span><br><span class="line">$table-font-size                = $font-size-small;</span><br><span class="line">$table-content-alignment        = left;</span><br><span class="line">$table-content-vertical         = middle;</span><br><span class="line">$table-th-font-weight           = <span class="number">700</span>;</span><br><span class="line">$table-cell-padding             = <span class="number">8</span>px;</span><br><span class="line">$table-cell-border-right-color  = $gainsboro;</span><br><span class="line">$table-cell-border-bottom-color = $gray-lighter;</span><br><span class="line">$table-row-odd-bg-color         = #f9f9f9;</span><br><span class="line">$table-row-hover-bg-color       = $whitesmoke;</span><br></pre></td></tr></table></figure>
<h1 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h1><h2 id="托管-Hexo-博客到-Coding"><a href="#托管-Hexo-博客到-Coding" class="headerlink" title="托管 Hexo 博客到 Coding"></a>托管 Hexo 博客到 Coding</h2><p>注意：coding账号注册时请选择个人版（如果注册了团队版，你会发现跟网上给的教程不太一样，而且，部署出来的网页地址无法修改成xxx.coding.me）。</p>
<ul>
<li>创建项目<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027145840374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
<li>配置SSH公钥<br>首先点击右上角的头像-个人设置-SSH公钥-新增公匙-输入你自己的SSH公匙-永久有效(推荐)-确定即可。</li>
<li>修改站点配置文件<br>对该配置进行修改如下(注意缩进)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">    coding: git@git.dev.tencent.com:Xiao-Hu-Z/Xiao-Hu-Z.coding.me.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>该配置指定了Coding仓库的地址，并通过HTTPS方式进行连接。同样我们也可以通过SSH方式。<br>安装完成后，开始项目的部署操作，用的是HTTPS方式，会弹出输入用户名密码的输入框，键入你的coding用户名密码即可。</p>
<h2 id="gulp-4-0实现静态资源压缩"><a href="#gulp-4-0实现静态资源压缩" class="headerlink" title="gulp 4.0实现静态资源压缩"></a>gulp 4.0实现静态资源压缩</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install gulp</span><br></pre></td></tr></table></figure>
<ul>
<li>安装这些功能模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</span><br></pre></td></tr></table></figure>
<ul>
<li>创建任务在站点根目录下新建gulpfile.js文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var gulp = require(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">//Plugins模块获取</span><br><span class="line">var minifycss = require(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line">var uglify = require(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">var htmlmin = require(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line">var htmlclean = require(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line">//压缩css</span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">//压缩html</span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">.pipe(htmlclean())</span><br><span class="line">.pipe(htmlmin(&#123;</span><br><span class="line">removeComments: <span class="literal">true</span>,</span><br><span class="line">minifyJS: <span class="literal">true</span>,</span><br><span class="line">minifyCSS: <span class="literal">true</span>,</span><br><span class="line">minifyURLs: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩js 不压缩min.js</span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.0以前的写法</span><br><span class="line">//gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">  //  <span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span></span><br><span class="line">//]);</span><br><span class="line">//4.0以后的写法</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // Do something after a, b, and c are finished.</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/qq_41518277/article/details/101766036#_355" target="_blank" rel="noopener">NexT主题进阶</a><br><a href="https://blog.csdn.net/colton_null/article/details/97622079" target="_blank" rel="noopener">Hexo Theme NexT 主题个性化配置最佳实践</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86556971" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列4-加速Hexo博客</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86538306" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列2-部署博客到Coding上</a><br><a href="https://hanhanhanxu.github.io/2019/05/15/coding/" target="_blank" rel="noopener">使用coding加快博客网站访问速度</a><br><a href="http://ju.outofmemory.cn/entry/105418" target="_blank" rel="noopener">托管 Hexo 博客到 Coding</a><br><a href="https://www.cnblogs.com/aoguai/p/11405829.html" target="_blank" rel="noopener">2019hexo博客部署到coding该绕的坑</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>11.旋转数组的最小数字</title>
    <url>/2019/10/22/11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目：<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p> <strong>思路1：</strong><br>暴力解法：根据给定的数组特点，从左到右遍历数组元素，当首次遇到数组中某个元素比上一个元素小时，该元素就是我们需要的元素</p><a id="more"></a>

<p><strong>思路2：</strong></p>
<ul>
<li>二分查找：<blockquote>
<ul>
<li>用两个指针，分别指向数组的第一个和最后一个元素</li>
<li>接着找到中间元素，如果中间元素位于前面的递增子数组（中间元素大于或等于第一个元指针指向元素）把第一个指针指向中间元素</li>
<li>如果中间元素位于后面的递增子数组（中间元素大于或等于第一个元指针指向元素），把第二个指针指向中间元素</li>
<li>最终，两指针会指向相邻的元素，第二个指针刚好指向是最小元素</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[i]&lt;=rotateArray[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>二分查找：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = low;<span class="comment">//防止数组的前面0个元素搬到最后面</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(rotateArray[low]&gt;=rotateArray[high])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(high-low==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid=high;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[low]==rotateArray[high] &amp;&amp; rotateArray[low]==rotateArray[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> result=rotateArray[low];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=high;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rotateArray[i]&lt;result)</span><br><span class="line">                        result=rotateArray[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid]&gt;=rotateArray[low])</span><br><span class="line">                low=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid]&lt;=rotateArray[high])</span><br><span class="line">                high=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(rotateArray)):</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i<span class="number">-1</span>]&gt;rotateArray[i]):</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        high=len(rotateArray)<span class="number">-1</span></span><br><span class="line">        mid=low</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> rotateArray[low]&gt;=rotateArray[high]:</span><br><span class="line">            <span class="keyword">if</span> high-low==<span class="number">1</span>:</span><br><span class="line">                mid=high</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            mid=(low+high)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[low]==rotateArray[high] <span class="keyword">and</span> rotateArray[low]==rotateArray[mid]:</span><br><span class="line">                result = rotateArray[low]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(low,high+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> result &gt; rotateArray[i]:</span><br><span class="line">                        result = rotateArray[i]</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid]&gt;=rotateArray[low]:</span><br><span class="line">                low=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high=mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>10.斐波那契数列（跳台阶）</title>
    <url>/2019/10/20/10.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿题目一：<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><p>思路</p><ul>
<li>如果只有一阶台阶，一种跳法，如果只有两阶台阶，两种跳法</li>
<li>把n阶台阶时的跳法看成n的函数，记法f(n)，f(n)=f(n-1)+f(n-2)</li>
</ul><p>采用循环方式实现，递归实践效率太低<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result[n];         </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibOne=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibTwo=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fibN=fibOne+fibTwo;</span><br><span class="line">            fibOne=fibTwo;</span><br><span class="line">            fibTwo=fibN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibN;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        result=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> result[n]</span><br><span class="line">        </span><br><span class="line">        f1=<span class="number">1</span></span><br><span class="line">        f2=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            fn=f1+f2</span><br><span class="line">            f1=f2</span><br><span class="line">            f2=fn</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>相关题目：</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> result[number];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">2</span>,fn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fn=f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=fn;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f=<span class="number">2</span>*f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//return pow(2,number-1);</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>KLT 光流算法</title>
    <url>/2019/10/20/KLT-%E5%85%89%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Optical-Flow"><a href="#Optical-Flow" class="headerlink" title="Optical Flow"></a>Optical Flow</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132123717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132137931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="KLT"><a href="#KLT" class="headerlink" title="KLT"></a>KLT</h1><p>KLT 算法本质上也基于光流的三个假设，不同于前述直接比较像素点灰度值的作法，KLT 比较像素点周围的窗口像素，来寻找最相似的像素点。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102013215737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132228980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流—LK光流—基于金字塔分层的LK光流—中值流</a><br><a href="https://leijiezhang001.github.io/KLT/" target="_blank" rel="noopener">KLT 光流算法详解</a><br><a href="https://blog.csdn.net/irobot_davinci/article/details/29635199" target="_blank" rel="noopener">KLT角点跟踪算法(LK)学习（一）——算法原理</a></p>]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>9.用两个栈实现队列</title>
    <url>/2019/10/20/9.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：</p><ul>
<li>首先把元素插入stack1;</li>
<li>当stack2为空时，把stack1的元素逐个弹出并压入stack2</li>
<li>当stack2步为空时，在stack2的栈顶元素最先进入队列的元素，可以弹出</li>
</ul><p><strong>C++</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s.empty();         //如果栈为空则返回true, 否则返回false;</span></span><br><span class="line"><span class="comment">s.size();          //返回栈中元素的个数</span></span><br><span class="line"><span class="comment">s.top();           //返回栈顶元素, 但不删除该元素</span></span><br><span class="line"><span class="comment">s.pop();           //弹出栈顶元素, 但不返回其值</span></span><br><span class="line"><span class="comment">s.push();          //将元素压入栈顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> data=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> head=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>




<p><strong>Python</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                <span class="comment">#.pop(i)将列表中第i项元素取出并删除该元素</span></span><br><span class="line">                self.stack2.append(self.stack1.pop(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>Harris角点检测</title>
    <url>/2019/10/20/Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为角点"><a href="#何为角点" class="headerlink" title="何为角点"></a>何为角点</h1><p>下面有两幅不同视角的图像，通过找出对应的角点进行匹配。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095257386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>再看下图所示，放大图像的两处角点区域：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095313814.png#pic_center"><br>角点在保留图像图形重要特征的同时，可以有效地减少信息的数据量，使其信息的含量很高，有效地提高了计算的速度，有利于图像的可靠匹配，使得实时处理成为可能。</p><p>我们可以直观的概括下角点所具有的特征：</p><ul>
<li>轮廓之间的交点；</li>
<li>对于同一场景，即使视角发生变化，通常具备稳定性质的特征；<ul>
<li>该点附近区域的像素点无论在梯度方向上还是其梯度幅值上有着较大变化；<h1 id="角点检测算法基本思想"><a href="#角点检测算法基本思想" class="headerlink" title="角点检测算法基本思想"></a>角点检测算法基本思想</h1>算法基本思想是使用一个固定窗口在图像上进行任意方向上的滑动，比较滑动前与滑动后两种情况，窗口中的像素灰度变化程度，如果存在任意方向上的滑动，都有着较大灰度变化，那么我们可以认为该窗口中存在角点。<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1></li>
</ul>
</li>
</ul><a id="more"></a>


<p>当窗口发生[u,v]移动时，那么滑动前与滑动后对应的窗口中的像素点灰度变化描述如下：</p>
<script type="math/tex; mode=display">E(u, v)=\sum_{x_{s}, y} w(x, y)[I(x+u, y+v)-I(x, y)]^{2}</script><p>[u,v]是窗口的偏移量<br>(x,y)是窗口内所对应的像素坐标位置，窗口有多大，就有多少个位置<br>w(x,y)是窗口函数，最简单情形就是窗口内的所有像素所对应的w权重系数均为1。但有时候，我们会将w(x,y)函数设定为以窗口中心为原点的二元正态分布。如果窗口中心点是角点时，移动前与移动后，该点的灰度变化应该最为剧烈，所以该点权重系数可以设定大些，表示窗口移动时，该点在灰度变化贡献较大；而离窗口中心(角点)较远的点，这些点的灰度变化几近平缓，这些点的权重系数，可以设定小点，以示该点对灰度变化贡献较小，那么我们自然想到使用二元高斯函数来表示窗口函数，所以通常窗口函数有如下两种形式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095759748.png#pic_center"><br>根据上述表达式，当窗口处在平坦区域上滑动，可以想象的到，灰度不会发生变化，那么E(u,v) = 0；如果窗口处在比纹理比较丰富的区域上滑动，那么灰度变化会很大。算法最终思想就是计算灰度发生较大变化时所对应的位置，当然这个较大是指针任意方向上的滑动，并非单指某个方向。</p>
<p>$I(x+u, y+v)$泰勒展开可得：</p>
<script type="math/tex; mode=display">I(x+u, y+v)=I(x, y)+I_{x} u+I_{y} v+O\left(u^{2}, v^{2}\right)</script><p>当发生微小位移时，忽略无穷小量，写成矩阵形式：</p>
<script type="math/tex; mode=display">E(u, v)=\sum_w[u, v]\left[\begin{array}{cc}{I_{x}^{2}} & {I_{x} I_{y}} \\ {I_{x} I_{y}} & {I_{y}^{2}}\end{array}\right]\left[\begin{array}{l}{u} \\ {v}\end{array}\right]=[u, v]M\left[\begin{array}{l}{u} \\ {v}\end{array}\right]</script><p>所以E(u,v)表达式可以更新为：</p>
<script type="math/tex; mode=display">E(u,v)\cong \begin{bmatrix}
u\\ v\end{bmatrix}M\begin{bmatrix}
u & 
v\end{bmatrix}</script><p>矩阵M为:</p>
<script type="math/tex; mode=display">M(x,y)=\Sigma_w \left[ \begin{matrix} I_x^2& I_xI_y \\ I_xI_y & I_y^2\end{matrix} \right]</script><p>E(u,v)是一个二次型，而由下述定理可知<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101744919.png#pic_center"><br>M分解可得：</p>
<script type="math/tex; mode=display">M=X\Sigma X^T = X \left[ \begin{matrix} \lambda_1& 0\\ 0& \lambda_2\end{matrix} \right] X^T</script><p>令E(u,v)=常数，我们可用一个椭圆来描绘这一函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101810715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>椭圆的长短轴是与结构张量M的两个特征值相对应的量。通过判断的情况我们就可以区分出‘flat’，‘edge’，‘corner’这三种区域，因为最直观的印象：</p>
<ul>
<li>corner：在水平、竖直两个方向上变化均较大的点，即Ix、Iy都较大 <ul>
<li>edge ：仅在水平、或者仅在竖直方向有较大的点，即Ix和Iy只有其一较大 </li>
<li>flat   ： 在水平、竖直方向的变化量均较小的点，即Ix、Iy都较小</li>
</ul>
</li>
</ul>
<p>M是由Ix，Iy构成，它的特征值正好可以反映Ix，Iy的情况，下面我以一种更容易理解的方式来讲述椭圆的物理意义。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101904206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>下图是对这三种情况窗口中的对应像素的梯度分布进行绘制：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101940485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>如果使用椭圆进行数据集表示，则绘制图示如下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020103310120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以得出下列结论：</p>
<blockquote>
<p>特征值都比较大时，即窗口中含有角点<br>特征值一个较大，一个较小，窗口中含有边缘<br>特征值都比较小，窗口处在平坦区域<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020102013942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<h1 id="度量角点响应"><a href="#度量角点响应" class="headerlink" title="度量角点响应"></a>度量角点响应</h1><p>特征值计算一般比较繁琐，所以把M写为：</p>
<script type="math/tex; mode=display">M(x,y)=\Sigma_w \left[ \begin{matrix} I_x^2& I_xI_y \\ I_xI_y & I_y^2\end{matrix} \right] = \left[ \begin{matrix} A& C\\ C& B\end{matrix} \right]</script><p>定义角点响应函数R（corner response function），采用近似的形式，α为常数，一般取0.04-0.06：</p>
<script type="math/tex; mode=display">R = detM-\alpha (traceM)^2\\
detM=\lambda_1 \lambda_2=AB-C^2\\
traceM=\lambda_1 + \lambda_2 = A+B</script><blockquote>
<p>可以通过判断R的值来判断某个点是不是角点了。</p>
<ul>
<li>角点：R为大数值整数</li>
<li>边缘：R为大数值负数</li>
<li>平坦区：绝对值R是小数值<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020102127533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center#pic_center"><h1 id="harris角点性质"><a href="#harris角点性质" class="headerlink" title="harris角点性质"></a>harris角点性质</h1>参数α对角点检测的影响：增大α的值，将减小角点响应值R，减少被检测角点的数量；减小α的值，将增大角点响应值R，增加被检测角点的数量。</li>
</ul>
</blockquote>
<ul>
<li>Harris角点检测对亮度和对比度的变化不敏感。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020104945973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
<li>Harris角点检测具有旋转不变性，不具备尺度不变性。如下图所示，在小尺度下的角点被放大后可能会被认为是图像边缘。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020105015840.png#pic_center"></li>
</ul>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>harris角点检测算法步骤</p>
<ol>
<li><p>利用Soble计算出XY方向的梯度值</p>
</li>
<li><p>计算出$I_x^2,I_y^2,I_xI_y$</p>
</li>
<li><p>利用高斯函数对$I_x^2,I_y^2,I_xI_y$进行滤波</p>
</li>
<li><p>计算局部特征结果矩阵M的特征值和响应函数$C(i,j)=Det(M)-k(trace(M))^2   (0.04&lt;=k&lt;=0.06)$</p>
</li>
<li><p>将计算出响应函数的值C进行非极大值抑制，滤除一些不是角点的点，同时要满足大于设定的阈值</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include "opencv2/imgproc/imgproc.hpp"  </span></span><br><span class="line"><span class="comment">#include "opencv2/highgui/highgui.hpp"  </span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">RGB转换成灰度图像的一个常用公式是：</span><br><span class="line">Gray = R*0.299 + G*0.587 + B*0.114</span><br><span class="line">*/</span><br><span class="line">//******************灰度转换函数*************************  </span><br><span class="line">//第一个参数image输入的彩色RGB图像的引用；  </span><br><span class="line">//第二个参数imageGray是转换后输出的灰度图像的引用；  </span><br><span class="line">//*******************************************************</span><br><span class="line">void ConvertRGB2GRAY(const Mat &amp;image, Mat &amp;imageGray);</span><br><span class="line"> </span><br><span class="line">//******************Sobel卷积因子计算X、Y方向梯度和梯度方向角********************  </span><br><span class="line">//第一个参数imageSourc原始灰度图像；  </span><br><span class="line">//第二个参数imageSobelX是X方向梯度图像；  </span><br><span class="line">//第三个参数imageSobelY是Y方向梯度图像；  </span><br><span class="line">//第四个参数pointDrection是梯度方向角数组指针  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelGradDirction(Mat &amp;imageSource, Mat &amp;imageSobelX, Mat &amp;imageSobelY);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的X方向梯度幅值的平方*************************  </span><br><span class="line">//第一个参数imageGradX是X方向梯度图像；    </span><br><span class="line">//第二个参数SobelAmpXX是输出的X方向梯度图像的平方  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelXX(const Mat imageGradX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXX);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的Y方向梯度幅值的平方*************************    </span><br><span class="line">//第一个参数imageGradY是Y方向梯度图像；  </span><br><span class="line">//第二个参数SobelAmpXX是输出的Y方向梯度图像的平方  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelYY(const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpYY);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的XY方向梯度幅值的乘积*************************    </span><br><span class="line">//第一个参数imageGradX是X方向梯度图像；</span><br><span class="line">//第二个参数imageGradY是Y方向梯度图像；</span><br><span class="line">//第二个参数SobelAmpXY是输出的XY方向梯度图像 </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelXY(const Mat imageGradX, const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXY);</span><br><span class="line"> </span><br><span class="line">//****************计算一维高斯的权值数组*****************</span><br><span class="line">//第一个参数size是代表的卷积核的边长的大小</span><br><span class="line">//第二个参数sigma表示的是sigma的大小</span><br><span class="line">//*******************************************************</span><br><span class="line">double *getOneGuassionArray(int size, double sigma);</span><br><span class="line"> </span><br><span class="line">//****************高斯滤波函数的实现*****************</span><br><span class="line">//第一个参数srcImage是代表的输入的原图</span><br><span class="line">//第二个参数dst表示的是输出的图</span><br><span class="line">//第三个参数size表示的是卷积核的边长的大小</span><br><span class="line">//*******************************************************</span><br><span class="line">void MyGaussianBlur(Mat_&lt;<span class="built_in">float</span>&gt; &amp;srcImage, Mat_&lt;<span class="built_in">float</span>&gt; &amp;dst, int size);</span><br><span class="line"> </span><br><span class="line">//****计算局部特涨结果矩阵M的特征值和响应函数H = (A*B - C) - k*(A+B)^2******</span><br><span class="line">//M</span><br><span class="line">//A  C</span><br><span class="line">//C  B</span><br><span class="line">//Tr(M)=a+b=A+B</span><br><span class="line">//Det(M)=a*b=A*B-C^2</span><br><span class="line">//计算输出响应函数的值得矩阵</span><br><span class="line">//****************************************************************************</span><br><span class="line">void harrisResponse(Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussYY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData,<span class="built_in">float</span> k);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//***********非极大值抑制和满足阈值及某邻域内的局部极大值为角点**************</span><br><span class="line">//第一个参数是响应函数的矩阵</span><br><span class="line">//第二个参数是输入的灰度图像</span><br><span class="line">//第三个参数表示的是输出的角点检测到的结果图</span><br><span class="line">void LocalMaxValue(Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData, Mat &amp;srcGray, Mat &amp;ResultImage,int kSize);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	const Mat srcImage = imread(<span class="string">"3.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"could not load image...\n"</span>);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"srcImage"</span>, srcImage);</span><br><span class="line">	Mat srcGray;</span><br><span class="line">	ConvertRGB2GRAY(srcImage, srcGray);</span><br><span class="line">	Mat imageSobelX;</span><br><span class="line">	Mat imageSobelY;</span><br><span class="line">	Mat resultImage;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelXX;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelYY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelXY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianXX;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianYY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianXY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; HarrisRespond;</span><br><span class="line">	//计算Soble的XY梯度</span><br><span class="line">	SobelGradDirction(srcGray, imageSobelX, imageSobelY);</span><br><span class="line">	//计算X方向的梯度的平方</span><br><span class="line">	SobelXX(imageSobelX, imageSobelXX);</span><br><span class="line">	SobelYY(imageSobelY, imageSobelYY);</span><br><span class="line">	SobelXY(imageSobelX, imageSobelY, imageSobelXY);</span><br><span class="line">	//计算高斯模糊XX YY XY</span><br><span class="line">	MyGaussianBlur(imageSobelXX, GaussianXX,3);</span><br><span class="line">	MyGaussianBlur(imageSobelYY, GaussianYY, 3);</span><br><span class="line">	MyGaussianBlur(imageSobelXY, GaussianXY, 3);</span><br><span class="line">	harrisResponse(GaussianXX, GaussianYY, GaussianXY, HarrisRespond, 0.05);</span><br><span class="line">	LocalMaxValue(HarrisRespond, srcGray, resultImage, 3);</span><br><span class="line">	imshow(<span class="string">"imageSobelX"</span>, imageSobelX);</span><br><span class="line">	imshow(<span class="string">"imageSobelY"</span>, imageSobelY);</span><br><span class="line">	imshow(<span class="string">"resultImage"</span>, resultImage);</span><br><span class="line">	waitKey(0);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">void ConvertRGB2GRAY(const Mat &amp;image, Mat &amp;imageGray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!image.data || image.channels() != 3)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//创建一张单通道的灰度图像</span><br><span class="line">	imageGray = Mat::zeros(image.size(), CV_8UC1);</span><br><span class="line">	//取出存储图像像素的数组的指针</span><br><span class="line">	uchar *pointImage = image.data;</span><br><span class="line">	uchar *pointImageGray = imageGray.data;</span><br><span class="line">	//取出图像每行所占的字节数</span><br><span class="line">	size_t stepImage = image.step;</span><br><span class="line">	size_t stepImageGray = imageGray.step;</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; imageGray.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; imageGray.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			pointImageGray[i*stepImageGray + j] = (uchar)(0.114*pointImage[i*stepImage + 3 * j] + 0.587*pointImage[i*stepImage + 3 * j + 1] + 0.299*pointImage[i*stepImage + 3 * j + 2]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//存储梯度膜长</span><br><span class="line">void SobelGradDirction(Mat &amp;imageSource, Mat &amp;imageSobelX, Mat &amp;imageSobelY)</span><br><span class="line">&#123;</span><br><span class="line">	imageSobelX = Mat::zeros(imageSource.size(), CV_32SC1);</span><br><span class="line">	imageSobelY = Mat::zeros(imageSource.size(), CV_32SC1);</span><br><span class="line">	//取出原图和X和Y梯度图的数组的首地址</span><br><span class="line">	uchar *P = imageSource.data;</span><br><span class="line">	uchar *PX = imageSobelX.data;</span><br><span class="line">	uchar *PY = imageSobelY.data;</span><br><span class="line"> </span><br><span class="line">	//取出每行所占据的字节数</span><br><span class="line">	int step = imageSource.step;</span><br><span class="line">	int stepXY = imageSobelX.step;</span><br><span class="line"> </span><br><span class="line">	int index = 0;//梯度方向角的索引</span><br><span class="line">	<span class="keyword">for</span> (int i = 1; i &lt; imageSource.rows - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 1; j &lt; imageSource.cols - 1; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			//通过指针遍历图像上每一个像素   </span><br><span class="line">			double gradY = P[(i + 1)*step + j - 1] + P[(i + 1)*step + j] * 2 + P[(i + 1)*step + j + 1] - P[(i - 1)*step + j - 1] - P[(i - 1)*step + j] * 2 - P[(i - 1)*step + j + 1];</span><br><span class="line">			PY[i*stepXY + j*(stepXY / step)] = abs(gradY);</span><br><span class="line"> </span><br><span class="line">			double gradX = P[(i - 1)*step + j + 1] + P[i*step + j + 1] * 2 + P[(i + 1)*step + j + 1] - P[(i - 1)*step + j - 1] - P[i*step + j - 1] * 2 - P[(i + 1)*step + j - 1];</span><br><span class="line">			PX[i*stepXY + j*(stepXY / step)] = abs(gradX);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//将梯度数组转换成8位无符号整型</span><br><span class="line">	convertScaleAbs(imageSobelX, imageSobelX);</span><br><span class="line">	convertScaleAbs(imageSobelY, imageSobelY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void SobelXX(const Mat imageGradX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXX)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpXX = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpXX.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpXX.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpXX.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradX.at&lt;uchar&gt;(i, j)*imageGradX.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpXX, SobelAmpXX);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void SobelYY(const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpYY)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpYY = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradY.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpYY.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpYY.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpYY.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradY.at&lt;uchar&gt;(i, j)*imageGradY.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpYY, SobelAmpYY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void SobelXY(const Mat imageGradX, const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXY)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpXY = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpXY.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpXY.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpXY.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradX.at&lt;uchar&gt;(i, j)*imageGradY.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpXY, SobelAmpXY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//计算一维高斯的权值数组</span><br><span class="line">double *getOneGuassionArray(int size, double sigma)</span><br><span class="line">&#123;</span><br><span class="line">	double sum = 0.0;</span><br><span class="line">	//定义高斯核半径</span><br><span class="line">	int kerR = size / 2;</span><br><span class="line"> </span><br><span class="line">	//建立一个size大小的动态一维数组</span><br><span class="line">	double *arr = new double[size];</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line"> </span><br><span class="line">		// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去</span><br><span class="line">		arr[i] = exp(-((i - kerR)*(i - kerR)) / (2 * sigma*sigma));</span><br><span class="line">		sum += arr[i];//将所有的值进行相加</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	//进行归一化	</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] /= sum;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MyGaussianBlur(Mat_&lt;<span class="built_in">float</span>&gt; &amp;srcImage, Mat_&lt;<span class="built_in">float</span>&gt; &amp;dst, int size)</span><br><span class="line">&#123;</span><br><span class="line">	CV_Assert(srcImage.channels() == 1 || srcImage.channels() == 3); // 只处理单通道或者三通道图像</span><br><span class="line">	int kerR = size / 2;</span><br><span class="line">	dst = srcImage.clone();</span><br><span class="line">	int channels = dst.channels();</span><br><span class="line">	double* arr;</span><br><span class="line">	arr = getOneGuassionArray(size, 1);//先求出高斯数组</span><br><span class="line"> </span><br><span class="line">									   //遍历图像 水平方向的卷积</span><br><span class="line">	<span class="keyword">for</span> (int i = kerR; i &lt; dst.rows - kerR; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = kerR; j &lt; dst.cols - kerR; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> GuassionSum[3] = &#123; 0 &#125;;</span><br><span class="line">			//滑窗搜索完成高斯核平滑</span><br><span class="line">			<span class="keyword">for</span> (int k = -kerR; k &lt;= kerR; k++)</span><br><span class="line">			&#123;</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (channels == 1)//如果只是单通道</span><br><span class="line">				&#123;</span><br><span class="line">					GuassionSum[0] += arr[kerR + k] * dst.at&lt;<span class="built_in">float</span>&gt;(i, j + k);//行不变，列变换，先做水平方向的卷积</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)//如果是三通道的情况</span><br><span class="line">				&#123;</span><br><span class="line">					Vec3f bgr = dst.at&lt;Vec3f&gt;(i, j + k);</span><br><span class="line">					auto a = arr[kerR + k];</span><br><span class="line">					GuassionSum[0] += a*bgr[0];</span><br><span class="line">					GuassionSum[1] += a*bgr[1];</span><br><span class="line">					GuassionSum[2] += a*bgr[2];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (int k = 0; k &lt; channels; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (GuassionSum[k] &lt; 0)</span><br><span class="line">					GuassionSum[k] = 0;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (GuassionSum[k] &gt; 255)</span><br><span class="line">					GuassionSum[k] = 255;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (channels == 1)</span><br><span class="line">				dst.at&lt;<span class="built_in">float</span>&gt;(i, j) = static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)</span><br><span class="line">			&#123;</span><br><span class="line">				Vec3f bgr = &#123; static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[1]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[2]) &#125;;</span><br><span class="line">				dst.at&lt;Vec3f&gt;(i, j) = bgr;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//竖直方向</span><br><span class="line">	<span class="keyword">for</span> (int i = kerR; i &lt; dst.rows - kerR; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = kerR; j &lt; dst.cols - kerR; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> GuassionSum[3] = &#123; 0 &#125;;</span><br><span class="line">			//滑窗搜索完成高斯核平滑</span><br><span class="line">			<span class="keyword">for</span> (int k = -kerR; k &lt;= kerR; k++)</span><br><span class="line">			&#123;</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (channels == 1)//如果只是单通道</span><br><span class="line">				&#123;</span><br><span class="line">					GuassionSum[0] += arr[kerR + k] * dst.at&lt;<span class="built_in">float</span>&gt;(i + k, j);//行变，列不换，再做竖直方向的卷积</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)//如果是三通道的情况</span><br><span class="line">				&#123;</span><br><span class="line">					Vec3f bgr = dst.at&lt;Vec3f&gt;(i + k, j);</span><br><span class="line">					auto a = arr[kerR + k];</span><br><span class="line">					GuassionSum[0] += a*bgr[0];</span><br><span class="line">					GuassionSum[1] += a*bgr[1];</span><br><span class="line">					GuassionSum[2] += a*bgr[2];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (int k = 0; k &lt; channels; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (GuassionSum[k] &lt; 0)</span><br><span class="line">					GuassionSum[k] = 0;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (GuassionSum[k] &gt; 255)</span><br><span class="line">					GuassionSum[k] = 255;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (channels == 1)</span><br><span class="line">				dst.at&lt;<span class="built_in">float</span>&gt;(i, j) = static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)</span><br><span class="line">			&#123;</span><br><span class="line">				Vec3f bgr = &#123; static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[1]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[2]) &#125;;</span><br><span class="line">				dst.at&lt;Vec3f&gt;(i, j) = bgr;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete[] arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void harrisResponse(Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussYY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData,<span class="built_in">float</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	//创建一张响应函数输出的矩阵</span><br><span class="line">	resultData = Mat_&lt;<span class="built_in">float</span>&gt;(GaussXX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; resultData.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; resultData.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> a = GaussXX.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			<span class="built_in">float</span> b = GaussYY.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			<span class="built_in">float</span> c = GaussXY.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) = a*b - c*c - k*(a + b)*(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//非极大值抑制</span><br><span class="line">void LocalMaxValue(Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData, Mat &amp;srcGray, Mat &amp;ResultImage, int kSize)</span><br><span class="line">&#123;</span><br><span class="line">	int r = kSize / 2;</span><br><span class="line">	ResultImage = srcGray.clone();</span><br><span class="line">	<span class="keyword">for</span> (int i = r; i &lt; ResultImage.rows - r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = r; j &lt; ResultImage.cols - r; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j + 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i, j + 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j + 1))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> ((int)resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; 18000)</span><br><span class="line">				&#123;</span><br><span class="line">					circle(ResultImage, Point(i, j), 5, Scalar(0,0,255), 2, 8, 0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/linqianbi/article/details/78930239" target="_blank" rel="noopener">https://blog.csdn.net/linqianbi/article/details/78930239</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——论文翻译（A Robust and Versatile Monocular Visual-Inertial State Estimator）</title>
    <url>/2019/10/19/VINS-Mono%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88VINS-Mono-A-Robust-and-Versatile-Monocular-Visual-Inertial-State-Estimator%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><font color="gray" size="10"><center>VINS-Mono：一种鲁棒且通用的单目视觉惯性状态估计器</center></font><p><strong>摘要</strong>：由一个相机和一个低成本惯性测量单元(IMU)组成的单目视觉惯性系统(VINS)，构成了用于度量六自由度状态估计的最小传感器套件。然而，由于缺乏直接距离测量，在IMU处理、估计器初始化、外部标定和非线性优化等方面提出了重大挑战。本文提出了VINS-Mono：一种具有鲁棒性和通用性的单目视觉惯性状态估计器。该方法从用于估计器初始化和故障恢复的鲁棒的程序开始。采用一种基于紧耦合、非线性优化的方法，通过融合预积分后的IMU测量值和特征观测值，获得高精度的视觉惯性里程计。结合紧耦合方法，回环检测模块能够以最小的计算代价实现重定位。此外，我们还进行四自由度位姿图优化，以加强全局一致性。我们验证了该系统在公共数据集和真实环境实验的性能，并与其他最先进的算法进行了比较。我们还在MAV平台上执行机载闭环自主飞行，并将算法移植到基于iOS的demo中。特别强调的是，本文提出的工作是一个可靠、完整和通用的系统，适用于需要高精度定位的不同应用。我们为PC和iOS移动设备开源了我们的实现方法。<br>关键词：单目视觉惯性系统，状态估计，传感器融合，SLAM</p><a id="more"></a>


<h1 id="I-引言"><a href="#I-引言" class="headerlink" title="I. 引言"></a>I. 引言</h1><p>状态估计无疑是机器人导航、自主驾驶、虚拟现实(VR)和增强现实(AR)等广泛应用中最基本的模块。仅使用单目摄像机的方法由于其体积小、成本低和硬件设置简单而获得了社会的极大兴趣[1]-[5]。然而，单目视觉系统无法恢复度量尺度，因此限制了它们在实际机器人中的应用。近年来，我们看到了一种发展趋势，即用低成本惯性测量单元(IMU)辅助单目视觉系统。这种单目视觉-惯性系统(VINS)的主要优点是具有可观测的度量尺度，以及翻滚角(roll)和俯仰角(pitch)。这让需要有尺度的状态估计的导航任务成为可能。此外，==对IMU测量值的积分可以显著提高运动跟踪性能，弥补光照变化、缺少纹理的区域或运动模糊的视觉轨迹损失的差距==。事实上，单目VINS不仅广泛应用于移动机器人、无人机和移动设备上，还是满足充分自我感知和环境感知的最小传感器。</p>
<p>然而，所有这些优点都是有代价的。对于单目VINS，众所周知，需要加速度激励以测量尺度。这意味着==单目VIN估计器不能从静止状态启动，而是从未知的移动状态发动==。同时要认识到视觉惯性系统高度非线性的事实，在估计器初始化方面还有重大挑战。两个传感器的存在也使得摄像机-IMU的外部校准至关重要。最后，为了消除在可接受的处理窗口内的长期漂移，提出了一个完整的系统，包括视觉惯性里程计、回环检测、重定位和全局优化。</p>
<p>为了解决所有这些问题，我们提出了VINS-Mono，一个鲁棒且通用的单目视觉惯性状态估计器。我们的解决方案开始于即时估计初始化。这个初始化模块也用于故障恢复。我们的解决方案的核心是一个鲁棒的基于紧耦合的滑动窗非线性优化的单目视觉惯性里程计(VIO)。==单目VIO模块不仅提供精确的局部姿态、速度和方位估计，而且还以在线方式执行摄像机IMU外部校准和IMU偏置校正==。使用DBoW2[6]进行回环检测。==重新定位是在对单目VIO进行特征级别融合的紧耦合设置中完成==。这使得重新定位具有鲁棒性和精确性且有最小的计算代价。最后，几何验证的回环被添加到位姿图中，并且由于来自单目VIO的可观测的翻滚角和俯仰角，生成四自由度(DOF)位姿图以确保全局一致性。</p>
<p>VINS-Mono结合并改进了我们先前在单目视觉-惯性融合方面的工作[7]-[10]。它建立在我们紧耦合、基于优化的单目VIO的公式之上[7][8]，并结合了[9]中引入的改进初始化过程。[10]中给出了移植到移动设备的第一次尝试。与我们以前的工作相比，VINS-Mono的进一步改进包括改进的含偏置校正的IMU预积分、紧耦合重定位、全局位姿图优化、广泛的实验评估以及鲁棒和通用的开源实现。</p>
<p>整个系统完整且易于使用。它已经被成功应用于小规模AR场景、中型无人机导航和大规模状态估计任务。与其他最先进的方法相比具有优异的性能。为此，我们总结了我们的贡献，如下所示：<br>1、一个鲁棒的初始化过程，它能够从未知的初始状态引导系统。<br>2、一个紧耦合、基于优化的单目视觉惯性里程计，具有相机-IMU外部校准和IMU偏置估计。<br>3、在线回环检测与紧耦合重定位。<br>4、四自由度全局位姿图优化。<br>5、用于无人机导航、大规模定位和移动AR应用的实时性能演示。<br>6、完全集成于ros的pc版本以及可在iphone 6或更高版本上运行的IOS版本的开源代码。</p>
<p>论文的其余部分如下：在第二节中，我们讨论了相关的文献。在第三节中，我们对完整的系统框架进行了概述。在第四节中，给出了视觉的预处理和IMU测量值的预积分步骤。在第五节中，我们讨论了估计器的初始化过程。在第六节中提出了一种紧耦合、自标定、非线性优化的单目VIO。第七节和第八节分别给出了紧耦合重定位和全局位姿图优化。实施细节和实验结果见第九节。最后，第十节本文对研究方向进行了探讨和展望。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019194830365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h1><p>关于基于单目视觉的状态估计/里程计SLAM的学术工作非常广泛。值得注意的方法包括PTAM[1]、SVO[2]、LSD-SLAM[3]、DSO[5]和ORB-SLAM[4]。显然，尝试对任何方法进行全面回顾都无法完整。然而，在这一节中，我们跳过了关于只使用视觉的方法的讨论，而只专注于关于单目视觉惯性状态估计的最相关的结果。<br>处理视觉和惯性测量的最简单的方法是松耦合的传感器融合[11][12]，其中IMU被视为一个独立的模块，用于辅助运动的视觉结构(sfm)获得的纯视觉位姿估计。融合通常由扩展卡尔曼滤波(EKF)完成，其中IMU用于状态传播，而视觉位姿用于更新。进一步说，紧耦合视觉惯性算法要么基于EKF[13]-[15]，要么基于图优化[7][8][16][17]，其中相机和IMU测量值是从原始测量水平联合优化的。一种流行的基于EKF的VIO方法是MSCKF[13][14]。MSCKF在状态向量中维护以前的几个摄像机位姿，并使用多个摄像机视图中相同特征的视觉测量来形成多约束更新。SR-ISWF[18][19]是MSCKF的扩展。它采用squareroot形式[20]实现单精度表示，避免了较差的数值性质。该方法采用逆滤波器进行迭代再线性化，使其与基于优化的算法相当。批量图优化或集束调整技术（BA）维护和优化所有测量值以获得最优状态估计。为了达到恒定的处理时间，==流行的基于图的VIO方法[8][16][17]通常采用边缘化过去的状态和测量来优化最近状态的有界滑动窗口==。由于对非线性系统迭代求解的计算要求很高，很少有基于图的非线性系统能够在资源受限的平台（如手机上）实现实时性能。</p>
<p>对于视觉测量处理，根据视差模型的定义，算法可分为直接法和间接法。直接法[2][3][21]最小化光度误差，而间接法最小化几何位移。直接法因其吸引区域小，需要很好的初始估计，而间接法在提取和匹配特征时需要额外的计算资源。间接法由于其成熟性和鲁棒性，在实际工程部署中得到了广泛的应用。然而，直接法更容易扩展到稠密建图，因为它们是直接在像素级别上操作的。</p>
<p>在实践中，IMU通常以比摄像机更高的速率获取数据。不同的方法被提出来处理高速率的IMU测量值。最简单的方法是在基于EKF的方法中使用IMU进行状态传播[11][13]。在图优化公式中，为了避免重复的IMU重复积分，提出了一种有效的方法，即IMU预积分(IMU pre-integration)。这种方法在[22]中首次提出的，它用欧拉角来参数化旋转误差。在我们先前的工作中[7]，我们提出了一种流形上的IMU预积分旋转公式，利用连续IMU误差状态动力学推导了协方差传递方程。然而IMU偏置被忽略了。在[23]中通过增加后验IMU偏置校正，进一步改进了预积分理论。</p>
<p>精确的初始值对于引导任何单目VINS是至关重要的。在[8][24]中提出了一种利用短期IMU预积分相对旋转的线性估计器初始化方法。但是，该方法不对陀螺仪偏置进行建模，无法在原始投影方程中对现代传感器噪声进行建模。在实际应用中，当视觉特性远离传感器套件时，这会导致不可靠的初始化。在[25]中给出了单目视觉惯性初始化问题的一种封闭解。随后，在[26]中提出了对这种封闭形式的解决方案的扩展，增加了陀螺仪的偏置校准。这些方法依赖于长时间内IMU测量的双重积分，无法模拟惯性积分的不确定性。在[27]中，提出了一种基于SVO的重初始化和故障恢复算法。这是一种基于松耦合融合框架的实用方法。然而，需要额外的朝下的距离传感器来恢复度量尺度。在[17]中引入了一种建立在ORB-SLAM[4]上的初始化算法。给出了一组ORB-SLAM的关键帧，计算了视觉惯性全局BA的尺度、重力方向、速度和IMU偏置的初步估计。然而，尺度收敛所需的时间可能超过10秒。这可能会给需要在一开始就进行尺度估计的机器人导航任务带来问题。</p>
<p>VIO方法，不管它们所依赖的基本数学公式，在全局的平移和旋转中长期受到漂移的影响。为此，回环检测在长期操作中起着重要的作用。ORB-SLAM[4] 利用了词袋模型能够闭合回环并重用地图。回环检测之后进行7自由度（位置、方向和尺度）的位姿图优化。相对于单目VINS，由于IMU的加入，漂移只发生在4自由度，即三维平移，和围绕重力方向的旋转（偏航角）。因此，本文选择在最小四自由度设定下，优化具有回环约束的位姿图。</p>
<h1 id="III-概述"><a href="#III-概述" class="headerlink" title="III.概述"></a>III.概述</h1><p>提出的单目视觉惯性状态估计器的结构如图2所示。该系统从测量预处理(IV)开始，在其中提取和跟踪特征，对两个连续帧间的IMU测量值进行预积分。初始化过程(V)提供了所有必要的值，包括姿态、速度、重力向量、陀螺仪偏置和三维特征位置，用于引导随后的基于非线性优化的VIO。VIO(VI)与重定位(VII)模块紧密地融合了预先积分的IMU测量、特征观测和回环重新检测到的特征。最后，位姿图优化模块(VIII)接受几何验证的重定位结果，并进行全局优化以消除漂移。VIO、重新定位和位姿图优化模块在多线程设置中同时运行。每个模块有不同的运行速度和实时保证，以确保在任何时候可靠运行。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920013857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们现在对整篇论文中使用的符号和坐标系进行定义。我们认为(.)w(.)w是世界坐标系(world frame)。重力方向与世界坐标系z轴对齐。$(⋅)b$是本体坐标系(body frame)，我们把它定义为与IMU坐标系相同。$(⋅)c$是相机坐标系(camera frame)。我们同时使用旋转矩阵R和Hamilton四元数q来表示旋转。我们主要在状态向量中使用四元数，也用旋转矩阵来表示三维向量的旋转。$q_{wb}，p_{wb}$​表示从本体坐标系到世界坐标系的旋转和平移。$b_k$​表示获取第k个图像时的本体坐标系。$c_k$表示获取第k个图像时的相机坐标系。⊗表示两个四元数之间的乘法运算。$g_w=[0,0,g]T$是世界坐标系上的重力向量。最后，我们将(^)表示为某一具体量的噪声测量值或估计值。</p>
<h1 id="IV-测量预处理"><a href="#IV-测量预处理" class="headerlink" title="IV.测量预处理"></a>IV.测量预处理</h1><p>本节介绍VIO的预处理步骤。对于视觉测量，我们跟踪连续帧之间的特征，并在最新帧中检测新特征。对于IMU测量，我们在两个连续帧之间做预积分。请注意，我们使用的低成本IMU的测量值受到偏置和噪声的影响。因此，我们在IMU预积分过程中特别考虑偏置。</p>
<h2 id="A-视觉处理前端"><a href="#A-视觉处理前端" class="headerlink" title="A.视觉处理前端"></a>A.视觉处理前端</h2><p>对于每一幅新图像，KLT稀疏光流算法对现有特征进行跟踪[29]。同时，检测新的角点特征[30]以保证每个图像特征的最小数目(100-300)。该检测器通过设置两个相邻特征之间像素的最小间隔来执行均匀的特征分布。二维特征首先是不失真的，然后在通过外点剔除后投影到一个单位球面上。利用基本矩阵模型的RANSAC算法进行外点剔除。<br>在此步骤中还选择了关键帧。我们有两个关键帧选择标准。第一是与上一个关键帧的平均视差。如果在当前帧和最新关键帧之间跟踪的特征点的平均视差超出某个特定阈值，则将该帧视为新的关键帧。请注意，不仅平移，旋转也会产生视差。然而，特征点无法在纯旋转运动中三角化。为了避免这种情况，在计算视差时我们使用陀螺仪测量值的短时积分来补偿旋转。请注意，此旋转补偿仅用于关键帧选择，而不涉及VINS公式中的旋转计算。为此，即使陀螺仪含有较大的噪声或存在偏置，也只会导致次优的关键帧选择结果，不会直接影响估计质量。另一个标准是跟踪质量。如果跟踪的特征数量低于某一阈值，我们将此帧视为新的关键帧。这个标准是为了避免跟踪特征完全丢失。</p>
<h1 id="B-IMU预积分"><a href="#B-IMU预积分" class="headerlink" title="B.IMU预积分"></a>B.IMU预积分</h1><p>IMU预积分是在[22]中首次提出的，它将欧拉角的旋转误差参数化。在我们先前的工作中[7]，我们提出了一个流形上的IMU预积分旋转公式。该文利用连续时间的IMU误差状态动力学推导协方差传递函数，但忽略了IMU偏置。文[23]通过增加后验IMU偏置校正，进一步改进了预积分理论。本文通过引入IMU偏置校正，扩展了我们在前面工作[7]中提出的IMU预积分。<br>IMU的原始陀螺仪和加速度计测量结果$\hat w$ 和$\hat a$如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019201549992.png#pic_center"><br>IMU测量值是在本体坐标系中测量的，它是平衡重力和平台动力的合力，并受到加速度偏置$b_a$、陀螺仪偏置$b_w$和附加噪声的影响。假设加速度计和陀螺仪测量值中的附加噪声为高斯噪声，$n_a～N(0,sigma^2_a)$，$n_w～N(0,sigma^2_w)$​。加速度计偏置和陀螺仪偏置被建模为随机游走，其导数为高斯性的，$n_{ba}～N(0,σ^2_{ba})$，$n_{bw}～N(0,σ^2_{bw})$。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202057834.png#pic_center"></p>
<p>给定对应于体坐标系$b_k$和$b_{k+1}$的两个时刻，位置、速度和方向状态可以在时间间隔$[t_k,t_{k+1}]$间，在世界坐标系下中通过惯性测量值传递：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202237245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$∆t_k$是时间间隔$[t_k,t_{k+1}]$之间的持续时间。</p>
<p>可见，IMU状态传递需要坐标系$b_k$的旋转、位置和速度。当这些起始状态改变时，我们需要重新传递IMU测量值。特别是在基于优化的算法中，每次调整位姿时，都需要在它们之间重新传递IMU测量值。这种传递策略在计算上要求很高。为了避免重新传递，我们采用了预积分算法。<br>将参考坐标系从世界坐标系转变为局部坐标系$b_k$后，我们只能对线性的加速度$\hat a$和角速度$\hat w$相关的部分进行预积分，如下所示：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202449110.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202554843.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920251370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以看出预积分项(6)能通过将$b_k$视为参考帧的IMU测量值单独得到。$α^{b_k}_{k+1}$、$β^{b-k}b_{k+1}$、$γ^{b-k}_{k+1}$只与$b_k$和$b_{k+1}$中的IMU偏置有关，与其他状态无关。当偏置估计发生变化时，若偏置变化很小，我们将$α^{bk}_{k+1}、β^{bk}b_{k+1}、γ^{bk}_{k+1}$按其对偏置的一阶近似来调整，否则就进行重新传递。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传递IMU测量值。</p>
<p>对于离散时间的实现，可以采用不同的数值积分方法，如欧拉积分、中点积分、RK4积分等。这里选择了欧拉积分来演示易于理解的过程(我们在代码中使用了中点积分)。</p>
<p>在开始时，$\alpha^{bk}_{k}$、$β^{bk}_{k}$是0，$\gamma^{bk}_{k}$是单位四元数。$α$，$β$，$γ$在(6)中的平均值是如下逐步传递的。注意，增加的噪声项$n_a$，$n_w$是未知的，在实现中被视为零。这得到了预积分的估计值，标记为$(\hat⋅)$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203125870.png#pic_center"><br>i是在$[t_k,t_{k+1}]$中IMU测量值对应的离散时刻，$δ_t$是IMU测量值i和i+1之间的时间间隔。</p>
<p>然后讨论协方差传递问题。由于四维旋转四元数$γ^{b_k}_t$被过参数化，我们将其误差项定义为围绕其平均值的扰动：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203259791.png#pic_center"><br>其中$δθ^{b_k}_t$是三维小扰动。</p>
<p>我们可以导出误差项的连续时间线性化方程(6)：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203414375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$P^{bk}_{b_{k+1}}$可以通过初始协方差$P^{b_k}_{b_k}=0$的一阶离散时间协方差更新递归计算：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203627976.png#pic_center"><br>其中Q是噪声的对角线协方差矩阵$(σ^2_a,σ^2_w,σ^2_{b_a},σ^2_{b_w})$</p>
<p>同时，$δz_{b_{k+1}}^{b_k}$​的一阶雅可比矩阵$J_{b_{k+1}}$​​相对于δzbk​bk​​也可以用初始雅可比矩阵$J_{b_k}=I$ 递归计算。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203912837.png#pic_center"><br>利用这个递推公式，得到协方差矩阵$P^{b_k}_{b_{k+1}}$​​和雅可比矩阵$J^{b_k}_{b_{k+1}}$​​、$α^{b_k}_{b_{k+1}}$、$β^{b_k}_{b_{k+1}}$、$γ^{b_k}_{b_{k+1}}$关于偏置的一阶近似可以写为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203947220.png#pic_center"><br>其中$J^α_{b_a}$是$J_b{k+1}$中的子块矩阵，其位置对应于$\frac{δα^{b_k}_{b_{k+1}}}{δb_{a_k}}$。<br>$J^α_{b_w}、J^β_{b_a}、J^β_{b_w}、J^γ_{b_w}$也使用同样的含义。当偏置估计发生轻微变化时，我们使用(12)近似校正预积分结果，而不重新传递。</p>
<p>现在我们可以写下IMU测量模型所其对应的协方差$P^{b_k}_{b_{k+1}}$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204124533.png#pic_center"></p>
<h1 id="V-估计器初始化"><a href="#V-估计器初始化" class="headerlink" title="V.估计器初始化"></a>V.估计器初始化</h1><p>单目紧耦合VIO是一个高度非线性的系统。由于单目相机无法直接观测到尺度，因此，如果没有良好的初始值，很难直接将这两种测量结果融合在一起。可以假设一个静止的初始条件来启动单目VINS估计器。然而，这种假设是不合适的，因为在实际应用中经常会遇到运动下的初始化。当IMU测量结果被大偏置破坏时，情况就变得更加复杂了。事实上，初始化通常是单目VINS最脆弱的步骤。需要一个鲁棒的初始化过程以确保系统的适用性。</p>
<p>我们采用松耦合的传感器融合方法得到初始值。我们发现纯视觉SLAM，或从运动中恢复结构(SfM)，具有良好的初始化性质。在大多数情况下，纯视觉系统可以通过从相对运动方法（如八点法[32]或五点法[33]或估计单应性矩阵）中导出初始值来引导自己。通过对齐IMU预积分与纯视觉SfM结果，我们可以粗略地恢复尺度、重力、速度，甚至偏置。这足以引导非线性单目VINS估计器，如图4所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204212487.png#pic_center"><br>与在初始阶段同时估计陀螺仪和加速度计偏置的[17]相比，我们在初始阶段选择忽略加速度计偏置项。加速度计偏置与重力耦合，且由于重力向量相对于平台动力学的大量级，以及初始阶段相对较短，这些偏置项很难被观测到。我们以前的工作对加速度计偏置标定进行了详细的分析[34]。</p>
<h1 id="A-滑动窗口-Sliding-Window-纯视觉SfM"><a href="#A-滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="A. 滑动窗口(Sliding Window)纯视觉SfM"></a>A. 滑动窗口(Sliding Window)纯视觉SfM</h1><p>初始化过程从纯视觉SfM估计相机尺度位姿(up-to-scale)和特征位置图开始。</p>
<p>我们保持了一个帧的滑动窗口来限制计算复杂度。首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，我们使用五点法[33]恢复这两个帧之间的相对旋转和尺度平移。否则，我们将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，我们任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP[35]来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)[36]最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c_0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}_{c_k}，q^{c0}_{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"><br>其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p>
<h2 id="B-视觉惯性校准"><a href="#B-视觉惯性校准" class="headerlink" title="B. 视觉惯性校准"></a>B. 视觉惯性校准</h2><p>1）陀螺仪偏置标定：考虑窗口中连续两帧bk和bk+1，我们从视觉sfM中得到旋转$q^{c0}_{b_k}$和$q^{c0}_{b_{k+1}}$​​，从IMU预积分得到的相对约束$γ^{b_k}_{b_{k+1}}$​。我们对陀螺仪偏置求IMU预积分项的线性化，并最小化以下代价函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"><br>其中B代表窗口的所有帧。利用第四部分导出的偏置雅可比，给出了$γ^{b_k}_{b_{k+1}}$​对陀螺仪偏置的一阶近似。这样，我们得到了陀螺仪偏置bw的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}_{b_{k+1}}、\hat β^{b_k}_{b_{k+1}}、\hat γ^{b_k}_{b_{k+1}}$ 。</p>
<p>2）速度、重力向量和尺度初始化：在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"><br>其中，$v^{b_k}_{b_k}$​​是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。</p>
<p>考虑窗口中两个连续帧$b_k$和$b_{k+1}$，那么(5)可以写成：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205047939.png#pic_center"><br>我们可以将(14)和(17)合并成以下线性测量模型：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204900731.png#pic_center"><br>可以看出，$R^{c_0}_{b_k}，R^{c_0}_{b_{k+1}}，\hat p^{c_0}_{c_k}，\hat p^{c_0}_{c_{k+1}}$是从带尺度的单目视觉中得到的，$∆t_k$是两个连续帧之间的时间间隔。通过求解线性最小二乘问题：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205002105.png#pic_center"><br>我们可以得到窗口中每一帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及尺度参数。</p>
<p>3）重力细化：通过约束量值，可以对原线性初始化步骤得到的重力向量进行细化。在大多数情况下，重力向量的大小是已知的。这导致重力向量只剩2个自由度。因此，我们在其切线空间上用两个变量重新参数化重力。参数化将重力向量表示为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205157776.png#pic_center"><br>其中g是已知的重力大小，$\bar {\hat g}$​​是表示重力方向的单位向量，b1和b2是跨越切平面的两个正交基，如图5所示，w1和w2分别是在b1和b2上的对应位移。通过算法1的叉乘运算，可以找到一组b1、b2。然后用</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920522547.png#pic_center"><br>代替(17)中的g，并与其它状态变量一起求解w1和w2。此过程迭代到$\bar {\hat g}$收敛为止。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205247493.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>4）完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$​。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p>
<h1 id="VI-紧耦合单目VIO"><a href="#VI-紧耦合单目VIO" class="headerlink" title="VI. 紧耦合单目VIO"></a>VI. 紧耦合单目VIO</h1><p>在估计器初始化后，我们采用基于滑动窗口的紧耦合单目VIO进行高精度和鲁棒的状态估计。图3显示了滑动窗口的图示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205519675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="A-公式"><a href="#A-公式" class="headerlink" title="A. 公式"></a>A. 公式</h2><p>滑动窗口中的完整状态向量定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205554259.png#pic_center"><br>其中$x_k$是捕获第k图像时的IMU状态。它包含了IMU在世界坐标系中的位置、速度和方向，以及在IMU本体坐标系中的加速度计偏置和陀螺仪偏置。n是关键帧的总数，m是滑动窗口中的特征总数，$λ_l$是第一次观测到第l个特征的逆深度。</p>
<p>我们使用视觉惯性BA。我们最小化所有测量残差的先验和Mahalanobis范数之和，得到最大后验估计：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205631782.png#pic_center"><br>$r_B​(z^{b_k}_{b_{k+1}},X)$和$r_C(\hat z_l^{c_j},X)$分别是IMU和视觉测量的残差。残差的详细定义将在第六节的B和C中提出。B是所有IMU测量的集合，C是在当前滑动窗口中至少观察到两次的一组特征。${r_p,H_p}$是来自边缘化的先验信息。Ceres Solver[38]被用来解决这个非线性问题。</p>
<h2 id="B-IMU测量残差"><a href="#B-IMU测量残差" class="headerlink" title="B. IMU测量残差"></a>B. IMU测量残差</h2><p>考虑滑动窗口中连续两个帧$b_k$和$b_{k+1}$内的IMU测量，根据(13)中定义的IMU测量模型，预积分IMU测量的残差可以定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205738287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>其中，$[·]_{xyz}$是提取四元数q的向量部分，以进行误差状态表示。$δθ^{bk}_{b_{k+1}}$​​是四元数的三维误差状态表示。$[\hat α^{b_k}_{b{k+1}}、\hat β^{b_k}_{b{k+1}}      \hat γ^{b_k}_{b{k+1}}]^T$是在两个连续图像帧的间隔时间内使用仅包含噪声的加速度计和陀螺仪测量值预积分的IMU测量项。加速度计和陀螺仪偏置也包括在在线校正的剩余项中。</p>
<h2 id="C-视觉测量残差"><a href="#C-视觉测量残差" class="headerlink" title="C. 视觉测量残差"></a>C. 视觉测量残差</h2><p>与在广义图像平面上定义重投影误差的传统针孔相机模型相比，我们在单位球面上定义摄像机的测量残差。几乎所有类型相机的光学，包括广角、鱼眼或全向相机，都可以模拟为连接单位球体表面的单位射线。假设第l个特征在第i幅图像中被第一次观察到，第j幅图像中的特征观测的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205925902.png#pic_center"><br>其中$[u^{c_i}_l,v^{c_i}_l]$是第一次观测到出现在第i图像中的第l个特征。$[\hat u^{c_i}_l,\hat v^{c_i}_l]$是在第j图像中对相同特征的观察。$π^{−1}_c$​是利用摄像机内参将像素位置转换成单位向量的反投影函数。由于视觉残差的自由度是2，所以我们将残差向量投影到切平面上。如图6所示，b1、b2是在切平面$\hat {\bar P^{c_j}_l}$上的两个任意选择的正交基。我们可以很容易地找到一组$b_1、b_2$，如算法1所示。在(22)中使用的$P^{c_j}_l$​​是正切空间中固定长度的标准协方差。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210021988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="D-边缘化"><a href="#D-边缘化" class="headerlink" title="D. 边缘化"></a>D. 边缘化</h2><p>为了限制基于优化的VIO的计算复杂度，本文引入了边缘化。我们有选择地从滑动窗口中将IMU状态xK和特征λ1边缘化，同时将对应于边缘状态的测量值转换为先验。</p>
<p>如图7所示，当倒数第二帧是关键帧时，它将停留在窗口中，而最旧的帧与其相应的测量值被边缘化。但如果倒数第二帧是非关键帧，我们丢掉视觉测量值，保留连接到这个非关键帧的IMU测量值。为了保持系统的稀疏性，我们不会边缘化非关键帧的所有测量值。我们的边缘化方案旨在保持窗口中空间分离的关键帧。这确保了特征三角化有足够的视差，并且最大化了在大激励下获得加速度计测量值的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210401727.png#pic_center"></p>
<h2 id="E-摄像机速率状态估计的纯运动视觉惯性BA"><a href="#E-摄像机速率状态估计的纯运动视觉惯性BA" class="headerlink" title="E. 摄像机速率状态估计的纯运动视觉惯性BA"></a>E. 摄像机速率状态估计的纯运动视觉惯性BA</h2><p>对于计算能力较低的设备如手机，由于对非线性优化的计算要求很高，紧耦合单目VIO无法实现摄像机速率输出。为此，我们采用了一种轻量级的纯运动视觉惯性BA，以提升状态估计速率到相机速率(30Hz)。</p>
<p>纯运动单目视觉惯性BA的代价函数与(22)中单目VIO的代价函数相同。然而我们只对固定数量的最新IMU状态的姿态和速度进行了优化，而不是对滑动窗口中的所有状态进行优化。我们将特征深度、外部参数、偏置和旧的IMU状态这些不希望优化的状态作为常量来处理。我们使用所有的视觉和惯性测量来进行纯运动的BA。这导致了比单帧PnP方法更平滑的状态估计。图8显示了提出方法的插图。与在最先进的嵌入式计算机上可能导致超过50ms的完全紧耦合单目VIO不同，这种纯运动的视觉惯性BA只需大约5ms来计算。这使得低延迟的相机频率进行位姿估计对无人机和AR应用特别有利。<br>F. IMU前向传递以达到IMU速率状态估计</p>
<p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="F-IMU前向传递以达到IMU速率状态估计"><a href="#F-IMU前向传递以达到IMU速率状态估计" class="headerlink" title="F. IMU前向传递以达到IMU速率状态估计"></a>F. IMU前向传递以达到IMU速率状态估计</h2><p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="G-故障检测与恢复"><a href="#G-故障检测与恢复" class="headerlink" title="G. 故障检测与恢复"></a>G. 故障检测与恢复</h2><p>虽然我们紧耦合的单目视觉对各种具有挑战性的环境和运动是鲁棒的。由于强烈的光照变化或剧烈的运动，故障仍然是不可避免的。主动故障检测和恢复策略可以提高系统的实用性。故障检测是一个独立的模块，它检测估计器的异常输出。我们目前使用以下标准进行故障检测：<br>1、在最新帧中跟踪的特征数小于某一阈值；<br>2、最近两个估计器输出之间的位置或旋转有较大的不连续性；<br>3、偏置或外部参数估计有较大的变化；</p>
<p>一旦检测到故障，系统将切换回初始化阶段。一旦单目VIO被成功初始化，将新建一个独立的位姿图。</p>
<h1 id="VII-重定位"><a href="#VII-重定位" class="headerlink" title="VII. 重定位"></a>VII. 重定位</h1><p>我们的滑动窗口和边缘化方案限制了计算的复杂性，但也给系统带来了累积漂移。更确切地说，漂移发生在全局三维位置(x,y,z)和围绕重力方向的旋转(yaw)。为了消除漂移，提出了一种与单目VIO无缝集成的紧耦合重定位模块。重定位过程从一个循环检测模块开始，该模块识别已经访问过的地方。然后建立回环检测候选帧和当前帧之间的特征级连接。这些特征的对应关系紧密地集成到单目VIO模块中，从而以最小计算代价得到无漂移状态估计。多个特征的多个观测直接用于重定位，从而提高了定位的精度和状态估计的平滑性。重定位过程如图9(a)所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210456719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-特征恢复"><a href="#B-特征恢复" class="headerlink" title="B. 特征恢复"></a>B. 特征恢复</h2><p>当检测到回路时，通过检索特征对应关系建立局部滑动窗口与回环候选帧之间的连接。通过BRIEF描述子匹配找到对应关系。直接描述子匹配可能会造成大量异常值。为此，我们使用两步进行几何异常值剔除，如图10所示。<br>1、2D-2D：RANSAC[31]的基本矩阵检验。我们利用当前图像中检索到的特征的二维观测和回环候选图像进行基本矩阵检验。<br>2、3D-2D：RANSAC的PNP检验。基于特征在局部滑动窗口中已知的三维位置，以及回环候选图像中的二维观测，进行PNP检验。</p>
<p>当内点超过一定阈值时，我们将该候选帧视为正确的循环检测并执行重定位。</p>
<h2 id="C-紧耦合重定位"><a href="#C-紧耦合重定位" class="headerlink" title="C. 紧耦合重定位"></a>C. 紧耦合重定位</h2><p>重定位过程有效地使单目VIO(VI)维持的当前滑动窗口与过去的位姿图对齐。在重定位过程中，我们将所有回环帧的位姿作为常量。利用所有IMU测量值、局部视觉测量和从回环中提取特征对应值，共同优化滑动窗口。我们可以轻松地为回环帧v观察到的检索特征编写视觉测量模型，使其与VIO中的视觉测量相同，如(25)所示。唯一的区别是，从位姿图(VIII)或直接从上一个里程计的输出（如果这是第一次重定位）获得的回环帧的姿态$(\hat q^w_v,\hat p^w_v)$<br>(q^​vw​,p^​vw​)被视为常数。为此，我们可以在(22)中稍微修改非线性代价函数，增加回环项：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210641949.png#pic_center"><br>其中L是回环帧中检索到的特征的观测集。$(l,v)$是指在回环帧v中观察到的第l个特征。虽然代价函数与(22)略有不同，但待解状态的维数保持不变，因为回环帧的构成被视为常数。当用当前滑动窗口建立多个回环时，我们同时使用来自所有帧的所有回环特征对应进行优化。这就为重定位提供了多视角的约束，从而提高了定位的精度和平滑性。请注意，过去的姿态和回环帧的全局优化发生在重定位之后，将在第八节中讨论。</p>
<h1 id="VIII-全局位姿图优化"><a href="#VIII-全局位姿图优化" class="headerlink" title="VIII. 全局位姿图优化"></a>VIII. 全局位姿图优化</h1><p>重新定位后，局部滑动窗口移动并与过去的位姿对齐。利用重定位结果，开发了额外的位姿图优化步骤，以确保过去位姿集注册到全局一致的配置中。</p>
<p>由于视觉惯性的建立使翻滚角和俯仰角完全可观测，累积漂移只发生在四个自由度(x，y，z和yaw)。为此，我们忽视对无漂移翻滚和俯仰状态的估计，只进行了四自由度位姿图的优化。</p>
<h2 id="A-在位姿图中添加关键帧"><a href="#A-在位姿图中添加关键帧" class="headerlink" title="A. 在位姿图中添加关键帧"></a>A. 在位姿图中添加关键帧</h2><p>当关键帧从滑动窗口被边缘化时，它将被添加到位姿图中。这个关键帧在位姿图中作为顶点，它通过两种类型的边与其他顶点连接：</p>
<p>1）顺序边(Sequential Edge)：关键帧将建立与之前关键帧的若干顺序边。顺序边表示局部滑动窗口中两个关键帧之间的相对转换，其值直接从VIO中获取。考虑到新边缘化的关键帧i及其先前的一个关键帧j，顺序边只包含相对位置和偏航角。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210857102.png#pic_center">)<br>2）回环边(Loop Closure Edge)：如果新边缘化的关键帧有一个回环连接，它将与回环帧通过一个回环边在位姿图图中连接。同样，闭环边缘只包含与(27)相同定义的四自由度相对位姿变换。回环边的值由重定位结果得出。</p>
<h2 id="B-4自由度位姿图优化"><a href="#B-4自由度位姿图优化" class="headerlink" title="B. 4自由度位姿图优化"></a>B. 4自由度位姿图优化</h2><p>我们将帧i和j之间边的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210815393.png#pic_center"><br>其中，$\hat \phi _i，\hat    θ_i$是直接从单目VIO中得到的翻滚角和俯仰角的估计。</p>
<p>通过最小化以下代价函数，对顺序边和回环边的整个图进行优化：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921101530.png#pic_center"></p>
<p>其中S是所有顺序边的集合，L是回环边的集合。尽管紧耦合的重定位已经有助于消除错误的回环，但我们添加了另一个Huber范数 $ρ(·)$，以进一步减少任何可能的错误回环的影响。相反，我们不对顺序边使用任何鲁棒范数，因为这些边是从VIO中提取出来的，VIO已经包含了足够多的外点排除机制。</p>
<p>位姿图优化和重定位(VII-C)异步运行在两个独立的线程中。以便在需要重定位时，能立即使用最优化的位姿图。同样，即使当前的位姿图优化尚未完成，仍然可以使用现有的位姿图配置进行重新定位。这一过程如图9(b)所示。</p>
<h2 id="C-位姿图管理"><a href="#C-位姿图管理" class="headerlink" title="C. 位姿图管理"></a>C. 位姿图管理</h2><p>随着行程距离的增加，位姿图的大小可能会无限增长，从而限制了长时间系统的实时性。为此，我们实行了一个下采样过程，将位姿图数据库保持在有限的大小。所有具有回环约束的关键帧都将被保留，而其他与相邻帧过近或方向非常相似的关键帧可能会被删除。关键帧被移除的概率和其相邻帧的空间密度成正比。</p>
<h1 id="IX-实验结果"><a href="#IX-实验结果" class="headerlink" title="IX. 实验结果"></a>IX. 实验结果</h1><p>我们进行了三个实验和两个应用，以评估所提出的VINS-Mono系统。在第一个实验中，我们将提出的算法与另一种最先进算法在公共数据集上进行比较。我们通过数值分析以验证了系统的精度。然后在室内环境中测试我们的系统，以评估在重复场景中的性能。通过大量的实验验证了系统的长期实用性。此外，我们还将所提出的系统应用于两个应用。对于空中机器人的应用，我们使用VINS-Mono作为位置反馈来控制无人机跟踪预定的轨迹。然后我们将我们的方法移植到iOS移动设备上，并与Google Tango进行比较。</p>
<h2 id="A-数据集比较"><a href="#A-数据集比较" class="headerlink" title="A. 数据集比较"></a>A. 数据集比较</h2><p>我们使用EuRoC MAV视觉-惯性数据集[41]评估我们提出的VINS-Mono。这个数据集是在一架微型飞行器上收集的，它包含立体图像(Aptina MT9V034全局快门、WVGA单色、20 FPS)、同步IMU测量(ADIS 16448、200 Hz)和地面真实状态(Vicon和Leica MS 50)。我们只使用左边相机的图像。在这数据集中会观察到较大的IMU偏置和光照变化。</p>
<p>在这些实验中，我们将VINS-Mono和OKVIS进行了比较，这是一种最先进的单目和立体相机VIO。OKVIS是另一种基于优化的滑动窗口算法。我们的算法与OKVIS在许多细节上是不同的，如技术部分所示。我们的系统具有良好的初始化和回环功能。我们使用MH_03_median和MH_05_difficult两组序列来证明该方法的性能。为了简化表示，我们使用VINS来表示我们只使用单目VIO的方法，而VINS_loop表示含重定位和位姿图优化的完全版本。我们分别用OKVIS_Mono和OKVIS_stereo表示OKVIS使用单目和立体图像的结果。为了进行公平的比较，我们丢弃前100个输出，并使用接下来的150个输出对齐地面真值，并比较其余的估计器输出。</p>
<p>MH_03_median序列轨迹如图11所示。我们只比较平移误差，因为旋转运动在这个序列中是可以忽略的。图12显示了x、y、z误差与时间的关系，以及平移误差与距离的关系。在误差图中，具有回环的VINS-Mono具有最小的平移误差。我们在MH_05_difficult上观察到类似的结果。该方法具有最小的平移误差。平移和旋转误差如图14所示。由于该序列运动平稳，偏角变化不大，只发生位置漂移。显然，回环闭合有效地约束了累积漂移。OKVIS在翻滚角和俯仰角估计方面表现更好。一个可能的原因是VINS-Mono采用了预积分技术，即IMU传递的一阶近似，以节省计算资源。</p>
<p>VINS-Mono在所有Euroc数据集中都表现良好，即使在最具挑战性的序列V1_03_difficult中，它具有剧烈性的运动、纹理较少的区域和显著的光照变化。由于采用了专用的初始化过程，该方法可以在V1_03_difficult快速初始化。</p>
<p>对于纯VIO，VINS-Mono和OKVIS具有相似的精度，很难区分哪个比较好。然而，VINS-Mono在系统级别上优于OKVIS。它是一个完整的系统，具有鲁棒的初始化和回环闭合功能来辅助单目视觉。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211301627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211334529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-室内实验"><a href="#B-室内实验" class="headerlink" title="B. 室内实验"></a>B. 室内实验</h2><p>在室内实验中，我们选择实验室环境作为实验区域。我们使用的传感器套件如图15所示。它搭载在DJI A3控制器上，包含一个单目照相机（20Hz）和一个IMU（100 Hz）。我们手握传感器套件，在实验室以正常的速度行走。如图16所示，我们遇到行人，光线较弱的位置，纹理较少的区域，玻璃和反射。多媒体附件中可以找到视频。 </p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211501205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们将我们的结果与OKVIS进行了比较，如图17所示。图17(a)是OKVIS的VIO输出。图17(b)是所提出的无回环方法的VIO结果。图17©是所提出的具有重定位和回环闭合的方法的结果。当我们在室内转圈时，会出现明显的漂移。OKVIS和只有VIO版本的VINS-Mono在x、y、z和偏航角上积累了大量漂移。我们的重定位和回环闭合模块有效地消除了所有这些漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211551914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="C-大范围环境"><a href="#C-大范围环境" class="headerlink" title="C. 大范围环境"></a>C. 大范围环境</h2><p>1）走出实验室：我们在室内和室外混合环境中测试VINS-Mono。传感器套件与图15所示的相同。我们从实验室的一个座位上开始，在室内空间里走来走去。然后我们下楼，在大楼外的操场上走来走去。接下来，我们回到楼里并上楼。最后，我们回到了实验室的同一个座位。整个轨迹超过700米，持续约10分钟。在多媒体附件中可以找到实验的视频。</p>
<p>轨迹如图19所示。图19(a)是OKVIS的轨迹。当我们上楼时，OKVIS显示出不稳定的特征跟踪，导致估计错误。我们看不到红色街区楼梯的形状。VINS-Mono的纯VIO结果如图19(b)所示。有闭环的轨迹如图19©所示。该方法的楼梯形状清晰。为验证其准确性，将闭环轨迹与谷歌地图对齐，如图18所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921164349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>OKVIS的 x、y和z轴的最终漂移为[13.80,-5.26,7.23]米。VINS-Mono无环闭路的最终漂移为[-5.47,2.76,-0.29]m，占整个轨迹长度的0.88%，小于OKVIS的2.36%。经回环修正，最终漂移上界为[-0.032,0.09,-0.07]m，与整个轨迹长度相比这是微不足道的。虽然我们没有地面真值，但我们仍然可以直观地检查优化后的轨迹是否平滑并能精确地与卫星地图对齐。</p>
<p>2）环游校园：这张环绕整个科大校园的非常大规模的数据集是用一个手持的VI-Sensor 4记录下来的。该数据集覆盖的地面长度约为710米，宽度为240米，高度变化为60米。总路径长度为5.62km。数据包含25Hz图像和200Hz IMU，持续1小时34分钟。对VINS-Mono的稳定性和耐久性进行测试是一个非常有意义的实验。</p>
<p>在这个大规模的测试中，我们将关键帧数据库的大小设置为2000，以提供足够的回环信息并达到实时性。我们运行此数据集时，采用英特尔i7-4790 CPU运行在3.60GHz。时间统计数据显示在表I中。如图20，估计的轨迹与谷歌地图一致。与谷歌地图相比，我们的结果在这个非常长时间的测试中几乎没有漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921174092.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211751315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>D. 应用1：航空机器人的反馈控制</p>
<p>如图21(a)所示，我们将VINS-Mono应用于航空机器人的自主反馈控制。我们使用了一个具有752×480分辨率的前向全局曝光相机(MatrixVisionMvBlueFOXMLC200w)，并配备了190度鱼眼镜头。DJIA3飞行控制器用于IMU测量和姿态稳定控制。机载计算资源是Intel i7-5500 U CPU运行在3.00GHz。传统的针孔摄像机模型不适用于大视场摄像机。我们使用MEI[42]模型，由[43]介绍的工具包进行校准。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211839510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>在本实验中，我们测试使用VINS_Mono的状态估计来进行自主轨迹跟踪的性能。实验中回环检测被禁止。四旋翼被命令跟踪一个八字形图案，每个圆圈半径为1.0米，如图21(b)所示。在轨迹周围设置了四个障碍物，以验证VINS-Mono无闭环的准确性。在实验过程中，四旋翼连续四次跟踪这一轨迹。100 Hz机载状态估计(VI-F)支持对四旋翼的实时反馈控制。</p>
<p>地面真值是用OptiTrack 5获得的。总轨迹长度为61.97 m。最终漂移为[0.08，0.09，0.13]m，为0.29%的位置漂移。平移和旋转的细节以及它们相应的误差如图23所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211919318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="E-应用2：移动设备"><a href="#E-应用2：移动设备" class="headerlink" title="E. 应用2：移动设备"></a>E. 应用2：移动设备</h2><p>我们将VINS-Mono移植到移动设备上，并提供一个简单的AR应用程序来展示其准确性和鲁棒性。我们将我们的移动实现命名为VINS-Mobile6，并将其与Google Tango Device 7进行了比较，后者是移动平台在商业上最好的增强现实解决方案之一。</p>
<p>VINS-Mono运行在iPhone7 Plus上。我们使用iPhone采集的30 Hz、分辨率为640×480的图像，以及内置InvenSense MP67B 6轴陀螺仪和加速度计获得的100 Hz 的IMU数据。如图24所示，我们将iPhone与一个启用Tango功能的联想Phab 2 Pro一起安装。Tango设备使用全局快门、鱼眼相机和同步IMU进行状态估计。首先，我们在从估计的视觉特征中提取出来的平面上插入一个虚拟立方体，如图25(a)所示。然后，我们拿着这两个装置，以正常的速度在房间内外行走。当检测到回环时，我们使用四自由度位姿图优化(VIII-B)，以消除x，y，z和yaw漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212019875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212037844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921210026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>有趣的是，当我们打开一扇门时，Tango的偏航角估计会跳转到一个很大的角度，如图25(b)所示。其原因可能是由于不稳定的特征跟踪或主动故障检测和恢复而导致的估计器崩溃。然而，VINS-Mono在这个具有挑战性的情况中仍然表现很好。行走了大约264米后我们回到起点。最后的结果可以在图25( c)中看到，Tango的轨迹在最后一圈会漂移，而我们的VINS会回到起点。四自由度位姿图的优化消除了总轨迹的漂移。这与开始相比，立方体被标记到图像上的同一位置也印证了这一点。</p>
<p>诚然，尤其是对局部状态的估计，Tango比我们的实现更准确。但是实验结果表明，我们的方法可以在通用移动设备上运行，并且具有媲美特殊工程设备的潜力。实验还证明了该方法的鲁棒性。视频可以在多媒体附件中找到。</p>
<h1 id="X-结论和未来工作"><a href="#X-结论和未来工作" class="headerlink" title="X. 结论和未来工作"></a>X. 结论和未来工作</h1><p>本文提出了一种鲁棒、通用的单目视觉惯性估计器。我们的方法在IMU预积分，估计器初始化和故障恢复，在线外部校准，紧耦合视觉惯性里程计，重定位和有效的全局优化上，具有最先进的和新颖的解决方案。我们通过与最先进的开源实现和高度优化的行业解决方案进行比较，显示出更好的性能。我们开源了PC和iOS的实现，以造福社会。</p>
<p>虽然基于特征的VINS估计器已经达到了实际使用的成熟程度，我们仍然看到了未来研究的许多方向。单目VINS可能会根据运动和环境而达到较难观测甚至退化的状态。我们最感兴趣的是在线方法来评估单目VINS的可观测性，以及在线生成运动计划来恢复可观测性。另一个研究方向是在大量消费设备上大规模部署单目VINS，例如移动电话。这一应用要求在线校准几乎所有传感器的内参和外参，以及在线鉴定校准质量。最后，我们感兴趣的是制作由单目VINS给出的稠密地图。我们在[44]中首次给出了用于无人机导航的单目视觉-惯性稠密地图的结果。然而，仍需进行广泛的研究以进一步提高系统的精度和鲁棒性。</p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>8.二叉树的下一节点</title>
    <url>/2019/10/19/8.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目：<br>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。<br>树中的结点不仅包含左右子节点的指针，同时包含指向父结点的指针。<br>思路：</p><ul>
<li>如果一个节点有右子树，那么它的下一个节点就是它的右子树的最左子节点</li>
<li>没有右子树，分两种情况<blockquote>
<p>1.它是它父节点的左子节点，那么它的下一个节点就是它的父节点<br>2.它是它父节点的右子节点，可以沿着指向父节点的指针一直向上遍历，直到找到==一个是它的父节点的左子节点的节点==，如果这个节点存在，那么这个节点的父节点就是要找的下一个节点<br><strong>C++</strong></p>
</blockquote>
</li>
</ul><a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode *father;</span><br><span class="line"> *     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), father(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        TreeNode* p_next=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p_right=p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(p_right-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">               p_right=p_right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p_next=p_right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;father)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p_current=p;</span><br><span class="line">            TreeNode* p_father=p-&gt;father;</span><br><span class="line">            <span class="keyword">while</span>(p_father &amp;&amp; p_current==p_father-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                p_current=p_father;</span><br><span class="line">                p_father=p_father-&gt;father;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p_next=p_father;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p_next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.father = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> p==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        p_next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span>(p.right):</span><br><span class="line">            p_right=p.right</span><br><span class="line">            <span class="keyword">while</span> p_right.left:</span><br><span class="line">                p_right=p_right.left</span><br><span class="line">            p_next=p_right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span>(p.father):</span><br><span class="line">            p_current=p</span><br><span class="line">            p_father=p.father</span><br><span class="line">            <span class="keyword">while</span>(p_father <span class="keyword">and</span> p_current==p_father.right):</span><br><span class="line">                p_current=p_father</span><br><span class="line">                p_father=p_father.father</span><br><span class="line">                </span><br><span class="line">            p_next=p_father</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> p_next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>7.重建二叉树</title>
    <url>/2019/10/19/7.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>在二叉树的前序遍历和中序遍历中确定根节点的值，分别找到前序遍历和中序遍历左右子树对应的子序列，再以同样的方法，构建左右子树，用递归方法完成。<br><strong>C++</strong></p><a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty()||vin.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//前序遍历的第一个数值就是根节点的值</span></span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//在中序遍历序列中找到根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> root_index,i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==pre[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                root_index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_left,pre_right,vin_left,vin_right;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;root_index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_left.push_back(pre[i+<span class="number">1</span>]);</span><br><span class="line">            vin_left.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=root_index+<span class="number">1</span>;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_right.push_back(pre[i]);</span><br><span class="line">            vin_right.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/* 递归调用，层层调用，直到调用到叶子节点，返回NULL*/</span></span><br><span class="line">        <span class="comment">//构建左子树</span></span><br><span class="line">        root-&gt;left=reConstructBinaryTree(pre_left,vin_left);</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root-&gt;right=reConstructBinaryTree(pre_right,vin_right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span>(len(pre)==<span class="number">0</span> <span class="keyword">or</span> len(tin)==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root=TreeNode(pre[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#         for i in range(len(tin)):</span></span><br><span class="line"><span class="comment">#             if tin[i]==pre[0]:</span></span><br><span class="line"><span class="comment">#                 root_index=i </span></span><br><span class="line"><span class="comment">#                 break </span></span><br><span class="line">                </span><br><span class="line">        root_index=tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root.left=self.reConstructBinaryTree(pre[<span class="number">1</span>:<span class="number">1</span>+root_index],tin[:root_index])</span><br><span class="line">        root.right=self.reConstructBinaryTree(pre[root_index+<span class="number">1</span>:],tin[root_index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>9.用两个栈实现队列</title>
    <url>/2019/10/19/6.%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>仅仅需要打印数值,而不是反转链表,这个还是有区别.如果单纯的反转打印链表的值的话,我们可以使用stack操作.<br><strong>C++</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt;nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">        ListNode* node=head;</span><br><span class="line">        <span class="keyword">while</span>(node !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(node);</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node=nodes.top();<span class="comment">//返回栈顶元素, 但不删除该元素</span></span><br><span class="line">            ArrayList.push_back(node-&gt;val);</span><br><span class="line">            nodes.pop();<span class="comment">//弹出栈顶元素, 但不返回其值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>Python</strong></p><a id="more"></a>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ArrayList=[]</span><br><span class="line">        head=listNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ArrayList.insert(<span class="number">0</span>,head.val)</span><br><span class="line">            head=head.next</span><br><span class="line">        <span class="keyword">return</span> ArrayList</span><br><span class="line">        </span><br><span class="line"><span class="comment">#        while head:</span></span><br><span class="line"><span class="comment">#            ArrayList.append(head.val)</span></span><br><span class="line"><span class="comment">#            head=head.next</span></span><br><span class="line"><span class="comment">#        return ArrayList[::-1]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>5.替换空格</title>
    <url>/2019/10/19/5.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><ul>
<li>从前往后替换，时间复杂度$O(n^2)$</li>
<li>从后往前替换，时间复杂度$O(n)$</li>
</ul><p><strong>C++</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 指向字符数组的字符指针str，字符数组长度length</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> originalLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlank=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，统计空格个数、替换前字符个数、替换后字符个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            originalLength++;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">                numberOfBlank++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 替换空格</span></span><br><span class="line">        <span class="keyword">int</span> newLength = originalLength +<span class="number">2</span>* numberOfBlank;</span><br><span class="line">        <span class="keyword">if</span>(newLength+<span class="number">1</span>&gt;length)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *p1 = str+originalLength;	<span class="comment">// 字符指针指向原始字符串的末尾</span></span><br><span class="line">        <span class="keyword">char</span> *p2 = str+newLength;		<span class="comment">// 字符指针指向替换后字符串的末尾</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p1 == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *p2-- = <span class="string">'0'</span>;</span><br><span class="line">                *p2-- = <span class="string">'2'</span>;</span><br><span class="line">                *p2-- = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                *p2-- = *p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*original_length为字符串str的实际长度*/</span></span><br><span class="line">        <span class="keyword">int</span> original_length = <span class="number">0</span>;			<span class="comment">//原始长度</span></span><br><span class="line">        <span class="keyword">int</span> number_blank = <span class="number">0</span>;				<span class="comment">//空格数</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;				<span class="comment">//遍历字符串</span></span><br><span class="line">            original_length++;				<span class="comment">//长度+1</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                number_blank++;				<span class="comment">//遇到空格+1</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*new_length为把空格替换成'%20'之后的长度*/</span></span><br><span class="line">        <span class="keyword">int</span> new_length = original_length + <span class="number">2</span> * number_blank;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p1 = original_length;	<span class="comment">//原始字符串末尾索引值</span></span><br><span class="line">        <span class="keyword">int</span> p2 = new_length;		<span class="comment">//计算长度后的字符串末尾索引值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*index_original指针开始向前移动，如果遇到空格，替换成'%20'，否则进行复制操作*/</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt; p1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[p1] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[p2--] = <span class="string">'0'</span>;</span><br><span class="line">                str[p2--] = <span class="string">'2'</span>;</span><br><span class="line">                str[p2--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[p2--] = str[p1];</span><br><span class="line">            &#125;</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#string（区别于list）是一种不可变的数据类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        origianl_length=len(s)</span><br><span class="line">        number_blank=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">' '</span>:</span><br><span class="line">                number_blank+=<span class="number">1</span></span><br><span class="line">        p1=origianl_length<span class="number">-1</span></span><br><span class="line">        p2=origianl_length+<span class="number">2</span>*number_blank<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        new_s=[<span class="string">' '</span>]*(p2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[p1]==<span class="string">' '</span>:</span><br><span class="line">                new_s[p2]=<span class="string">'0'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">                new_s[p2]=<span class="string">'2'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">                new_s[p2]=<span class="string">'%'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_s[p2]=s[p1]</span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            p1-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>4.二维数组中的查找</title>
    <url>/2019/10/19/4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>Python</strong><br>遍历二维数组<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> target==array[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><a id="more"></a>
<p>规律：首先选取数组右上角的数字</p>
<ul>
<li>如果该数字等于要查找的数字，则查找结束</li>
<li>该数字大于要查找的数字，则剔除这个数字所在的列</li>
<li>该数字小于要查找的数字，则剔除这个数字所在的行<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        row=<span class="number">0</span></span><br><span class="line">        column=len(array[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;len(array) <span class="keyword">and</span> column&gt;=<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(array[row][column]==target):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span>(array[row][column]&gt;target):</span><br><span class="line">                column-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<strong>C++</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">array</span>[<span class="number">0</span>].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target==<span class="built_in">array</span>[i][j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column=<span class="built_in">array</span>[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;<span class="built_in">array</span>.size()&amp;&amp; column&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="built_in">array</span>[row][column])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;<span class="built_in">array</span>[row][column])</span><br><span class="line">                column--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>VINS-Mono论文学习与代码解读</title>
    <url>/2019/10/18/VINS-Mono%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86564879" target="_blank" rel="noopener">VINS-Mono代码解读——启动文件launch与参数配置文件yaml介绍</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86030962" target="_blank" rel="noopener">VINS-Mono代码解读——各种数据结构 sensor_msgs</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/85797156" target="_blank" rel="noopener">VINS-Mono代码解读——视觉跟踪 feature_trackers</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86290941" target="_blank" rel="noopener">VINS-Mono理论学习——IMU预积分 Pre-integration （Jacobian 协方差）</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86293038" target="_blank" rel="noopener">VINS-Mono代码解读——状态估计器流程 estimator 写在初始化和非线性优化前</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/89106128" target="_blank" rel="noopener">VINS-Mono理论学习——视觉惯性联合初始化与外参标定</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/93593844" target="_blank" rel="noopener">VINS-Mono理论学习——后端非线性优化</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/87878550" target="_blank" rel="noopener">VINS-Mono代码解读——回环检测与重定位 pose graph loop closing</a></li>
</ol>]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>四元素插值</title>
    <url>/2019/09/23/%E5%9B%9B%E5%85%83%E7%B4%A0%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>四元数插值常见的有线性插值、球面线性插值等</p><h1 id="线性插值（Linear-Interpolation，简称Lerp）"><a href="#线性插值（Linear-Interpolation，简称Lerp）" class="headerlink" title="线性插值（Linear Interpolation，简称Lerp）"></a>线性插值（Linear Interpolation，简称Lerp）</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923142118617.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923142716322.png#pic_center"><br>四元数表示旋转时是单位四元数，这种插值方式，相当于我们是沿着一条直线（也就是圆上的一个弦）进行插值的，这样插值出来的四元数不是单位四元数</p><p>归一化线性插值（Normalized LinearInterpolation，简称Nlerp)<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923142812617.png#pic_center"><br>有其他问题的。如下图所示，在同等时间内， vt 扫过的⻆度是不同的, vt 扫过的速度（或者说⻆速度）首先会不断地增加，到t = 0.50之后会开始减速，所以Nlerp插值不能保证均匀的⻆速度。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923142853174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><a id="more"></a>


<h1 id="球面线性插值（Spherical-Linear-Interpolation，简称Slerp）"><a href="#球面线性插值（Spherical-Linear-Interpolation，简称Slerp）" class="headerlink" title="球面线性插值（Spherical Linear Interpolation，简称Slerp）"></a>球面线性插值（Spherical Linear Interpolation，简称Slerp）</h1><p>为了解决这个问题，我们可以转而对⻆度进行线性插值。这就要使用更复杂一些的插值方法了，比如常用的球面线性插值(Spherical Linear Interpolation)，简称Slerp。Slerp插值可以解决前面的均匀角速度问题，它能够保证每两个四元数之间的⻆速度是固定的，这就从原理上保证了插值的效果。如下图所示，如果 v1 和 v2 之间的夹⻆为 w，那么：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923141855317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><script type="math/tex">V_t=K_0V_0+K_1V_1</script><br>推导比较简单，利用三角形、三角函数性质可得：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923142037435.png#pic_center"><br>简化版求解方法<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923145256349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190923145206987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"> * 题目：四元数球面线性插值</span></span><br><span class="line"><span class="comment"> * 我们用智能手机采集了图像序列和IMU数据，由于IMU帧率远大于图像帧率，需要你用Slerp方法进行四元数插值，使得插值后的IMU和图像帧对齐</span></span><br><span class="line"><span class="comment"> * 已知某帧图像的时间戳为：t =700901880170406，离该图像帧最近的前后两个时刻IMU时间戳为：</span></span><br><span class="line"><span class="comment"> * t1 = 700901879318945，t2 = 700901884127851</span></span><br><span class="line"><span class="comment"> * IMU在t1, t2时刻测量得的旋转四元数为：</span></span><br><span class="line"><span class="comment"> * q1x=0.509339, q1y=0.019188, q1z=0.049596, q1w=0.858921；</span></span><br><span class="line"><span class="comment"> * q2x=0.509443, q2y=0.018806, q2z=0.048944,q2w=0.858905</span></span><br><span class="line"><span class="comment"> * 根据上述信息求IMU对齐到图像帧的插值后的四元数</span></span><br><span class="line"><span class="comment">****************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四元数球面线性插值简化方法：v'=v1*cosθ' + v⊥*sinθ'，原理见公众号推送文章</span></span><br><span class="line"> <span class="function">Quaterniond <span class="title">slerp</span><span class="params">(<span class="keyword">double</span> t, Quaterniond &amp;q1, Quaterniond &amp;q2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	 <span class="comment">// ---- 开始你的代码 ----- //</span></span><br><span class="line">	 <span class="comment">//归一化四元数</span></span><br><span class="line">	 q1.normalize();</span><br><span class="line">	 q2.normalize();</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//四元数变为Mat: 方法 1</span></span><br><span class="line"><span class="comment">//	 double q1_array[4]=&#123;q1.w(),q1.x(),q1.y(),q1.z()&#125;;</span></span><br><span class="line"><span class="comment">//	 double q2_array[4]=&#123;q2.w(),q2.x(),q2.y(),q2.z()&#125;;</span></span><br><span class="line"><span class="comment">//	 Mat q1_Mat(4,1,CV_64F,q1_array);</span></span><br><span class="line"><span class="comment">//	 Mat q2_Mat(4,1,CV_64F,q2_array);</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 四元数变为Mat: 方法 2</span></span><br><span class="line">     Mat q1_Mat=(Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">1</span>)&lt;&lt;q1.w(),q1.x(),q1.y(),q1.z());</span><br><span class="line">     Mat q2_Mat=(Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">1</span>)&lt;&lt;q2.w(),q2.x(),q2.y(),q2.z());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">double</span> dotProd=q1_Mat.dot(q2_Mat);</span><br><span class="line">     <span class="keyword">double</span> norm2=norm(q1_Mat,NORM_L2)*norm(q2_Mat,NORM_L2);</span><br><span class="line">     <span class="keyword">double</span> costTheta=dotProd/norm2;</span><br><span class="line">     Mat result;</span><br><span class="line">     Quaterniond result_quat;</span><br><span class="line">     <span class="keyword">if</span>(costTheta&gt;<span class="number">0.9995f</span>)&#123;</span><br><span class="line">         result=(<span class="number">1.0f</span>-t)*q1_Mat+t*q2_Mat;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">double</span> theta=acosf(costTheta);</span><br><span class="line">         <span class="keyword">double</span> thetaT=theta*t;</span><br><span class="line">         Mat qperp=q2_Mat-<span class="built_in">cos</span>(theta)*q1_Mat;</span><br><span class="line">         <span class="comment">//Mat qperp=q2_Mat-costTheta*q1_Mat;</span></span><br><span class="line">         result=q1_Mat*<span class="built_in">cos</span>(thetaT)+qperp*<span class="built_in">sin</span>(thetaT);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     result=result/norm(result,NORM_L2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mat 转化为四元数</span></span><br><span class="line">    result_quat.w() = result.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    result_quat.x() = result.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    result_quat.y() = result.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    result_quat.z() = result.at&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result_quat;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// ---- 结束你的代码 ----- //</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	double t_img(700901880170406), t1_imu(700901879318945), t2_imu(700901884127851);</span><br><span class="line"></span><br><span class="line">    Quaterniond q1 = Quaterniond(<span class="number">0.858921</span>, <span class="number">0.509339</span>, <span class="number">0.019188</span>, <span class="number">0.049596</span>);</span><br><span class="line">    Quaterniond q2 = Quaterniond(<span class="number">0.858905</span>, <span class="number">0.509443</span>, <span class="number">0.018806</span>, <span class="number">0.048944</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> t = (t_img - t1_imu) / (t2_imu - t1_imu);</span><br><span class="line">    Quaterniond q_slerp = slerp(t, q1, q2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"插值后的四元数：q_slerp =\n"</span>&lt;&lt; q_slerp.coeffs() &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//coeffs的顺序是(x,y,z,w)</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019092315533115.png"></p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>EAI Dashgo D1小车  Hokuyo激光雷达UTM-30LX-EW    Gmapping建图与导航</title>
    <url>/2019/08/31/EAI-Dashgo-D1%E5%B0%8F%E8%BD%A6-Hokuyo%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEUTM-30LX-EW-Gmapping%E5%BB%BA%E5%9B%BE%E4%B8%8E%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h1><p><strong>urg_lidar.launch</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- A simple launch file for the urg_node package. --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  When using an IP-connected LIDAR, populate the "ip_address" parameter with the address of the LIDAR.</span></span><br><span class="line"><span class="comment">      Otherwise, leave it blank. If supported by your LIDAR, you may enable the publish_intensity</span></span><br><span class="line"><span class="comment">      and/or publish_multiecho options. --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"urg_node"</span> <span class="attr">pkg</span>=<span class="string">"urg_node"</span> <span class="attr">type</span>=<span class="string">"urg_node"</span> <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ip_address"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"serial_port"</span> <span class="attr">value</span>=<span class="string">"/dev/ttyACM0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"serial_baud"</span> <span class="attr">value</span>=<span class="string">"115200"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"frame_id"</span> <span class="attr">value</span>=<span class="string">"laser"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"calibrate_time"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"publish_intensity"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"publish_multiecho"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"angle_min"</span> <span class="attr">value</span>=<span class="string">"-1.5707963"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"angle_max"</span> <span class="attr">value</span>=<span class="string">"1.5707963"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p><strong>gmapping_demo.launch</strong><br>修改为：<br><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">   &lt;node <span class="type">name</span>="arduino" pkg="dashgo_bringup" <span class="keyword">type</span>="dashgo_driver.py" output="screen"&gt;</span><br><span class="line">      &lt;rosparam file="$(find dashgo_bringup)/config/my_dashgo_params.yaml" command="load" /&gt;</span><br><span class="line">   &lt;/node&gt;</span><br><span class="line"></span><br><span class="line"> &lt;node <span class="type">name</span>="urg_node" pkg="urg_node" <span class="keyword">type</span>="urg_node" output="screen"&gt;</span><br><span class="line">  &lt;param <span class="type">name</span>="serial_port"         <span class="keyword">type</span>="string" <span class="keyword">value</span>="/dev/ttyACM0"/&gt;  </span><br><span class="line">  &lt;param <span class="type">name</span>="serial_baudrate"     <span class="keyword">type</span>="int"    <span class="keyword">value</span>="115200"/&gt;</span><br><span class="line">  &lt;param <span class="type">name</span>="frame_id"            <span class="keyword">type</span>="string" <span class="keyword">value</span>="laser"/&gt;</span><br><span class="line">  &lt;param <span class="type">name</span>="inverted"            <span class="keyword">type</span>="bool"   <span class="keyword">value</span>="false"/&gt;</span><br><span class="line">  &lt;param <span class="type">name</span>="angle_compensate"    <span class="keyword">type</span>="bool"   <span class="keyword">value</span>="true"/&gt;</span><br><span class="line">  &lt;/node&gt;</span><br><span class="line"></span><br><span class="line">  &lt;<span class="keyword">include</span> file="$(find dashgo_description)/launch/dashgo_description.launch"/&gt;</span><br><span class="line"></span><br><span class="line"> &lt;node pkg="tf" <span class="keyword">type</span>="static_transform_publisher" <span class="type">name</span>="base_link_to_laser" </span><br><span class="line">    args="0.0 0.0 0.4 0.0 0.0  0.0 /base_link /laser 40" /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;<span class="keyword">include</span> file="$(find dashgo_nav)/launch/gmapping.launch"/&gt;</span><br><span class="line">  &lt;<span class="keyword">include</span> file="$(find dashgo_nav)/launch/move_base.launch"/&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>args 第一个参数 0.0 表示雷达中心距离底盘重心的 x 轴距离</li>
<li>args 第二个参数 0.0 表示雷达中心距离底盘重心的 y 轴距离</li>
<li>args 第二个参数 0.2 表示雷达中心距离底盘重心的 z 轴距离</li>
<li>args 第四个参数表示将雷达绕 z 轴左右偏转程度,为 yaw 偏航角</li>
<li>args 第五个参数表示将雷达绕 y 轴前后翻滚程度,为 pitch 俯仰角</li>
<li>args 第六个参数表示将雷达绕 x 轴左右侧滚,为 roll 侧滚角,该参数一般为 0.0,目前只能设为 0.0,-3.14 和 3.14</li>
</ul>
<p>运行：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">roslaunch dashgo_nav gmapping_demo<span class="selector-class">.launch</span> </span><br><span class="line">roslaunch dashgo_rviz view_navigation<span class="selector-class">.launch</span> </span><br><span class="line">rosrun teleop_twist_keyboard teleop_twist_keyboard.py</span><br></pre></td></tr></table></figure></p>
<p>保存地图<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rosrun map_server map_saver -f ./<span class="built_in">map</span>/zoulang</span><br></pre></td></tr></table></figure></p>
<p>建的图为实验室的走廊<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190831201414500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="自主导航"><a href="#自主导航" class="headerlink" title="自主导航"></a>自主导航</h1><p>yocs_velocity_smoother是一个速度、加速度限制器，用来防止robot navigation的速度/转速过快，加速度/快减速过大。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install ros-kinetic-yocs-velocity-smoother</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find dashgo_bringup)/launch/bringup_smoother.launch"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"urg_node"</span> <span class="attr">pkg</span>=<span class="string">"urg_node"</span> <span class="attr">type</span>=<span class="string">"urg_node"</span> <span class="attr">output</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"serial_port"</span>         <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"/dev/ttyACM0"</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"serial_baudrate"</span>     <span class="attr">type</span>=<span class="string">"int"</span>    <span class="attr">value</span>=<span class="string">"115200"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"frame_id"</span>            <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"laser"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"inverted"</span>            <span class="attr">type</span>=<span class="string">"bool"</span>   <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"angle_compensate"</span>    <span class="attr">type</span>=<span class="string">"bool"</span>   <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find dashgo_description)/launch/dashgo_description.launch"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"tf"</span> <span class="attr">type</span>=<span class="string">"static_transform_publisher"</span> <span class="attr">name</span>=<span class="string">"base_link_to_laser"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">args</span>=<span class="string">"0.0 0.0 0.4 0.0 0.0 0.0 /base_link /laser40"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Map server --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"map_file"</span> <span class="attr">default</span>=<span class="string">"$(find dashgo_nav)/maps/map.yaml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"map_server"</span> <span class="attr">pkg</span>=<span class="string">"map_server"</span> <span class="attr">type</span>=<span class="string">"map_server"</span> <span class="attr">args</span>=<span class="string">"$(arg map_file)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"initial_pose_x"</span> <span class="attr">default</span>=<span class="string">"0.0"</span>/&gt;</span> <span class="comment">&lt;!-- Use 17.0 for willow's map in simulation --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"initial_pose_y"</span> <span class="attr">default</span>=<span class="string">"0.0"</span>/&gt;</span> <span class="comment">&lt;!-- Use 17.0 for willow's map in simulation --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"initial_pose_a"</span> <span class="attr">default</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find dashgo_nav)/launch/amcl.launch.xml"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"initial_pose_x"</span> <span class="attr">value</span>=<span class="string">"$(arg initial_pose_x)"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"initial_pose_y"</span> <span class="attr">value</span>=<span class="string">"$(arg initial_pose_y)"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"initial_pose_a"</span> <span class="attr">value</span>=<span class="string">"$(arg initial_pose_a)"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"$(find dashgo_nav)/launch/teb_move_base.launch"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch dashgo_nav teb_amcl_demo.<span class="built_in">launch</span></span><br><span class="line">roslaunch dashgo_rviz view_navigation.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">roslaunch dashgo_nav teb_amcl_demo.launch  <span class="string">map_file:</span>=<span class="regexp">/home/</span>xiaohu<span class="regexp">/map/</span>zoulang.yaml</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
  </entry>
  <entry>
    <title>Hokuyo激光雷达UTM-30LX-EW用hector_slam建图</title>
    <url>/2019/08/29/Hokuyo%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEUTM-30LX-EW%E7%94%A8hector-slam%E5%BB%BA%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>编写接收scan topic的hector_slam_launch文件下的launch文件</li>
</ol><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;<span class="keyword">include</span> file="$(find hector_mapping)/launch/mapping_default.launch"&gt;</span><br><span class="line">    &lt;arg <span class="type">name</span>="base_frame" <span class="keyword">value</span>="base_frame"/&gt;</span><br><span class="line">    &lt;arg <span class="type">name</span>="odom_frame" <span class="keyword">value</span>="base_frame"/&gt;  //要把odom值换成base_frame,这样就不需要odemetry,不然会报错</span><br><span class="line">  &lt;/<span class="keyword">include</span>&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;<span class="keyword">include</span> file="$(find hector_geotiff)/launch/geotiff_mapper.launch"&gt;</span><br><span class="line">    &lt;arg <span class="type">name</span>="trajectory_source_frame_name" <span class="keyword">value</span>="base_frame"/&gt; </span><br><span class="line">  &lt;/<span class="keyword">include</span>&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;node pkg="tf" <span class="keyword">type</span>="static_transform_publisher"       <span class="type">name</span>="base_frame_to_laser_broadcaster" args="0 0 0 0 0 0 base_frame laser 100"/&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;node pkg="rviz" <span class="keyword">type</span>="rviz" <span class="type">name</span>="rviz"</span><br><span class="line">    args="-d $(find hector_slam_launch)/rviz_cfg/mapping_demo.rviz"/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<ol>
<li>启动节点</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun urg_node urg_node _ip_address:=<span class="number">192.168</span><span class="number">.0</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启动hector slam</li>
</ol>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch hector_slam_launch tutorial.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190829163858478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<ol>
<li>保存地图</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosrun</span> map_server map_saver</span><br></pre></td></tr></table></figure>
<p>便会在home目录下自动保存一个名为“map.pgm”地图文件。</p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu ROS中使用Hokuyo激光雷达UTM-30LX-EW</title>
    <url>/2019/08/28/ububntu16-ROS%E4%B8%AD%E4%BD%BF%E7%94%A8Hokuyo%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEUTM-30LX-EW/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h1><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install ros-kinetic-urg-<span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure><h1 id="设置ip地址"><a href="#设置ip地址" class="headerlink" title="设置ip地址"></a>设置ip地址</h1><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828194617159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>台式机的网卡名称：eno1<br>添加一个静态的IP地址。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/network/<span class="built_in">int</span>erfaces</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828194510638.png"><br>重启网卡；使之配置生效</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/networking restart</span></span><br></pre></td></tr></table></figure><a id="more"></a>





<p>因为Hokuyo激光雷达的固定IP地址是“192.168.1.10”（出厂设置是“192.168.0.10”），我们的激光雷达未修改ip,出厂设置是“192.168.0.10”</p>
<p>所以在Ubuntu上添加IP地址时，使用“192.168.0.XX”，最后两个数字应该和“10区分”，前面三段和激光雷达的IP一样。</p>
<p>打开终端:ping 雷达 IP，测试硬件是否连接正常</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ping <span class="number">192.168</span><span class="number">.0</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828194802708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="查看激光雷达"><a href="#查看激光雷达" class="headerlink" title="查看激光雷达"></a>查看激光雷达</h1><ol>
<li>启动<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun urg_node urg_node _ip_address:=<span class="number">192.168</span><span class="number">.0</span><span class="number">.10</span></span><br></pre></td></tr></table></figure></li>
<li>查看激光雷达检测到的数据</li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">rostopic <span class="keyword">echo</span> <span class="string">/scan</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828195103396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<ol>
<li>查看激光雷达扫描的消息类型和消息结构<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828195150831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
<li>在rviz中查看激光数据：</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rviz</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828195430845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu 镭神智能C16驱动配置</title>
    <url>/2019/08/28/ubuntu16-%E9%95%AD%E7%A5%9E%E6%99%BA%E8%83%BDC16%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>配置IP方式<br><a href="https://www.linuxidc.com/Linux/2012-09/71087.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2012-09/71087.htm</a></li>
</ol><p>注 eh0为网卡的名称 ，不同设备的网卡名称略有区别。查看网卡名称方式如下</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828133700254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>上图中enp2s0为我的电脑的网卡名称。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/network/<span class="built_in">int</span>erfaces</span><br></pre></td></tr></table></figure><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828160054220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>重启网卡；使之配置生效</p><a id="more"></a>



<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/networking restart</span></span><br></pre></td></tr></table></figure>
<ol>
<li>打开终端:ping 雷达 IP，测试硬件是否连接正常，若 ping 通则正常，否则检查硬件连接.（雷达IP默认为：192.168.1.200）</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ping <span class="number">192.168</span><span class="number">.1</span><span class="number">.200</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828151217732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">可进一步用：sudo tcpdump -n -i enp2s0<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828160114472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">source ~/lslida_C16/devel/setup<span class="selector-class">.bash</span> </span><br><span class="line">roslaunch lslidar_c16_decoder lslidar_c16<span class="selector-class">.launch</span> --screen</span><br></pre></td></tr></table></figure>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rviz</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190828161507236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>激光SLAM</category>
      </categories>
  </entry>
  <entry>
    <title>小觅双目+IMU联合标定</title>
    <url>/2019/08/23/%E5%B0%8F%E8%A7%85%E5%8F%8C%E7%9B%AE-IMU%E8%81%94%E5%90%88%E6%A0%87%E5%AE%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装Kalibr"><a href="#安装Kalibr" class="headerlink" title="安装Kalibr"></a>安装Kalibr</h1><p>Kalibr工程有两种，一种是已经编译好的包，叫CDE package,另一种是未经编译的源文件。<br>选择源码安装</p><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-setuptools <span class="keyword">python</span>-rosinstall ipython libeigen3-devlibboost-<span class="keyword">all</span>-dev doxygen libopencv-dev ros-indigo-vision-opencvros-indigo-image-transport-plugins ros-indigo-cmake-modulespython-software-properties software-properties-common libpoco-devpython-matplotlib <span class="keyword">python</span>-scipy <span class="keyword">python</span>-git <span class="keyword">python</span>-pip ipython libtbb-devlibblas-dev liblapack-dev <span class="keyword">python</span>-catkin-tools libv4l-dev</span><br></pre></td></tr></table></figure><a id="more"></a>

<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sudo pip installpython-igraph <span class="comment">--upgrade</span></span><br></pre></td></tr></table></figure>
<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/kalibr_workspace/src</span><br><span class="line">cd ~/kalibr_workspace</span><br><span class="line">source /opt/ros/kinetic/setup.bash</span><br><span class="line">catkin init</span><br><span class="line">catkin<span class="built_in"> config </span>--extend /opt/ros/kinetic</span><br><span class="line">catkin<span class="built_in"> config </span>--cmake-args <span class="attribute">-DCMAKE_BUILD_TYPE</span>=Release</span><br></pre></td></tr></table></figure>
<h3 id="下载并编译"><a href="#下载并编译" class="headerlink" title="下载并编译"></a>下载并编译</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/kalibr_workspace/src</span></span><br><span class="line">git clone https:<span class="string">//github.com/ethz-asl/Kalibr.git</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/kalibr_workspace</span></span><br><span class="line">catkin build -DCMAKE_BUILD_TYPE=Release -j4</span><br></pre></td></tr></table></figure>
<h3 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> ~<span class="regexp">/kalibr_workspace/</span>devel<span class="regexp">/setup.bash</span></span><br></pre></td></tr></table></figure>
<h1 id="mynteye标定"><a href="#mynteye标定" class="headerlink" title="mynteye标定"></a>mynteye标定</h1><h3 id="get-img-params获得："><a href="#get-img-params获得：" class="headerlink" title="get_img_params获得："></a>get_img_params获得：</h3><p> <strong>获取相机标定参数</strong><br> <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/samples/</span>_output<span class="regexp">/bin/</span>tutorials<span class="regexp">/get_img_params</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">I/get_img_params.cc:<span class="number">44</span> Intrinsics left: &#123;pinhole, width: <span class="number">752</span>, height: <span class="number">480</span>, fx: <span class="number">362.20059643202876032</span>, fy: <span class="number">363.50065250745848289</span>, cx: <span class="number">406.58699068023440759</span>, cy: <span class="number">234.35161110061483214</span>, model: <span class="number">0</span>, coeffs: [<span class="number">-0.25034765682756088</span>, <span class="number">0.05057939920289762</span>, <span class="number">-0.00070536676161976</span>, <span class="number">-0.00852554513070338</span>, <span class="number">0.00000000000000000</span>]&#125;</span><br><span class="line">I/get_img_params.cc:<span class="number">45</span> Intrinsics right: &#123;pinhole, width: <span class="number">752</span>, height: <span class="number">480</span>, fx: <span class="number">365.14014888558477878</span>, fy: <span class="number">365.13385298966960590</span>, cx: <span class="number">389.32395100630907336</span>, cy: <span class="number">234.95160212312546832</span>, model: <span class="number">0</span>, coeffs: [<span class="number">-0.30377346762098512</span>, <span class="number">0.07992969367399984</span>, <span class="number">0.00005154751753072</span>, <span class="number">-0.00067345903740579</span>, <span class="number">0.00000000000000000</span>]&#125;</span><br><span class="line">I/get_img_params.cc:<span class="number">46</span> Extrinsics right to left: &#123;rotation: [<span class="number">0.99867908939669447</span>, <span class="number">-0.00634455661374854</span>, <span class="number">0.05098845950961969</span>, <span class="number">0.00598903163893333</span>, <span class="number">0.99995670037792639</span>, <span class="number">0.00712242018683670</span>, <span class="number">-0.05103144032669509</span>, <span class="number">-0.00680764060926713</span>, <span class="number">0.99867384471984544</span>], translation: [<span class="number">-120.02489764113249748</span>, <span class="number">-1.17826374090507469</span>, <span class="number">-5.20582051599965379</span>]&#125;</span><br><span class="line">ROSMsgInfoPair:</span><br><span class="line">left:</span><br><span class="line">width: <span class="number">752</span>, height: <span class="number">480</span></span><br><span class="line">distortion_model: PINHOLE</span><br><span class="line">D: <span class="number">-0.250348</span>,<span class="number">0.0505794</span>,<span class="number">-0.000705367</span>,<span class="number">-0.00852555</span>,<span class="number">0</span>,</span><br><span class="line">K: <span class="number">362.201</span>,<span class="number">0</span>,<span class="number">363.501</span>,<span class="number">0</span>,<span class="number">406.587</span>,<span class="number">234.352</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">R: <span class="number">0.995541</span>,<span class="number">0.00317344</span>,<span class="number">0.0942805</span>,<span class="number">-0.00348417</span>,<span class="number">0.999989</span>,<span class="number">0.00313134</span>,<span class="number">-0.0942695</span>,<span class="number">-0.00344587</span>,<span class="number">0.995541</span>,</span><br><span class="line">P: <span class="number">326.239</span>,<span class="number">0</span>,<span class="number">340.971</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">326.239</span>,<span class="number">235.709</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">right:</span><br><span class="line">width: <span class="number">752</span>, height: <span class="number">480</span></span><br><span class="line">distortion_model: PINHOLE</span><br><span class="line">D: <span class="number">-0.303773</span>,<span class="number">0.0799297</span>,<span class="number">5.15475e-05</span>,<span class="number">-0.000673459</span>,<span class="number">0</span>,</span><br><span class="line">K: <span class="number">365.14</span>,<span class="number">0</span>,<span class="number">365.134</span>,<span class="number">0</span>,<span class="number">389.324</span>,<span class="number">234.952</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">R: <span class="number">0.999013</span>,<span class="number">0.00980714</span>,<span class="number">0.04333</span>,<span class="number">-0.00966439</span>,<span class="number">0.999947</span>,<span class="number">-0.00350257</span>,<span class="number">-0.0433621</span>,<span class="number">0.00308036</span>,<span class="number">0.999055</span>,</span><br><span class="line">P: <span class="number">326.239</span>,<span class="number">0</span>,<span class="number">340.971</span>,<span class="number">-39195.5</span>,<span class="number">0</span>,<span class="number">326.239</span>,<span class="number">235.709</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br></pre></td></tr></table></figure>
<p>相机投影参数：fx、fy、cx、cy</p>
<p>相机畸变参数：coeffs[5]=[k1,k2,p1,p2,k3]</p>
<p>  <strong>获取IMU标定参数</strong><br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/samples/</span>_output<span class="regexp">/bin/</span>tutorials<span class="regexp">/get_imu_params</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">I/get_imu_params.cc:<span class="number">23</span> Motion <span class="built_in">int</span>rinsics: &#123;accel: &#123;scale: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], assembly: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], drift: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], noise: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], bias: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], x: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], y: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], z: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>]&#125;, gyro: &#123;scale: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], assembly: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], drift: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], noise: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], bias: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], x: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], y: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], z: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>]&#125;&#125;</span><br><span class="line">I/get_imu_params.cc:<span class="number">24</span> Motion extrinsics left to imu: &#123;rotation: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>], translation: [<span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>, <span class="number">0.00000000000000000</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>Camera与IMU参数：</p>
<blockquote>
<p>Each camera has the following parameters:</p>
<p>  camera_model<br>      camera projection type (pinhole / omni)<br>      intrinsics<br>      vector containing the intrinsic parameters for the given projection type. elements are as follows:<br>      pinhole: [fu fv pu pv]<br>      omni: [xi fu fv pu pv]<br>      ds: [xi alpha fu fv pu pv]<br>      eucm: [alpha beta fu fv pu pv]<br>      see Supported models for more information<br>      distortion_model<br>      lens distortion type (radtan / equidistant)<br>      distortion_coeffs<br>      parameter vector for the distortion model<br>      see Supported models for more information<br>      T_cn_cnm1<br>      camera extrinsic transformation, always with respect to the last camera in the chain<br>      (e.g. cam1: T_cn_cnm1 = T_c1_c0, takes cam0 to cam1 coordinates)<br>      T_cam_imu<br>      IMU extrinsics: transformation from IMU to camera coordinates (T_c_i)<br>      timeshift_cam_imu<br>      timeshift between camera and IMU timestamps in seconds (t_imu = t_cam + shift)<br>      rostopic<br>      topic of the camera’s image stream<br>      resolution<br>      camera resolution [width,height]</p>
<h1 id="Kalibr-标定"><a href="#Kalibr-标定" class="headerlink" title="Kalibr 标定"></a>Kalibr 标定</h1><h3 id="1-标定-Camera"><a href="#1-标定-Camera" class="headerlink" title="1. 标定 Camera"></a>1. 标定 Camera</h3><p>参考：<a href="https://github.com/ethz-asl/kalibr/wiki/multiple-camera-calibration" target="_blank" rel="noopener">Multiple camera calibration</a><br><strong>mynt相机发布topic</strong></p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">source wrappers/ros/devel/<span class="built_in">setup</span>.bash</span><br><span class="line">roslaunch mynt_eye_ros_wrapper <span class="built_in">display</span>.launch</span><br></pre></td></tr></table></figure>
<p><strong>数据采集</strong><br>通过 ROS 发布 image 消息的节点, 我们只需要使用 rosbag record 工具将拍摄到的标定板图像制作成 bag 文件。</p>
<p>建议在捕获校准数据时将摄像机流的频率降低到4 Hz左右。这减少了数据集中的冗余信息，从而降低了校准的运行时间。</p>
<p>ROS 提供了改变 topic 发布频率的节点<a href="http://wiki.ros.org/topic_tools/throttle" target="_blank" rel="noopener">throttle</a>, 指令如下 :</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">rosrun topic_tools throttle <span class="keyword">messages</span> /mynteye/<span class="keyword">left</span>/image_raw <span class="number">4.0</span> </span><br><span class="line"></span><br><span class="line">rosrun topic_tools throttle <span class="keyword">messages</span> /mynteye/<span class="keyword">right</span>/image_raw <span class="number">4.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">rosbag <span class="keyword">record</span> -O stereo_calibra.bag</span><br></pre></td></tr></table></figure>
<p><strong>标定</strong></p>
<p> 集好数据集以后, 就可以用已经安装好的 Kalibr 标定双目相机了, 指令如下:</p>
<p>标定方式：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">kalibr_calibrate_cameras <span class="params">--bag</span> [filename.bag] <span class="params">--topics</span> [TOPIC_0 <span class="string">...</span> TOPIC_N] <span class="params">--models</span> [MODEL_0 <span class="string">...</span> MODEL_N] <span class="params">--target</span> [target.yaml]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>bag filename.bag：包含数据的ROS包</p>
</li>
<li><p>topics TOPIC_0 … TOPIC_N：相机节点</p>
</li>
<li><p>models MODEL_0 … MODEL_N：list of camera/distortion models to be fitted<br>(see <a href="https://github.com/ethz-asl/kalibr/wiki/supported-models" target="_blank" rel="noopener">Supported models</a>)</p>
</li>
<li>target target.yaml：the calibration target configuration</li>
</ul>
<p>采集好数据集以后, 就可以用已经安装好的 Kalibr 标定双目相机了, 指令如下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">source ros_ws<span class="regexp">/kalibr/</span>devel/setup.bash</span><br><span class="line">kalibr_calibrate_cameras --bag <span class="regexp">/home/</span>xiaohu<span class="regexp">/bagfiles/</span>stereo_calibra.bag  --topics <span class="regexp">/mynteye/</span>left<span class="regexp">/image_raw /</span>mynteye<span class="regexp">/right/</span>image_raw --models pinhole-radtan pinhole-radtan --target <span class="regexp">/home/</span>xiaohu<span class="regexp">/bagfiles/</span>april_6x6_80x80cm_A0.yaml</span><br></pre></td></tr></table></figure>
<p><strong>输出cam_chain.yaml</strong></p>
<h3 id="2-标定-Camera-IMU"><a href="#2-标定-Camera-IMU" class="headerlink" title="2. 标定 Camera-IMU"></a>2. 标定 Camera-IMU</h3><p>参考：<a href="https://github.com/ethz-asl/kalibr/wiki/camera-imu-calibration#calibration-target" target="_blank" rel="noopener">Camera-IMU calibration</a><br>Example chain.yaml<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">cam0:</span><br><span class="line">  camera_model: pinhole</span><br><span class="line">  <span class="built_in">int</span>rinsics: [<span class="number">461.629</span>, <span class="number">460.152</span>, <span class="number">362.680</span>, <span class="number">246.049</span>]</span><br><span class="line">  distortion_model: radtan</span><br><span class="line">  distortion_coeffs: [<span class="number">-0.27695497</span>, <span class="number">0.06712482</span>, <span class="number">0.00087538</span>, <span class="number">0.00011556</span>]</span><br><span class="line">  T_cam_imu:</span><br><span class="line">  - [<span class="number">0.01779318</span>, <span class="number">0.99967549</span>,<span class="number">-0.01822936</span>, <span class="number">0.07008565</span>]</span><br><span class="line">  - [<span class="number">-0.9998017</span>, <span class="number">0.01795239</span>, <span class="number">0.00860714</span>,<span class="number">-0.01771023</span>]</span><br><span class="line">  - [<span class="number">0.00893160</span>, <span class="number">0.01807260</span>, <span class="number">0.99979678</span>, <span class="number">0.00399246</span>]</span><br><span class="line">  - [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]</span><br><span class="line">  timeshift_cam_imu: <span class="number">-8.121e-05</span></span><br><span class="line">  rostopic: /cam0/image_raw</span><br><span class="line">  resolution: [<span class="number">752</span>, <span class="number">480</span>]</span><br><span class="line">cam1:</span><br><span class="line">  camera_model: omni</span><br><span class="line">  <span class="built_in">int</span>rinsics: [<span class="number">0.80065662</span>, <span class="number">833.006</span>, <span class="number">830.345</span>, <span class="number">373.850</span>, <span class="number">253.749</span>]</span><br><span class="line">  distortion_model: radtan</span><br><span class="line">  distortion_coeffs: [<span class="number">-0.33518750</span>, <span class="number">0.13211436</span>, <span class="number">0.00055967</span>, <span class="number">0.00057686</span>]</span><br><span class="line">  T_cn_cnm1:</span><br><span class="line">  - [ <span class="number">0.99998854</span>, <span class="number">0.00216014</span>, <span class="number">0.00427195</span>,<span class="number">-0.11003785</span>]</span><br><span class="line">  - [<span class="number">-0.00221074</span>, <span class="number">0.99992702</span>, <span class="number">0.01187697</span>, <span class="number">0.00045792</span>]</span><br><span class="line">  - [<span class="number">-0.00424598</span>,<span class="number">-0.01188627</span>, <span class="number">0.99992034</span>,<span class="number">-0.00064487</span>]</span><br><span class="line">  - [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]</span><br><span class="line">  T_cam_imu:</span><br><span class="line">  - [ <span class="number">0.01567142</span>, <span class="number">0.99978002</span>,<span class="number">-0.01393948</span>,<span class="number">-0.03997419</span>]</span><br><span class="line">  - [<span class="number">-0.99966203</span>, <span class="number">0.01595569</span>, <span class="number">0.02052137</span>,<span class="number">-0.01735854</span>]</span><br><span class="line">  - [ <span class="number">0.02073927</span>, <span class="number">0.01361317</span>, <span class="number">0.99969223</span>, <span class="number">0.00326019</span>]</span><br><span class="line">  - [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]</span><br><span class="line">  timeshift_cam_imu: <span class="number">-8.681e-05</span></span><br><span class="line">  rostopic: /cam1/image_raw</span><br><span class="line">  resolution: [<span class="number">752</span>, <span class="number">480</span>]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>camera_model//相机模型<br>camera projection type (pinhole / omni)<br>intrinsics//相机内参<br>vector containing the intrinsic parameters for the given projection type. elements are as follows:<br>pinhole: [fu fv pu pv]<br>omni: [xi fu fv pu pv]<br>distortion_model//畸变模型<br>lens distortion type (radtan / equidistant)<br>distortion_coeffs//畸变参数<br>parameter vector for the distortion model<br>T_cn_cnm1//左右摄像头的相对位姿<br>camera extrinsic transformation, always with respect to the last camera in the chain<br>(e.g. cam1: T_cn_cnm1 = T_c1_c0, takes cam0 to cam1 coordinates)<br>timeshift_cam_imu//在捕捉数据时，imu数据和图像时间偏移<br>timeshift between camera and IMU timestamps in seconds (t_imu = t_cam + shift)<br>rostopic<br>topic of the camera’s image stream<br>resolution<br>camera resolution [width,height]</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">#Acc</span>elerometers</span><br><span class="line">accelerometer_noise_density: <span class="number">1.86</span>e-<span class="number">03</span>   <span class="selector-id">#Noise</span> density (continuous-time)</span><br><span class="line">accelerometer_random_walk:   <span class="number">4.33</span>e-<span class="number">04</span>   <span class="selector-id">#Bias</span> random walk</span><br><span class="line"></span><br><span class="line">#Gyroscopes</span><br><span class="line">gyroscope_noise_density:     <span class="number">1.87</span>e-<span class="number">04</span>   <span class="selector-id">#Noise</span> density (continuous-time)</span><br><span class="line">gyroscope_random_walk:       <span class="number">2.66</span>e-<span class="number">05</span>   <span class="selector-id">#Bias</span> random walk</span><br><span class="line"></span><br><span class="line">rostopic:                    /imu0      <span class="selector-id">#the</span> IMU ROS topic</span><br><span class="line">update_rate:                 <span class="number">200.0</span>      <span class="selector-id">#Hz</span> (<span class="keyword">for</span> discretization of the values above)</span><br></pre></td></tr></table></figure>
<p><strong>数据采集</strong><br>在标定完双目内外参数以后, 可以接着标定和 IMU 之间的外参数了. 这次采用同样的标定板, 采集数据的最佳频率为图像20Hz, IMU 200 Hz 。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">rosbag record -O stereo_imu_calibra.bag  <span class="regexp">/mynteye/</span>left<span class="regexp">/image_raw /my</span>nteye<span class="regexp">/right/im</span>age_raw <span class="regexp">/mynteye/imu</span><span class="regexp">/data_raw</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>采集数据的起始和结束阶段注意别晃动太大，如从桌子上拿起或者放下。如果有这样的动作，在标定阶段应该跳过bag数据集的首尾的数据.<ul>
<li>采集数据的时候应该给imu各个轴足够的激励，如先依次绕各个轴运动，运动完后来个在空中画8字之类的操作，当然也要注意别运动太剧烈，图像都模糊了。</li>
</ul>
</li>
</ul>
<p><strong>标定</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">kalibr_calibrate_imu_camera --target <span class="regexp">/home/</span>xiaohu<span class="regexp">/bagfiles/</span>april_6x6_80x80cm_A0.yaml --cam <span class="regexp">/home/</span>xiaohu<span class="regexp">/bagfiles/</span>camchain-stereo_calibra.yaml --imu <span class="regexp">/home/</span>xiaohu<span class="regexp">/bagfiles/imu</span>_mynteye.yaml --bag <span class="regexp">/home/</span>xiaohu<span class="regexp">/bagfiles/</span>stereo_imu_calibra.bag --bag-<span class="keyword">from</span>-to <span class="number">2</span> <span class="number">37</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>标定</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS下单目和双目相机的标定</title>
    <url>/2019/08/22/ROS%E4%B8%8B%E5%8D%95%E7%9B%AE%E5%92%8C%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E7%9A%84%E6%A0%87%E5%AE%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>标定方法：<br>可以通过matlab，OpenCV，ROS三种方式进行相机标定。<br>ROS提供了camera_calibration Package：<a href="https://github.com/ros-perception/image_pipeline" target="_blank" rel="noopener">image_pipeline</a>，通过这个Package可以使用棋盘标定板对单目和双目相机进行标定。</p><p>另外推荐一个标定工具Kalibr：<a href="https://github.com/ethz-asl/kalibr" target="_blank" rel="noopener">Kalibr</a>，可以实现Multiple camera calibration、Camera-IMU calibration、Rolling Shutter Camera calibration。</p><a id="more"></a>

<p>ROS官方提供了用于单目或者双目标定的camera_calibration包。这个包是使用opencv里的张正友标定法。</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol>
<li><strong>安装相机驱动 usb_cam</strong></li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> catkin_ws/src </span><br><span class="line">git clone https:<span class="string">//github.com/bosch-ros-pkg/usb_cam.git</span> </span><br><span class="line"><span class="keyword">cd</span> <span class="string">..</span> </span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>安装编译image_pipeline包</strong></li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> catkin_ws/src  </span><br><span class="line">git clone  https:<span class="string">//github.com/ros-perception/image_pipeline.git</span>  </span><br><span class="line"><span class="keyword">cd</span> <span class="string">..</span>  </span><br><span class="line">rosdep install <span class="params">--from-paths</span> src <span class="params">--ignore-src</span>   <span class="comment"># 安装image_pipeline 所需的依赖</span></span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>  编译报错：Project ‘eigen_conversion’ specifies ‘ /usr/locate/eigen3’ as an include dir， which is not found.<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190822205530509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>      <strong>解决：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> <span class="meta">cp</span> -r usr/locate/eigen3 usr/<span class="meta">include</span></span><br></pre></td></tr></table></figure>
<p>eigen3被默认安装到了usr/include里了（系统默认的路径）</p>
<h1 id="1-单目标定"><a href="#1-单目标定" class="headerlink" title="1. 单目标定"></a>1. 单目标定</h1><p>本次标定用笔记本电脑自带的摄像头</p>
<h3 id="启动相机"><a href="#启动相机" class="headerlink" title="启动相机"></a>启动相机</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch usb_cam usb_cam-test.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<h3 id="查看相机话题名称"><a href="#查看相机话题名称" class="headerlink" title="查看相机话题名称"></a>查看相机话题名称</h3><p>用rostopic list命令查看<br>如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usb_cam/</span>camera_info</span><br><span class="line"><span class="regexp">/usb_cam/im</span>age_raw</span><br></pre></td></tr></table></figure>
<h3 id="启动标定程序"><a href="#启动标定程序" class="headerlink" title="启动标定程序"></a>启动标定程序</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py <span class="params">--size</span> 6x7 <span class="params">--square</span> 0.108 image:=<span class="string">/usb_cam/image_raw</span> camera:=<span class="string">/usb_cam</span></span><br></pre></td></tr></table></figure>
<p>此命令运行标定结点的python脚本，其中 ：<br>（1）—size 6x7 为当前标定板的大小<br>（2）—square 0.108为每个棋盘格的边长<br>（3）image:=/camera/image_raw标定当前订阅图像来源自名为/camera/image_raw的topic<br>（4）camera:=/camera为摄像机名，（即在/image_raw前面部分）<br>这将打开标定窗口，如图所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190822213008293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">当calibration按钮亮起时，代表已经有足够的数据进行摄像头的标定，此时请按下calibration并等待一分钟左右。如图所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190822214824661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">**** Calibrating ****</span><br><span class="line">(<span class="string">'D = '</span>, [<span class="number">-0.05651230673613042</span>, <span class="number">0.05365333789734001</span>, <span class="number">0.011954617047270473</span>, <span class="number">-0.007954085488820484</span>, <span class="number">0.0</span>])</span><br><span class="line">(<span class="string">'K = '</span>, [<span class="number">563.3143134843859</span>, <span class="number">0.0</span>, <span class="number">309.5068045388687</span>, <span class="number">0.0</span>, <span class="number">564.0055491490933</span>, <span class="number">241.35221521036223</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">(<span class="string">'R = '</span>, [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">(<span class="string">'P = '</span>, [<span class="number">559.8577880859375</span>, <span class="number">0.0</span>, <span class="number">304.33687100739917</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">561.94921875</span>, <span class="number">246.2792387874797</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>])</span><br><span class="line">None</span><br><span class="line"># oST version <span class="number">5.0</span> parameters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[image]</span><br><span class="line"></span><br><span class="line">width</span><br><span class="line"><span class="number">640</span></span><br><span class="line"></span><br><span class="line">height</span><br><span class="line"><span class="number">480</span></span><br><span class="line"></span><br><span class="line">[narrow_stereo]</span><br><span class="line"></span><br><span class="line">camera matrix</span><br><span class="line"><span class="number">563.314313</span> <span class="number">0.000000</span> <span class="number">309.506805</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">564.005549</span> <span class="number">241.352215</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">distortion</span><br><span class="line"><span class="number">-0.056512</span> <span class="number">0.053653</span> <span class="number">0.011955</span> <span class="number">-0.007954</span> <span class="number">0.000000</span></span><br><span class="line"></span><br><span class="line">rectification</span><br><span class="line"><span class="number">1.000000</span> <span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">1.000000</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">projection</span><br><span class="line"><span class="number">559.857788</span> <span class="number">0.000000</span> <span class="number">304.336871</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">561.949219</span> <span class="number">246.279239</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">1.000000</span> <span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p>When you click on the “Save” button after a succesfull calibration, the data (calibration data and images used for calibration) will be written to /tmp/calibrationdata.tar.gz. </p>
<h1 id="2-双目标定"><a href="#2-双目标定" class="headerlink" title="2. 双目标定"></a>2. 双目标定</h1><p>使用小觅的双目摄像头</p>
<h3 id="运行节点："><a href="#运行节点：" class="headerlink" title="运行节点："></a>运行节点：</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch mynt_eye_ros_wrapper mynteye.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure>
<h3 id="查看相机topic"><a href="#查看相机topic" class="headerlink" title="查看相机topic"></a>查看相机topic</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">rostopic <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<p>如下：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/mynteye/<span class="built_in">right</span>/image_raw</span><br><span class="line">/mynteye/<span class="built_in">left</span>/image_raw</span><br></pre></td></tr></table></figure>
<h3 id="启动标定程序-1"><a href="#启动标定程序-1" class="headerlink" title="启动标定程序"></a>启动标定程序</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.<span class="keyword">py</span> --size <span class="number">7</span>x6 --square <span class="number">0.108</span> --<span class="keyword">no</span>-service-check --approximate=<span class="number">0.1</span> righ<span class="variable">t:</span>=/<span class="keyword">right</span>/image_raw_color lef<span class="variable">t:</span>=/<span class="keyword">left</span>/image_raw_color right_camer<span class="variable">a:</span>=/mynteye/<span class="keyword">right</span> 　　left_camer<span class="variable">a:</span>=/mynteye/<span class="keyword">left</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190823170452291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Left:</span><br><span class="line">(<span class="string">'D = '</span>, [<span class="number">-0.3153135896494001</span>, <span class="number">0.08922897369815266</span>, <span class="number">-0.0002901905072099891</span>, <span class="number">0.0013458912791125815</span>, <span class="number">0.0</span>])</span><br><span class="line">(<span class="string">'K = '</span>, [<span class="number">360.8622464893198</span>, <span class="number">0.0</span>, <span class="number">388.85768685450614</span>, <span class="number">0.0</span>, <span class="number">362.6297239043804</span>, <span class="number">266.69728029954047</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">(<span class="string">'R = '</span>, [<span class="number">0.8780352507831123</span>, <span class="number">-0.47856253594806547</span>, <span class="number">0.005656639390464657</span>, <span class="number">0.47856253594806547</span>, <span class="number">0.8777728998218779</span>, <span class="number">-0.022195394235022585</span>, <span class="number">0.005656639390464657</span>, <span class="number">0.022195394235022585</span>, <span class="number">0.9997376490387657</span>])</span><br><span class="line">(<span class="string">'P = '</span>, [<span class="number">1099.5137871406264</span>, <span class="number">0.0</span>, <span class="number">376.4960060119629</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1099.5137871406264</span>, <span class="number">271.408206820488</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>])</span><br><span class="line"></span><br><span class="line">Right:</span><br><span class="line">(<span class="string">'D = '</span>, [<span class="number">-0.3153135896494001</span>, <span class="number">0.08922897369815266</span>, <span class="number">-0.0002901905072099891</span>, <span class="number">0.0013458912791125815</span>, <span class="number">0.0</span>])</span><br><span class="line">(<span class="string">'K = '</span>, [<span class="number">360.8622464893198</span>, <span class="number">0.0</span>, <span class="number">388.85768685450614</span>, <span class="number">0.0</span>, <span class="number">362.6297239043804</span>, <span class="number">266.69728029954047</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">(<span class="string">'R = '</span>, [<span class="number">0.8780352507831123</span>, <span class="number">-0.47856253594806547</span>, <span class="number">0.005656639390464657</span>, <span class="number">0.47856253594806547</span>, <span class="number">0.8777728998218779</span>, <span class="number">-0.022195394235022585</span>, <span class="number">0.005656639390464657</span>, <span class="number">0.022195394235022585</span>, <span class="number">0.9997376490387657</span>])</span><br><span class="line">(<span class="string">'P = '</span>, [<span class="number">1099.5137871406264</span>, <span class="number">0.0</span>, <span class="number">376.4960060119629</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1099.5137871406264</span>, <span class="number">271.408206820488</span>, <span class="number">-4.2339274257936083e-10</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>])</span><br><span class="line">(<span class="string">'self.T '</span>, [<span class="number">-1.8428136778322234e-13</span>, <span class="number">-3.380063804237598e-13</span>, <span class="number">8.546840383179693e-15</span>])</span><br><span class="line">(<span class="string">'self.R '</span>, [<span class="number">1.0</span>, <span class="number">-9.875948024418507e-14</span>, <span class="number">9.330047922141889e-14</span>, <span class="number">9.875948024418507e-14</span>, <span class="number">1.0</span>, <span class="number">1.4596901161827484e-13</span>, <span class="number">-9.330047922141889e-14</span>, <span class="number">-1.4596901161827484e-13</span>, <span class="number">1.0</span>])</span><br><span class="line">None</span><br><span class="line"># oST version <span class="number">5.0</span> parameters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[image]</span><br><span class="line"></span><br><span class="line">width</span><br><span class="line"><span class="number">752</span></span><br><span class="line"></span><br><span class="line">height</span><br><span class="line"><span class="number">480</span></span><br><span class="line"></span><br><span class="line">[narrow_stereo/left]</span><br><span class="line"></span><br><span class="line">camera matrix</span><br><span class="line"><span class="number">360.862246</span> <span class="number">0.000000</span> <span class="number">388.857687</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">362.629724</span> <span class="number">266.697280</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">distortion</span><br><span class="line"><span class="number">-0.315314</span> <span class="number">0.089229</span> <span class="number">-0.000290</span> <span class="number">0.001346</span> <span class="number">0.000000</span></span><br><span class="line"></span><br><span class="line">rectification</span><br><span class="line"><span class="number">0.878035</span> <span class="number">-0.478563</span> <span class="number">0.005657</span></span><br><span class="line"><span class="number">0.478563</span> <span class="number">0.877773</span> <span class="number">-0.022195</span></span><br><span class="line"><span class="number">0.005657</span> <span class="number">0.022195</span> <span class="number">0.999738</span></span><br><span class="line"></span><br><span class="line">projection</span><br><span class="line"><span class="number">1099.513787</span> <span class="number">0.000000</span> <span class="number">376.496006</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">1099.513787</span> <span class="number">271.408207</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">1.000000</span> <span class="number">0.000000</span></span><br><span class="line"></span><br><span class="line"># oST version <span class="number">5.0</span> parameters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[image]</span><br><span class="line"></span><br><span class="line">width</span><br><span class="line"><span class="number">752</span></span><br><span class="line"></span><br><span class="line">height</span><br><span class="line"><span class="number">480</span></span><br><span class="line"></span><br><span class="line">[narrow_stereo/right]</span><br><span class="line"></span><br><span class="line">camera matrix</span><br><span class="line"><span class="number">360.862246</span> <span class="number">0.000000</span> <span class="number">388.857687</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">362.629724</span> <span class="number">266.697280</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">distortion</span><br><span class="line"><span class="number">-0.315314</span> <span class="number">0.089229</span> <span class="number">-0.000290</span> <span class="number">0.001346</span> <span class="number">0.000000</span></span><br><span class="line"></span><br><span class="line">rectification</span><br><span class="line"><span class="number">0.878035</span> <span class="number">-0.478563</span> <span class="number">0.005657</span></span><br><span class="line"><span class="number">0.478563</span> <span class="number">0.877773</span> <span class="number">-0.022195</span></span><br><span class="line"><span class="number">0.005657</span> <span class="number">0.022195</span> <span class="number">0.999738</span></span><br><span class="line"></span><br><span class="line">projection</span><br><span class="line"><span class="number">1099.513787</span> <span class="number">0.000000</span> <span class="number">376.496006</span> <span class="number">0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">1099.513787</span> <span class="number">271.408207</span> <span class="number">-0.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">1.000000</span> <span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p>When you click on the “Save” button after a succesfull calibration, the data (calibration data and images used for calibration) will be written to /tmp/calibrationdata.tar.gz.</p>
<blockquote>
<p>参考：</p>
<p><a href="http://wiki.ros.org/camera_calibration" target="_blank" rel="noopener">http://wiki.ros.org/camera_calibration</a><br><a href="https://blog.csdn.net/qq_29229045/article/details/78622697" target="_blank" rel="noopener">ROS下相机标定</a></p>
</blockquote>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>标定</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子滤波(PF)</title>
    <url>/2019/08/20/%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="粒子滤波理论"><a href="#粒子滤波理论" class="headerlink" title="粒子滤波理论"></a>粒子滤波理论</h1><p>粒子滤波通过非参数化的蒙特卡洛 (Monte Carlo) 模拟方法来实现递推贝叶斯滤波，适用 于任何能用状态空间模型描述的非线性系统，精度可以逼近最优估计。粒子滤波器具有简单、易于实现等特点，它为分析非线性动态系统提供了一种有效的解决方法，从而引起 目标跟踪、信号处理以及自动控制等领域的广泛关注。首先概述用于求解目标状态后验概率的贝叶斯滤波理论 随后介绍具有普遍适用性的粒子滤波器，最后针对当前粒子滤波器存在的粒子 多样性丧失问题，提出了一种量子进化粒子滤波算法。</p><a id="more"></a>
<h2 id="贝叶斯滤波"><a href="#贝叶斯滤波" class="headerlink" title="贝叶斯滤波"></a>贝叶斯滤波</h2><p>动态系统的目标跟踪问题可以通过图所示的状态空间模型来描述。本节在贝叶斯滤 波框架下讨论目标跟踪问题。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019082114452597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>其中 f(), h() 分别为状态转移方程与观测方程，在目标跟踪问题中，动态系统的状态空间模型可描述为</p>
<script type="math/tex; mode=display">x_k=f(x_{k-1})+u_{k-1}</script><script type="math/tex; mode=display">y_k=h(x_k)+v_k</script><p>为了描述方便，用$X_k=x_{0:k}$={$x_0,x_1,…,x_k$}与$Y_k=y_{0:k}$={$y_0,y_1,…,y_k$}分别表示 0 到 k 时刻所有的状态与观测值。 </p>
<p>在处理目标跟踪问题时， 通常假设目标的状态转移过程服从一阶马尔可夫模型：</p>
<ul>
<li>假设当前时刻的==状态$x_k$ 只与上一时刻的状$x_{k-1}$有关==</li>
<li>假设观测值相互独立，即==观测值$y_k$只与 k 时刻的状态$x_k$有关==</li>
</ul>
<p>贝叶斯滤波为非线性系统的状态估计问题提供了一种基于概率分布形式的解决方案。 贝叶斯滤波将状态估计视为一个概率推理过程， 即将目标状态的估计问题转换为利用贝叶斯公式求解后验概率密度$p(x_k|Y_k)$ 或滤波概率密度$p(x_k|Y_k)$，进而获得目标状态的最优估计。<br><strong>贝叶斯滤波包含预测和更新两个阶段</strong>：</p>
<ul>
<li>预测过程：利用系统模型预测状态的先验概率密度 </li>
<li>更新过程：利用最新的测量值对先验概率密度进行修正，得到后验概率密度</li>
</ul>
<p>假设已知$k_1$ 时刻的概率密度函数为$p(x_{k-1}|Y_{k-1})$，贝叶斯滤波的具体过程如下：</p>
<ol>
<li><strong>预测过程</strong>，由$p(x_{k-1}|Y_{k-1})$得到$p(x_{k}|Y_{k-1})$<script type="math/tex; mode=display">p(x_k,x_{k-1}|Y_{k-1})=p(x_k|x_{k-1},Y_{k-1})   p(x_{k-1}|Y_{k-1})</script></li>
</ol>
<p>当给定$x_{k-1}$时，状态$x_k$与$Y_{k-1}$相互独立，所以：</p>
<script type="math/tex; mode=display">p(x_k,x_{k-1}|Y_{k-1})=p(x_k|x_{k-1})p(x_{k-1}|Y_{k-1})</script><p>对上式$x_{k-1}$积分：</p>
<script type="math/tex; mode=display">p(x_k,|Y_{k-1})=\int p(x_k|x_{k-1})p(x_{k-1}|Y_{k-1})dx_{k-1}</script><ol>
<li><strong>跟新过程</strong>，由$p(x_k,|Y_{k-1})$得到$p(x_k,|Y_{k})$：<br>获取 k 时刻的测量$y_k$后，利用贝叶斯公式对先验概率密度进行更新，得到后验概率<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821151700602.png#pic_center"><br>假设$y_k$只有$x_k$决定，即：<script type="math/tex; mode=display">p(y_k|x_k,Y_{k-1})=p(y_k|x_k)</script>因此：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821152025820.png#pic_center"><br>其中，$p(y_k|Y_{k-1})$为归一化常数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821152255977.png#pic_center"><br>贝叶斯滤波以递推的形式给出后验 (或滤波 )概率密度函数的最优解。 目标状态的最优估计值可由后验 ( 或滤波 ) 概率密度函数进行计算。 通常根据极大后验 (MAP) 准则或最小均方误 差(MMSE) 准则，将具有极大后验概率密度的状态或条件均值作为系统状态的估计值，即<script type="math/tex; mode=display">\hat{x}_k^{MAP}=argminp(x_k|Y_k)</script><script type="math/tex; mode=display">\hat{x}_k^{MMSE}=\int E([x_k|Y_k])=\int f(x_k)p(x_k|Y_k)dx_k</script>贝叶斯滤波需要进行积分运算，除了一些特殊的系统模型（如线性高斯系统，有限状态的离散系统）之外，对于一般的非线性、非高斯系统，贝叶斯滤波很难得到后验概率的封闭解析式。因此，现有的非线性滤波器多采用近似的计算方法解决积分问题，以此来获取估计的次优解。在系统的非线性模型可由在当前状态展开的线性模型有限近似的前提下，基于一阶或二阶Taylor级数展开的扩展Kalman滤波得到广泛应用。在一般情况下，逼近概率密度函数比逼近非线性函数容易实现。据此，Julier与Uhlmann提出一种Unscented Kalman滤波器，通过选定的sigma点来精确估计随机变量经非线性变换后的均值和方差，从而更好的近似状态的概率密度函数，其理论估计精度优于扩展Kalman滤波。获取次优解的另外一中方案便是基于蒙特卡洛模拟的粒子滤波器。<br><strong>## 粒子滤波<br>标准的粒子滤波算法流程为</strong>：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826114055219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
</ol>
<h3 id="贝叶斯重要性采样"><a href="#贝叶斯重要性采样" class="headerlink" title="贝叶斯重要性采样"></a>贝叶斯重要性采样</h3><p>粒子滤波算法的核心思想便是利用一系列随机样本的加权和表示后验概率密度，通过求和来近似积分操作。假设可以从后验概率密度$p(x_k,Y_k)$中抽取N个独立同分布的随机样本$x_k^{(i)},i=1,…,N$，则有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821160035880.png#pic_center"><br>这里$x_k$为连续变量，$\delta (x-x_k)$为单位冲激函数(狄拉克函数)，即$\delta (x-x_k)=0$，$x  \neq x_k$,且$\int \delta (x)dx=1$.</p>
<p>当$x_k$为离散变量时，后验概率分布$P(x_k|Y_k)$可近似逼近为:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821160001494.png"><br>设 $x_k^{(i)}$为从后验概率密度函数$p(x_k|Y_k)$中获取的采样粒子，则任意函数$f(x_k)$ 的期望<br>估计可以用求和方式逼近，即<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821160415685.png#pic_center"><br>蒙特卡洛方法一般可以归纳为以下三个步骤：</p>
<ul>
<li>构造概率模型。对于本身具有随机性质的问题，主要工作是正确地描述和模拟这个概 率过程。对于确定性问题，比如计算定积分、求解线性方程组、偏微分方程等问题，采 用蒙特卡洛方法求解需要事先构造一个人为的概率过程，将它的某些参量视为问题的 解。</li>
<li>从指定概率分布中采样。产生服从己知概率分布的随机变量是实现蒙特卡洛方法模拟 试验的关键步骤。 </li>
<li>建立各种估计量的估计。一般说来，构造出概率模型并能从中抽样后，便可进行现模 拟试验。随后，就要确定一个随机变量，将其作为待求解问题的解进行估计。 </li>
</ul>
<p>在实际计算中， <strong>通常无法直接从后验概率分布中采样， 如何得到服从后验概率分布的随机样本是蒙特卡洛方法中基本的问题之一</strong>。 ==重要性采样法引入一个已知的、 容易采样的重要性概率密度函数$q(x_k|Y_k)$，从中生成采样粒子，利用这些随机样本的加权和来逼近后验滤<br>波概率密度$p(x_k|Y_k)$== ，如图 2.3所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821160745836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>令{$x_k^{(i)}, w_k^{(i)},i=1,…,N$表示一支撑点，其中$x_k^{(i)}$是 k 时刻第 i 个粒子的状态，其相应的权值为$ w_k^{(i)}$ ，则后验滤波概率密度可以表示为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821161103465.png#pic_center"><br>其中：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821161204410.png#pic_center"><br>当采样粒子的数目很大时，便可近似逼近真实的后验概率密度函数。任意函数$f(x_k)$的期望估计为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190821161407463.png#pic_center"></p>
<h3 id="序贯重要性采样算法"><a href="#序贯重要性采样算法" class="headerlink" title="序贯重要性采样算法"></a>序贯重要性采样算法</h3><p>在基于重要性采样的蒙特卡洛模拟方法中，估计后验滤波概率需要利用所有的观测数据，每次新的观测数据来到都需要重新计算整个状态序列的重要性权值。序贯重要性采样作为粒子滤波的基础，它将统计学中的序贯分析方法应用到的蒙特卡洛方法中，从而实现后验滤波概率密度的递推估计。假设重要性概率密度函数$q(x_{0:k}|y_{1:k})$可以分解为</p>
<script type="math/tex; mode=display">q(x_{0:k}|y_{1:k})=q(x_{0:k-1}|y_{1:k-1}) q(x_k|x_{0:k-1}，y_{1:k-1})</script><p>设系统状态是一个马尔可夫过程，且给定系统状态下各次观测独立，则有<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826110136724.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826110126696.png#pic_center"></p>
<p>后验概率密度函数的递归形式可以表示为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826110458830.png#pic_center"><br>粒子权值$w_k^{(i)}$的递归形式可以表示为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826110606359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>通常，需要对粒子权值进行归一化处理，即<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826110647797.png#pic_center"><br>序贯重要性采样算法从重要性概率密度函数中生成采样粒子，并随着测量值的依次到来递推求得相应的权值，最终以粒子加权和的形式来描述后验滤波概率密度，进而得到状态估计。序贯重要性采样算法的流程可以用如下伪代码描述：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826112642193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h3 id="重要密度函数的选择"><a href="#重要密度函数的选择" class="headerlink" title="重要密度函数的选择"></a>重要密度函数的选择</h3><p>重要性概率密度函数的选择对粒子滤波的性能有很大影响，在设计与实现粒子滤波器的过程中十分重要。在工程应用中，通常选取状态变量的转移概率密度函数作为重要性概率密度函数。此时，粒子的权值为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826113328640.png#pic_center"><br>转移概率的形式简单且易于实现，在观测精度不高的场合，将其作为重要性概率密度函数可以取得较好的滤波效果。<br>然而，==采用转移概率密度函数作为重要性概率密度函数没有考虑最新观测数据所提供的信息，从中抽取的样本与真实后验分布产生的样本存在一定的偏差==，特别是当观测模型具有较高的精度或预测先验与似然函数之间重叠部分较少时，这种偏差尤为明显。<br>择重要性概率密度函数的一个标准是使得粒子权值的方差最小。Doucet等给出的最优重要性概率密度函数为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826113632863.png#pic_center"><br>此时，粒子的权值为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826113659119.png#pic_center"></p>
<blockquote>
<p>参考<br><a href="https://wenku.baidu.com/view/362c5868a300a6c30c229fbd.html" target="_blank" rel="noopener">粒子滤波理论一看就懂</a></p>
</blockquote>
]]></content>
      <categories>
        <category>滤波算法</category>
      </categories>
  </entry>
  <entry>
    <title>无迹卡尔曼滤波（UKF)</title>
    <url>/2019/08/18/%E6%97%A0%E8%BF%B9%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>无损卡尔曼滤波又称无迹卡尔曼滤波（Unscented Kalman Filter，UKF），是无损变换（Unscented Transform，UT）与标准卡尔曼滤波体系的结合，通过无损变换变换使非线性系统方程适用于线性假设下的标准卡尔曼体系。</p><p>UKF使用的是统计线性化技术，我们把这种线性化的方法叫做无损变换（unscented transformation）这一技术主要通过n个在先验分布中采集的点（我们把它们叫sigma points）的线性回归来线性化随机变量的非线性函数，由于我们考虑的是随机变量的扩展，所以这种线性化要比泰勒级数线性化（EKF所使用的策略）更准确。和EKF一样，UKF也主要分为预测和更新。</p><a id="more"></a>

<p>UKF的基本思想是卡尔曼滤波与无损变换，它能有效地克服EKF估计精度低、稳定性差的问题，因为不用忽略高阶项，所以对于非线性分布统计量的计算精度高。</p>
<h1 id="2-CTRV运动模型"><a href="#2-CTRV运动模型" class="headerlink" title="2. CTRV运动模型"></a>2. CTRV运动模型</h1><p>恒定转率和速度模型（Constant Turn Rate and Velocity，CTRV）</p>
<h3 id="2-1-CTRV的目标状态量："><a href="#2-1-CTRV的目标状态量：" class="headerlink" title="2.1 CTRV的目标状态量："></a>2.1 CTRV的目标状态量：</h3><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819100637641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819100958824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="2-2-CTRV的状态转移函数："><a href="#2-2-CTRV的状态转移函数：" class="headerlink" title="2.2 CTRV的状态转移函数："></a>2.2 CTRV的状态转移函数：</h3><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819101412520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819101550969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819102107721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="2-3-CTRV-Process-Noise"><a href="#2-3-CTRV-Process-Noise" class="headerlink" title="2.3 CTRV Process Noise"></a>2.3 CTRV Process Noise</h3><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819103526397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819104046490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819104738388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="3-Prediction"><a href="#3-Prediction" class="headerlink" title="3. Prediction"></a>3. Prediction</h1><p>分为3个步骤：</p>
<ul>
<li>产生Sigma点</li>
<li>预测Sigma点的下一帧状态 （类似于粒子滤波中的预测，更新粒子状态）</li>
<li>预测系统状态的均值和方差（类似于粒子滤波中的加权平均）</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819110512236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="3-1-Generate-Sigma-Points"><a href="#3-1-Generate-Sigma-Points" class="headerlink" title="3.1 Generate Sigma Points"></a>3.1 Generate Sigma Points</h3><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819112505867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>通常，假定状态的个数为 n ，我们会产生 2n+1 个sigma点，其中第一个就是我们当前状态的均值 μ ，sigma点集的均值的计算公式为：</p>
<script type="math/tex; mode=display">\chi^{[ 1 ]} = \mu</script><script type="math/tex; mode=display">\chi^{[i]} = \mu + \left( \sqrt {(n + \lambda)P}\right)_i \quad for \ \ i=2, ..., n+1</script><script type="math/tex; mode=display">\chi^{[i]} = \mu - \left( \sqrt {(n + \lambda)P} \right)_{i-n} \quad for \ \ i=n+2, ..., 2n+1</script><p>其中的 λ 是一个超参数，根据公式，λ 越大， sigma点就越远离状态的均值，λ 越小， sigma点就越靠近状态的均值。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019081911410191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在我们的CTRV模型中，状态数量 n 除了要包含5个状态以外，还要包含处理噪声 μa 和 μω˙,因为这些处理噪声对模型也有着非线性的影响。在增加了处理噪声的影响以后，我们的不确定性矩阵 P 就变成了：</p>
<script type="math/tex; mode=display">P = \left( \begin{array}{c} P' & 0 \\ 0 & Q \end{array} \right)</script><p>其中，P′ 就是我们原来的不确定性矩阵（在CTRV模型中就是一个 5×5 的矩阵），Q是处理噪声的协方差矩阵，在CTRV模型中考虑到直线加速度核Q的形式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819170212569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">计算增广的Sigma Points<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819170337324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="3-2-预测sigma-point"><a href="#3-2-预测sigma-point" class="headerlink" title="3.2 预测sigma point"></a>3.2 预测sigma point</h3><p>现在我们有sigma点集，根据process model  $g(\chi_k, \mu_k)$预测未来的Sigma点$X_{k+1|k}$</p>
<script type="math/tex; mode=display">\chi_{k+1} = g(\chi_k, \mu_k)</script><p>需要注意的是，这里的输入$\chi_k$ 是一个 (7,15)的矩阵（因为考虑了两个噪声量），但是输出 $\chi_{k+1 | k}$是一个(5,15)的矩阵（因为这是预测的结果，本质上是基于运动模型的先验，先验中的均值不应当包含 $a , ω˙$这类不确定的量）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819132143799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="3-3-预测均值和方差"><a href="#3-3-预测均值和方差" class="headerlink" title="3.3  预测均值和方差"></a>3.3  预测均值和方差</h3><p>根据预测的Sigma点$X_{k+1|k}$生成状态预测$x_{k+1|k}, P_{k+1|k}$</p>
<ol>
<li>首先要计算出各个sigma点的权重，权重的计算公式为：<script type="math/tex; mode=display">w_{i} = \frac{\lambda}{\lambda + n_{\sigma}}, \quad i = 1$$.
$$w_{i} = \frac{1}{2(\lambda + n_{\sigma})}, \quad i = 2, ..., 2n_{\sigma}+1</script></li>
</ol>
<ol>
<li>然后基于每个sigma点的权重去求新的分布的均值和方差：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819132323338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>$x_{k+1|k}$是sigma点集中每个点各个状态量的加权和， P′ 即为先验分布的协方差（不确定性） $P_{k+1|k}$ ， 由每个sigma点的方差的加权和求得。</li>
</ol>
<h1 id="4-Update"><a href="#4-Update" class="headerlink" title="4. Update"></a>4. Update</h1><h3 id="4-1-Predict-Measurement-将先验映射到测量空间然后算出均值和方差）"><a href="#4-1-Predict-Measurement-将先验映射到测量空间然后算出均值和方差）" class="headerlink" title="4.1  Predict Measurement(将先验映射到测量空间然后算出均值和方差）"></a>4.1  Predict Measurement(将先验映射到测量空间然后算出均值和方差）</h3><p>测量分为两个部分，LIDAR测量和RADAR测量，其中LIDAR测量模型本身就是线性的，所以我们重点还是放在RADAR测量模型的处理上面，RADAR的测量f非线性映射函数为： </p>
<script type="math/tex; mode=display">h(x) = \left[
 \begin{matrix}
   \rho  \\
   \phi \\
   \dot{\rho} 
  \end{matrix}
  \right] =
  \left[
 \begin{matrix}
  \sqrt{p_x^2+p_y^2}  \\
   \arctan{\frac{p_y}{p_x}} \\
  \frac{p_x v_x + p_y v_y}{\sqrt{p_x^2+p_y^2}  }
  \end{matrix}\right]</script><p>Measurement model如图所示：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819132912882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>再一次，我们使用无损转换来解决，但是这里，我们可以不用再产生sigma points了，我们可以直接使用预测出来的sigma点集，并且可以忽略掉处理噪声部分。那么对先验的非线性映射就可以表示为如下的sigma point预测（即预测非线性变换以后的均值和协方差）：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019081913284139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819133034445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>这里的 R 也是测量噪声，在这里我们直接将测量噪声的协方差加到测量协方差上是因为该噪声对系统没有非线性影响。在本例中，以RADAR的测量为例，那么测量噪声R为：</p>
<script type="math/tex; mode=display">R = E[ww^T] = \left(\begin{matrix} \sigma_{\rho}^2 & 0 & 0 \\  0 & \sigma_{\psi}^2 & 0 \\  0 & 0 & \sigma_{\dot\rho}^2 \\ \end{matrix}\right)</script><h3 id="4-2-Update-State"><a href="#4-2-Update-State" class="headerlink" title="4.2 Update State"></a>4.2 Update State</h3><ul>
<li>首先计算出sigma点集在状态空间和测量空间的互相关函数$T_{k+1|k}$</li>
<li>计算卡尔曼增益$K_{k+1|k}$</li>
<li>更新状态，计算$x_{k+1|k+1}（其中 $z_{k+1}$ 是新得到的测量，而 $z_{k+1|k}$ 则是我们根据先验计算出来的在测量空间的测量)。</li>
<li>更新状态协方差矩阵，计算$P_{k+1|k+1}$</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190819133352530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p>参考：<br><a href="https://blog.csdn.net/adamshan/article/details/78359048" target="_blank" rel="noopener">无人驾驶汽车系统入门（三）——无损卡尔曼滤波，目标追踪，C++</a><br><a href="https://blog.csdn.net/AdamShan/article/details/78265754" target="_blank" rel="noopener">无人驾驶汽车系统入门（二）——高级运动模型和扩展卡尔曼滤波</a></p>
<h1 id><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      <categories>
        <category>滤波算法</category>
      </categories>
  </entry>
  <entry>
    <title>线性插值、双线性插值</title>
    <url>/2019/08/14/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E3%80%81%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190814224605205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>双线性插值，又称为双线性内插。在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。</p><p>假设源图像大小为$m\times n$，目标图像为$a\times b$。那么两幅图像的边长比分别为：$m\times n$和$N\times b$。注意，通常这个比例不是整数，编程存储的时候要用浮点型。目标图像的第$（i,j）$个像素点（i行j列）可以通过边长比对应回源图像。其对应坐标为$（i<em>m/a,j</em>n/b）$。显然，这个对应坐标一般来说不是整数，而非整数的坐标是无法在图像这种离散数据上使用的。双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的值（灰度值或者RGB值）。</p><a id="more"></a>


<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>若图像为灰度图像，那么（i，j）点的灰度值的数学计算模型是：</p>
<script type="math/tex; mode=display">f(x,y)=b_{1}+b_{2}x+b_{3}y+b_{4}xy</script><p>其中$b_{1},b_{2},b_{3},b_{4}$是相关的系数。关于其的计算过程如下如下：<br>如图，已知$Q_{12}，Q_{22}，Q_{11}，Q_{21}$，但是要插值的点为P点，这就要用双线性插值了，首先在x轴方向上，对R1和R2两个点进行插值，这个很简单，然后根据$R1$和$R2$对P点进行插值，这就是所谓的双线性插值。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190814221450442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>假如我们想得到未知函数f在点$P=(x,y)$的值，假设我们已知函数$f$在$Q_{11}=(x_{1},y_{1}),Q_{12}=(x_{1},y_{2}),Q_{21}=(x_{2},y_{1}),Q_{22}=(x_{2},y_{2})$四个点的值。<br>首先在 x 方向进行线性插值，得到</p>
<script type="math/tex; mode=display">f(R_{1})\approx \frac{x_{2}-x}{x_{2}-x_{1}} f(Q_{11}) + \frac{x-x_{1}}{x_{2}-x_{1}} f(Q_{21}) \leftarrow R_{1}=(x,y_{1})</script><script type="math/tex; mode=display">f(R_{2})\approx \frac{x_{2}-x}{x_{2}-x_{1}} f(Q_{12}) + \frac{x-x_{1}}{x_{2}-x_{1}} f(Q_{22}) \leftarrow R_{1}=(x,y_{2})</script><p>然后在 y 方向进行线性插值，得到:</p>
<script type="math/tex; mode=display">f(P)\approx \frac{y_{2}-y}{y_{2}-y_{1}} f(R_{1}) + \frac{y-y_{1}}{y_{2}-y_{1}} f(R_{2})</script><p>这样就得到所要的结果f(x,y):</p>
<script type="math/tex; mode=display">f(x,y) \approx \frac{Q_{11}}{(x_{2}-x_{1})(y_{2}-y_{1})} (x_{2}-x)(y_{2}-y) + \frac{Q_{21}}{(x_{2}-x_{1})(y_{2}-y_{1})} (x-x_{1})(y-y_{1})</script><p>如果选择一个坐标系统使得 f 的四个已知点坐标分别为 (0, 0)、(0, 1)、(1, 0) 和 (1, 1)，那么插值公式就可以化简为:</p>
<script type="math/tex; mode=display">f(x,y) \approx f(0,0)(1-x)(1-y)+f(1,0)x(1-y)+f(0,1)(1-x)y+f(1,1)xy</script><p>或者用矩阵运算表示为:</p>
<script type="math/tex; mode=display">f(x,y) \approx [1-x \ x] \begin{bmatrix}         f(0,0) & f(0,1) \         f(1,0) & f(1,1) \end{bmatrix} \begin{bmatrix}         1-y\         y \end{bmatrix}</script><p>这种插值方法的结果通常不是线性的，线性插值的结果与插值的顺序无关。首先进行 y 方向的插值，然后进行 x 方向的插值，所得到的结果是一样的。</p>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/objdetect/objdetect.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//srcX = dstX * (srcWidth /dstWidth)</span></span><br><span class="line"><span class="comment">//srcY = dstY * (srcHeight/dstHeight)</span></span><br><span class="line"><span class="comment">//f(i+u,j+v) = (1-u)(1-v)f(i,j) + (1-u)vf(i,j+1) + u(1-v)f(i+1,j) + uvf(i+1,j+1);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> scale = <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">double</span> srcX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> srcY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Int_tmp_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> Dot_tmp_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Int_tmp_y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> Dot_tmp_y = <span class="number">0</span>;</span><br><span class="line">    Mat src = imread(<span class="string">"./res/lena.jpg"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">Mat <span class="title">dst</span><span class="params">(scale * src.cols, scale * src.rows, src.type())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> x = <span class="number">0</span>; x &lt; src.cols * scale - (<span class="keyword">int</span>)scale; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> y = <span class="number">0</span>; y &lt; src.rows * scale - (<span class="keyword">int</span>)scale; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)</span><br><span class="line">                dst.at&lt;<span class="keyword">char</span>&gt;(x, y) = src.at&lt;<span class="keyword">char</span>&gt;(x, y);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                srcX = x / scale;</span><br><span class="line">                Int_tmp_x = (<span class="keyword">int</span>)srcX;</span><br><span class="line">                Dot_tmp_x = srcX - Int_tmp_x;</span><br><span class="line"></span><br><span class="line">                srcY = y / scale;</span><br><span class="line">                Int_tmp_y = (<span class="keyword">int</span>)srcY;</span><br><span class="line">                Dot_tmp_y = srcY - Int_tmp_y;</span><br><span class="line"></span><br><span class="line">                dst.at&lt;uchar&gt;(x, y) =</span><br><span class="line">                    (<span class="number">1</span> - Dot_tmp_x)*(<span class="number">1</span> - Dot_tmp_y)*src.at&lt;uchar&gt;(Int_tmp_x, Int_tmp_y) +</span><br><span class="line">                    (<span class="number">1</span> - Dot_tmp_x)*Dot_tmp_y*src.at&lt;uchar&gt;(Int_tmp_x, Int_tmp_y + <span class="number">1</span>) +</span><br><span class="line">                    Dot_tmp_x*(<span class="number">1</span> - Dot_tmp_y)*src.at&lt;uchar&gt;(Int_tmp_x + <span class="number">1</span>, Int_tmp_y) +</span><br><span class="line">                    Dot_tmp_x*Dot_tmp_y*src.at&lt;uchar&gt;(Int_tmp_x + <span class="number">1</span>, Int_tmp_y + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dst.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//imwrite("./res/lena_large.jpg", dst);</span></span><br><span class="line">    imshow(<span class="string">"Dst"</span>,dst);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>DeepLab V2论文笔记</title>
    <url>/2019/07/14/DeepLab-V2%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>论文原文：<a href="https://arxiv.org/abs/1606.00915" target="_blank" rel="noopener">https://arxiv.org/abs/1606.00915</a></p>]]></content>
      <categories>
        <category>深度学习</category>
        <category>语义分割</category>
      </categories>
  </entry>
  <entry>
    <title>DeepLab V1论文笔记</title>
    <url>/2019/07/13/DeepLab-V1%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文：<a href="https://arxiv.org/abs/1412.7062v4" target="_blank" rel="noopener">https://arxiv.org/abs/1412.7062v4</a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>DeepLab是结合了深度卷积神经网络(DCNNs)和概率图模型(DenseCRFs)的方法。实验发现DCNNs最后一层的响应不能充分地用于定位精确的目标分割，根本原因是DCNNs的高级特征的平移不变性（即高层次特征映射）。DeepLab解决这一问题的方法是通过将DCNNs层的响应和完全连接的条件随机场(CRF)结合。同时模型创新性的将Hole（即空洞卷积）算法应用到DCNNs模型上。</p><a id="more"></a>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ol>
<li>相比于传统的视觉算法(SIFT或HOG)，DCNN以其end-to-end方式获得了很好的效果，成功部分可以归功于DCNN对图像转换的平移不变性，这一属性能加强它们学习数据的分层抽象能力。 不变性非常适用于高级视觉任务, 但不利于低级任务, 如姿态估计、语义分割，在这些任务中我们倾向于精确的定位而不是抽象的空间关系。</li>
<li>DCNN在图像标注任务应用上的两大技术障碍: <blockquote>
<p>信号的下采样：DCNN每层max-pooling及downsampling(striding)的结合造成信号分辨率减小，DeepLab是采用的atrous(带孔)算法扩展感受野，获取更多的上下文信息。<br>空间不灵敏性(不变性) ：分类器获取以对象中心的决策是需要空间变换的不变性，这天然的限制了DCNN的定位精度，DeepLab采用完全连接的条件随机场(DenseCRF)能够捕获细微的边缘细节，同时也适应远程依赖，模型很大程度上提高了基于像素级别分类器的性能。</p>
</blockquote>
</li>
<li>DeepLab的三个主要优点 ：<blockquote>
<ul>
<li>速度：带atrous算法的DCNN可以保持8FPS的速度，全连接CRF平均推断需要0.5s。<ul>
<li>准确：在PASCAL语义分割挑战中获得了第二的成绩</li>
</ul>
</li>
<li>简单：DeepLab是由两个非常成熟的模块(DCNN和CRFs)级联而成<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1></li>
</ul>
</blockquote>
</li>
<li><p>DeepLab系统应用在语义分割任务上，目的是做逐像素分类的，这与使用两阶段的DCNN方法形成鲜明对比(指R-CNN等系列的目标检测工作)，R-CNN系列的做法是原先图片上获取候选区域，再送到DCNN中获取分割建议，重新排列取结果。虽然这种方法明确地尝试处理前段分割算法的本质，但在仍没有明确的利用DCNN的预测图。</p>
</li>
<li><p>我们的系统与其他先进模型的主要区别在于DenseCRFs和DCNN的结合。是将每个像素视为CRF节点，利用远程依赖关系，并使用CRF推理直接优化DCNN的损失函数。Koltun(2011)的工作表明完全连接的CRF在语义分割下非常有效。</p>
</li>
<li><p>也有其他组采取非常相似的方向，将DCNN和密集的CRF结合起来，我们已经更新提出了DeepLab系统(指的是DeepLabV2)。</p>
</li>
</ol>
<h1 id="3-密集分类下的卷积神经网络"><a href="#3-密集分类下的卷积神经网络" class="headerlink" title="3.  密集分类下的卷积神经网络"></a>3.  密集分类下的卷积神经网络</h1><h2 id="3-1-采用孔洞算法的高效密集滑动窗口特征提取"><a href="#3-1-采用孔洞算法的高效密集滑动窗口特征提取" class="headerlink" title="3.1 采用孔洞算法的高效密集滑动窗口特征提取"></a>3.1 采用孔洞算法的高效密集滑动窗口特征提取</h2><p>空洞算法：atrous算法可以稀疏的采样底层特征映射，该方法可以使用任何采样率计算密集的特征映射。在VGG-16中使用不同采样率的空洞卷积，可以让模型密集计算时明确控制网络的感受野，从而保证DCNN的预测图可靠的预测图像中物体的位置。</p>
<p>将VGG-16的全连接层改成卷积层，图像以原始分辨率输入，会产生非常稀疏的检测分数（步幅32,步幅=输入尺寸/输出特征尺寸步幅），为了在我们的8像素的目标步幅上更密集地计算分数，在VGG网络中最后两个最大池化层之后跳过subsampling(池化层)，而是采用2或者4采样率的空洞卷积对特征图做采样扩大感受野从而缩小步幅。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190713220706128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714153501835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>蓝色部分是输入：7×7的图像；</li>
<li>青色部分是输出：3×3的图像；</li>
<li>空洞卷积核：3×3 采样率(扩展率)为2 无padding。</li>
</ul>
<p>图1的这种方法被称为“孔洞算法”（atrous algorithm）（空洞卷积），并且已经被用于高效计算多孔算法(也叫做非抽取小波变换)。 通过添加到im2col函数（将多通道特征图转换为矢量块），将稀疏样本的底层特征图添加到Caffe框架中来实现这个操作。 并且允许以任何目标子采样率有效地计算密集的CNN特征图，而不引入任何近似值。</p>
<p>微调Imagenet预先训练的VGG-16网络的模型权重，使其可以用于图像分类。 然后将最后一层的1000-way分类器改成21-way分类器，损失函数是CNN输出（原图8倍下采样）空间每个点的cross-entropy之和，所有位置和标签在整体损失函数中的权重相等，目标是ground truth（8倍下采样），SGD优化目标函数。</p>
<h2 id="3-2-用卷积网络减小感受野并加速密集计算"><a href="#3-2-用卷积网络减小感受野并加速密集计算" class="headerlink" title="3.2 用卷积网络减小感受野并加速密集计算"></a>3.2 用卷积网络减小感受野并加速密集计算</h2><p>网络进行密集分数计算的另一个关键因素是明确控制网络的感受野大小。 基于DCNN的图像识别方法依赖于在Imagenet大规模分类任务上预先训练的网络。 这些网络通常具有很大的感受野大小，无法保证良好的定位精度。此外，在将网络转换为完全卷积的网络之后，第一个全连接层具有4,096个大的7×7空间大小的滤波器，密集分数图计算成为瓶颈。。我们在第一层FC前下采样，同时减少FC的通道数（从4096到1024）。</p>
<p>我们已经通过将第一FC层空间抽样到4×4空间大小来解决这两个严重的实际问题。 这将网络的感受野减少到128×128（零填充）或308×308（卷积模式），并将第一个FC层的计算时间缩短了3倍。 使用我们的基于Caffe的实现和Titan GPU，由此产生的VGG派生网络非常有效：给定一个306×306输入图像，它在网络末端产生39×39密集原始特征图，速率约为8 fps在测试期间。 训练时的速度为3帧/秒。 我们还成功地将全连接层上的神经元数量从4096个减少到1024个，在不牺牲性能的情况下进一步大大减少了计算时间和内存占用，详见第5节。使用较小的网络，如Krizhevsky等 （2013）可以允许视频速率测试时密集特征计算，即使在轻型GPU上。</p>
<h1 id="4-详细的边界恢复：完全连接的条件随机场和多尺度预测"><a href="#4-详细的边界恢复：完全连接的条件随机场和多尺度预测" class="headerlink" title="4. 详细的边界恢复：完全连接的条件随机场和多尺度预测"></a>4. 详细的边界恢复：完全连接的条件随机场和多尺度预测</h1><h2 id="4-1-深卷积网络和定位挑战"><a href="#4-1-深卷积网络和定位挑战" class="headerlink" title="4.1 深卷积网络和定位挑战"></a>4.1 深卷积网络和定位挑战</h2><p>如图2所示，DCNN分数图可以可靠地预测图像中对象的存在和粗略位置，但不太适合用于勾画其精确轮廓。 卷积网络在分类精度和定位精度之间有自然的trade-off：深度模型表明了最大池化层在分类任务中很有效，但增加的不变性和大的感受野使得在其高输出层分数推断位置的问题更困难。<br>解决方法：</p>
<ul>
<li>利用卷积网络中多层的信息来更好地估计对象边界。 </li>
<li>采用超像素表示，实质上是将定位任务委托给低级分割方法。</li>
</ul>
<p>Deeplab方案：耦合DCNN的识别能力和完全连接的CRF的细粒度定位精度来寻求新的替代方向，并表明它在解决定位挑战方面非常成功，产生了准确的语义分割结果。</p>
<h2 id="4-2-全连接CRF用于精确定位"><a href="#4-2-全连接CRF用于精确定位" class="headerlink" title="4.2 全连接CRF用于精确定位"></a>4.2 全连接CRF用于精确定位</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714110823350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>传统上，CRF已被用于平滑噪声分割图。通常，这些模型包含耦合相邻节点的能量项，有利于相同标签分配空间近端像素。定性的说，这些短程的CRF主要功能是清除在手工特征基础上建立的弱分类器的虚假预测。</p>
<p>与这些较弱的分类器相比，现代DCNN体系结构如我们在这项工作中使用的结构产生了定性不同的得分图和语义标签预测。如图2所示，Score map通常相当平滑并产生均匀分类结果。在这个制度下，使用短距离CRFs可能不好，因为我们的目标应该是恢复详细的局部结构，而不是进一步平滑。使用对比敏感的能量函数（Rother等人，2004）结合局部范围的CRF可以潜在地改善局部化，但仍然忽略了薄弱结构(thin-structures)，通常需要解决昂贵的离散优化问题。</p>
<p>为了克服短距离CRF的这些限制，可用全连接的CRF来提升分割精度。该模型采用能量函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714155409534.png"></p>
<p>其中 $x$ 是像素的标签分配。<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714112738205.png==#pic_center"><br>$P(x_i)$是像素i的标签分配概率</p>
<script type="math/tex; mode=display">θ_{ij} (x_i , x_j ) = μ(x_i , x_j ) m=\sum ^K_{m=1}w_m · k_m (f_i , f_j )</script><p>其中：<br>$μ(x_i , x_j ) =1$ if $x_i \neq x_j$,否则为0<br>$k^m$是高斯核取决于为像素$i$和$j$提取的特征（表示为$f$），并由参数 $w^m$加权<br>采用双边位置和颜色组合，具体来说，内核是：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714113959723.png"><br>其中第一个内核依赖于像素位置（表示为$p$ ）和像素颜色强度（表示为$I$），而第二个内核只取决于像素位置。超参数 $\sigma _{\alpha }$， $\sigma _{\beta }$和$\sigma _{\gamma  }$控制高斯核的“尺度”。</p>
<h2 id="4-3-多尺度预测"><a href="#4-3-多尺度预测" class="headerlink" title="4.3 多尺度预测"></a>4.3 多尺度预测</h2><p>使用多尺度预测提高边界定位效果：在输入图像和前四个最大池化层的输出上加了两层的MLP(第一层是128个3×3卷积，第二层是128个1×1卷积)，最终输出的特征映射送到模型的最后一层辅助预测，合起来模型最后的softmax层输入特征多了5×128=640个通道，实验表示多尺度有助于提升预测结果，但是效果不如CRF明显。</p>
<h1 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h1><ol>
<li>实验设置<blockquote>
<ul>
<li>数据集：PASCAL VOC 2012 segmentation benchmark<ul>
<li>DCNN模型：权重采用预训练的VGG16</li>
<li>DCNN损失函数：交叉熵cross-entropy</li>
<li>训练器：SGD，batch=20</li>
</ul>
</li>
<li>学习率：初始为0.001，最后的分类层是0.01。每2000次迭代乘0.1</li>
<li>权重：0.9的动量， 0.0005的衰减</li>
</ul>
</blockquote>
</li>
</ol>
<p>DeepLab由DCNN和CRF组成，训练策略是分段训练，即DCNN的输出是CRF的一元势函数，在训练CRF时是固定的。在对DCNN做了fine-tune后，对CRF做交叉验证。</p>
<ol>
<li>验证集上评估<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714160144493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
</ol>
<p>可以看到带CRF和多尺度的(MSc)的DeepLab模型效果明显上升了。</p>
<ol>
<li><p>多尺度特征应用<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714160214556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>第一行是普通输出，第二行是带多尺度的输出，可以看出多尺度输出细节部分要好点</p>
</li>
<li><p>离散卷积的效果<br>atrous算法可以允许调整感受野（FOV），大的离散卷积效果更好（同时见Table 1）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714160323170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p>评估边界附近的精确度<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714160418154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p>与其他模型对比DeepLab捕获到最好的边界<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190714160432162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>DeepLab创造性的结合了DCNN和CRF产生一种新的语义分割模型，模型有准确的预测结果同时计算效率高。在PASCAL VOC 2012上展现了先进的水平。DeepLab是卷积神经网络和概率图模型的交集，后续可考虑将CNN和CRF结合到一起做end-to-end训练。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>语义分割</category>
      </categories>
  </entry>
  <entry>
    <title>Fully Convolutional Networks for Semantic Segmentation论文笔记</title>
    <url>/2019/07/13/Fully-Convolutional-Networks-for-Semantic-Segmentation%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>FCN反卷积</strong><br>而本文使用的反卷积运算方式则不同于以上的Full卷积方式，而是首先对特征图各神经元之间进行0填充，即上池化；然后再进行卷积运算。计算公式为：(W1−1)×S-2×P+F=W2<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712153444487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>如，令W1=3，S=2，P=1，F=3，则W2=5<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712172513994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h3 id="跳级结构"><a href="#跳级结构" class="headerlink" title="跳级结构"></a>跳级结构</h3><ul>
<li><p>如下图所示：对原图进行卷积conv1、pool1后图像缩小为1/2；对图像进行第二次卷积conv2、pool2后图像缩小为1/4；对图像进行第三次卷积conv3、pool3后图像缩小为1/8，此时保留pool3的featuremap；对图像进行第四次卷积conv4、pool4后图像缩小为1/16，此时保留pool4的featuremap；对图像进行第五次卷积conv5、pool5后图像缩小为1/32，然后把原来CNN操作过程中的全连接编程卷积操作的conv6、conv7，图像的featuremap的大小依然为原图的1/32,此时图像不再叫featuremap而是叫heatmap。</p>
</li>
<li><p>其实直接使用前两种结构就已经可以得到结果了，这个上采样是通过反卷积（deconvolution）实现的，对第五层的输出（32倍放大）反卷积到原图大小。但是得到的结果还上不不够精确，一些细节无法恢复。于是将第四层的输出和第三层的输出也依次反卷积，分别需要16倍和8倍上采样，结果过也更精细一些了。这种做法的好处是兼顾了local和global信息。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712152641352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712112643719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">  其中，输入图像大小为$500<em>500</em>3$，预测输出维度为$500<em>500</em>21$(20类+背景)，蓝色竖线表示卷积运算，绿色竖线表示池化运算，灰色竖线表示crop运算；</p>
</li>
</ul><a id="more"></a>

<p><strong>微调(权重初始化)</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712154038569.png">   </p>
<blockquote>
<p>将在ImageNet数据集中训练的网络参数初始化FCN网络的参数，不使用红色部分的参数。</p>
</blockquote>
<p><strong>FCN-32s</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712154848862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<blockquote>
<p>输入图像大小为500<em>500</em>3，卷积网络阶段获得的特征图为16<em>16</em>21；然后反卷积运算的步长为32直接获得最终的预测结果；</p>
</blockquote>
<p><strong>FCN-16s</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712154951385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<blockquote>
<p>输入图像大小为$500<em>500</em>3$，卷积网络阶段获得的特征图为$16<em>16</em>21$；然后第一次反卷积运算的步长为2获得$34<em>34</em>21$的特征图，并将其与pool4的特征图进行连接；最后进行第二次反卷积运算，步长为16获得最终的预测结果；</p>
</blockquote>
<p> <strong>FCN-8s</strong><br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712155130135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">  </p>
<blockquote>
<p>输入图像大小为$500<em>500</em>3$，卷积网络阶段获得的特征图为$16<em>16</em>21$；然后第一次反卷积运算的步长为2获得$34<em>34</em>21$的特征图，并将其与pool4的特征图进行连接；接着进行第二次反卷积运算，步长为2获得$70<em>70</em>21$的特征图，并将其与pool3的特征图进行连接；最后进行第三次反卷积运算，步长为8,获得最终的预测结果；</p>
<h3 id="模型的评价指标"><a href="#模型的评价指标" class="headerlink" title="模型的评价指标"></a>模型的评价指标</h3><p>本文使用了四种常用于语义分割场景下的评价方式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190712155252268.png"><br>其中，$n_{ij}$表示将本属于第i类的像素预测为属于第j类的像素数量；$n_{cl}$表示像素的类别总数；$t_i$表示属于第i类的像素总数。</p>
</blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_36269513/article/details/80420363" target="_blank" rel="noopener">https://blog.csdn.net/qq_36269513/article/details/80420363</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>语义分割</category>
      </categories>
  </entry>
  <entry>
    <title>SegNet+tensorflow训练和测试</title>
    <url>/2019/07/13/SegNet-tensorflow%E8%AE%AD%E7%BB%83%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>代码：<a href="https://github.com/aizawan/segnet" target="_blank" rel="noopener">https://github.com/aizawan/segnet</a></p><h1 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h1><p>自行修改参数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python train.py \</span><br><span class="line">  --iteration <span class="number">20000</span> \</span><br><span class="line">  --snapshot <span class="number">4000</span> \</span><br><span class="line">  --optimizer adadelta \</span><br><span class="line">  --learning_rate <span class="number">1.0</span></span><br></pre></td></tr></table></figure></p><a id="more"></a>

<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190713125116146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python eval.py \</span><br><span class="line">  --resdir eval \</span><br><span class="line">  --outdir output/camvid/segnet \</span><br><span class="line">  --checkpoint_dir output/camvid/segnet/trained_model \</span><br><span class="line">  --num_sample <span class="number">233</span></span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190713125558941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019071313201811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>语义分割</category>
      </categories>
  </entry>
  <entry>
    <title>SegNet论文笔记</title>
    <url>/2019/07/13/SegNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ol>
<li>论文提出了一个全新的全卷积的Semantic Segmentation模型：SegNet，用于逐个像素的语义分割。</li>
<li>模型主要由：编码网络(encoder network),解码网络(decoder network)和逐像素分类器(pixel-wise classification layer)组成。SegNet的新颖之处在于decoder阶段的上采样方式，具体来说，decoder时上采样使用了encoder阶段下采样的最大池化的索引(indices)，这消除了上采样的学习需要。考虑到上采样是稀疏的，再配合滤波器产生最后的分割图。</li>
</ol><a id="more"></a>
<h1 id="1-IntroductionSemantic"><a href="#1-IntroductionSemantic" class="headerlink" title="1. IntroductionSemantic"></a>1. IntroductionSemantic</h1><ol>
<li><p>Segmentation常用于道路场景分割，大多数像素属于大类，需要平滑的分割，模型要能够依据形状提取物体，这需要保留好的边界信息，从计算的角度来考虑，需要有效的存储量和计算时间。而现有的Semantic Segmentation的问题在于：最大池化和下采样会降低feature map的分辨率(即降低feature map分辨率会损失边界信息)，SegNet针对这一问题设计了将低分辨率feature map映射到高分辨率的方法(利用池化索引)，从而产生精确边界的分割结果。</p>
</li>
<li><p>SegNet的encoder部分使用的是VGG16的前13层(即使用预训练的VGG16做特征提取层)，核心在于decoder部分，解码器使用从相应的编码器接受的max-pooling indices来进行输入特征图的非线性upsampling，这样做有以下几个优点：</p>
<blockquote>
<ul>
<li>改善边界描述</li>
<li>减少end到end的训练参数</li>
<li>这样的upsampling的形式形式可以仅需要少量的修改而用于多种encoder-decoder架构</li>
</ul>
</blockquote>
</li>
</ol>
<h1 id="2-LITERATURE-R-EVIEW"><a href="#2-LITERATURE-R-EVIEW" class="headerlink" title="2. LITERATURE R EVIEW"></a>2. LITERATURE R EVIEW</h1><ol>
<li><p>传统的Semantic Segmentation方法：用随机森林(RF),Boosting等做类别的中心预测，用SfM提取特征，配合CRF提高预测精度。但是这些方法效果都不好，总结原因是这些方法都需要提高分类特征。</p>
</li>
<li><p>而近期深度卷积网络在分类问题上表现出色，考虑将深度网络应用到Semantic Segmentation上，例如：FCN，效果比传统方法好很多。有工作将RNN、条件随机场(CRF)引入配合decoder做预测，有助于提高边界描绘能力，并且指出了，CRF-RNN这一套可以附加到包括SegNet在内的任何深度分割模型。<br>现有的多尺度的深度神经网络架构的应用，常见两种形式：</p>
<blockquote>
<ul>
<li>将输入放缩为多个尺度得到相应的feature map</li>
<li>将一张图送到模型，得到不同层的feature map</li>
</ul>
</blockquote>
</li>
<li><p>这些方法的共同想法都是使用多尺度信息将高层的feature map包含的语义信息与底层的feature map包含的精度信息融合到一起。但是，这样方法参数多，比较难训练</p>
<h1 id="3-ARCHITECTURE"><a href="#3-ARCHITECTURE" class="headerlink" title="3. ARCHITECTURE"></a>3. ARCHITECTURE</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019071317214054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
</li>
<li>SegNet由编码网络，解码网络后接一个像素分类层组成。</li>
</ol>
<ul>
<li><strong>编码网络(encoder network)</strong>：由13个卷积层组成，与VGG16的前13层卷积相同，将VGG16在大型数据集上训练得到的权重值作为编码网络的权重初始值，删掉VGG16中的全连接层，有利于在最深的编码器输出处保留较高分辨率的特征图，可以大幅度减少encoder层中训练参数的数量（from 134M to 14.7M）</li>
<li><strong>解码网络(decoder network)</strong>： 每一层encoder都对应着一层decoder，因此decoder网络也是13层，将低分辨率的feature map映射回和输入一样大小分类器(mask)</li>
<li><strong>像素分类层(pixelwise classification layer)</strong>：在decoder网络输出后接一个多分类的soft-max分类器对每个像素生成类别概率。</li>
</ul>
<ol>
<li><strong>Encoder network:</strong><br> encoder网络中的每一个编码器通过一组卷积核来产生一系列的feature maps，后接一层BN+RELU+Max-pooling(2x2,stride=2)，Max-pooling用于实现小空间移动上的空间不变性,同时，可以在feature map上有较大的感受野，但由于使用Max-pooling 导致分辨率上的损失。这种损失对边界界定产生不利的影响，因此encoder网络要在进行下采样前着重捕捉和保存边界信息。由于实际内存的限制，所以无法保存feature map 的全部信息。本文提出只保存max-pooling indices(在每个池化窗口maximum feature value的位置）。</li>
<li><p><strong>Decoder network:</strong><br>在decoder端，采用的也是正常的卷积、bn、relu的操作，不同的地方在于最后加上了一个softmax用来整理输出的k个channel的概率图，k是指定的分割类别数目。不同的地方在于SegNet在上采样过程中解码器使用来自对应的编码器特征图的存储的最大池化索引来上采样其输入特征图,产生的sparse feature map，然后将这些特征图与可训练的解码器滤波器组卷积以产生密集的特征图，然后batch normalization产生多通道feature map，ecoder输出的高维度的特征表示被送入一个可训练的soft-max多分类器，对每个像素进行单独分类。</p>
</li>
<li><p>DeconvNet与U-Net有与SegNet相似的结构，但DeconvNet有更多的训练参数，需要更多的计算资源而且不利于进行end-to-end的训练。<br>U-Net不利用max-pooling index而是将整个feature map 送到decoder 拼接到上采样后的feature map，十分占用内存资源，因此U-Net中无法使用到conv5和max-pool5模块，而SegNet却可以利用VGG16全部预训练过的卷积层的权重值。</p>
</li>
</ol>
<p>这么做会产生稀疏的feature maps。再对执行卷积操作产生密集feature maps。值得注意的是，在与encoder中第一层对应的decoder层中（即decoder的最后一层卷积)，与原图像为RGB的3通道不同，该层产生的是一个通道为K(类别数）的multi-channel feature maps，然后将其送入softmax分类器，做逐像素的分类处理。</p>
<h2 id="3-1-Decoder-Variants"><a href="#3-1-Decoder-Variants" class="headerlink" title="3.1 Decoder Variants"></a>3.1 Decoder Variants</h2><ol>
<li>SegNet-Basic: SegNet的较小版本，4个encoder和4个decoder</li>
</ol>
<ul>
<li>encoder阶段是LRN + (Conv+BN +ReLU + - MaxPool)x4 论文给出的时卷积不使用bias</li>
<li><p>decoder阶段是(UpPool+Conv+ BN)x4 + Conv(分割层)</p>
<p> convolutional layer in both the encoder and decoder network. No biases are used after convolutions and no ReLU non-linearity is present in the decoder network.</p>
</li>
</ul>
<ol>
<li><p>对比SegNet和FCN实现Decoder的过程。SegNet保留pooling时的位置信息，upsampling时直接将数据放在原先的位置，而FCN采用transposed convolutions+双线性插值，每一个像素都是运算后的结果。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190713181125846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p><strong>不同decoder实验分析</strong><br>为验证不同decoder结构的表现，作者针对SegNet以及FCN网络设计了不同的decoder结构，并进行了详细的实验分析<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190713184537974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">其中，解码网络结构如下：</p>
<blockquote>
<ul>
<li>Bilinear-Interpolation : 双线性插值上采样。<br>SegNet-Basic: </li>
<li>4<em>(encodes[conv+bn+relu+maxpooling] + decoders[conv+bn]) ，kenel size: 7</em>7。 </li>
<li>SegNet-Basic-SingleChannelDecoder: decoder采用单通道滤波器，可以有效减少参数数量。</li>
<li>SegNet-Basic-EncoderAddition: 将decoder与encoder对应的特征图相加。</li>
<li>FCN-Basic:与SegNet-Basic具有相同的encoders，但是decoders采用FCN的反卷积方式。</li>
<li>FCN-Basic-NoAddition:去掉特征图相加的步骤，只学习上采样的卷积核。</li>
<li>FCN-Basic-NoDimReduction: 不进行降维。</li>
</ul>
</blockquote>
<p>通过上表分析，可以得到如下分析结果：</p>
<blockquote>
<ul>
<li>bilinear interpolation 表现最差，说明了在进行分割时，decoder学习的重要性。</li>
<li>SegNet-Basic与FCN-Basic对比，均具有较好的精度，不同点在于SegNet存储空间消耗小，FCN-Basic由于feature map进行了降维，所以时间更短。</li>
<li>SegNet-Basic与FCN-Basic-NoAddition对比，两者的decoder有很大相似之处，SegNet-Basic的精度更高，一方面是由于SegNet-Basic具有较大的decoder,同时说明了encoder过程中低层次feature map的重要性。</li>
<li>FCN-Basic-NoAddition与SegNet-Basic-SingleChannelDecoder：证明了当面临存储消耗，精度和inference时间的妥协的时候，我们可以选择SegNet，当内存和inference时间不受限的时候，模型越大，表现越好。</li>
</ul>
</blockquote>
</li>
<li><p><strong>总结：</strong></p>
<blockquote>
<ul>
<li>encoder特征图全部存储时，性能最好。 这最明显地反映在语义轮廓描绘度量（BF）中。</li>
<li>当限制存储时，可以使用适当的decoder（例如SegNet类型）来存储和使用encoder特征图（维数降低，max-pooling indices）的压缩形式来提高性能。</li>
<li>更大的decoder提高了网络的性能。</li>
</ul>
</blockquote>
</li>
</ol>
<h1 id="3-2-训练"><a href="#3-2-训练" class="headerlink" title="3.2 训练"></a>3.2 训练</h1><blockquote>
<ul>
<li>数据集：CamVid （训练：367张，测试：233，图片尺寸：360X480,11个类别）</li>
<li>优化方法：SGD</li>
<li>learning_rate:0.1</li>
<li>momentum: 0.9</li>
<li>mini-batch: 12</li>
<li>loss: cross-entropy</li>
</ul>
</blockquote>
<h1 id="3-3-分析"><a href="#3-3-分析" class="headerlink" title="3.3 分析"></a>3.3 分析</h1><p>使用三种评价指标：</p>
<blockquote>
<ul>
<li>global accuracy 数据集中被正确分类的像素所占的比例。</li>
<li>class average accuracy 每种类别准确率和取平均。</li>
<li>mIoU 惩罚 FalsePositivate 的预测,在每个类别上计算IOU然后取平均值。</li>
</ul>
</blockquote>
<p>实现性能最好的是当encoder 的feature map全部被保存，对于一个给定的encoder 网络，更大的decode网络可以提升性能，当inference 内存被限制时，encoder层压缩后的feature maps(降维,max-pooling indices) 可以进行保存并用适当的解码器来提升性能。</p>
<p><a href="https://arxiv.org/abs/1511.00561" target="_blank" rel="noopener">论文英文原文</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>语义分割</category>
      </categories>
  </entry>
  <entry>
    <title>R-FCN论文笔记</title>
    <url>/2019/07/10/R-FCN%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>分类需要特征具有平移不变性，检测则要求对目标的平移做出准确响应。<br>提出了Position-sensitive score maps，以解决图像分类中的平移不变性与目标检测中的平移变化之间的困境。SPP，Faster R-CNN类的方法在ROI pooling前都是卷积，是具备平移不变性的，但一旦插入ROI pooling之后，后面的网络结构就不再具备平移不变性了。</p><a id="more"></a>
<ul>
<li>平移不变性：在用基础的分类结构比如ResNet、Inception给一只猫分类时，无论猫怎么扭曲、平移，最终识别出来的都是猫，输入怎么变形输出都不变这就是平移不变性，网络的层次越深这个特性会越明显。</li>
<li>平移可变性则是针对目标检测的，一只猫从图片左侧移到了右侧，检测出的猫的坐标会发生变化就称为平移可变性。当卷积网络变深后最后一层卷积输出的feature map变小，物体在输入上的小偏移，经过N多层pooling后在最后的小feature map上会感知不到。</li>
</ul>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>目标检测的深度网络家族（SPP，Fast R-CNN，Faster R-CNN），通过感兴趣区域（RoI）池化层可以划分成两个子网络：（1）独立于RoI的共享“全卷积”subnetwork，（ii）不共享计算的RoI subnetwork。</p>
<p>对于region-based的检测方法，以Faster R-CNN为例，实际上是分成了几个subnetwork，第一个用来在整张图上做比较耗时的conv，这些操作与region无关，是计算共享的。第二个subnetwork是用来产生候选的boundingbox（如RPN），第三个subnetwork用来分类或进一步对box进行regression（如Fast RCNN），这个subnetwork和region是有关系的，必须每个region单独跑网络，衔接在这个subnetwork和前两个subnetwork中间的就是ROI pooling。我们希望的是，耗时的卷积都尽量移到前面共享的subnetwork上。因此，和Faster RCNN中用的ResNet（前91层共享，插入ROI pooling，后10层不共享）策略不同，本文把所有的101层都放在了前面共享的subnetwork。最后用来prediction的卷积只有1层，大大减少了计算量。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190710204931530.png"><br>物体分类要求平移不变性越大越好 (图像中物体的移动不用区分)，而物体检测要求有平移变化。所以，ImageNet 分类领先的结果证明尽可能有平移不变性的全卷积结构更受亲睐。另一方面，物体检测任务需要一些平移变化的定位表示。假设图像分类网络的卷积层越深，则该网络对平移越不敏感。<br>ResNet在网络的卷积层间插入 RoI 池化层，分类时ROI pooling之后卷积不再有平移可变性。</p>
<p><strong>整个R-FCN的结构</strong><br>一个base的conv网络如ResNet101, 一个RPN（Faster RCNN来的）,一个position sensitive的prediction层，最后的ROI pooling+投票的决策层<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019071014594651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">为了将平移可变性并入FCN，使用一组专门的卷积层来构建一系列position-sensitive score maps作为FCN输出。<br>。这些分数图中的每一个都相对空间的位置信息进行编码（例如“在目标的左边”）。在这个FCN的顶端，我们添加了一个位置敏感的RoI池化层，它从这些score maps中获取信息，并且后面没有权重（卷积/fc）层。整个架构是端到端的学习。所有可学习的层都是卷积的，并在整个图像上共享。</p>
<h1 id="Our-approach"><a href="#Our-approach" class="headerlink" title="Our approach"></a>Our approach</h1><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p>基于区域的系统在不同 benchmarks 上依然精度领先。用更快 R-CNN 中的区域建议网络 (RPN) 提取候选区域，该 RPN 为全卷积网络。效仿更快 R-CNN，共享 RPN 和 R-FCN 的特征。</p>
<ul>
<li>跟随R-CNN，采用two-stage目标检测算法（R-CNN，SPPNet，Faster R-CNN，Fast R-CNN，Inside-Outside Net，OHEM），包括：区域提议和区域分类。</li>
<li>不依赖区域提取（SSD 和 Yolo ）</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190710154537337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">      Region Proposal Network (RPN)提出了候选RoI，然后将其应用于评分图上。所有可学习的权重层都是卷积的，并在整个图像上计算；每个RoI的计算成本可以忽略不计。</p>
<p>RPN 给出感兴趣区域，R-FCN 对RoI分类为目标类别和背景。在R-FCN中，所有可学习的权重层都是卷积的，并在整个图像上进行计算。最后一个卷积层为每个类别产生一堆大小为$k^2$的位置敏感分数图，从而得到一个具有C个目标类别的$k^2(C+1)$通道输出层（+1为背景）。一堆$k^2$个分数图对应于描述相对位置的k×k空间网格。例如，对于k×k=3×3，大小为9的分数图编码目标类别在$top-left,top-center,top-right,…,bottom-right$</p>
<p>R-FCN 最后用位置敏感 RoI 池化层，给每个 RoI 1个分数。选择性池化图解：看上图的橙色响应图像 (top−left)，抠出橙色方块 RoI，池化橙色方块 RoI 得到橙色小方块 (分数)；其它颜色的响应图像同理。对所有颜色的小方块投票 (或池化) 得到1类的响应结果。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190710160310184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>R-FCN 在与 RPN 共享的卷积层后多加1个卷积层。所以，R-FCN 与 RPN 一样，输入为整幅图像。但 R-FCN 最后1个卷积层的输出从整幅图像的卷积响应图像中分割出感兴趣区域的卷积响应图像。</p>
<h3 id="2-Backbone-architecture"><a href="#2-Backbone-architecture" class="headerlink" title="2. Backbone architecture:"></a>2. Backbone architecture:</h3><p>典型的R-FCN是基于ResNet-101， 网络有100个卷积层，1个全局平均池化层和1个1000类的全连接层。删除了平均池化层和全连接层，只使用卷积层来计算特征图。使用ResNet-101，在ImageNet上预训练。ResNet-101中的最后一个卷积块是2048维，我们附加一个随机初始化的1024维的1×1卷积层来降维，然后，我们应用$k^2(C+1)$通道卷积层来生成分数图。</p>
<h3 id="3-Position-sensitive-score-maps-amp-Position-sensitive-RoI-pooling："><a href="#3-Position-sensitive-score-maps-amp-Position-sensitive-RoI-pooling：" class="headerlink" title="3. Position-sensitive score maps &amp; Position-sensitive RoI pooling："></a>3. Position-sensitive score maps &amp; Position-sensitive RoI pooling：</h3><p>为了将位置信息显式地编码到每个RoI中，将每个RoI矩形分成k×k的组块。对于大小为w×h的RoI矩形，组块的大小为$\approx \frac{w}{k} \times \frac{h}{k}$，构建最后的卷积层为每个类别产生$k^2$分数图。在第(i,j)个组块（0≤i,j≤k−1）中，我们定义了一个位置敏感的RoI池化操作，它只在第(i,j)个score map中进行池化：</p>
<script type="math/tex; mode=display">r_c(i,j ~|~ \Theta) = \sum_{(x,y)\in \text{bin}(i,j)} z_{i,j,c}(x+x_0, y+y_0 ~|~ \Theta)/n.</script><p>其中：<br>$r_c(i,j)$是第$(i,j)$个组块中第c个类别的池化响应<br> $z_{i,j,c}$是$k^2(C+1)$分数图中的一个分数图。<br>$(x_0,y_0)$表示一个RoI的左上角<br>n是组块中的像素数量<br>Θ表示网络的所有可学习参数<br><strong>分类：</strong><br>通过对分数进行平均来简单地投票，为每个RoI产生一个(C+1)维向量：$r_c(Θ)=∑_i,jr_c(i,j | Θ)$，计算类别的softmax响应，$s_c(\Theta)=e^{r_c(\Theta)} / \sum_{c’=0}^C e^{r_{c’}(\Theta)}$<br><strong>定位：</strong><br>$k^2(C+1)$维的卷积层后，增加1个$4k^2$维的卷积层来回归边界框。每个 RoI 产生的4k24k2维向量经平均投票后，用快速 R-CNN 的参数化得到1个44维向量$(t_x,t_y,t_w,t_h)$</p>
<h3 id="4-训练"><a href="#4-训练" class="headerlink" title="4. 训练:"></a>4. 训练:</h3><p>每个 RoI 的损失函数为交叉熵损失与边界框回归损失的和。</p>
<script type="math/tex; mode=display">L(s, t_{x,y,w,h})=L_{cls}(s_{c^*})+\lambda[c^*>0]L_{reg}(t,t^*)=-log\left(\frac{e^{r_{c^*}(\Theta)}}{\sum^{C}_{c'=0}e^{r_{c'}(\Theta)}}\right)+\lambda[c^*>0]L_{reg}(t,t^*)</script><p>$c^<em>$是RoI的真实标签,t\</em>表示真实的边界框<br>$c^<em>$=0说明 RoI 的真实标签为背景。Lreg与快速 R-CNN 中的边界框损失回归相同。RPN 产生的区域建议当 RoI 与 真实边框的 IoU 超过0.5时，标定为正样本。<br><strong>在线难例挖掘 (OHEM)</strong>。假设每个图像前向产生N个区域建议，计算所有建议的损失。按损失排序所有 RoIs，选择损失最高的B个 RoIs 3。<br><em>*参数：</em></em><br>0.0005的权重衰减和0.9的动量。默认情况下，我们使用单尺度训练：调整图像的大小，使得尺度（图像的较短边）为600像素。</p>
<h3 id="5-推断"><a href="#5-推断" class="headerlink" title="5. 推断"></a>5. 推断</h3><p>在RPN和R-FCN之间计算共享的特征图，RPN部分提出RoI，R-FCN部分在其上评估类别分数并回归边界框。在推断过程中，我们评估了300个RoI进行公平比较，作为标准实践，使用0.3的IoU阈值，通过非极大值抑制（NMS）对结果进行后处理。</p>
<h3 id="6-A-trous-and-stride（空洞和步长）"><a href="#6-A-trous-and-stride（空洞和步长）" class="headerlink" title="6. À trous and stride（空洞和步长）"></a>6. À trous and stride（空洞和步长）</h3><p>全卷积架构享有FCN广泛使用的语义分割的网络修改的好处。特别的是，我们将ResNet-101的有效步长从32像素降低到了16像素，增加了分数图的分辨率。conv4阶段（stride = 16）之前和之后的所有层都保持不变；第一个conv5块中的stride=2操作被修改为stride=1，并且conv5阶段的所有卷积滤波器都被“hole algorithm”修改来弥补减少的步幅。为了进行公平的比较，RPN是在conv4阶段（与R-FCN共享）之上计算的，就像Faster R-CNN的情况那样，所以RPN不会受空洞行为的影响。下表显示了R-FCN的消融结果（k×k=7×7，没有OHEM）。这个空洞窍门提高了2.6点的mAP。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190710220544767.png"></p>
<h3 id="7-可视化"><a href="#7-可视化" class="headerlink" title="7. 可视化"></a>7. 可视化</h3><p>RoI 分类的可视化。RPN 刚好产生包含 person 类的 RoI。经过 R-FCN 的最后1个卷积层后产生9个相对空间位置的分数图，对 person 类的每个相对空间位置通道内的 RoI 桶平均池化得到3×33×3的池化分数，投票后送入分类器判断属于 person 类。当分类正确时，该类通道的位置敏感分数图 (中间) 的大多数橙色实线网格内的响应在整个 RoI 位置范围内最强。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190710221044808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3. 相关工作"></a>3. 相关工作</h1><p>R-CNN 证实用深度网络产生区域建议是有效的。R-CNN 在剪切变形的区域上评价卷积网络，区域间不共享计算。SPP 网络，快速 R-CNN 和更快速 R-CNN 为”半卷积” (卷积子网络在整幅图像上共享计算，另1个子网络评价各个区域)。</p>
<p>一些物体检测器被认为是”全卷积“模型。OverFeat 在共享卷积特征图上滑窗操作来检测物体。类似地，快速 R-CNN 等也用滑动窗口，它们的1个单尺度的滑动窗口可看作1个卷积层。更快 R-CNN 的 RPN 部分为1个预测关于多尺寸参考盒 (锚) 的边界框的全卷积检测器。更快 R-CNN 的 RPN 未知区域建议的类，但 SSD 该部分已知特定的类。</p>
<p>另一类物体检测器采用全连接层，在整个图像上产生整体物体的检测结果</p>
<p>待写，待修改！！！</p>
<p><a href="https://arxiv.org/abs/1605.06409" target="_blank" rel="noopener">论文原文</a><br><a href="https://blog.csdn.net/c20081052/article/details/80522388" target="_blank" rel="noopener">【深度学习R-FCN】——深刻解读R-FCN网络结构</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>语义分割</category>
      </categories>
  </entry>
  <entry>
    <title>目标检测算法SSD+tensorflow</title>
    <url>/2019/07/08/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95SSD-tensorflow/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-SSD-minimal-example"><a href="#1-SSD-minimal-example" class="headerlink" title="1. SSD minimal example"></a>1. SSD minimal example</h1><p>To run the notebook you first have to unzip the checkpoint files in ./checkpoint</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">unzip ssd_300_vgg<span class="selector-class">.ckpt</span><span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure><p>解压数据如图所示</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190708202441366.png"><br>终端运行：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">jupyter</span> notebook notebooks/ssd_notebook.ipynb</span><br></pre></td></tr></table></figure><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190708202659424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><a id="more"></a>



<p>也可以转化为python代码执行：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span> notebooks/ssd_notebook.<span class="keyword">py</span></span><br></pre></td></tr></table></figure></p>
<h1 id="2-Evaluation-on-Pascal-VOC-2007"><a href="#2-Evaluation-on-Pascal-VOC-2007" class="headerlink" title="2. Evaluation on Pascal VOC 2007"></a>2. Evaluation on Pascal VOC 2007</h1><h2 id="2-1-下载数据"><a href="#2-1-下载数据" class="headerlink" title="2.1 下载数据"></a>2.1 下载数据</h2><p>当前版本仅支持Pascal VOC数据集（2007和2012）。 为了用于训练SSD模型，需要使用tf_convert_data.py脚本将前者转换为TF-Records<br>下载解压好文件，VOC2007目录结构如下:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">+VOCtrainval_06-Nov<span class="number">-2007</span></span><br><span class="line">    +VOCdevkit</span><br><span class="line">        +VOC2007</span><br><span class="line">            +Annotations</span><br><span class="line">            +ImageSets</span><br><span class="line">            +JPEGImages</span><br><span class="line">            +SegmentationClass</span><br><span class="line">            +SegmentationObject</span><br><span class="line">+VOCtest_06-Nov<span class="number">-2007</span></span><br><span class="line">    +VOCdevkit</span><br><span class="line">        +VOC2007</span><br><span class="line">            +Annotations</span><br><span class="line">            +ImageSets</span><br><span class="line">            +JPEGImages</span><br><span class="line">            +SegmentationClass</span><br><span class="line">            +SegmentationObject</span><br></pre></td></tr></table></figure></p>
<h1 id="2-1-转换TF-Records格式"><a href="#2-1-转换TF-Records格式" class="headerlink" title="2.1 转换TF-Records格式"></a>2.1 转换TF-Records格式</h1><p>为了避免每次在终端敲那么多字母，建议新建一个.sh文件，把以下脚本粘贴进去，只要在这里更改dataset的路径就可以了，最后在文件所在目录打开终端并输入bash tf_convert_data.sh：<br>报错：<br>测试集转换为tensorflow专用TF-Records格式<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename = tf_convert_data.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This is a shell script to convert Pascal VOC datasets(2007 and 2012) into TF-Records only.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Directory where the original dataset is stored</span></span><br><span class="line"><span class="attribute">DATASET_DIR</span>=/home/xiaohu/文档/计算机视觉/VOC2007/VOCtest_06-Nov-2007/VOCdevkit/VOC2007/</span><br><span class="line"></span><br><span class="line"><span class="comment">#Output directory where to store TFRecords files</span></span><br><span class="line"><span class="attribute">OUTPUT_DIR</span>=/home/xiaohu/cv//dataset/VOC2007/VOCtest_06-Nov-2007/VOCdevkit/VOC2007_tfrecord/</span><br><span class="line"></span><br><span class="line">python /home/xiaohu/cv/SSD-Tensorflow-master/tf_convert_data.py \</span><br><span class="line">    <span class="attribute">--dataset_name</span>=pascalvoc \</span><br><span class="line">    <span class="attribute">--dataset_dir</span>=<span class="variable">$&#123;DATASET_DIR&#125;</span> \</span><br><span class="line">    <span class="attribute">--output_name</span>=voc_2007_test \</span><br><span class="line">    <span class="attribute">--output_dir</span>=<span class="variable">$&#123;OUTPUT_DIR&#125;</span></span><br></pre></td></tr></table></figure><br>报错如下：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Dataset directory: /home/xiaohu/jisuanjishijue/shujuji/VOC2007/VOCtrainval_06-Nov-2007/VOCdevkit/VOC2007/</span><br><span class="line">Output directory: /home/xiaohu/cv/VOCtrainval_06-Nov-2007/VOCdevkit/VOC2007_tfrecord/</span><br><span class="line">&gt;&gt; Converting image 1/5011Traceback (most recent call last):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"./tf_convert_data.py"</span>, <span class="keyword">line</span> 59, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    tf.<span class="keyword">app</span>.<span class="keyword">run</span>()</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python3.5/dist-packages/tensorflow/python/platform/app.py"</span>, <span class="keyword">line</span> 126, <span class="keyword">in</span> <span class="keyword">run</span></span><br><span class="line">    _sys.<span class="keyword">exit</span>(main(argv))</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"./tf_convert_data.py"</span>, <span class="keyword">line</span> 54, <span class="keyword">in</span> main</span><br><span class="line">    pascalvoc_to_tfrecords.<span class="keyword">run</span>(FLAGS.dataset_dir, FLAGS.output_dir, FLAGS.output_name)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/home/xiaohu/cv/SSD-Tensorflow-master/datasets/pascalvoc_to_tfrecords.py"</span>, <span class="keyword">line</span> 218, <span class="keyword">in</span> <span class="keyword">run</span></span><br><span class="line">    _add_to_tfrecord(dataset_dir, img_name, tfrecord_writer)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/home/xiaohu/cv/SSD-Tensorflow-master/datasets/pascalvoc_to_tfrecords.py"</span>, <span class="keyword">line</span> 177, <span class="keyword">in</span> _add_to_tfrecord</span><br><span class="line">    _process_image(dataset_dir, name)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/home/xiaohu/cv/SSD-Tensorflow-master/datasets/pascalvoc_to_tfrecords.py"</span>, <span class="keyword">line</span> 83, <span class="keyword">in</span> _process_image</span><br><span class="line">    image_data = tf.gfile.FastGFile(filename, 'r').<span class="keyword">read</span>()</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python3.5/dist-packages/tensorflow/python/lib/io/file_io.py"</span>, <span class="keyword">line</span> 127, <span class="keyword">in</span> <span class="keyword">read</span></span><br><span class="line">    pywrap_tensorflow.ReadFromStream(self._read_buf, length, status))</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python3.5/dist-packages/tensorflow/python/lib/io/file_io.py"</span>, <span class="keyword">line</span> 95, <span class="keyword">in</span> _prepare_value</span><br><span class="line">    <span class="keyword">return</span> compat.as_str_any(val)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python3.5/dist-packages/tensorflow/python/util/compat.py"</span>, <span class="keyword">line</span> 113, <span class="keyword">in</span> as_str_any</span><br><span class="line">    <span class="keyword">return</span> as_str(value)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/lib/python3.5/dist-packages/tensorflow/python/util/compat.py"</span>, <span class="keyword">line</span> 86, <span class="keyword">in</span> as_text</span><br><span class="line">    <span class="keyword">return</span> bytes_or_text.<span class="keyword">decode</span>(encoding)</span><br><span class="line">UnicodeDecodeError: 'utf-8' codec can't <span class="keyword">decode</span> byte 0xff <span class="keyword">in</span> position 0: invalid start byte</span><br></pre></td></tr></table></figure><br>解决办法，修改pascalvoc_to_tfrecords.py第83行<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190708223107589.png"><br>正常运行<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070822334661.png"></p>
<h2 id="2-3-下载SSD-models"><a href="#2-3-下载SSD-models" class="headerlink" title="2.3 下载SSD models"></a>2.3 下载SSD models</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190709133250805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>链接：</p>
<ul>
<li><a href="https://drive.google.com/file/d/0B0qPCUZ-3YwWZlJaRTRRQWRFYXM/view" target="_blank" rel="noopener">SSD-300 VGG-based</a></li>
<li><a href="https://drive.google.com/file/d/0B0qPCUZ-3YwWUXh4UHJrd1RDM3c/view" target="_blank" rel="noopener">SSD-300 VGG-based</a> </li>
<li><a href="https://drive.google.com/open?id=0B0qPCUZ-3YwWT1RCLVZNN3RTVEU" target="_blank" rel="noopener">SSD-512 VGG-based</a></li>
</ul>
<p>下好后放在相对应的文件夹下(我自己改变了CHECKPOINT_PATH路径，没有放在文件夹checkpoints里面)</p>
<p>新建脚本eval_ssd_network.sh并将如下代码粘贴进去<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># This is the eval script.</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">DATASET_DIR</span>=/home/xiaohu/cv/dataset/VOC2007/VOCtest_06-Nov-2007/VOCdevkit/VOC2007_tfrecord/</span><br><span class="line"></span><br><span class="line"><span class="attribute">EVAL_DIR</span>=../log_files/log_eval/    # Directory where the results are saved <span class="keyword">to</span></span><br><span class="line"><span class="attribute">CHECKPOINT_PATH</span>=/home/xiaohu/cv/models/tfmodlels/SSD/VGG_VOC0712_SSD_300x300_ft_iter_120000.ckpt</span><br><span class="line"></span><br><span class="line"><span class="comment">#dataset_name这个参数在代码里面写死了</span></span><br><span class="line">python ./eval_ssd_network.py \</span><br><span class="line">    <span class="attribute">--eval_dir</span>=<span class="variable">$&#123;EVAL_DIR&#125;</span> \</span><br><span class="line">    <span class="attribute">--dataset_dir</span>=<span class="variable">$&#123;DATASET_DIR&#125;</span> \</span><br><span class="line">    <span class="attribute">--dataset_name</span>=pascalvoc_2007 \</span><br><span class="line">    <span class="attribute">--dataset_split_name</span>=test \</span><br><span class="line">    <span class="attribute">--model_name</span>=ssd_300_vgg \</span><br><span class="line">    <span class="attribute">--checkpoint_path</span>=<span class="variable">$&#123;CHECKPOINT_PATH&#125;</span> \</span><br><span class="line">    <span class="attribute">--batch_size</span>=1</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h2><p>终端执行：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bash </span>eval_ssd_network.sh</span><br></pre></td></tr></table></figure><br>报错如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190709122949771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>解决参考：<a href="https://blog.csdn.net/w5688414/article/details/78529884" target="_blank" rel="noopener">https://blog.csdn.net/w5688414/article/details/78529884</a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:Evaluation [<span class="number">495</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">990</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">1485</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">1980</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">2475</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">2970</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">3465</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">3960</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">4455</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">4950</span>/<span class="number">4952</span>]</span><br><span class="line">INFO:tensorflow:Evaluation [<span class="number">4952</span>/<span class="number">4952</span>]</span><br><span class="line"><span class="number">2019</span><span class="number">-07</span><span class="number">-09</span> <span class="number">12</span>:<span class="number">54</span>:<span class="number">32.189218</span>: W ./tensorflow/core/grappler/optimizers/graph_optimizer_stage.h:<span class="number">230</span>] Failed to run optimizer ArithmeticOptimizer, stage HoistCommonFactor. Error: Node average_precision_voc07/ArithmeticOptimizer/HoistCommonFactor_Add_AddN <span class="keyword">is</span> missing output properties at position :<span class="number">0</span> (num_outputs=<span class="number">0</span>)</span><br><span class="line">AP_VOC07/mAP[<span class="number">0.74313246273623845</span>]</span><br><span class="line">AP_VOC12/mAP[<span class="number">0.76659695026662222</span>]</span><br><span class="line">INFO:tensorflow:Finished evaluation at <span class="number">2019</span><span class="number">-07</span><span class="number">-09</span><span class="number">-04</span>:<span class="number">54</span>:<span class="number">41</span></span><br><span class="line">Time spent : <span class="number">475.949</span> seconds.</span><br><span class="line">Time spent per BATCH: <span class="number">0.096</span> seconds.</span><br></pre></td></tr></table></figure>
<h1 id="2-5-tensorboard显示"><a href="#2-5-tensorboard显示" class="headerlink" title="2.5 tensorboard显示"></a>2.5 tensorboard显示</h1><p>在../log_files/log_eval 下打开终端输入：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">tensorboard <span class="attribute">--logdir</span>=log_eval</span><br></pre></td></tr></table></figure><br>在谷歌浏览器中输入<a href="http://localhost:6006" target="_blank" rel="noopener">http://localhost:6006</a> 后查看</p>
<h1 id="3-训练"><a href="#3-训练" class="headerlink" title="3.训练"></a>3.训练</h1><p>先将训练集转化成tfrecords，然后打开train_ssd_network.py修改第154行的最大训练步数，将None改为比如1000（自行修改）。<br>新建脚本train_ssd_network.sh</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># This is the eval script.</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">DATASET_DIR</span>=/home/xiaohu/cv/dataset/VOC2007/VOCtrainval_06-Nov-2007/VOCdevkit/VOC2007_tfrecord/</span><br><span class="line"></span><br><span class="line"><span class="attribute">TRAIN_DIR</span>=../log_files/log_train/    # Directory where the results are saved <span class="keyword">to</span></span><br><span class="line"><span class="attribute">CHECKPOINT_PATH</span>=/home/xiaohu/cv/models/tfmodlels/SSD/VGG_VOC0712_SSD_300x300_ft_iter_120000.ckpt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#dataset_name这个参数在代码里面写死了</span></span><br><span class="line">python3 ./eval_ssd_network.py \</span><br><span class="line">    <span class="attribute">--train_dir</span>=<span class="variable">$&#123;TRAIN_DIR&#125;</span> \</span><br><span class="line">    <span class="attribute">--dataset_dir</span>=<span class="variable">$&#123;DATASET_DIR&#125;</span> \</span><br><span class="line">    <span class="attribute">--dataset_name</span>=pascalvoc_2007 \</span><br><span class="line">    <span class="attribute">--dataset_split_name</span>=train \</span><br><span class="line">    <span class="attribute">--model_name</span>=ssd_300_vgg \</span><br><span class="line">    <span class="attribute">--checkpoint_path</span>=<span class="variable">$&#123;CHECKPOINT_PATH&#125;</span> \</span><br><span class="line">    <span class="attribute">--save_summaries_secs</span>=60 \</span><br><span class="line">    <span class="attribute">--save_interval_secs</span>=600 \</span><br><span class="line">    <span class="attribute">--weight_decay</span>=0.0005 \</span><br><span class="line">    <span class="attribute">--optimizer</span>=adam \</span><br><span class="line">    <span class="attribute">--learning_rate</span>=0.001 \</span><br><span class="line">    <span class="attribute">--batch_size</span>=8</span><br></pre></td></tr></table></figure>
<p>开始训练：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bash </span>train_ssd_network.sh</span><br></pre></td></tr></table></figure></p>
<h1 id="4-制作自己数据集"><a href="#4-制作自己数据集" class="headerlink" title="4. 制作自己数据集"></a>4. 制作自己数据集</h1><h2 id="4-1-安装标注工具"><a href="#4-1-安装标注工具" class="headerlink" title="4.1 安装标注工具"></a>4.1 安装标注工具</h2><p>源代码：<a href="https://github.com/tzutalin/labelImg" target="_blank" rel="noopener">https://github.com/tzutalin/labelImg</a><br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">make</span> qt5py3</span><br><span class="line"><span class="keyword">python3</span> labelImg.<span class="keyword">py</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-2-标注数据"><a href="#4-2-标注数据" class="headerlink" title="4.2 标注数据"></a>4.2 标注数据</h2><p><strong>1.创建文件夹</strong><br>按照VOC数据集的要求，创建以下文件夹：</p>
<ul>
<li>Annotations：用于存放标注后的xml文件</li>
<li>ImageSets/Main：用于存放训练集、测试集、验收集的文件列表</li>
<li>JPEGImages：用于存放原始图像</li>
</ul>
<p><strong>2.标注数据</strong></p>
<p>待写！！！</p>
<p>代码链接：<a href="https://github.com/balancap/SSD-Tensorflow" target="_blank" rel="noopener">https://github.com/balancap/SSD-Tensorflow</a><br>参考：<a href="https://blog.csdn.net/comway_Li/article/details/85240291" target="_blank" rel="noopener">手把手教你训练自己的目标检测模型（SSD篇）</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>SSD论文笔记</title>
    <url>/2019/07/08/SSD%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>提出了一种使用单个深度神经网络来检测图像中的目标的方法。我们的方法命名为SSD，将边界框的输出空间离散化为不同长宽比的一组默认框和并缩放每个特征映射的位置。在预测时，网络会在每个默认框中为每个目标类别的出现生成分数，并对框进行调整以更好地匹配目标形状。<br>网络还结合了不同分辨率的多个特征映射的预测，自然地处理各种尺寸的目标。</p><a id="more"></a>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>提出了第一个基于深度网络的目标检测器，它不对边界框假设的像素或特征进行重采样，并且与其它方法有一样精确度。<br>速度的根本改进来自消除边界框提出和随后的像素或特征重采样阶段。<br>改进包括使用小型卷积滤波器来预测边界框位置中的目标类别和偏移量，使用不同长宽比检测的单独预测器（滤波器），并将这些滤波器应用于网络后期的多个特征映射中，以执行多尺度检测。<br>贡献如下：</p>
<ul>
<li>引入了SSD，这是一种针对多个类别的单次检测器，比先前的先进的单次检测器（YOLO）更快，并且准确得多，事实上，与执行显式区域提出和池化的更慢的技术具有相同的精度（包括Faster R-CNN）。</li>
<li>SSD的核心是预测固定的一系列默认边界框的类别分数和边界框偏移，使用更小的卷积滤波器应用到特征映射上。</li>
<li>为了实现高检测精度，我们根据不同尺度的特征映射生成不同尺度的预测，并通过纵横比明确分开预测。</li>
<li>这些设计功能使得即使在低分辨率输入图像上也能实现简单的端到端训练和高精度，从而进一步提高速度与精度之间的权衡。</li>
<li>实验包括在PASCAL VOC，COCO和ILSVRC上评估具有不同输入大小的模型的时间和精度分析，并与最近的一系列最新方法进行比较</li>
</ul>
<h1 id="The-Single-Shot-Detector-SSD"><a href="#The-Single-Shot-Detector-SSD" class="headerlink" title="The Single Shot Detector (SSD)"></a>The Single Shot Detector (SSD)<img alt data-src="https://img-blog.csdnimg.cn/20190708143405242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></h1><p><strong>SSD framework:</strong><br>-对于每个对象训练，SSD只需要一个输入图像和ground truth boxes。卷积的方式,我们评价一系列小的(例如:4)。不同aspect ratios的default boxes在几个特征图的每个位置，不同尺度(例如8×8和4×4 (b)和(c))。对于每个each default box,我们预测shape offsets和confidence为所有对象类别($(c_1, c_2···c _p)$)。在训练期间，我们首先把default boxes与ground truth boxes相匹配。</p>
<h1 id="2-1-Model"><a href="#2-1-Model" class="headerlink" title="2.1 Model"></a>2.1 Model</h1><p>SSD方法基于前馈卷积网络，该网络产生固定大小的边界框集合，并对这些边界框中存在的目标类别实例进行评分，然后进行非极大值抑制步骤来产生最终的检测结果。早期的网络层基于用于高质量图像分类的标准架构（在任何分类层之前被截断），我们将其称为基础网络。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190708102842738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>采用VGG16做基础模型，首先VGG16是在ILSVRC CLS-LOC数据集预训练。分别将VGG16的全连接层fc6和fc7转换成3×3卷积层conv6和1×1卷积层conv7，同时将池化层pool5由原来的2×2-s2变成3x3-s1，为了配合这种变化，采用了一种Atrous Algorithm，其实就是conv6采用扩展卷积或带孔卷积（Dilation Conv），其在不增加参数与模型复杂度的条件下指数级扩大卷积的视野，其使用扩张率(dilation rate)参数，来表示扩张的大小，如下图7所示，(a)是普通的3×3卷积，其视野就是3×3，(b)是扩张率为2，此时视野变成7×7，(c)扩张率为4时，视野扩大为15×1515×15，但是视野的特征更稀疏了。Conv6采用3×33×3大小但dilation rate=6的扩展卷积。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190708161610364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>然后移除dropout层和fc8层，并新增一系列卷积层，在检测数据集上做finetuing。</p>
<p><strong>Multi-scale feature maps for detection</strong><br>在base network后，添加一些卷积层，这些层的大小逐渐减小，可以进行多尺度预测</p>
<p><strong>Convolutional predictors for detection</strong><br>每一个新添加的层，可以使用一系列的卷积核进行预测。对于一个大小为m*n、p通道的特征层，使用3x3的卷积核进行预测，在某个位置上预测出一个值，该值可以是某一类别的得分，也可以是相对于default bounding boxes的偏移量，并且在图像的每个位置都将产生一个值。</p>
<p><strong>Default boxes and aspect ratios</strong><br>对于网络顶部的多个特征映射，我们将系列默认边界框与每个特征映射单元相关联。在每个特征映射单元中，我们预测单元中相对于默认边界框形状的偏移量，以及指出每个边界框中存在的每个类别实例的类别分数。在特征图的每个位置预测K个box。对于每个box，预测C个类别得分，以及相对于default bounding box的4个偏移值，这样需要(C+4)<em>k个预测器，在m</em>n的特征图上将产生(C+4)<em>k</em>m*n个预测值。这里，default bounding box类似于FasterRCNN中anchors。<br>SSD在不同的特征层中考虑不同的尺度，RPN在一个特征层考虑不同的尺度。</p>
<h2 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2 训练"></a>2.2 训练</h2><p>训练SSD和训练使用region proposals的典型检测器之间的关键区别：需要将ground truth信息分配给一系列固定的检测器输出中的特定输出。<br><strong>Matching Strategy</strong><br> 在Yolo中，ground truth的中心落在哪个单元格，该单元格中与其IOU最大的边界框负责预测它。SD中却完全不一样，SSD的先验框与ground truth的匹配原则主要有两点：</p>
<ul>
<li>对于图片中每个ground truth，找到与其IOU最大的先验框，该先验框与其匹配，这样，可以保证每个ground truth一定与某个先验框匹配。通常称与ground truth匹配的先验框为正样本，反之，若一个先验框没有与任何ground truth进行匹配，那么该先验框只能与背景匹配，就是负样本。一个图片中ground truth是非常少的， 而先验框却很多，如果仅按第一个原则匹配，很多先验框会是负样本，正负样本极其不平衡，所以需要第二个原则。</li>
<li>对于剩余的未匹配default box，若与某个ground truth的IOU大于某个阈值（一般是0.5），那么该default box也与这个ground truth进行匹配。这意味着某个ground truth可能与多个default box匹配。</li>
</ul>
<p>一个匹配示意图，其中绿色的GT是ground truth，红色为先验框，FP表示负样本，TP表示正样本。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190708164435130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><strong>Training Objective</strong><br>$x_{ij}^p = \lbrace 1,0 \rbrace$是第$i$个default box匹配到类别$p$的第$j$个实际ground truth，$\sum_i x_{ij}^p \geq 1$，总体目标损失函数是定位损失（loc）和置信度损失（conf）的加权和：</p>
<script type="math/tex; mode=display">L(x, c, l, g) = \frac{1}{N}(L_{conf}(x, c) + \alpha L_{loc}(x, l, g))</script><p>$N$是匹配的默认边界框的数量。定位损失是 predicted box($l$)与ground truth box($g$)参数之间的Smooth L1损失。类似于Faster R-CNN，我们回归默认边界框($d$)的中心偏移量($c_x, c_y$)和其宽度($w$)、高度($h$)的偏移量。</p>
<script type="math/tex; mode=display">L_{loc}(x,l,g) = \sum_{i \in Pos}^N \sum_{m \in \lbrace cx, cy, w, h \rbrace} x_{ij}^k \mathtt{smooth}_{L1}(l_{i}^m - \hat{g}_j^m) \\
\hat{g}_j^{cx} = (g_j^{cx} - d_i^{cx}) / d_i^w \quad \quad
\hat{g}_j^{cy} = (g_j^{cy} - d_i^{cy}) / d_i^h \\
\hat{g}_j^{w} = \log\Big(\frac{g_j^{w}}{d_i^w}\Big) \quad \quad
\hat{g}_j^{h} = \log\Big(\frac{g_j^{h}}{d_i^h}\Big)</script><p><img alt data-src="https://img-blog.csdnimg.cn/20190708165124813.png#pic_center=10x10"><br>置信度损失是在多类别置信度($c$)上的softmax损失，通过交叉验证权重项$\alpha$设为1。</p>
<script type="math/tex; mode=display">L_{conf}(x, c) = - \sum_{i\in Pos}^N x_{ij}^p log(\hat{c}_i^p) - \sum_{i\in Neg} log(\hat{c}_i^0)\quad \mathtt{where}\quad\hat{c}_i^p = \frac{\exp(c_i^p)}{\sum_p \exp(c_i^p)}</script><p><strong>Choosing Scales and Aspect Ratios for Default Boxes</strong><br>为了处理不同尺度的物体，一些文章，如：Overfeat，处理不同大小的图像，然后将结果综合。实际上，采用同一个网络，不同层上的feature map，也能达到同样的效果。图像分割算法FCN表明，采用低层的特征图可以提高分割效果，因为低层保留的图像细节信息比较多。</p>
<p>其中VGG16中的Conv4_3层将作为用于检测的第一个特征图,conv4_3层特征图大小是38×38，但是该层比较靠前，其norm较大，所以在其后面增加了一个L2 Normalization层（和Batch Normalization层不太一样，其仅仅是对每个像素点在channle维度做归一化，而Batch Normalization层是在[batch_size, width, height]三个维度上做归一化）。从后面新增的卷积层中提取Conv7，Conv8_2，Conv9_2，Conv10_2，Conv11_2作为检测所用的特征图，加上Conv4_3层，共提取了6个特征图，其大小分别是$(38, 38), (19, 19), (10, 10), (5, 5), (3, 3), (1, 1)$，但是不同特征图设置的Default Boxes数目不同（同一个特征图上每个单元设置的Default Boxes是相同的）</p>
<p>对于先验框的尺度，其遵守一个线性递增规则：随着特征图大小降低，default boxes尺度线性增加。假设我们要使用m个特征图进行预测,每个特征图的default Boxes尺度计算如下：</p>
<p><script type="math/tex">s_k = s_\text{min} + \frac{s_\text{max} - s_\text{min}}{m - 1} (k - 1),\quad k\in [1, m]</script>其中$s_\text{min}$为0.2，$s_\text{max}$为0.9<br>为default boxes添加不同的长宽比，并将它们表示为$a_r \in {1, 2, 3, \frac{1}{2}, \frac{1}{3}}$。可以计算每个default boxes的宽度($w_k^a = s_k\sqrt{a_r}$)和高度($h_k^a = s_k / \sqrt{a_r}$)。对于 aspect ratio = 1，额外增加一个default box，该box的尺度为$s’_k = \sqrt{s_k s_{k+1}}$，在每个特征图位置得到6个default boxes。我们将每个default boxes的中心设置为$(\frac{i+0.5}{|f_k|}, \frac{j+0.5}{|f_k|})$，其中$|f_k|$是第$k$个特征图的大小，$i, j\in [0, |f_k|)$。</p>
<p><strong>Hard Negative Mining</strong><br> ground truth匹配的先验框为正样本，反之，若一个先验框没有与任何ground truth进行匹配，那么该先验框只能与背景匹配，就是负样本。尽管一个ground truth可以与多个先验框匹配，但是ground truth相对先验框还是太少了，经过matching后，很多default box是负样本，这将导致正样本、负样本不均衡，训练难以收敛。因此，该论文将负样本根据置信度进行排序，选取误差的较大的top-k作为训练的负样本，保证负样本、正样本的比例为3：1。</p>
<p><strong>Data Augmentation</strong><br>为了使模型对各种输入目标大小和形状更鲁棒，每张训练图像都是通过以下选项之一进行随机采样的：</p>
<ul>
<li>使用整个原始输入图像。</li>
<li>采样一个图像块，使得与目标之间的最小Jaccard重叠为0.1，0.3，0.5，0.7或0.9。</li>
<li>随机采样一个图像块。</li>
</ul>
<p>每个采样图像块的大小是原始图像大小的[0.1，1]，长宽比在$\frac {1} {2}$和2之间。如果实际边界框的中心在采用的图像块中，我们保留实际边界框与采样图像块的重叠部分。在上述采样之后，将每个采样图像块调整到固定尺寸并以0.5的概率进行水平翻转。</p>
<p><a href="https://arxiv.org/abs/1512.02325" target="_blank" rel="noopener">论文原文</a></p>
<p>参考：<a href="https://blog.csdn.net/xiaohu2022/article/details/79833786" target="_blank" rel="noopener">目标检测算法之SSD</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>AlexNet</title>
    <url>/2019/07/06/AlexNet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AlexNet特点"><a href="#AlexNet特点" class="headerlink" title="AlexNet特点"></a>AlexNet特点</h1><p>AlexNet是在LeNet的基础上加深了网络的结构，学习更丰富更高维的图像特征。AlexNet的特点：</p><ul>
<li>更深的网络结构</li>
<li>使用层叠的卷积层，即卷积层+卷积层+池化层来提取图像的特征</li>
<li>使用Dropout抑制过拟合<ul>
<li>使用数据增强Data Augmentation抑制过拟合</li>
<li>使用Relu替换之前的sigmoid的作为激活函数</li>
<li>多GPU训练</li>
</ul>
</li>
</ul><a id="more"></a>

<h1 id="ReLu作为激活函数"><a href="#ReLu作为激活函数" class="headerlink" title="ReLu作为激活函数"></a>ReLu作为激活函数</h1><p>在最初的感知机模型中，输入和输出的关系如下：</p>
<script type="math/tex; mode=display">y = \sum_i{w_ix_i} + b</script><p>只是单纯的线性关系，这样的网络结构有很大的局限性：即使用很多这样结构的网络层叠加，其输出和输入仍然是线性关系，无法处理有非线性关系的输入输出。因此，对每个神经元的输出做个非线性的转换也就是，将上面就加权求和$\sum_i{w_ix_i} + b$的结果输入到一个非线性函数，也就是激活函数中。 这样，由于激活函数的引入，多个网络层的叠加就不再是单纯的线性变换，而是具有更强的表现能力。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704165718907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在最初，sigmoid和tanh函数最常用的激活函数。</p>
<ol>
<li>sigmoid<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704165732839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在网络层数较少时，sigmoid函数的特性能够很好的满足激活函数的作用：它把一个实数压缩至0到1之间，当输入的数字非常大的时候，结果会接近1；当输入非常大的负数时，则会得到接近0的结果。这种特性，能够很好的模拟神经元在受刺激后，是否被激活向后传递信息（输出为0，几乎不被激活；输出为1，完全被激活）。<br>sigmoid一个很大的问题就是梯度饱和。 观察sigmoid函数的曲线，当输入的数字较大（或较小）时，其函数值趋于不变，其导数变的非常的小。这样，在层数很多的的网络结构中，进行反向传播时，由于很多个很小的sigmoid导数累成，导致其结果趋于0，权值更新较慢。</li>
<li><p>ReLu<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704165954660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>针对sigmoid梯度饱和导致训练收敛慢的问题，在AlexNet中引入了ReLU。ReLU是一个分段线性函数，小于等于0则输出为0；大于0的则恒等输出。相比于sigmoid，ReLU有以下有点：</p>
<ul>
<li><p>计算开销低。sigmoid的正向传播有指数运算，倒数运算，而ReLu是线性输出；反向传播中，sigmoid<br>有指数运算，而ReLU有输出的部分，导数始终为1.</p>
<ul>
<li>梯度饱和问题</li>
<li>稀疏性。Relu会使一部分神经元的输出为0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生</li>
</ul>
<p>单个训练样本是线性变换，但是每个训练样本的线性变换是不一样的，这样整个训练样本集来说，就是非线性的变换。</p>
</li>
</ul>
<h1 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h1><p>神经网络由于训练的参数多，表能能力强，所以需要比较多的数据量，不然很容易过拟合。当训练数据有限时，可以通过一些变换从已有的训练数据集中生成一些新的数据，以快速地扩充训练数据。对于图像数据集来说，可以对图像进行一些形变操作：</p>
<ul>
<li>翻转</li>
<li>随机裁剪</li>
<li>平移，颜色光照的变换</li>
<li>…</li>
</ul>
<p>AlexNet中对数据做了以下操作：</p>
<ul>
<li>随机裁剪，对256×256的图片进行随机裁剪到227×227，然后进行水平翻转。</li>
</ul>
</li>
</ol>
<ul>
<li>测试的时候，对左上、右上、左下、右下、中间分别做了5次裁剪，然后翻转，共10个裁剪，之后对结果求平均。</li>
<li>对RGB空间做PCA（主成分分析），然后对主成分做一个（0, 0.1）的高斯扰动，也就是对颜色、光照作变换，结果使错误率又下降了1%。</li>
</ul>
<h1 id="层叠池化"><a href="#层叠池化" class="headerlink" title="层叠池化"></a>层叠池化</h1><p>在LeNet中池化是不重叠的，即池化的窗口的大小和步长是相等的，如下<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704170622157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在AlexNet中使用的池化（Pooling）却是可重叠的，也就是说，在池化的时候，每次移动的步长小于池化的窗口长度。AlexNet池化的大小为3×3的正方形，每次池化移动步长为2，这样就会出现重叠。重叠池化可以避免过拟合，这个策略贡献了0.3%的Top-5错误率。与非重叠方案s=2，z=2相比，输出的维度是相等的，并且能在一定程度上抑制过拟合。</p>
<h1 id="局部相应归一化"><a href="#局部相应归一化" class="headerlink" title="局部相应归一化"></a>局部相应归一化</h1><p>ReLU具有让人满意的特性，它不需要通过输入归一化来防止饱和。如果至少一些训练样本对ReLU产生了正输入，那么那个神经元上将发生学习。然而，我们仍然发现接下来的局部响应归一化有助于泛化。aix,y表示神经元激活，通过在(x,y)位置应用核i，然后应用ReLU非线性来计算，响应归一化激活$b^i_{x,y}$通过下式给定：</p>
<script type="math/tex; mode=display">b^i_{x,y} = a_{x,y}^i / \big( k + \alpha \sum _{j = max(0, i-n / 2)} ^{min(N-1, i+n / 2)} (a_{x,y}^j)^2 \big)^\beta</script><p>其中，N是卷积核的个数，也就是生成的FeatureMap的个数；$k,\alpha,\beta,n$是超参数，论文中使用的值是$k = 2 , n =5 ,\alpha = 10^{-4},\beta = 0.75$<br>输出$b^i_x,y$和输入$a^j_x,y$的上标表示的是当前值所在的通道，也即是叠加的方向是沿着通道进行。将要归一化的值$a^i_x,y$所在附近通道相同位置的值的平方累加起来$\sum _{j = max(0, i-n / 2)} ^{min(N-1, i+n / 2)} (a_{x,y}^j)^2$</p>
<h1 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h1><p>引入Dropout主要是为了防止过拟合。在神经网络中Dropout通过修改神经网络本身结构来实现，对于某一层的神经元，通过定义的概率将神经元置为0，这个神经元就不参与前向和后向传播，就如同在网络中被删除了一样，同时保持输入层与输出层神经元的个数不变，然后按照神经网络的学习方法进行参数更新。在下一次迭代中，又重新随机删除一些神经元（置为0），直至训练结束。<br>Dropout应该算是AlexNet中一个很大的创新，现在神经网络中的必备结构之一。Dropout也可以看成是一种模型组合，每次生成的网络结构都不一样，通过组合多个模型的方式能够有效地减少过拟合，Dropout只需要两倍的训练时间即可实现模型组合（类似取平均）的效果，非常高效。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704171157113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="Alex网络结构"><a href="#Alex网络结构" class="headerlink" title="Alex网络结构"></a>Alex网络结构</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704171225572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704171344700.png"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704173956828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p>AlexNet 不算池化层总共有 8 层，前 5 层为卷积层，其中第一、第二和第五层卷积都包含了一个最大池化层，后三层为全连接层。所以 AlexNet 的简略结构如下：<br>输入&gt;卷积&gt;池化&gt;卷积&gt;池化&gt;卷积&gt;卷积&gt;卷积&gt;池化&gt;全连接&gt;全连接&gt;全连接&gt;输出</p>
<p>各层的结构和参数如下：</p>
<ul>
<li><p>卷积层C1<br>该层的处理流程是： 卷积—&gt;ReLU—&gt;归一化—&gt;池化。</p>
<ul>
<li>卷积，输入是227×227，使用96个11×11×3的卷积核，得到的FeatureMap为55×55×96<ul>
<li>ReLU，将卷积层输出的FeatureMap输入到ReLU函数中。</li>
<li>池化，使用3×3步长为2的池化单元（重叠池化，步长小于池化单元的宽度），输出为27×27×96（(55−3)/2+1=27)</li>
<li>局部响应归一化，使用k=2,n=5,α=10−4,β=0.75进行局部归一化，输出的仍然为27×27×96，输出分为两组，每组的大小为27×27×48</li>
</ul>
</li>
</ul>
</li>
<li><p>卷积层C2<br>该层的处理流程是：卷积—&gt;ReLU—&gt;归一化—&gt;池化。</p>
<ul>
<li>卷积，输入是2组27×27×48。使用2组，每组128个尺寸为5×5×48的卷积核，并作了边缘填充padding=2，卷积的步长1. 则输出的FeatureMap为2组，每组的大小为27×27 times128. （(27+2∗2−5)/1+1=27）</li>
<li>ReLU，将卷积层输出的FeatureMap输入到ReLU函数中</li>
<li>池化运算的尺寸为3×3，步长为2，池化后图像的尺寸为(27−3)/2+1=13，输出为13×13×256局部响应归一化，使用k=2,n=5,α=10−4,β=0.75<ul>
<li>进行局部归一化，输出的仍然为13×13×256，输出分为2组，每组的大小为13×13×128</li>
</ul>
</li>
</ul>
</li>
<li><p>卷积层C3<br>该层的处理流程是： 卷积—&gt;ReLU</p>
<ul>
<li>卷积，输入是13×13×256，使用2组共384尺寸为3×3×256的卷积核，做了边缘填充padding=1，卷积的步长为1.则输出的FeatureMap为13×13 times384<ul>
<li>ReLU，将卷积层输出的FeatureMap输入到ReLU函数中</li>
</ul>
</li>
</ul>
</li>
<li><p>卷积层C4<br>该层的处理流程是： 卷积—&gt;ReLU该层和C3类似。</p>
<ul>
<li>卷积，输入是13×13×384，分为两组，每组为13×13×192.使用2组，每组192个尺寸为3×3×192的卷积核，做了边缘填充padding=1，卷积的步长为1.则输出的FeatureMap为13×13 times384，分为两组，每组为13×13×192<ul>
<li>ReLU，将卷积层输出的FeatureMap输入到ReLU函数中</li>
</ul>
</li>
</ul>
</li>
<li><p>卷积层C5<br>该层处理流程为：卷积—&gt;ReLU—&gt;池化</p>
<ul>
<li>卷积，输入为13×13×384，分为两组，每组为13×13×192。使用2组，每组为128尺寸为3×3×192的卷积核，做了边缘填充padding=1，卷积的步长为1.则输出的FeatureMap为13×13×256<ul>
<li>ReLU，将卷积层输出的FeatureMap输入到ReLU函数中<ul>
<li>池化，池化运算的尺寸为3×3，步长为2，池化后图像的尺寸为 (13−3)/2+1=6<br>,即池化后的输出为6×6×256</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>全连接层FC6<br>该层的流程为：（卷积）全连接 —&gt;ReLU —&gt;Dropout</p>
<ul>
<li>卷积-&gt;全连接： 输入为6×6×256,该层有4096个卷积核，每个卷积核的大小为6×6×256。由于卷积核的尺寸刚好与待处理特征图（输入）的尺寸相同，即卷积核中的每个系数只与特征图（输入）尺寸的一个像素值相乘，一一对应，因此，该层被称为全连接层。由于卷积核与特征图的尺寸相同，卷积运算后只有一个值，因此，卷积后的像素层尺寸为4096×1×1，即有4096个神经元。<ul>
<li>ReLU,这4096个运算结果通过ReLU激活函数生成4096个值</li>
<li>Dropout,抑制过拟合，随机的断开某些神经元的连接或者是不激活某些神经元</li>
</ul>
</li>
</ul>
</li>
<li><p>全连接层FC7<br>流程为：全连接—&gt;ReLU—&gt;Dropout</p>
<ul>
<li>全连接，输入为4096的向量</li>
<li>ReLU,这4096个运算结果通过ReLU激活函数生成4096个值<ul>
<li>Dropout,抑制过拟合，随机的断开某些神经元的连接或者是不激活某些神经元</li>
</ul>
</li>
</ul>
</li>
<li><p>输出层</p>
<ul>
<li>第七层输出的4096个数据与第八层的1000个神经元进行全连接，经过训练后输出1000个float型的值，这就是预测结果</li>
</ul>
</li>
</ul>
<p>在论文中，输入图像大小为 224 x 224 x 3，实际为 227 x 227 x 3。各层输出采用 relu 进行激活。前五层卷积虽然计算量极大，但参数量并不如后三层的全连接层多，但前五层卷积层的作用却要比全连接层重要许多。</p>
<h1 id="AlexNet参数数量"><a href="#AlexNet参数数量" class="headerlink" title="AlexNet参数数量"></a>AlexNet参数数量</h1><p>卷积层的参数 = 卷积核的数量 * 卷积核 + 偏置</p>
<ul>
<li>C1: 96个11×11×3的卷积核，96×11×11×3+96=34848</li>
<li>C2: 2组，每组128个5×5×48的卷积核，(128×5×5×48+128)×2=307456</li>
<li>C3: 384个3×3×256的卷积核，3×3×256×384+384=885120</li>
<li>C4: 2组，每组192个3×3×192的卷积核，(3×3×192×192+192)×2=663936</li>
<li>C5: 2组，每组128个3×3×192的卷积核，(3×3×192×128+128)×2=442624</li>
<li>FC6: 4096个6×6×256的卷积核，6×6×256×4096+4096=37752832</li>
<li>FC7: 4096∗4096+4096=16781312</li>
<li>output: 4096∗1000=4096000</li>
</ul>
<p>卷积层 C2,C4,C5中的卷积核只和位于同一GPU的上一层的FeatureMap相连。从上面可以看出，参数大多数集中在全连接层，在卷积层由于权值共享，权值参数较少。</p>
<p>原文链接：<a href="https://www.cnblogs.com/wangguchangqing/p/10333370.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangguchangqing/p/10333370.html</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>Faster RCNN论文笔记</title>
    <url>/2019/07/05/Faster-RCNN%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>最先进的目标检测网络依靠 region proposal algorithms来假设目标的位置。SPPnet和Fast R-CNN等研究已经减少了这些检测网络的运行时间，使得 region proposal 计算成为一个瓶颈<br>Region Proposal Network (RPN) ，RPN网络与检测网络共享完整的图像卷积特征，大大减少了生成候选框所需的时间。RPN是一个全卷积网络，可以同时在每个位置预测目标边界和目标分数。RPN经过端到端的训练，可以生成高质量的区域建议，使用Fast R-CNN来用于检测。</p><a id="more"></a>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>引入了新的区域建议网络（RPN），它们共享最先进目标检测网络的卷积层。通过在测试时共享卷积，计算区域建议的边际成本很小（例如，每张图像10ms）<br>RPN旨在有效预测具有广泛（各种）尺度和长宽比的区域提议。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070520494280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>与使用图像金字塔（图1，a）或滤波器金字塔（图1，b）的流行方法相比，我们引入新的“锚”盒anchor boxes作为多种尺度和长宽比的参考。我们的方案可以被认为是回归参考d 金字塔（图1，c），它避免了枚举多种比例或长宽比的图像或滤波器。这个模型在使用单尺度图像进行训练和测试时运行良好，从而有利于运行速度。</p>
<p>解决多尺度和尺寸的不同方案。<br>（a）构建图像和特征映射金字塔，分类器以各种尺度运行。<br>（b）在特征映射上运行具有多个比例/大小的滤波器的金字塔。<br>（c）我们在回归函数中使用参考边界框金字塔。<br>为了将RPN与Fast R-CNN 目标检测网络相结合，我们提出了一种训练方案，在微调区域建议(region proposal)任务和微调目标检测之间进行交替，同时保持区域提议的固定。该方案快速收敛，并产生两个任务之间共享的具有卷积特征的统一网络。</p>
<h1 id="2-RELATED-WORK"><a href="#2-RELATED-WORK" class="headerlink" title="2. RELATED WORK"></a>2. RELATED WORK</h1><p><strong>Object Proposals</strong><br>广泛使用的目标提议方法包括基于超像素分组（例如，选择性搜索，CPMC，MCG）和那些基于滑动窗口的方法（例如窗口中的目标，EdgeBoxes）。目标提议方法被采用为独立于检测器（例如，选择性搜索目标检测器，R-CNN和Fast R-CNN）的外部模块。<br><strong>用于目标检测的深度网络</strong><br>R-CNN方法[5]端到端地对CNN进行训练，将建议区域分类为目标类别或背景。R-CNN主要作为分类器，并不能预测目标边界（除了通过边界框回归进行细化）。其准确度取决于区域提议模块的性能<br>使用深度网络来预测目标边界框的方法:</p>
<ul>
<li>OverFeat方法中，训练一个全连接层来预测假定单个目标定位任务的边界框坐标。然后将全连接层变成卷积层，用于检测多个类别的目标</li>
<li>MultiBox方法，从网络中生成区域提议，网络最后的全连接层同时预测多个类别不相关的边界框，并推广到OverFeat的“单边界框”方式。</li>
</ul>
<p>OverFeat计算图像金字塔的卷积特征用于分类，定位和检测。共享卷积特征映射的自适应大小池化Adaptively-sized pooling (SPP) （SPP）被开发用于有效的基于区域的目标检测，和语义分割。Fast R-CNN能够对共享卷积特征进行端到端的检测器训练。</p>
<h1 id="3-FASTER-R-CNN"><a href="#3-FASTER-R-CNN" class="headerlink" title="3. FASTER R-CNN"></a>3. FASTER R-CNN</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705213529708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705214048719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>Faster R-CNN由两个模块组成：</p>
<ul>
<li>proposes regions的深度全卷积网络</li>
<li>使用提议区域的Fast R-CNN检测器<h2 id="3-1-Region-Proposal-Networks"><a href="#3-1-Region-Proposal-Networks" class="headerlink" title="3.1 Region Proposal Networks"></a>3.1 Region Proposal Networks</h2>RPN的作用是输入一张图像，输出一批矩形候选框，类似于以往目标检测中的selective search，网络结构是基于卷积神经网络，但输出包含二分类softmax和bbox回归的多任务模型。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190707102207744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><h3 id="3-1-1-Anchors"><a href="#3-1-1-Anchors" class="headerlink" title="3.1.1 Anchors"></a>3.1.1 Anchors</h3><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190707091634227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在每个滑动窗口位置，我们同时预测多个区域建议，其中每个位置可能提议的最大数目表示为k。因此，reg层具有个4k输出，编码k个边界框的坐标，cls层输出2k个分数，估计每个建议是目标或不是目标的概率。锚点位于所讨论的滑动窗口的中心，并与一个尺度和长宽比相关。默认情况下，我们使用3个尺度和3个长宽比，在每个滑动位置产生k=9个锚点。对于大小为W×H（通常约为2400）的卷积特征映射，总共有WHk个锚点。</li>
</ul>
<p>训练、测试区域提案和目标检测网络都是在单一尺度的图像上,缩放图像为600*600,多尺度特征提取可能提高准确率但是不利于速度与准确率之间的权衡。<br>对于anchor，我们用3个简单的尺度:$128^2$ ,$256^2$ ,$512^2$ pixels，和3个简单的长宽比，1:1，1:2，2:1，共９种矩形。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190707100848566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="Translation-Invariant-Anchors"><a href="#Translation-Invariant-Anchors" class="headerlink" title="Translation-Invariant Anchors"></a>Translation-Invariant Anchors</h3><p>方法的一个重要特性是它是平移不变的，无论是在锚点还是计算相对于锚点的区域提议的函数。如果在图像中平移目标，提议应该平移，并且同样的函数应该能够在任一位置预测建议(proposal)。<br>平移不变特性也减小了模型的大小。MultiBox有(4 + 1) × 800-维的全连接输出层，而我们的方法在个锚点的情况下有(4 + 2) × 9-维的卷积输出层。因此，我们的输出层具有(512 × (4 + 2) × 9个参数（对于VGG-16），比MultiBox输出层的个参数（(1536 × (4 + 1) × 800 for GoogleNet）少了两个数量级</p>
<h3 id="Multi-Scale-Anchors-as-Regression-References"><a href="#Multi-Scale-Anchors-as-Regression-References" class="headerlink" title="Multi-Scale Anchors as Regression References"></a>Multi-Scale Anchors as Regression References</h3><p>多尺度预测有两种流行的方法：</p>
<ul>
<li>基于图像/特征金字塔，例如DPM和基于CNN的方法，在多个尺度上进行缩放，并且针对每个尺度计算特征映射（HOG或深卷积特征），非常耗时。<ul>
<li>在特征映射上使用多尺度（和/或长宽比）的滑动窗口。例如，在DPM中，使用不同的滤波器大小（例如5×7和7×5）分别对不同长宽比的模型进行训练。可以把它看作是一个“滤波器金字塔”。</li>
</ul>
</li>
</ul>
<p>作为比较，我们的基于锚点方法被建立在锚点金字塔上，这是更具成本效益的。方法参照多尺度和长宽比的锚盒来分类和回归边界框。它只依赖单一尺度的图像和特征映射，并使用单一尺寸的滤波器（特征映射上的滑动窗口）</p>
<p>这种基于锚点的多尺度设计，可以简单地使用在单尺度图像上计算的卷积特征，Fast R-CNN检测器也是这样做的。多尺度锚点设计是共享特征的关键组件，不需要额外的成本来处理尺度。</p>
<h3 id="3-1-2-Loss-Function"><a href="#3-1-2-Loss-Function" class="headerlink" title="3.1.2 Loss Function"></a>3.1.2 Loss Function</h3><p> 正负样本的判定：</p>
<ul>
<li>某anchor与任一目标区域的IOU最大，则判为目标<ul>
<li>某anchor与任一目标区域的IOU&gt;0.7则判定有目标，即正样本</li>
<li>某anchor与任一目标区域的IOU&lt;0.3则判为背景，即负样本</li>
</ul>
</li>
</ul>
<p><strong>损失函数：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070615200549.png"><br>i is the index of an anchor in a mini-batch<br>$p_i$ is the predicted probability of anchor i being an<br>object.<br>The ground-truth label$p^<em>_i$  is 1 if the anchor is positive, and is 0 if the anchor is negative.<br>$t_i$ is a vector representing the 4 parameterized coordinates<br>of the predicted bounding box<br>$t_i^</em>$ is that of the ground-truth box associated with a positive anchor.<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190706160205873.png"><br>Variables $x$, $x_a$ , and $x^*$are for the predicted box, anchor box, and ground-truth box respectively (likewise for y, w, h)</p>
<h3 id="3-1-3-训练RPN"><a href="#3-1-3-训练RPN" class="headerlink" title="3.1.3 训练RPN"></a>3.1.3 训练RPN</h3><ol>
<li>RPN可以使用反向传播和SGD实现端到端的训练，依照Fast R-CNN中的“image-centric”采样策略训练这个网络。每个mini-batch由包含了许多正负样本的单个图像组成。们可以优化所有anchor的损失函数，但是这会偏向于负样本，因为正负样本主要根据IOU值大小的来标定的，这样一来负样本就比较多。</li>
<li><strong>训练数据：</strong> 从一图片中随机提取256个anchor去计算一个mini-batch的损失函数。正样本：负样本=1:1，如果一个图像中的正样本数小于128，则多用一些负样本以满足有256个Proposal可以用于训练。</li>
<li><strong>权重参数</strong>：前面几层参数是经ImageNet数据集预训练后的vgg16来进行初始化，新增的两层为权重均设置为满足0均值，标准差为0.01的高斯分布来进行初始化。</li>
<li><strong>学习率</strong>：基于PASCAL VOC数据集，前60k的mini-batch，Lr =0.001，之后的20k个mini-batch，Lr = 0.0001</li>
<li><strong>优化算法</strong>：Momentum，其中设置momentum = 0.9，权重衰减系数设置为0.0005。</li>
</ol>
<h2 id="3-2-RPN和Fast-R-CNN共享图像卷积特征"><a href="#3-2-RPN和Fast-R-CNN共享图像卷积特征" class="headerlink" title="3.2 RPN和Fast R-CNN共享图像卷积特征"></a>3.2 RPN和Fast R-CNN共享图像卷积特征</h2><p>区域生成网络（RPN）和fast RCNN都需要一个原始特征提取网络<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190706165056620.png"><br>介绍三种能使网络共享图像特征的方法：</p>
<ul>
<li>交叉训练(Alternating training)。首先训练RPN，然后拿着RPN生成的proposals去训练Fast R-CNN，然后通过训练Fast R-CNN得到调整的网络再去初始化RPN</li>
<li>近似联合训练:直接在上图结构上训练。在backward计算梯度时，把提取的ROI区域当做固定值看待；在backward更新参数时，来自RPN和来自Fast RCNN的增量合并输入原始特征提取层。</li>
<li>非近似联合训练。如上所述，由RPN预测的检测框也是输入的函数。 Fast R-CNN中的RoI池化层接受卷积特征以及预测的检测框作为输入，因此理论上有效的反向传播求解器也应该包含梯度w.r.t.框坐标。这些梯度在上述近似联合训练中被忽略。在非近似联合培训解决方案中，我们需要一个可区分w.r.t.框坐标的RoI池化层。</li>
</ul>
<p><strong>四步交替训练</strong>：</p>
<ul>
<li>单独训练RPN网络，网络参数由预训练模型载入</li>
<li><p>单独训练Fast-RCNN网络，将第一步RPN的输出候选区域作为检测网络的输入。具体而言，RPN输出一个候选框，通过候选框截取原图像，并将截取后的图像通过几次conv-pool，然后再通过roi-pooling和fc再输出两条支路，一条是目标分类softmax，另一条是bbox回归。截止到现在，两个网络并没有共享参数，只是分开训练了</p>
</li>
<li><p>用检测网络初始化RPN训练，但我们固定共享的卷积层，并且只微调RPN独有的层，现在两个网络共享卷积层了。</p>
</li>
<li>保持共享的卷积层固定，微调Fast R-CNN的fc层。这样，两个网络共享相同的卷积层，构成一个统一的网络。</li>
</ul>
<p>测试阶段流程图如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070710063327.png"></p>
<p>论文原文：<a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">https://arxiv.org/abs/1506.01497</a><br>参考：<br><a href="https://blog.csdn.net/jcli1_14/article/details/82193784" target="_blank" rel="noopener">Faster -RCNN算法笔记</a><br><a href="https://blog.csdn.net/u014365862/article/details/77887230" target="_blank" rel="noopener">Faster RCNN：RPN，anchor，sliding windows</a><br><a href="https://www.cnblogs.com/guoyaohua/p/9488119.html" target="_blank" rel="noopener">Faster R-CNN：详解目标检测的实现过程</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>Fast R-CNN论文笔记</title>
    <url>/2019/07/05/Fast-R-CNN%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文提出了一种快速的基于区域的卷积网络方法（fast R-CNN）用于目标检测。Fast R-CNN建立在以前使用的深卷积网络有效地分类目标的成果上。相比于之前的成果，Fast R-CNN采用了多项创新提高训练和测试速度来提高检测精度</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>复杂性的产生是因为检测需要目标的精确定位，这就导致两个主要的难点。首先，必须处理大量候选目标位置（通常称为“建议”）。 第二，这些候选框仅提供粗略定位，其必须被精细化以实现精确定位。 这些问题的解决方案经常会影响速度，准确性或简单性。<br>简化了最先进的基于卷积网络的目标检测器的训练过程。我们提出一个单阶段训练算法，共同学习分类候选框和改进他们的空间位置。 </p><a id="more"></a>

<h2 id="1-1-R-CNN-and-SPPnet"><a href="#1-1-R-CNN-and-SPPnet" class="headerlink" title="1.1 R-CNN and SPPnet"></a>1.1 R-CNN and SPPnet</h2><p>基于区域的卷积网络方法（RCNN）通过使用深度卷积网络来分类目标候选框，获得了很高的目标检测精度。然而，R-CNN具有显着的缺点： </p>
<ul>
<li>训练的模型是多阶段管道（pipeline）。R-CNN首先使用目标候选框对卷积神经网络进行微调。然后，它将卷积神经网络得到的特征送入SVM。 这些SVM作为目标检测器，替代通过微调学习的softmax分类器。 在第三个训练阶段，学习bbox（边界）回归。 </li>
<li>训练在时间和空间上是很大代价的。对于SVM和bbox回归训练，从每个图像中的每个目标候选框提取特征，并写入磁盘。对于非常深的网络，如VGG16，这个过程需要2.5 GPU-天在VOC07训练集上的5k图像。这些特征需要数百GB的存储空间。 </li>
<li>目标检测速度很慢。在测试时，从每个测试图像中的每个目标候选框提取特征。用VGG16网络检测目标需要47s /图像（在GPU上）。</li>
</ul>
<p> R-CNN很慢是因为它为每个目标候选框进行卷积神经网络正向传递，而不共享计算。SPP网络通过共享计算加速R-CNN。SPP网络计算整个输入图像的卷积特征映射，然后使用从共享特征映射提取的特征向量来对每个候选框（object proposals）进行分类。通过将候选框内的特征图的一部分最大化为固定大小的输出（例如，6X6）来提取针对候选框的特征。多个输出被池化，然后连接成空间金字塔池<br>  SPP网络也有显著的缺点。像R-CNN一样训练网络是一个多阶段的涉及提取特征的网络，和对网络进行微调有损失，训练SVM分类器，最后拟合边界回归（bbox）。特征也写入磁盘。但与R-CNN不同，微调算法不能更新在空间金字塔池之前的卷积层。</p>
<h2 id="1-2-Contributions"><a href="#1-2-Contributions" class="headerlink" title="1.2 Contributions"></a>1.2 Contributions</h2><p> Fast RCNN方法有几个优点：</p>
<ul>
<li>比R-CNN和SPP网络具有更高精度（mAP）的目标检测；</li>
<li>训练是使用多任务损失(loss)的单阶段训练；</li>
<li>训练可以更新所有网络层参数；</li>
<li>特征缓存不需要磁盘空间 </li>
</ul>
<h1 id="2-fast-R-CNN-结构和训练"><a href="#2-fast-R-CNN-结构和训练" class="headerlink" title="2.fast R-CNN 结构和训练"></a>2.fast R-CNN 结构和训练</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705130127996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705191147793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>图像归一化为224×224直接送入网络。<br>前五阶段是基础的conv+relu+pooling形式，在第五阶段结尾，输入P个候选区域（图像序号×1+几何位置×4，序号用于训练）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705133427467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>Fast R-CNN网络将整个图像和一组候选框作为输入。网络首先使用几个卷积层（conv）和最大池层来处理整个图像，以产生特征图。然后，对于每个候选框，感兴趣区域（RoI）池化层从特征图中提取固定长度的特征向量。每个特征向量被送到完全连接（fc）层的中。</p>
<h2 id="2-1-ROI-pooling-layer"><a href="#2-1-ROI-pooling-layer" class="headerlink" title="2.1 ROI pooling layer"></a>2.1 ROI pooling layer</h2><p>不同于前面的SPP，在Fast RCNN网络中，RoI来完成SPP层的作用。RoI指的是在一张图片上完成Selective Search后得到的“候选框”在特征图上的一个映射，RoI层的作用主要有两点：</p>
<ul>
<li>RoI池化层使用最大池化将任何有效的感兴趣区域内的特征转换成具有H × W（例如，7×7）的固定空间范围的小特征图。考虑到感兴趣区域（RoI）尺寸不一，但是输入图中后面FC层的大小是一个统一的固定值，ROI池化层的作用类似于SPP-net中的SPP层，即将不同尺寸的RoI feature map池化成一个固定大小的feature map。具体操作：假设经过RoI池化后的固定大小为$\frac{H}{W}$是一个超参数，假设输入的RoI feature map大小为$\frac{h}{w}$，池化窗口的尺寸为：$\frac{h}{H}\times \frac{w}{W}$，即用这个计算出的窗口对RoI feature map做max pooling，Pooling对每一个feature map通道都是独立的。</li>
<li>RoI是一个矩形窗口，成为一个特征映射。 每个RoI由指定其左上角（r; c）及其高度和宽度（h; w）的四元组（r; c; h; w）定义</li>
</ul>
<h2 id="2-2-Initializing-from-pre-trained-networks"><a href="#2-2-Initializing-from-pre-trained-networks" class="headerlink" title="2.2 Initializing from pre-trained networks"></a>2.2 Initializing from pre-trained networks</h2><p>实验了三个预训练的ImageNet网络，每个网络有五个最大池化层和五到十三个卷积层，当预训练网络初始化fast R-CNN网络时，其经历三个变换。 </p>
<ul>
<li><p>用RoI pooling layer取代网络的最后一个池化层,其通过将H和W设置为与网络的第一完全连接层兼容来配置（例如，对于VGG16，H = W = 7）</p>
</li>
<li><p>网络的最后全连接层和softmax（其被训练用于1000类ImageNet分类）被替换为前面描述的两个同级层（完全连接的层和softmax在K + 1类别和类别特定的边界回归）</p>
</li>
<li><p>输入两组数据到网络：一组图片和每一个图片的一组RoIs</p>
</li>
</ul>
<h2 id="2-3-Fine-tuning-for-detection"><a href="#2-3-Fine-tuning-for-detection" class="headerlink" title="2.3. Fine-tuning for detection"></a>2.3. Fine-tuning for detection</h2><ol>
<li>用反向传播训练所有网络权重是fast R-CNN的重要能力<br>SPPnet无法更新低于空间金字塔池化层的权重。 根本原因是当每个训练样本（即RoI）来自不同的图像时，通过SPP层的反向传播是非常低效的 ,低效的部分是因为每个RoI可能具有非常大的感受野，通常跨越整个输入图像。由于正向传递必须处理整个感受野，训练输入是大的（通常是整个图像）</li>
<li><p>作者利用特征分享的优势，提出一个更加有效的训练方法：SGD mini_batch分层采样方法。<br>首先随机取样N张图片，然后每张图片取样R/N个RoIs 。除此之外，网络在一次微调中将softmax分类器和bbox回归一起优化，区别于R-CNN的softmax回归，SVM，bbox回归的三步分开优化。</p>
</li>
<li><p>多任务损失（multi-task loss）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705190832397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>Fast R-CNN网络具有两个同级输出层，一个是softmax用于对每个RoI区域做分类，假如有K类待分(加上背景总共K+1类)，输出结果为$p=(p_{0}, \dots, p_{K})$，另一个是bbox，用于更精确的定位RoI的区域，输出结果$t^{k}=(t^{k}_{x}, t^{k}_{y}, t^{k}_{w}, t^{k}_{h})$。<br>多任务损失函数定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705160314254.png"></p>
<p> 上式中，$L_{cls}(p,u)=-logp_{u}$是真实类$u$的log损失函数，$L_{loc}中v={v_{x}, v_{y}, v_{w}, v_{h}}$是类为u的真实框的位置而$t^{u}=(t^{u}_{x}, t^{u}_{y}, t^{u}_{w}, t^{u}_{h})$是类为u的预测框位置。$当$u&gt;1$，[u&gt;1]$为1，反之为0。文中实验时$\lambda=1$。<br>背景类标记为u = 0，对于背景RoI，没有ground truth边界框的概念，因此Lloc被忽略<br>对于边界框回归，我们使用损失$L_{loc}：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705160456155.png"></p>
<p>  其中:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705160630408.png"></p>
<pre><code>    smooth是鲁棒的L1损失，对于异常值比在R-CNN和SPPnet中使用的L2损失更不敏感，当回归目标无界时，具有L2损失的训练可能需要仔细调整学习速率，以防止爆炸梯度。
</code></pre><p>超参数λ控制两个任务损失之间的平衡。将groundtruth回归目标$v_i$归一化为具有零均值和单位方差。所有实验都使用λ = 1。</p>
</li>
<li><p>小批量取样（mini-batch sampling）<br>不再类似于R-CNN那样使用均匀的随机采样128个训练样本，而是分层采样，先随机采样N张图片，然后从每张图片中采样R/N个RoIs，实际选择N=2， R=128，<br>训练数据构成：N张完整图片以50%概率水平翻转。没有使用数据扩增 。<br>R个候选框的构成方式如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705194417676.png"></p>
</li>
<li><p>通过RoI池层的反向传播</p>
<p>反向传播的函数为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070516371299.png"><br>$xi∈ R$是到RoI池化层的第i个激活输入<br>$y_{rj}$是来自第$r$个RoI的层的第$j$个输出节点<br>RoI池化层计算$y_{rj} = x_i<em>（r; j）$，其中$i</em>（r; j）= argmax _{i’∈R（r; j）}x_i’$，表示i节点是否被候选区域r的第j个节点选为最大值输出<br>$R（r; j）$是输出单元$y_{rj}$ 最大池化的子窗口中的输入的索引集合<br>单个 $x_{i}$ 可以被分配给几个不同的输出 $y_{rj}$<br>对于每个小批量（mini-batch）RoI  $r$和对于每个池化输出单元$y_{rj}$，如果$i$ 是 $y_{rj}$ 通过最大池化选择的argmax（一个函数），则将这个偏导数$αL/αy_{rj}$积累下来。在反向传播中，偏导数$αL/αy_{rj}$已经由RoI池层顶部的层的向后函数（backwards function）计算。</p>
</li>
<li><p>SGD超参数<br>用于分类的全连接层以均值为0、标准差为0.01的高斯分布初始化；<br>用于回归的全连接层以均值为0、标准差为0.001的高斯分布初始化，偏置都初始化为0</p>
<h1 id="3-Fast-R-CNN-detection"><a href="#3-Fast-R-CNN-detection" class="headerlink" title="3 Fast R-CNN detection"></a>3 Fast R-CNN detection</h1><p>一旦fast R-CNN网络被微调完毕，检测相当于运行前向传递（假设候选框是预先计算的）。网络将图像（或图像金字塔，编码为图像列表）和待计算概率的R个候选框的列表作为输入，当使用图像金字塔的时候，每个RoI被指定尺度使得接近224*224。<br>对于每个测试的RoI r，正向传递输出类别后验概率分布p和相对于r的预测的边界框偏移集合（K个类别中的每一个获得其自己的精细边界框预测）。我们使用估计的概率$P_r（class= k|r）= p_k$为每个对象类别k分配r的检测置信度。然后，我们使用R-CNN算法的设置和对每个类别独立执行非最大抑制。</p>
</li>
</ol>
<p><strong>全连接层提速</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705194631173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p>论文原文：<a href="https://arxiv.org/abs/1504.08083" target="_blank" rel="noopener">https://arxiv.org/abs/1504.08083</a><br>Fast RCNN算法详解：<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51036677" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51036677</a><br>RoI pooling layer解读：<a href="https://blog.csdn.net/xunan003/article/details/86583563" target="_blank" rel="noopener">https://blog.csdn.net/xunan003/article/details/86583563</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>VGG</title>
    <url>/2019/07/05/VGG/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="VGG的网络结构图"><a href="#VGG的网络结构图" class="headerlink" title="VGG的网络结构图"></a>VGG的网络结构图</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070514444886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br> 由上图所知，VGG一共有五段卷积，每段卷积之后紧接着最大池化层，作者一共实验了6种网络结构。分别是VGG-11，VGG-13,VGG-16,VGG-19，网络的输入是224*224大小的图像，输出是图像分类结果<br>VGG与Alexnet相比，具有如下改进几点：</p><ul>
<li>去掉了LRN层，作者发现深度网络中LRN的作用并不明显，干脆取消了<ul>
<li>采用更小的卷积核-3x3，Alexnet中使用了更大的卷积核，比如有7x7的，因此VGG相对于Alexnet而言，参数量更少</li>
<li>池化核变小，VGG中的池化核是2x2，stride为2，Alexnet池化核是3x3，步长为2</li>
</ul>
</li>
</ul><a id="more"></a>

<p>首先为了更好的探究深度对网络的影响，必须要解决参数量的问题，更深的网络意味着更多的参数，训练更困难，使用大卷积核时尤其明显.作者通过分析，认为由于卷积神经网络的特性，3x3大小的卷积核足以捕捉到横、竖以及斜对角像素的变化。使用大卷积核会带来参数量的爆炸不说，而且图像中会存在一些部分被多次卷积，可能会给特征提取带来困难，所以在VGG中，普遍使用3x3的卷积。</p>
<h1 id="VGG16"><a href="#VGG16" class="headerlink" title="VGG16"></a>VGG16</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705143607978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070514422770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>SPPNet论文笔记</title>
    <url>/2019/07/04/SPPNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ol>
<li>当前深度卷积神经网络（CNNs）都需要输入的图像尺寸固定（比如224×224），这种人为的需要导致面对任意尺寸和比例的图像或子图像时降低识别的精度(因为要经过crop/warp）</li>
<li>空间金字塔池化”(spatial pyramid pooling,)的池化策略以消除上述限制。SPP-net的网络结构能够产生固定大小的表示（representation）不管输入图像的尺寸或比例。</li>
<li>使用SPP-net，只需要从整张图片计算一次特征图（feature map），然后对任意尺寸的区域（子图像）进行特征池化以产生一个固定尺寸的表示用于训练检测器。这个方法避免了反复计算卷积特征。<h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h1></li>
<li>CNNs在训练和测试时一个技术问题：需要输入的图像尺寸是固定的（比如224×224），限制了输入图像的长宽比和缩放尺度。当遇到任意尺寸的图像是，都是先将图像适应成固定尺寸，方法包括裁剪和变。但裁剪会导致信息的丢失，变形会导致位置信息的扭曲变形，就会影响识别的精度<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704202635434.png"></li>
<li><p><strong>为什么CNNs需要一个固定的输入尺寸</strong>？<br>卷积层的参数和输入大小无关，它仅仅是一个卷积核在图像上滑动，不管输入图像多大都没关系，只是对不同大小的图片卷积出不同大小的特征图，但是全连接层的参数就和输入图像大小有关，因为它要把输入的所有像素点连接起来,需要指定输入层神经元个数和输出层神经元个数，所以需要规定输入的feature的大小。</p>
</li>
<li><p>SPP层放在最后一个卷积层之后。SPP层对特征图进行池化，并产生固定长度的输出，这个输出再喂给全连接层<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704203627122.png"></p>
</li>
<li>SPP有几个突出的优点：.<br> （1） SPP能在输入尺寸任意的情况下产生固定大小的输出，而以前的深度网络[3]中的滑窗池化(sliding window pooling)则不能<br> （2）SPP使用了多层空间箱(bin)，而滑窗池化则只用了一个窗口尺寸。多级池化对于物体的变形有十分强的鲁棒性。<br> （3）由于其对输入的灵活性，SPP可以池化从各种尺度抽取出来的特征</li>
<li>SPP-net不仅仅让测试阶段允许任意尺寸的输入能够产生表示(representations)，也允许训练阶段的图像可以有各种尺寸和缩放尺度。使用各种尺寸的图像进行训练可以提高尺度不变性，以及减少过拟合。</li>
<li>SPP的优点是与各类CNN设计是正交的，SPP对不同的CNN架构都有提升，可以帮助提升更复杂的（更大、更深）的卷积架构</li>
<li>在目标检测方面，SPP-net也表现优异.基于SPP-net的系统（建立在R-CNN流水线上）比R-CNN计算卷积特征要快24-120倍，而精度却更高。</li>
</ol><a id="more"></a>
<h1 id="2-Deep-networks-with-spatial-pyramid-pooling"><a href="#2-Deep-networks-with-spatial-pyramid-pooling" class="headerlink" title="2 Deep networks with spatial pyramid pooling"></a>2 Deep networks with spatial pyramid pooling</h1><h2 id="2-1-Convolutional-Layers-and-Feature-Maps"><a href="#2-1-Convolutional-Layers-and-Feature-Maps" class="headerlink" title="2.1 Convolutional Layers and Feature Maps"></a>2.1 Convolutional Layers and Feature Maps</h2><p>在颇受欢迎的七层架构中中，前五层是卷积层，其中一些后面跟着池化层。从他们也使用滑窗的角度来看，池化层也可以认为是“卷积层”。最后两层是全连接的，跟着一个N路softmax输出，其中N是类别的数量。上述的深度网络需要一个固定大小的图像尺寸,固定尺寸的要求仅仅是因为全连接层的存在导致的<br>卷积层接受任意尺寸的输入。卷积层使用滑动的特征过滤器，它们的输出基本保持了原始输入的比例关系,它们的输出就是特征图</p>
<h2 id="2-2-The-Spatial-Pyramid-Pooling-Layer"><a href="#2-2-The-Spatial-Pyramid-Pooling-Layer" class="headerlink" title="2.2 The Spatial Pyramid Pooling Layer"></a>2.2 The Spatial Pyramid Pooling Layer</h2><ol>
<li><p>卷积层接受任意大小的输入，所以他们的输出也是各种大小。而分类器（SVM/softmax）或者全连接层需要固定的输入大小的向量,这种向量可以使用the Bag-of-Words (BoW)方法通过池化特征来生成。空间金字塔池化对BoW进行了改进，使得通过池化可以保留局部空间块（local spatial bins）的信息。这些空间块的尺寸和图像的尺寸是成比例的，所以这样块的数量是固定的了。</p>
</li>
<li><p>为了让我们的神经网络适应任意尺寸的图像输入，我们用一个空间金字塔池化层替换掉了最后一个池化层（最后一个卷积层之后的pool5）。空间金字塔的输出是一个kM维向量，M代表块的数量，k代表最后一层卷积层的过滤器的数量。这个固定维度的向量就是全连接层的输入。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704213955436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"> </p>
</li>
<li>黑色图片代表卷积之后的特征图，接着我们以不同大小的块来提取特征，分别是4<em>4，2</em>2，1*1，将这三张网格放到下面这张特征图上，就可以得到16+4+1=21种不同的块(Spatial bins)，我们从这21个块中，每个块提取出一个特征，这样刚好就是我们要提取的21维特征向量。这种以不同的大小格子的组合方式来池化的过程就是空间金字塔池化（SPP）。比如，要进行空间金字塔最大池化，其实就是从这21个图片块中，分别计算每个块的最大值，从而得到一个输出单元，最终得到一个21维特征的输出。</li>
<li>空间金字塔最大池化（SPP-Max）的过程，其实就是从这21个图片块中，分别计算每个块的最大值，从而得到一个输出特征向量（跟上一层卷积核深度一样可能是256）。最后把一张任意大小的图片转换成了一个固定大小的21维特征（当然你可以设计其它维数的输出，增加金字塔的层数，或者改变划分网格的大小）。上面的三种不同刻度的划分，每一种刻度我们称之为金字塔的一层，使用多个不同刻度的层，可以提高我们所提取特征的鲁棒性。每一个图片块大小我们称之为：Sliding Windows Size了。如果你希望，金字塔的某一层输出n*n个特征，那么你就要用Windows Size大小为：(w/n,h/n)进行池化了。具体的SPP过程如下图5所示：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070509053438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
<li>例如上图，所以Conv5计算出的feature map也是任意大小的，现在经过SPP之后，就可以变成固定大小的输出了，以上图为例，一共可以输出（16+4+1）*256的特征。<h1 id="2-3-Training-the-Network"><a href="#2-3-Training-the-Network" class="headerlink" title="2.3 Training the Network"></a>2.3 Training the Network</h1><strong>单尺寸训练：</strong><br>从理论上讲，SPP-Net支持直接以多尺度的原始图片作为输入后直接反向传播（Backpropagation）。实际上（Actually），Caffe等实现中，为了计算的方便，GPU,CUDA等比较适合固定尺寸的输入，所以训练的时候输入的图片是固定了尺度了的。以$224<em>224$的输入为例：在Conv5之后的特征图为：13x13</em>256（a<em>a</em>c）；金字塔层bins:   n<em>n；将pooling层作为Sliding window pooling。Windows_size=[a/n] 向上取整 ， Stride_size=[a/n]向下取整。得到的特征是n</em>n个特征向量（向量的长度是256）。对于pool 3<em>3:      Windows_size=5 的计算公式是：[13/3]向上取整=5 ，Stride_size= 4的计算公式是：[13/3]向下取整。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190705095007529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><strong>多尺寸训练：</strong><br>使用两个尺度进行训练：224</em>224 和180*180，训练的时候，对于接受180输入的网络，我们实现另一个固定尺寸的网络。本例中，conv5输出的特征图尺寸是axa=10×10。我们仍然使用win = 上取整[a/n]，str = 下取整[a/n]，实现每个金字塔池化层。这个180网络的空间金字塔层的输出的大小就和224网络的一样了。训练过程中，我们通过使用共享参数的两个固定尺寸的网络实现了不同输入尺寸的SPP-net，为了降低从一个网络（比如224）向另一个网络（比如180）切换的开销，即用224的图片训练一个epoch，之后180的图片训练一个epoch，交替地进行。<br>多尺寸训练的主要目的是在保证已经充分利用现在被较好优化的固定尺寸网络实现的同时，模拟不同的输入尺寸。除了上述两个尺度的实现，我们也在每个epoch中测试了不同的sxs输入，s是从180到224之间均匀选取的<br>上面的单尺寸或多尺寸解析度只用于训练。在测试阶段，是直接对各种尺寸的图像应用SPP-net的。</li>
</ol>
<h1 id="3-SPP-NET-for-image-classification"><a href="#3-SPP-NET-for-image-classification" class="headerlink" title="3 SPP-NET for image classification"></a>3 SPP-NET for image classification</h1><h2 id="3-1-Experiments-on-ImageNet-2012-Classification"><a href="#3-1-Experiments-on-ImageNet-2012-Classification" class="headerlink" title="3.1 Experiments on ImageNet 2012 Classification"></a>3.1 Experiments on ImageNet 2012 Classification</h2><h3 id="3-1-1-Baseline-Network-Architectures-基准网络架构"><a href="#3-1-1-Baseline-Network-Architectures-基准网络架构" class="headerlink" title="3.1.1 Baseline Network Architectures(基准网络架构)"></a>3.1.1 Baseline Network Architectures(基准网络架构)</h3><p>对已有网络增加SPP层提升系能，包括ZF-5,Convnet-5,Overfeat-5/7，单尺度和多尺度输入图像的实验结果top-1及top-5 error如下表所示，第一个提出多尺度输入图像训练网络 </p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704215821465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="3-1-2-Multi-level-Pooling-Improves-Accuracy"><a href="#3-1-2-Multi-level-Pooling-Improves-Accuracy" class="headerlink" title="3.1.2 Multi-level Pooling Improves Accuracy"></a>3.1.2 Multi-level Pooling Improves Accuracy</h3><p>表2(b)中我们显示了使用单尺寸训练的结果。训练和测试尺寸都是224×224.这些网络中，卷积网络都和他们的基准网络有相同的结构，只是最后卷积层之后的池化层，被替换成了SPP层.表2中的结果我们使用了4层金字塔，{6x6, 3×3, 2×2, 1x1}(总共50个块)。为了公平比较，我们仍然使用标准的10-view预测法，每个view都是一个224×224的裁切。表2（b）中的结果显示了明显的性能提升。有趣的是，最大的提升（top-1 error，1.65%）来自于精度最高的网络架构。既然我们一直使用相同10个裁切view。这些提升只能是来自于多层次池化。<br>多层次池化带来的提升不只是因为更多的参数；而是因为多层次池化对对象的变形和空间布局更加鲁棒[15]。为了说明这个，我们使用一个不同的4层金字塔（4×4, 3×3, 2×2, 1×1}，共30个块）训练另一个ZF-5网络。这个网络有更少的参数，因为他的全连接层fc6有30×256维输入而不是36×256维。 网络的top-1/top-5错误率分别是35.06/14.04和50块的金字塔网络相近，明显好于非SPP基准网络（35.99/14.76）。</p>
<h3 id="3-1-3-Multi-size-Training-Improves-Accuracy"><a href="#3-1-3-Multi-size-Training-Improves-Accuracy" class="headerlink" title="3.1.3 Multi-size Training Improves Accuracy"></a>3.1.3 Multi-size Training Improves Accuracy</h3><p>表2（c）展示了多尺寸训练的结果。训练尺寸是224和180，测试尺寸是224。我们还使用标准的10-view预测法。所有架构的top-1/top-5错误率进一步下降。SPP-net(Overfeat-7)的Top-1 错误率降到29.68%，比非SPP网络低了2.33%，比单尺寸训练降低了0.68%。除了使用180和224两个尺寸，我们还随机选了[180;224]之间多个尺寸。SPP-net(Overfeat-7)的top1/5错误30.06%/10.96%。Top-1错误率比两尺寸版本有所下降，可能因为224这个尺寸（测试时用的尺寸）被更少的访问到。但结果仍然比但尺寸版本要好。<br>        之前的CNN解决方案也处理了不同尺寸问题，但他们主要是基于测试。在Overfeat和Howard的方法中，单一网络在测试解决被应用于不同的尺度，然后将分支平均。Howard进一步在低/高两个分辨率图像区域上训练了两个不同的网络，然后平均分支。据我们所知，我们是第一个对不同尺寸训练单一网络的方法。</p>
<h3 id="3-1-4-Full-image-Representations-Improve-Accuracy"><a href="#3-1-4-Full-image-Representations-Improve-Accuracy" class="headerlink" title="3.1.4 Full-image Representations Improve Accuracy"></a>3.1.4 Full-image Representations Improve Accuracy</h3><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704220622358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>接下来我们研究全图像视角的准确度。我们将图像保持比例不变的情况下缩放到min(w;h)=256。SPP-net应用到一整张图像上。为了公平比较，我们也计算中央224×224裁切这单一视图（上述评估都用过）的准确度。单视图比较的准确度见表3。验证了ZF-5/Overfeat-7，top-1错误率在全视图表示中全部下降。这说明保持完整内容的重要性。即使网络训练时只使用了正方形图像，却也可以很好地适应其他的比例。<br>对比表2和表3我们发现，结合多种视图大体上要好于全图像视图。然而全视图图像的表示仍然有价值。首先，经验上看，即使结合几十个视图，额外增加两个全图像视角（带翻转）仍然可以提高准确度大约0.2%。其次，全图像视图从方法论上讲与传统方法保持了一致，这些方法中对整张图像进行编码的SIFT向量被池化在一起。第三，在其他一些应用中，比如图像恢复，相似度评分需要图像表示而不是分类得分。一个全图像的表示就会成为首选。</p>
<p><strong>SPP-Net与R-CNN的对比</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704221748996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>对于R-CNN，整个过程是：</p>
<ul>
<li>首先通过选择性搜索，对待检测的图片进行搜索出~2000个候选窗口。 特征提取非常耗时<ul>
<li>把这2k个候选窗口的图片都缩放到227*227，然后分别输入CNN中，每个proposal提取出一个特征向量，也就是说利用CNN对每个proposal进行提取特征向量。 </li>
<li>把上面每个候选窗口的对应特征向量，利用SVM算法进行分类识别。 </li>
</ul>
</li>
</ul>
<p>而对于SPP-Net，整个过程是：</p>
<ul>
<li>首先通过选择性搜索，对待检测的图片进行搜索出2000个候选窗口。这一步和R-CNN一样。<ul>
<li>特征提取阶段。这一步就是和R-CNN最大的区别了，这一步骤的具体操作如下：把整张待检测的图片，输入CNN中，进行一次性特征提取，得到feature maps，然后在feature maps中找到各个候选框的区域，再对各个候选框采用金字塔空间池化，提取出固定长度的特征向量。而R-CNN输入的是每个候选框，然后在进入CNN，因为SPP-Net只需要一次对整张图片进行特征提取，速度会大大提升。</li>
<li>最后一步也是和R-CNN一样，采用SVM算法进行特征向量分类识别。</li>
</ul>
</li>
</ul>
<p><strong>Mapping a Window to Feature Maps</strong><br>我们知道，在原图中的proposal,经过多层卷积之后，位置还是相对于原图不变的（如下图所示），那现在需要解决的问题就是，如何能够将原图上的proposal,映射到卷积之后得到的特征图上，因为在此之后我们要对proposal进行金字塔池化。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704222709940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">对于映射关系，论文中给出了一个公式：<br>假设(x’,y’)表示特征图上的坐标点，坐标点(x,y)表示原输入图片上的点，那么它们之间有如下转换关系，这种映射关心与网络结构有关： (x,y)=(S<em>x’,S</em>y’)<br>反过来，我们希望通过(x,y)坐标求解(x’,y’)，那么计算公式如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704222735191.png"><br>其中S就是CNN中所有的strides的乘积，包含了池化、卷积的stride。<br>比如，对于下图的集中网络结构，S的计算如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190704222807282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p>参考：<a href="https://blog.csdn.net/v1_vivian/article/details/73275259" target="_blank" rel="noopener">https://blog.csdn.net/v1_vivian/article/details/73275259</a><br><a href="https://www.cnblogs.com/xiaoboge/p/10567869.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoboge/p/10567869.html</a><br>论文原文：<a href="https://arxiv.org/abs/1406.4729" target="_blank" rel="noopener">https://arxiv.org/abs/1406.4729</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>yolo v3 论文笔记</title>
    <url>/2019/07/03/yolo-v3-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703184150894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>作者对YOLO进行了进一步的更新，做了一些小设计更改让其表现更好。YOLOv3比YOLOv2相较大了一些，却更加准确，但是依然很快。在320×320 YOLOv3在28.2mAP上仅运行了22ms，和SSD的准确度相同但是快了3倍。在关注原有的0.5 IOU mAP 检测指标时，YOLOv3表现相当棒。在Titan X在52ms内实现了57.9 AP50，与RetinaNet在198ms内实现57.5AP50相当，但是快了3.8倍。</p><a id="more"></a>

<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h1 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a>2.更新</h1><p>谈到YOLOv3的更新情况，其实大多数时候我们就是直接把别人的好点子拿来用了。我们还训练了一个全新的、比其他网络更好的分类网络。为了方便你理解，让我们从头开始慢慢介绍<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703185321807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="2-1边界框预测"><a href="#2-1边界框预测" class="headerlink" title="2.1边界框预测"></a>2.1边界框预测</h2><p>在YOLO9000后，我们的系统开始用dimension clusters固定anchor box来选定边界框。神经网络会为每个边界框预测4个坐标：tx、ty、tw、th。如果目标cell距离图像左上角的边距是（cx, cy），且它对应边界框的宽和高为pw、ph，那么网络的预测值会是：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703185615332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>在训练期间，我们会计算方差。如果预测坐标的ground truth是$\hat{t}_<em>$，那相应的梯度就是ground truth值和预测值的差：$\hat{t}_</em>-t_*$。利用上述公式，我们能轻松推出这个结论。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703190035327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>YOLOv3用逻辑回归预测每个边界框的objectness score。如果当前预测的边界框比之前的更好地与ground truth对象重合，那它的分数就是1。如果当前的预测不是最好的，但它和ground truth对象重合到了一定阈值以上，神经网络会忽视这个预测。我们使用的阈值是.5。与[15]不同，我们的系统只为每个ground truth对象分配一个边界框。如果先前的边界框并未分配给相应对象，那它只是检测错了对象，而不会对坐标或分类预测造成影响。</p>
<h1 id="2-2-分类预测"><a href="#2-2-分类预测" class="headerlink" title="2.2 分类预测"></a>2.2 分类预测</h1><p>每个边界框都会使用多标记分类来预测框中可能包含的类。我们不用softmax，而是用单独的逻辑分类器，因为我们发现前者对于提升网络性能没什么用。在训练过程中，我们用二元交叉熵损失来预测类别。</p>
<p>这个选择有助于我们把YOLO用于更复杂的领域，如开放的图像数据集。这个数据集中包含了大量重叠的标签（如女性和人）。如果我们用的是softmax，它会强加一个假设，使得每个框只包含一个类别。但通常情况下这样做是不妥的，相比之下，多标记的分类方法能更好地模拟数据</p>
<h2 id="2-3-跨尺寸预测"><a href="#2-3-跨尺寸预测" class="headerlink" title="2.3 跨尺寸预测"></a>2.3 跨尺寸预测</h2><p>YOLOv3提供了3种尺寸不一的边界框。我们的系统用相似的概念提取这些尺寸的特征，以形成金字塔形网络[6]。我们<strong>在基本特征提取器中增加了几个卷积层，并用最后的卷积层预测一个三维张量编码：边界框、框中目标和分类预测</strong>。在COCO数据集实验中，我们的神经网络分别为每种尺寸各预测了3个边界框，所以得到的张量是N ×N ×[3∗(4+ 1+ 80)]，其中包含4个边界框offset、1个目标预测以及80种分类预测。</p>
<p>接着，我们从前两个图层中得到特征图，并对它进行2次上采样。再从网络更早的图层中获得特征图，用element-wise把高低两种分辨率的特征图连接到一起。这样做能使我们找到早期特征映射中的上采样特征和细粒度特征，并获得更有意义的语义信息。之后，我们添加几个卷积层来处理这个特征映射组合，并最终预测出一个相似的、大小是原先两倍的张量。<br>我们用同样的网络设计来预测边界框的最终尺寸，这个过程其实也有助于分类预测，因为我们可以从早期图像中筛选出更精细的特征。</p>
<p>和上一版一样，<strong>YOLOv3使用的聚类方法还是K-Means，它能用来确定边界框的先验</strong>。在实验中，我们选择了<strong>9个聚类和3个尺寸</strong>，然后<strong>在不同尺寸的边界框上均匀分割维度聚类</strong>。在COCO数据集上，这9个聚类分别是：(10×13)、(16×30)、(33×23)、(30×61)、(62×45)、(59×119)、(116 × 90)、(156 × 198)、(373 × 326)。</p>
<h2 id="2-4-特征提取器"><a href="#2-4-特征提取器" class="headerlink" title="2.4 特征提取器"></a>2.4 特征提取器</h2><p>这次我们用了一个新的网络来提取特征，它融合了YOLOv2、Darknet-19以及其他新型残差网络，由连续的3×3和1×1卷积层组合而成，当然，其中也添加了一些shortcut connection，整体体量也更大。因为一共有53个卷积层，所以我们称它为……别急哦…… <strong>Darknet-53</strong>！<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703190743849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>这个新型网络在性能上远超Darknet-19，但在效率上同样优于ResNet-101和ResNet-152。下表是在ImageNet上的实验结果：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703190800188.png"><br>每个网络都使用相同的设置进行训练，输入256×256的图片，并进行单精度测试。运行环境为Titan X。我们得出的结论是Darknet-53在精度上可以与最先进的分类器相媲美，同时它的浮点运算更少，速度也更快。和ResNet-101相比，Darknet-53的速度是前者的1.5倍；而ResNet-152和它性能相似，但用时却是它的2倍以上。</p>
<p>Darknet-53也可以实现每秒最高的测量浮点运算。这意味着网络结构可以更好地利用GPU，使其预测效率更高，速度更快。这主要是因为ResNets的层数太多，效率不高。</p>
<h2 id="2-5-训练"><a href="#2-5-训练" class="headerlink" title="2.5 训练"></a>2.5 训练</h2><p>我们只是输入完整的图像，并没有做其他处理。实验过程中涉及的多尺寸训练、大量数据增强和batch normalization等操作均符合标准。模型训练和测试的框架是Darknet神经网络。</p>
<h1 id="3-我们做了什么"><a href="#3-我们做了什么" class="headerlink" title="3.我们做了什么"></a>3.我们做了什么</h1><p>YOLOv3的表现非常好！请参见表3，就COCO奇怪的平均mAP成绩而言，它与SSD变体相当，但速度提高了3倍。尽管如此，它仍然比像RetinaNet这样的模型要差一点。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703190922841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>如果仔细看这个表，我们可以发现在IOU=.5（即表中的AP50）时，YOLOv3非常强大。它几乎与RetinaNet相当，并且远高于SSD变体。这就证明了它其实是一款非常灵活的检测器，擅长为检测对象生成合适的边界框。然而，随着IOU阈值增加，YOLOv3的性能开始同步下降，这时它预测的边界框就不能做到完美对齐了。</p>
<p>在过去，YOLO一直被用于小型对象检测。但现在我们可以预见其中的演变趋势，随着新的多尺寸预测功能上线，YOLOv3将具备更高的APS性能。但是它目前在中等尺寸或大尺寸物体上的表现还相对较差，仍需进一步的完善。</p>
<p>当我们基于AP50指标绘制精度和速度时（见图3），我们发现YOLOv3与其他检测系统相比具有显着优势。也就是说，它的速度正在越来越快。</p>
<h1 id="4-失败的尝试"><a href="#4-失败的尝试" class="headerlink" title="4.失败的尝试"></a>4.失败的尝试</h1><p>我们在研究YOLOv3时尝试了很多东西，以下是我们还记得的一些失败案例。</p>
<p>Anchor box坐标的偏移预测。我们尝试了常规的Anchor box预测方法，比如利用线性激活将坐标x、y的偏移程度预测为边界框宽度或高度的倍数。但我们发现这种做法降低了模型的稳定性，且效果不佳。</p>
<p>用线性方法预测x,y，而不是使用逻辑方法。我们尝试使用线性激活来直接预测x，y的offset，而不是逻辑激活。这降低了mAP成绩。</p>
<p>focal loss。我们尝试使用focal loss，但它使我们的mAP降低了2点。 对于focal loss函数试图解决的问题，YOLOv3从理论上来说已经很强大了，因为它具有单独的对象预测和条件类别预测。因此，对于大多数例子来说，类别预测没有损失？或者其他的东西？我们并不完全确定。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703192252867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">双IOU阈值和真值分配。在训练期间，Faster RCNN用了两个IOU阈值，如果预测的边框与.7的ground truth重合，那它是个正面的结果；如果在[.3—.7]之间，则忽略；如果和.3的ground truth重合，那它就是个负面的结果。我们尝试了这种思路，但效果并不好。</p>
<p>我们对现在的更新状况很满意，它看起来已经是最佳状态。有些技术可能会产生更好的结果，但我们还需要对它们做一些调整来稳定训练。</p>
<h1 id="5-更新的意义"><a href="#5-更新的意义" class="headerlink" title="5.更新的意义"></a>5.更新的意义</h1><p>YOLOv3是一个很好的检测器，它速度快，精度又高。虽然基于.3和.95的新指标，它在COCO上的成绩不如人意，但对于旧的检测指标.5 IOU，它还是非常不错的。</p>
<p>所以为什么我们要改变指标呢？最初的COCO论文里只有这样一句含糊其词的话：一旦评估完成，就会生成评估指标结果。Russakovsky等人曾经有一份报告，说人类很难区分.3与.5的IOU：“训练人们用肉眼区别IOU值为0.3的边界框和0.5的边界框是一件非常困难的事”。[16]如果人类都难以区分这种差异，那这个指标有多重要？</p>
<p>但也许更好的一个问题是：现在我们有了这些检测器，我们能用它们来干嘛？很多从事这方面研究的人都受雇于Google和Facebook，我想至少我们知道如果这项技术发展得完善，那他们绝对不会把它用来收集你的个人信息然后卖给……等等，你把事实说出来了！！哦哦。</p>
<p>那么其他巨资资助计算机视觉研究的人还有军方，他们从来没有做过任何可怕的事情，比如用新技术杀死很多人……呸呸呸</p>
<p>我有很多希望！我希望大多数人会把计算机视觉技术用于快乐的、幸福的事情上，比如计算国家公园里斑马的数量[11]，或者追踪小区附近到底有多少猫[17]。但是计算机视觉技术的应用已经步入歧途了，作为研究人员，我们有责任思考自己的工作可能带给社会的危害，并考虑怎么减轻这种危害。我们非常珍惜这个世界。</p>
<p>就是翻译一遍，没看太懂</p>
<p>YOLOv3论文：<a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" target="_blank" rel="noopener">https://pjreddie.com/media/files/papers/YOLOv3.pdf</a><br>参考：<a href="https://blog.csdn.net/leviopku/article/details/82660381" target="_blank" rel="noopener">https://blog.csdn.net/leviopku/article/details/82660381</a><br>YOLO官网： <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">https://pjreddie.com/darknet/yolo/</a><br>tensorflow的实现代码：<a href="https://github.com/wizyoung/YOLOv3_TensorFlow" target="_blank" rel="noopener">https://github.com/wizyoung/YOLOv3_TensorFlow</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>yolo v2 论文笔记</title>
    <url>/2019/07/03/yolo-v2-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>YOLO9000，一个最先进的，实时目标检测系统，可以检测超过9000个目标类别。<br>YOLOv2模型可以运行在不同的大小的图片上，提供速度和精度之间的轻松权衡<br>提出了一种联合训练目标检测和分类的方法。在COCO检测数据集和ImageNet分类数据集上同时训练YOLO9000，联合训练方法允许YOLO9000预测没有标记检测数据的目标类的检测，在ImageNet检测数据集上验证我们的方法</p><a id="more"></a>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><ol>
<li>与分类和标记等其他任务的数据集相比，当前目标检测数据集是有限的。希望检测可以缩放到目标分类的级别。然而，用于检测的标记图像比用于分类或标记的标记</li>
<li>提出了一种新方法来利用我们已经拥有的大量分类数据，并使用它来扩大当前检测系统的范围。方法使用目标分类的层次视图，允许我们将不同的数据集合在一起。 </li>
<li>提出了联合训练算法，允许我们在检测和分类数据上训练目标检测器方法利用标记的检测图像来学习精确地定位目标，同时使用分类图像来增加其词汇和鲁棒性。<br>所有代码和预训练模型都可以在 <a href="http://pjreddie.com/yolo9000/" target="_blank" rel="noopener">http://pjreddie.com/yolo9000/</a> <h1 id="2-Better"><a href="#2-Better" class="headerlink" title="2. Better"></a>2. Better</h1>与fast RCNN相比，YOLO的误差分析显示YOLO产生大量的定位误差，与基于候选区域的方法相比，YOLO具有相对较低的召回率率</li>
<li>Batch Normalization<br>通过在YOLO v1中的所有卷积层上增加batch normalization，mAP可提高2％，批标准化可以显着改善收敛性，同时不需要其他形式的正则化，即可删除dropout操作而不会产生过拟合。</li>
<li><p>High Resolution Classifier </p>
<p>YOLO v1首先以224×224分辨率训练的网络参数预训练网络，然后将输入图像分辨率resize到448x448以进行检测。这意味着网络必须首先学习调整到新的输入分辨率（448），将影响学习效果。<br>YOLO v2首先对分类网络（自定义的darknet）进行了finetune，分辨率改成448 * 448，在ImageNet数据集上训练10轮（10 epochs），训练后的网络就可以适应高分辨率的输入了<br>对检测网络部分（也就是后半部分）也进行finetune。这样通过提升输入的分辨率，mAP获得了4%的提升</p>
</li>
<li><p>Convolutional With Anchor Boxes<br>YOLO v1直接使用卷积特征提取器顶部的全连接层来预测边界框的坐标。<br>YOLO v2移除全连接层，并引用anchor boxes来预测边界框。首先，删除一个池化层，以使网络卷积层的输出具有更高的分辨率。另外，缩小输入图像为416x416，而不是448×448。此做法可使卷积特征图宽高都为奇数，保证只有一个中心网格单元。这是因为考虑到图片中的目标往往占据图像的中心，所以最好在中心拥有一个位置来预测这些目标，而不是利用四个位置来预测。YOLOv2使用了卷积层降采样（factor为32），使得输入卷积网络的416 <em> 416图片最终得到13 </em> 13的卷积特征图（416/32=13）。<br>YOLO v1，每个网格都预测2个boxes，每个boxes包含5个值，前4个值是预测框相对于网格左上角的偏移量和预测框相对于整个特征图的比例，第5个值是置信度。但是每个网格只预测一套分类概率值，供2个boxes共享。<br>YOLO v2利用anchor boxes，使得每个位置的各个anchor box都单独预测一套分类概率值。另外，使用anchor boxes，会使得精确度的小幅下降。如果没有anchor boxes，具体数据为：没有anchor boxes，模型recall为81%，mAP为69.5%；加入anchor boxes，模型recall为88%，mAP为69.2%。说明可以通过进一步的工作来加强准确率，的确有改进空间。 </p>
</li>
<li>Dimension Clusters<br>作者使用了K-means聚类方法类训练bounding boxes，可以自动找到更好的boxes宽高维度。传统的K-means聚类方法使用的是欧氏距离函数，也就意味着较大的boxes会比较小的boxes产生更多的error，聚类结果可能会偏离。<br>采用的评判标准是IOU得分（boxes之间的交集除以并集），error就和box的尺度无关了，距离函数为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703133347276.png"> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703150159436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">作者实验发现，5种boxes的Avg IOU(61.0)就和Faster R-CNN的9种Avg IOU(60.9)相当。 说明K-means方法的生成的boxes更具有代表性。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703151248477.png"></li>
<li><p>Direct location prediction<br>在YOLO模型上采用anchor boxes的第二个关键是模型不稳定性，作者认为这种不稳定主要来自预测box的(x,y)值，基于region proposal的object detection算法中，是通过预测下图中的tx和ty来得到(x,y)值<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703152304753.png"><br>在faster rcnn中,anchor的预测公式:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703152735884.png"><br>把上面的公式变形可得：</p>
<script type="math/tex; mode=display">x=(t_x∗w_a)−x_a\\
y=(t_y∗h_a)−y_a</script><p>这个公式的理解为：当预测tx=1，就会把box向右边移动一定距离（具体为anchor box的宽度），预测 tx=−1，就会把box向左边移动相同的距离</p>
<p>神经网络在特征图（13 <em>13 ）的每个cell上预测5个bounding boxe，同时每一个bounding box预测5个坐值，分别为$t_x,t_y,t_w,t_h,t_o$，其中前四个是坐标，$t_o$是置信度。如果这个cell距离图像左上角的边距为$(c_x,c_y)$以及该cell对应box（bounding box prior）的长和宽分别为$(p_w,p_h)$，那么预测值可以表示为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703153812571.png"> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703154148223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>定位预测值被归一化后，参数就更容易得到学习，模型就更稳定,通过使用 <strong>维度聚类</strong> 和 <em>*直接位置预测</em></em> 这两项Anchor Boxes改进方法，将 mAP 提高了5%</p>
</li>
<li><p>Fine-Grained Features（细粒度特征）<br>改进后的YOLO对13×13的feature map进行目标检测。更精确的特征（finer grained features）可以提高对于小目标的检测。Faster R-CNN和SSD都在网络的各种特征映射上运行他们提出的网络，以获得一系列的分辨率。我们采用不同的方法，仅仅添加一个通道层，从26x26分辨率的更早层中提取特征。</p>
<p> 传递层通过将相邻特征堆叠到不同的通道而不是堆叠到空间位置，将较高分辨率特征与低分辨率特征相连，类似于ResNet中的标识映射。YOLO v2 使用扩展后的的特征图（add passthrough），将mAP提高了了1%。</p>
</li>
<li>Multi-Scale Training（多尺度训练）<br>之前Yolo v1的固定图片输入大小为448x448，而Yolo v2因为Anchor box的引入从而将输入变为了416x416。进一步为了使得模型能够对各种尺度的图片进行有效检测，作者在训练Yolo v2时不再固定image size，而是每训练10个epochs随机地从一个组合{320; 352; :::; 608}中选取（注意它们都是32的倍数，因为darknet网络的步长为32）一个数作为输入的image size。此种训练方法被证明可有效地使得网络学会去自动识别各种尺度大小的图片。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703160315602.png"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703160425691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">  <h1 id="3-Faster"><a href="#3-Faster" class="headerlink" title="3. Faster"></a>3. Faster</h1></li>
<li><p>大多数检测网络有赖于VGG-16作为特征提取部分，VGG-16的确是一个强大而准确的分类网络，但是复杂度有些冗余。224 * 224的图片进行一次前向传播，其卷积层就需要多达306.9亿次浮点数运算。</p>
</li>
<li><p>YOLOv2使用的是基于Googlenet的定制网络，比VGG-16更快，一次前向传播仅需85.2亿次运算。可是它的精度要略低于VGG-16，单张224 * 224取前五个预测概率的对比成绩为88%和90%（低一点点也是可以接受的）</p>
</li>
<li><strong>Darknet-19</strong><br>Yolo v2还采用了有着19个Conv 层与5个maxpooling层的darknet-19作为模型的特征提取前端网络。在此网络中引入了BN用于稳定训练，加快收敛，同时防止模型过拟合</li>
</ol>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703160918222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">   </p>
<ol>
<li><p><strong>Training for classiﬁcation</strong><br>1）采用随机梯度下降法SGD，在 ImageNet-1000分类数据集 上训练了160个epochs，参数设定：<br>初始学习率 - starting learning rate：0.1<br>多项式速率衰减 - polynomial rate decay：4的幂次<br>权值衰减 - weight decay：0.0005<br>动量 - momentum：0.9</p>
<p>2）数据增广方法（Data augmentation）<br>采用了常见的data augmentation，包括：<br>随机裁剪、旋转 - random crops、rotations<br>色调、饱和度、曝光偏移 - hue、saturation、exposure shifts</p>
<p> 3）多分辨率训练<br>通过初始的224 <em> 224训练后，把分辨率上调到了448 </em> 448，同样的参数又训练了10个epochs，然后将学习率调整到了10^{-3}。</p>
</li>
</ol>
<ol>
<li><strong>Training for detection</strong><br>把分类网络改成检测网络，去掉原网络最后一个卷积层，增加了三个 3 <em> 3 （1024 ﬁlters）的卷积层，并且在每一个卷积层后面跟一个1 </em> 1的卷积层，输出个数是检测所需要的数量。<br>初始学习率为10^{-3}，训练了160个epochs（划分为60 | 10 | 90），权值衰减 与 momentum参数与前面一样。</li>
</ol>
<h1 id="4-Stronger"><a href="#4-Stronger" class="headerlink" title="4. Stronger"></a>4. Stronger</h1><p>使用联合训练方法，结合wordtree等方法，使YOLOv2的检测种类扩充到了上千种<br>不太懂，待写！！！</p>
<h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h1><ol>
<li>介绍了YOLOv2和YOLO9000，两个实时检测系统。YOLOv2在各种检测数据集上都是最先进的，也比其他检测系统更快。此外，它可以运行在各种图像大小，以提供速度和准确性之间的平滑折衷</li>
<li>YOLO9000是一个通过联合优化检测和分类来检测9000多个目标类别的实时框架。我们使用WordTree将各种来源的数据和我们的联合优化技术相结合，在ImageNet和COCO上同时进行训练。YOLO9000是在检测和分类之间缩小数据集大小差距的重要一步</li>
</ol>
<p>论文地址：<a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">https://arxiv.org/abs/1612.08242</a><br>参考：<a href="https://blog.csdn.net/oppo62258801/article/details/76796717" target="_blank" rel="noopener">https://blog.csdn.net/oppo62258801/article/details/76796717</a><br>    <a href="https://blog.csdn.net/lanran2/article/details/82826045" target="_blank" rel="noopener">https://blog.csdn.net/lanran2/article/details/82826045</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>yolo v1 论文笔记</title>
    <url>/2019/07/02/yolo-v1-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目标检测比较流行的算法可以分为两类</p><ul>
<li>基于Region Proposal的R-CNN系算法（R-CNN，Fast R-CNN, Faster R-CNN），它们是two-stage的，需要先使用启发式方法（selective search）或者CNN网络（RPN）产生Region Proposal，然后再在Region Proposal上做分类与回归。准确度高一些，但是速度慢</li>
<li>Yolo，SSD这类one-stage算法，其仅仅使用一个CNN网络直接预测不同目标的类别与位置。算法是速度快，但是准确性要低一些</li>
</ul><a id="more"></a>

<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ol>
<li>YOLO之前的物体检测方法主要是通过region proposal产生大量的可能包含待检测物体的 potential bounding box，再用分类器去判断每个 bounding box里是否包含有物体，以及物体所属类别的 probability或者 confidence，如R-CNN,Fast-R-CNN,Faster-R-CNN等</li>
<li>YOLO将物体检测任务当做一个regression问题来处理，使用一个神经网络，直接从一整张图像来预测出bounding box 的坐标、box中包含物体的置信度和物体的probabilities。YOLO的物体检测流程是在一个神经网络里完成的，所以可以end to end来优化物体检测性能</li>
</ol>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190702210450261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>YOLO非常简单：参见上图，单个卷积网络可同时预测多个边界框和这些盒的类概率.YOLO训练全图像并直接优化检测性能。<br>YOLO模型相对于之前的物体检测方法有多个优点： </p>
<ul>
<li>YOLO检测物体非常快。 没有复杂的检测流程，只需要将图像输入到神经网络就可以得到检测结果</li>
<li>基于图像的全局信息预测，与Fast R-cnn相比，在误检测方面的错误率降低很多</li>
<li>YOLO可以学到物体的泛化特征。 当YOLO在自然图像上做训练，在艺术作品上做测试时，YOLO表现的性能比DPM、R-CNN等之前的物体检测系统要好很多</li>
</ul>
<h1 id="2-Uniﬁed-Detection"><a href="#2-Uniﬁed-Detection" class="headerlink" title="2.Uniﬁed Detection"></a>2.Uniﬁed Detection</h1><ol>
<li><p>YOLO将输入图像划分为S*S的栅格，每一个栅格预测B个bounding boxes以及这些bounding boxes的confidence scores<br>confidence scores 代表了所预测的 box 中含有 object 的置信度和这个 box 预测的有多准</p>
<script type="math/tex; mode=display">P_{r}(Object) ∗ IOU ^{truth}
_{pred}</script><p>如果有 object 落在一个 grid cell 里，第一项取 1，否则取 0。 第二项是预测的 bounding box 和实际的 groundtruth 之间的 IoU 值</p>
<ul>
<li>每个 bounding box 要预测 (x, y, w, h) 和confidence 共5个值<ul>
<li>坐标x,y代表了预测的bounding box的中心与栅格边界的相对值。</li>
</ul>
</li>
<li>坐标w,h代表了预测的bounding box的width、height相对于整幅图像width,height的比例</li>
<li>confidence就是预测的predicted box和ground truth 的IOU值</li>
<li>每一个栅格还要预测C个conditional class probability（条件类别概率）：Pr(Classi|Object)。即在一个栅格包含一个Object的前提下，它属于某个类的概率</li>
</ul>
<ol>
<li><p>把条件类概率和每个框的预测的置信度值相乘，</p>
<script type="math/tex; mode=display">P_r(Class i |Object) * P_r(Object) * IOU ^{truth}_{pred} = P_r(Class i ) * IOU^{truth}_{pred}</script><p>它给出了每个框特定类别的置信度分数。这些分数体现了该类出现在框中的概率以及预测框拟合目标的程度。<br>为了在Pascal VOC上评估YOLO，我们使用S=7，B=2。Pascal VOC有20个标注类，所以C=20。我们最终的预测是7×7×30的张量。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019070221484386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="2-1-Network-Design"><a href="#2-1-Network-Design" class="headerlink" title="2.1. Network Design"></a>2.1. Network Design</h2></li>
<li><p>在Pascal VOC检测数据集[上进行评估,网络的初始卷积层从图像中提取特征，而全连接层负责预测输出概率和坐标。</p>
</li>
</ol>
</li>
<li>网络架构受图像分类模型GoogLeNet的启发,有24个卷积层，后面是2个全连接层,只使用1×1降维层，后面是3×3卷积层，而不是GoogLeNet使用的Inception模块。<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190702215357168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><h2 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2. 训练"></a>2.2. 训练</h2></li>
<li>首先在ImageNet 1000-classcompetition dataset训练网络的前20层，外加一层average-pooling layer和一层fully connected layer。经过一个星期时间的训练。 在imageNet 2012上Top 5的训练精度达到88%。</li>
<li>预训练网络中增加卷积层和连接层可以提高性能，将训练好的模型去掉最后的 average-pooling layer和fully connected layer。然后加上原来的四层conv layer和fully connected layer。在psiacl voc2007上进行检测网络的训练，训练的图像尺寸也由224 <em>224变为448 </em>448，最终的输出结果包含类别概率和物体坐标信息（X,Y,W,H）,对width和height进行归一化处理，使其值位于0-1之间</li>
<li>模型的最后一层使用线性激活函数，而所有其它的层使用下面的leaky rectified activation：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703091912393.png"></li>
<li><strong>损失函数</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190703092512198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
</ol>
<ul>
<li>误差使用平方和的形式，增加了边界框坐标预测的损失，并减少了不包含目标的框的置信度预测的损失，使用两个参数λcoord和λnoobj来实现这一点<br>对于不同大小的物体来说，预测的偏差对坐标误差的影响是不一样的，例如同样的预测偏差，对于大物体的影响要小于小物体。在计算坐标误差的时候不是使用预测的width和height，而是使用它们的平方根，以削弱这一影响</li>
<li>其中 $1_i^{obj}$表示目标是否出现在网格单元i中, $1_{ij}^{obj}$ 表示单元格i中的第j个边界框预测器“负责”该预测.注意，如果目标存在于该网格单元中（前面讨论的条件类别概率），则损失函数仅惩罚分类错误。如果预测器“负责”实际边界框（即该网格单元中具有最高IOU的预测器），则它也仅惩罚边界框坐标错误。</li>
<li>为避免过拟合，我们使用了Dropout和大量的数据增强. 在第一个连接层之后的dropout层的丢弃率设置为0.5，以防止层之间的相互适应。 对于数据增强，我们引入高达20％的原始图像大小的随机缩放和平移。我们还在HSV色彩空间中以高达1.5的因子随机调整图像的曝光度和饱和度.<h2 id="2-3-推断"><a href="#2-3-推断" class="headerlink" title="2.3. 推断"></a>2.3. 推断</h2>就像在训练中一样，预测测试图像的检测只需要一次网络评估</li>
</ul>
<p>Deformable parts models.可变形部分模型（DPM）使用滑动窗口方法进行目标检测[10]。DPM使用不相交的流程来提取静态特征，对区域进行分类，预测高评分区域的边界框等</p>
<h2 id="2-4-YOLO的限制"><a href="#2-4-YOLO的限制" class="headerlink" title="2.4. YOLO的限制"></a>2.4. YOLO的限制</h2><ul>
<li>YOLO 对相互靠的很近的物体，还有很小的群体检测效果不好，这是因为一个网格中只预测了两个框，并且只属于一类。</li>
<li>模型学习是从数据中预测边界框，因此它很难泛化到新的、不常见的长宽比或配置的目标。</li>
<li>由于损失函数的问题，定位误差是影响检测效果的主要原因。尤其是大小物体的处理上，还有待加强。</li>
</ul>
<p>论文原文：<a href="https://arxiv.org/pdf/1506.02640.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1506.02640.pdf</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/35416826" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35416826</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>CV学习资料</title>
    <url>/2019/06/19/CV%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>链接：<br><a href="https://github.com/scutan90/DeepLearning-500-questions/blob/master/ch08_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B.md" target="_blank" rel="noopener">DeepLearning-500-questions</a><br><a href="https://github.com/SnailTyan/deep-learning-papers-translation" target="_blank" rel="noopener">Deep Learning Papers Translation(CV)</a><br><a href="http://www.cvlibs.net/datasets/kitti/eval_object.php?obj_benchmark=2d" target="_blank" rel="noopener">KITTI数据集地址</a><br><a href="https://blog.csdn.net/xiao_lxl/article/details/90521163" target="_blank" rel="noopener">目标检测、深度估计、无人驾驶 papers最新论文算法笔记</a><br><a href="https://blog.csdn.net/ShuqiaoS/article/details/87360693" target="_blank" rel="noopener">语义分割综述——一文搞定语义分割</a><br>CV方面的各种大神：<a href="https://blog.csdn.net/u013524655/article/details/41383293" target="_blank" rel="noopener">https://blog.csdn.net/u013524655/article/details/41383293</a><br>YOLO系列之yolo v1： <a href="https://blog.csdn.net/leviopku/article/details/82588059" target="_blank" rel="noopener">https://blog.csdn.net/leviopku/article/details/82588059</a><br>YOLO系列之yolo v2：<a href="https://blog.csdn.net/leviopku/article/details/82588959" target="_blank" rel="noopener">https://blog.csdn.net/leviopku/article/details/82588959</a><br>yolo系列介绍好文章：<a href="https://www.cnblogs.com/makefile/p/YOLOv3.html" target="_blank" rel="noopener">https://www.cnblogs.com/makefile/p/YOLOv3.html</a><br>YOLOv3_TensorFlow：<a href="https://github.com/wizyoung/YOLOv3_TensorFlow" target="_blank" rel="noopener">https://github.com/wizyoung/YOLOv3_TensorFlow</a><br>YOLOv3目标检测有了TensorFlow实现，可用自己的数据来训练：<a href="http://www.imooc.com/article/274312" target="_blank" rel="noopener">http://www.imooc.com/article/274312</a><br>CV方面的各种大神：<a href="https://blog.csdn.net/u013524655/article/details/41383293" target="_blank" rel="noopener">https://blog.csdn.net/u013524655/article/details/41383293</a><br><a href="https://www.aiuai.cn/page/2/" target="_blank" rel="noopener">https://www.aiuai.cn/page/2/</a><ul>
<li>里程碑式的文献<br>深度学习做目标检测，RCNN、Fast RCNN、Fater RCNN、SPPNET、SSD和YOLO等模型；又例如，深度学习做目标跟踪，DLT、SO-DLT等等；再例如，对抗网络GAN、CGAN、DCGAN、LAPGAN等等<br><a href="https://arxiv.org/list/cs.CV/recent" target="_blank" rel="noopener">https://arxiv.org/list/cs.CV/recent</a></li>
</ul>
</li>
<li>计算视觉的顶会<br>  ICCV：国际计算机视觉大会<br>  CVPR：国际计算机视觉与模式识别大会<br>  ECCV：欧洲计算机视觉大会</li>
<li>计算机视觉的顶刊<br>  PAMI：IEEE 模式分析与机器智能杂志<br>  IJCV：国际计算机视觉杂志</li>
</ul><a id="more"></a>
<ul>
<li>YOLO官网： <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">https://pjreddie.com/darknet/yolo/</a></li>
<li>论文链接：<br>daily-paper-computer-vision：<a href="https://github.com/amusi/daily-paper-computer-vision" target="_blank" rel="noopener">https://github.com/amusi/daily-paper-computer-vision</a><br>Object Detection：<a href="https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html" target="_blank" rel="noopener">https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html</a><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190706102438276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
<li>目标检测论文整理：<a href="https://www.cnblogs.com/yhyue/p/9247962.html" target="_blank" rel="noopener">https://www.cnblogs.com/yhyue/p/9247962.html</a><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190706102513697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
<li>各类目标检测论文：<a href="https://blog.csdn.net/disen10/article/details/79713634" target="_blank" rel="noopener">https://blog.csdn.net/disen10/article/details/79713634</a><br><a href="https://github.com/amusi/awesome-object-detection" target="_blank" rel="noopener">object-detection</a><br><a href="https://blog.csdn.net/Fire_to_cheat_/article/details/88793509" target="_blank" rel="noopener">（目标检测）Faster R-CNN 论文解读+复现</a></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>词袋模型Bag-of-Words(BoW)</title>
    <url>/2019/06/19/%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8BBag-of-Words-BoW/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="词袋模型"><a href="#词袋模型" class="headerlink" title="词袋模型"></a>词袋模型</h1><p>词袋模型（Bag-of-Words，BoW）把特征当成一个个单词，通过比较两张图片中出现的单词是否一致，来判断这两张图片是否是同一场景。</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826195725181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>使用一种 k 叉树来表达字典。它的思路很简单,类似于层次聚类,是 k-means 的直接扩展。假定我们有 N个特征点,希望构建一个深度为 d,每次分叉为 k 的树,那么做法如下:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826195901841.png#pic_center"><br>最终在叶子层构建了单词,而树结构中的中间节点仅供快速查找时使用。这样一个 k 分支,深度为 d 的树,可以容纳 k d 个单词。另一方面,在查找某个给定特征对应的单词时,只需将它与每个中间结点的聚类中心比较(一共 d 次),即可找到最后的单词,保证了对数级别的查找效率。</p><a id="more"></a>

<h1 id="实践-创建字典"><a href="#实践-创建字典" class="headerlink" title="实践:创建字典"></a>实践:创建字典</h1><p><strong>训练字典</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment"> * 本节演示了如何根据data/目录下的十张图训练字典</span></span><br><span class="line"><span class="comment"> * ************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read the image </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reading images... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; images; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">"/home/xiaohu/slambook-master/ch12/data/"</span>+to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>;</span><br><span class="line">        images.push_back( imread(path) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// detect ORB features</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"detecting ORB features ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Ptr&lt; Feature2D &gt; detector = ORB::create();</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; descriptors;</span><br><span class="line">    <span class="keyword">for</span> ( Mat&amp; image:images )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints; </span><br><span class="line">        Mat descriptor;</span><br><span class="line">        detector-&gt;detectAndCompute( image, Mat(), keypoints, descriptor );</span><br><span class="line">        descriptors.push_back( descriptor );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create vocabulary </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"creating vocabulary ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    DBoW3::Vocabulary vocab;</span><br><span class="line">    vocab.create( descriptors );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"vocabulary info: "</span>&lt;&lt;vocab&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    vocab.save( <span class="string">"vocabulary.yml.gz"</span> );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"done"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对十张目标图像提取 ORB 特征并存放至 vector容器中,然后调用 DBoW3 的字典生成接口即可。在 DBoW3::Vocabulary 对象的构造函数中,我们能够指定树的分叉数量以及深度,不过这里使用了默认构造函数,也就是 k =10, d = 5。这是一个小规模的字典,最大能容纳 10000 个单词。对于图像特征,我们亦使<br>用默认参数,即每张图像 500 个特征点。最后我们把字典存储为一个压缩文件。</p>
<h1 id="相似度"><a href="#相似度" class="headerlink" title="相似度"></a>相似度</h1><p><strong>TF-IDF（Term Frequency / Inverse Document Frequency，译频率-逆文本频率）</strong><br>TF 部分的思想是,某单词在一个图像中经常出现,它的区分度就高。另一方面,IDF 的思想是,某单词在字典中出现的频率越低,则分类图像时区分度越高。</p>
<p>在词袋模型中,在建立字典时可以考虑 IDF 部分。统计某个叶子节点 $w _i$中的特<br>征数量相对于所有特征数量的比例,作为 IDF 部分。假设所有特征数量为 n,$w_i$ 数量为$n_i$ ,那么该单词的 IDF 为:.<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826205649506.png#pic_center"><br>TF 部分则是指某个特征在单个图像中出现的频率。假设图像 A 中,单词$w_ i$ 出现了 $n_i$ 次,而一共出现的单词次数为 n,那么 TF 为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826205805881.png#pic_center"><br>于是$w_ i$ 的权重等于 TF 乘 IDF 之积:<br>考虑权重以后,对于某个图像 A,它的特征点可对应到许多个单词,组成它的 Bag-of-Words:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190826212553385.png#pic_center"><br>单个向量$v_A$描述了一个图像 A。这个向量$v_A$是一个稀疏的向量,它的非零部分指示出图像 A 中含有哪些单词</p>
<p><strong>计算相似度</strong><br>L 1 范数形式:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019082621295470.png#pic_center"><br><strong>相似性评分的处理</strong>：<br>取一个先验相似度 $s(v_t , v_{t−∆t})$,它表示某时刻关键帧图像与上一时刻的关键帧的相似性。然后,其他的分值都参照这个值进行归一化:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827105320222.png#pic_center"><br>如果当前帧与之前某关键帧的相似度,超过当前帧与上一个关键帧相似度的 3 倍,就认为可能存在回环。这个步骤避免了引入绝对的相似性阈值，使得算法能够适应更多的环境。</p>
<h1 id="实践-相似度的计算"><a href="#实践-相似度的计算" class="headerlink" title="实践:相似度的计算"></a>实践:相似度的计算</h1><p>使用此字典,演示了两种比对方式:图像之间的直接比较以及图像与数据库之间的比较，生成 Bag-of-Words 并比较它们的差异</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DBoW3/DBoW3.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment"> * 本节演示了如何根据前面训练的字典计算相似性评分</span></span><br><span class="line"><span class="comment"> * ************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read the images and database  </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reading database"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//DBoW3::Vocabulary vocab("./vocabulary.yml.gz");</span></span><br><span class="line">    DBoW3::<span class="function">Vocabulary <span class="title">vocab</span><span class="params">(<span class="string">"/home/xiaohu/slambook-master/ch12/vocab_larger.yml.gz"</span>)</span></span>;  <span class="comment">// use large vocab if you want: </span></span><br><span class="line">    <span class="keyword">if</span> ( vocab.empty() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"Vocabulary does not exist."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reading images... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; images; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">"/home/xiaohu/slambook-master/ch12/data/"</span>+to_string(i+<span class="number">1</span>)+<span class="string">".png"</span>;</span><br><span class="line">        images.push_back( imread(path) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> in this case we are comparing images with a vocabulary generated by themselves, this may leed to overfitting.  </span></span><br><span class="line">    <span class="comment">// detect ORB features</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"detecting ORB features ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Ptr&lt; Feature2D &gt; detector = ORB::create();</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; descriptors;</span><br><span class="line">    <span class="keyword">for</span> ( Mat&amp; image:images )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints; </span><br><span class="line">        Mat descriptor;</span><br><span class="line">        detector-&gt;detectAndCompute( image, Mat(), keypoints, descriptor );</span><br><span class="line">        descriptors.push_back( descriptor );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// we can compare the images directly or we can compare one image to a database </span></span><br><span class="line">    <span class="comment">// images :</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"comparing images with images "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;images.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        DBoW3::BowVector v1;</span><br><span class="line">        vocab.transform( descriptors[i], v1 );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j=i; j&lt;images.size(); j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            DBoW3::BowVector v2;</span><br><span class="line">            vocab.transform( descriptors[j], v2 );</span><br><span class="line">            <span class="keyword">double</span> score = vocab.score(v1, v2);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"image "</span>&lt;&lt;i&lt;&lt;<span class="string">" vs image "</span>&lt;&lt;j&lt;&lt;<span class="string">" : "</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// or with database </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"comparing images with database "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    DBoW3::<span class="function">Database <span class="title">db</span><span class="params">( vocab, <span class="literal">false</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;descriptors.size(); i++ )</span><br><span class="line">        db.add(descriptors[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"database info: "</span>&lt;&lt;db&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;descriptors.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        DBoW3::QueryResults ret;</span><br><span class="line">        db.query( descriptors[i], ret, <span class="number">4</span>);      <span class="comment">// max result=4</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"searching for image "</span>&lt;&lt;i&lt;&lt;<span class="string">" returns "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"done."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自行训练字典"><a href="#自行训练字典" class="headerlink" title="自行训练字典"></a>自行训练字典</h1><p>用rgbd_dataset_freiburg1_xyz训练字典<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DBoW3/DBoW3.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> dataset_dir = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span> <span class="params">( dataset_dir+<span class="string">"/associate.txt"</span> )</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( !fin )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"please generate the associate file called associate.txt!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rgb_files, depth_files;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; rgb_times, depth_times;</span><br><span class="line">    <span class="keyword">while</span> ( !fin.eof() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> rgb_time, rgb_file, depth_time, depth_file;</span><br><span class="line">        fin&gt;&gt;rgb_time&gt;&gt;rgb_file&gt;&gt;depth_time&gt;&gt;depth_file;</span><br><span class="line">        rgb_times.push_back ( atof ( rgb_time.c_str() ) );</span><br><span class="line">        depth_times.push_back ( atof ( depth_time.c_str() ) );</span><br><span class="line">        rgb_files.push_back ( dataset_dir+<span class="string">"/"</span>+rgb_file );</span><br><span class="line">        depth_files.push_back ( dataset_dir+<span class="string">"/"</span>+depth_file );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( fin.good() == <span class="literal">false</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"generating features ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; descriptors;</span><br><span class="line">    Ptr&lt; Feature2D &gt; detector = ORB::create();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="built_in">string</span> rgb_file:rgb_files )</span><br><span class="line">    &#123;</span><br><span class="line">        Mat image = imread(rgb_file);</span><br><span class="line">        <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints; </span><br><span class="line">        Mat descriptor;</span><br><span class="line">        detector-&gt;detectAndCompute( image, Mat(), keypoints, descriptor );</span><br><span class="line">        descriptors.push_back( descriptor );</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"extracting features from image "</span> &lt;&lt; index++ &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"extract total "</span>&lt;&lt;descriptors.size()*<span class="number">500</span>&lt;&lt;<span class="string">" features."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create vocabulary </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"creating vocabulary, please wait ... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    DBoW3::Vocabulary vocab;</span><br><span class="line">    vocab.create( descriptors );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"vocabulary info: "</span>&lt;&lt;vocab&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    vocab.save( <span class="string">"vocab_larger_train.yml.gz"</span> );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"done"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">generating features ... </span><br><span class="line">[ INFO:<span class="number">0</span>] Initialize OpenCL runtime...</span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">1</span></span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">2</span></span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">3</span></span><br><span class="line">......</span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">788</span></span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">789</span></span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">790</span></span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">791</span></span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">792</span></span><br><span class="line">extracting features <span class="keyword">from</span> image <span class="number">793</span></span><br><span class="line">extract total <span class="number">396500</span> features.</span><br><span class="line">creating vocabulary, please wait ... </span><br><span class="line">vocabulary info: Vocabulary: k = <span class="number">10</span>, L = <span class="number">5</span>, Weighting = tf-idf, Scoring = L1-norm, Number of words = <span class="number">88334</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>视觉slam十四讲 10.后端１</title>
    <url>/2019/05/28/%E8%A7%86%E8%A7%89slam%E5%8D%81%E5%9B%9B%E8%AE%B2-10-%E5%90%8E%E7%AB%AF%EF%BC%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-状态估计的概率解释"><a href="#1-1-状态估计的概率解释" class="headerlink" title="1.1 状态估计的概率解释"></a>1.1 状态估计的概率解释</h2><p>在后端优化中，我们通常考虑更长的一段时间内的状态估计问题，而且不仅使用过去的信息更新自己的状态，也会用未来的信息更新自己，这种处理方式称为批量的（Batch）。如果当前状态只由过去决定，甚至只由前一个时刻决定，称为渐进的(Incremental)。</p><script type="math/tex; mode=display">x_{k}=f(x_{k−1},μ_{k})+ω_{k}\\      
z_{k,j}=h(y_{j},x_{k})+v_{k,j}</script><a id="more"></a>
<p>注意几点：</p>
<ul>
<li>只有当xk观测到了yi，才会产生观测数据。事实上在一个位置通常只能看到一小部分路标。</li>
<li>在没有运动方程的情况下，整个优化问题就只由许多个观测方程组成，类似于SfM（Structure from Motion）问题，相当于通过一组图像来恢复运动和结构。</li>
</ul>
<h2 id="1-2-线性系统和KF"><a href="#1-2-线性系统和KF" class="headerlink" title="1.2 线性系统和KF"></a>1.2 线性系统和KF</h2><p>当我们假设马尔可夫性。</p>
<script type="math/tex; mode=display">P(x_{k}|x_{k-1},x_{0},u_{1:k},z_{1:k-1}) =  =P(x_{k}|x_{k-1},u_{k})</script><p>预测和更新两个步骤：</p>
<ol>
<li>预测：<script type="math/tex; mode=display">\bar{x}_k=A_k\hat{x}_{k-1}+u_k,\quad\bar{P}_k=A_k\bar{P}_{k-1}A^T_k+R</script><ol>
<li>跟新：先计算K,它又称为卡尔曼增益。<script type="math/tex; mode=display">K=\bar{P}_kC^T_k(C_k\bar{P}_kC^T_k+Q_k)^{-1}</script>然后计算后验概率分布：<script type="math/tex; mode=display">\hat{x}_{k}=\bar{x}_k+K(z_k+K(z_k-C_k\bar{x}_k) \\
\hat{P}_{k}=(I-KC_k)\bar{P}_k\quad\quad\quad\quad\qquad</script></li>
</ol>
</li>
</ol>
<h2 id="1-3-非线性优化和EKF"><a href="#1-3-非线性优化和EKF" class="headerlink" title="1.3 非线性优化和EKF"></a>1.3 非线性优化和EKF</h2><ol>
<li><p>把卡尔曼滤波扩展到非线性系统中，称为卡尔曼滤波器（EKF），通常的做法，在某个点附近考虑运动方程及观测方程的一阶泰勒展开，只保留一阶项，即线性部分，然后按照线性系统进行推到。<br>令k-1时刻的均值和协方差矩阵为$\hat{x}_{k-1},\hat{P}_{k-1}$.在k时刻，把运动方程和观测方程在$\hat{x}_{k-1},\hat{P}_{k-1}$处线性化（相当于一阶泰勒展开），有：</p>
<script type="math/tex; mode=display">x_{k}\approx f(\hat{x}_{k-1},u_k)+\frac{\partial f}{\partial x_{k-1}}|_{\hat{x}_{k-1}}(x_{k-1}-\hat{x}_{k-1})+w_k</script><p>记偏导数：</p>
<script type="math/tex; mode=display">F=\frac{\partial f}{\partial {x}_{k-1}}|_{\hat{x}_{k-1}}</script><p>对于观测方程：</p>
<script type="math/tex; mode=display">z_k\approx h(\bar{x}_k)+\frac{\partial h}{\partial x_k}|_{\bar{x}_k}(x_k-\bar{x}_k)+n_k</script><p>记偏导数：</p>
<script type="math/tex; mode=display">H=\frac{\partial h}{\partial {x}_{k}}|_{\bar{x}_{k}}</script><p>在预测步骤中，根据运动方程有：</p>
<script type="math/tex; mode=display">P(x_k|x_0,u_{1:k},z_{0:k-1})=N(f(\hat{x}_{k-1},u_k),F\hat{P}_{k-1}F^T+R_k)</script><p>记：</p>
<script type="math/tex; mode=display">\bar{x}_k=f(\hat{x}_{k-1},u_k),\qquad\bar{P}_k=F\hat{P}_{k-1}F^T+R_k.</script><p>观测方程有：</p>
<script type="math/tex; mode=display">P(z_k|x_k)=N(h(\bar{x}_k)+H(x_k-\bar{x}_k),Q_k)</script><p>卡尔曼增益$K_k$:</p>
<script type="math/tex; mode=display">K_k=\bar{P}_kH^T(h\bar{P}_k H^T+Q_k)^{-1}</script><p>后验概率的形式：</p>
<script type="math/tex; mode=display">\hat{x}_k=\bar{x}_k+K_k(z_k-h(\bar{x}_k)),\hat{P}_k=(I-K_kH)\bar{P}_k</script><p>在线性系统和高斯噪声下，卡尔曼滤波给出了最优无偏估计。<br>在SLAM这种非线性的情况下，给出了单次线性近似的最大后验估计（MPA)。</p>
</li>
<li><p>EKF的局限性 ：</p>
<ol>
<li>滤波器方法一定程度上假设了马尔可夫性，也就是k时刻的状态只与k-1时刻相关，而与k-1之前的状态和观测都无关。如果当前帧确实与很久之前的数据有关（例如回环），那么滤波器就会很难处理。<ol>
<li>EKF滤波器仅在$X_{k-1}$处做了一次线性化，然后根据这次线性化结果，把后概率给算出来。这默认该点处的线性化近似在后概率处仍然是有效的。而实际上，当我们离工作点较远时，一阶泰勒展开与整个函数区别其实很大。</li>
<li>EKF需要对存储状态量的均值和方差，并对它们进行维护和更新。如果把路标也放进状态，由于视觉slam中路标数量很大，这个存储量相当可观，且与状态量呈平方增长，因此EKF SLAM普遍认为不适合大型场景。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="2-BA与图优化"><a href="#2-BA与图优化" class="headerlink" title="2 BA与图优化"></a>2 BA与图优化</h1><p>Bundle Adjustment，是指从视觉重建中提取出最优的3D模型和相机参数（内参数和外参数）。从每一个特征点反射出来的几束光线，在我们把相机姿态和特征点空间位置做出最优的调整之后，最后收束到相机光心的这个过程。在图优化框架的视觉slam算法<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190715181910361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="2-1-投影模型和BA代价函数"><a href="#2-1-投影模型和BA代价函数" class="headerlink" title="2.1 投影模型和BA代价函数"></a>2.1 投影模型和BA代价函数</h2><h2 id="2-2-BA的求解"><a href="#2-2-BA的求解" class="headerlink" title="2.2 BA的求解"></a>2.2 BA的求解</h2><h2 id="2-3-稀疏性和边缘化"><a href="#2-3-稀疏性和边缘化" class="headerlink" title="2.3 稀疏性和边缘化"></a>2.3 稀疏性和边缘化</h2><h2 id="2-4-鲁棒核函数"><a href="#2-4-鲁棒核函数" class="headerlink" title="2.4 鲁棒核函数"></a>2.4 鲁棒核函数</h2><h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><h1 id="3-实践：g2o"><a href="#3-实践：g2o" class="headerlink" title="3 实践：g2o"></a>3 实践：g2o</h1><h2 id="3-1-BA数据集"><a href="#3-1-BA数据集" class="headerlink" title="3.1 BA数据集"></a>3.1 BA数据集</h2><h2 id="3-2-g2o求解BA"><a href="#3-2-g2o求解BA" class="headerlink" title="3.2 g2o求解BA"></a>3.2 g2o求解BA</h2><p>定义节点，用节点表示相机和路标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"g2o/core/base_vertex.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"g2o/core/base_binary_edge.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/autodiff.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tools/rotation.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common/projection.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexCameraBAL</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">9</span>,Eigen::VectorXd&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    VertexCameraBAL() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span> <span class="params">( <span class="built_in">std</span>::istream&amp; <span class="comment">/*is*/</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span> <span class="params">( <span class="built_in">std</span>::ostream&amp; <span class="comment">/*os*/</span> )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">double</span>* update )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Eigen::VectorXd::<span class="function">ConstMapType <span class="title">v</span> <span class="params">( update, VertexCameraBAL::Dimension )</span></span>;</span><br><span class="line">        _estimate += v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexPointBAL</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    VertexPointBAL() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span> <span class="params">( <span class="built_in">std</span>::istream&amp; <span class="comment">/*is*/</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span> <span class="params">( <span class="built_in">std</span>::ostream&amp; <span class="comment">/*os*/</span> )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">double</span>* update )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Eigen::Vector3d::<span class="function">ConstMapType <span class="title">v</span> <span class="params">( update )</span></span>;</span><br><span class="line">        _estimate += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义边，表示相机路标之间的观测</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeObservationBAL</span> :</span> <span class="keyword">public</span> g2o::BaseBinaryEdge&lt;<span class="number">2</span>, Eigen::Vector2d,VertexCameraBAL, VertexPointBAL&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    EdgeObservationBAL() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span> <span class="params">( <span class="built_in">std</span>::istream&amp; <span class="comment">/*is*/</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span> <span class="params">( <span class="built_in">std</span>::ostream&amp; <span class="comment">/*os*/</span> )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span> override   <span class="comment">// The virtual function comes from the Edge base class. Must define if you use edge.</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> VertexCameraBAL* cam = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexCameraBAL*&gt; ( vertex ( <span class="number">0</span> ) );</span><br><span class="line">        <span class="keyword">const</span> VertexPointBAL* point = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPointBAL*&gt; ( vertex ( <span class="number">1</span> ) );</span><br><span class="line"></span><br><span class="line">        ( *<span class="keyword">this</span> ) ( cam-&gt;estimate().data(), point-&gt;estimate().data(), _error.data() );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( <span class="keyword">const</span> T* camera, <span class="keyword">const</span> T* point, T* residuals )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T predictions[<span class="number">2</span>];</span><br><span class="line">        CamProjectionWithDistortion ( camera, point, predictions );</span><br><span class="line">        residuals[<span class="number">0</span>] = predictions[<span class="number">0</span>] - T ( measurement() ( <span class="number">0</span> ) );</span><br><span class="line">        residuals[<span class="number">1</span>] = predictions[<span class="number">1</span>] - T ( measurement() ( <span class="number">1</span> ) );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// use numeric Jacobians</span></span><br><span class="line">        <span class="comment">// BaseBinaryEdge&lt;2, Vector2d, VertexCameraBAL, VertexPointBAL&gt;::linearizeOplus();</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// using autodiff from ceres. Otherwise, the system will use g2o numerical diff for Jacobians</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> VertexCameraBAL* cam = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexCameraBAL*&gt; ( vertex ( <span class="number">0</span> ) );</span><br><span class="line">        <span class="keyword">const</span> VertexPointBAL* point = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPointBAL*&gt; ( vertex ( <span class="number">1</span> ) );</span><br><span class="line">        <span class="keyword">typedef</span> ceres::internal::AutoDiff&lt;EdgeObservationBAL, <span class="keyword">double</span>, VertexCameraBAL::Dimension, VertexPointBAL::Dimension&gt; BalAutoDiff;</span><br><span class="line"></span><br><span class="line">        Eigen::Matrix&lt;<span class="keyword">double</span>, Dimension, VertexCameraBAL::Dimension, Eigen::RowMajor&gt; dError_dCamera;</span><br><span class="line">        Eigen::Matrix&lt;<span class="keyword">double</span>, Dimension, VertexPointBAL::Dimension, Eigen::RowMajor&gt; dError_dPoint;</span><br><span class="line">        <span class="keyword">double</span> *parameters[] = &#123; <span class="keyword">const_cast</span>&lt;<span class="keyword">double</span>*&gt; ( cam-&gt;estimate().data() ), <span class="keyword">const_cast</span>&lt;<span class="keyword">double</span>*&gt; ( point-&gt;estimate().data() ) &#125;;</span><br><span class="line">        <span class="keyword">double</span> *jacobians[] = &#123; dError_dCamera.data(), dError_dPoint.data() &#125;;</span><br><span class="line">        <span class="keyword">double</span> value[Dimension];</span><br><span class="line">        <span class="keyword">bool</span> diffState = BalAutoDiff::Differentiate ( *<span class="keyword">this</span>, parameters, Dimension, value, jacobians );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy over the Jacobians (convert row-major -&gt; column-major)</span></span><br><span class="line">        <span class="keyword">if</span> ( diffState )</span><br><span class="line">        &#123;</span><br><span class="line">            _jacobianOplusXi = dError_dCamera;</span><br><span class="line">            _jacobianOplusXj = dError_dPoint;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ( <span class="number">0</span> &amp;&amp; <span class="string">"Error while differentiating"</span> );</span><br><span class="line">            _jacobianOplusXi.setZero();</span><br><span class="line">            _jacobianOplusXj.setZero();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据BALProblem类当中的实际数据来生成一些节点和边，交给g2o进行优化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set up the vertexs and edges for the bundle adjustment. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildProblem</span><span class="params">(<span class="keyword">const</span> BALProblem* bal_problem, g2o::SparseOptimizer* optimizer, <span class="keyword">const</span> BundleParams&amp; params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_points = bal_problem-&gt;num_points();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_cameras = bal_problem-&gt;num_cameras();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> camera_block_size = bal_problem-&gt;camera_block_size();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> point_block_size = bal_problem-&gt;point_block_size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set camera vertex with initial value in the dataset.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* raw_cameras = bal_problem-&gt;cameras();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cameras; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ConstVectorRef <span class="title">temVecCamera</span><span class="params">(raw_cameras + camera_block_size * i,camera_block_size)</span></span>;</span><br><span class="line">        VertexCameraBAL* pCamera = <span class="keyword">new</span> VertexCameraBAL();</span><br><span class="line">        pCamera-&gt;setEstimate(temVecCamera);   <span class="comment">// initial value for the camera i..</span></span><br><span class="line">        pCamera-&gt;setId(i);                    <span class="comment">// set id for each camera vertex </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// remeber to add vertex into optimizer..</span></span><br><span class="line">        optimizer-&gt;addVertex(pCamera);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set point vertex with initial value in the dataset. </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* raw_points = bal_problem-&gt;points();</span><br><span class="line">    <span class="comment">// const int point_block_size = bal_problem-&gt;point_block_size();</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num_points; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ConstVectorRef <span class="title">temVecPoint</span><span class="params">(raw_points + point_block_size * j, point_block_size)</span></span>;</span><br><span class="line">        VertexPointBAL* pPoint = <span class="keyword">new</span> VertexPointBAL();</span><br><span class="line">        pPoint-&gt;setEstimate(temVecPoint);   <span class="comment">// initial value for the point i..</span></span><br><span class="line">        pPoint-&gt;setId(j + num_cameras);     <span class="comment">// each vertex should have an unique id, no matter it is a camera vertex, or a point vertex </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// remeber to add vertex into optimizer..</span></span><br><span class="line">        pPoint-&gt;setMarginalized(<span class="literal">true</span>);</span><br><span class="line">        optimizer-&gt;addVertex(pPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set edges for graph..</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>  num_observations = bal_problem-&gt;num_observations();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* observations = bal_problem-&gt;observations();   <span class="comment">// pointer for the first observation..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_observations; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeObservationBAL* bal_edge = <span class="keyword">new</span> EdgeObservationBAL();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> camera_id = bal_problem-&gt;camera_index()[i]; <span class="comment">// get id for the camera; </span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> point_id = bal_problem-&gt;point_index()[i] + num_cameras; <span class="comment">// get id for the point </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(params.robustify)</span><br><span class="line">        &#123;</span><br><span class="line">            g2o::RobustKernelHuber* rk = <span class="keyword">new</span> g2o::RobustKernelHuber;</span><br><span class="line">            rk-&gt;setDelta(<span class="number">1.0</span>);</span><br><span class="line">            bal_edge-&gt;setRobustKernel(rk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set the vertex by the ids for an edge observation</span></span><br><span class="line">        bal_edge-&gt;setVertex(<span class="number">0</span>,<span class="keyword">dynamic_cast</span>&lt;VertexCameraBAL*&gt;(optimizer-&gt;vertex(camera_id)));</span><br><span class="line">        bal_edge-&gt;setVertex(<span class="number">1</span>,<span class="keyword">dynamic_cast</span>&lt;VertexPointBAL*&gt;(optimizer-&gt;vertex(point_id)));</span><br><span class="line">        bal_edge-&gt;setInformation(Eigen::Matrix2d::Identity());</span><br><span class="line">        bal_edge-&gt;setMeasurement(Eigen::Vector2d(observations[<span class="number">2</span>*i+<span class="number">0</span>],observations[<span class="number">2</span>*i + <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">       optimizer-&gt;addEdge(bal_edge) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-求解"><a href="#3-3-求解" class="headerlink" title="3.3 求解"></a>3.3 求解</h2><p>求解设置：</p>
<ul>
<li>使用何种方法来定义非线性优化的下降策略</li>
<li>使用哪类线性求解器</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">9</span>,<span class="number">3</span>&gt; &gt; BalBlockSolver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSolverOptionsFromFlags</span><span class="params">(BALProblem* bal_problem, <span class="keyword">const</span> BundleParams&amp; params, g2o::SparseOptimizer* optimizer)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    BalBlockSolver* solver_ptr;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    g2o::LinearSolver&lt;BalBlockSolver::PoseMatrixType&gt;* linearSolver = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(params.linear_solver == <span class="string">"dense_schur"</span> )&#123;</span><br><span class="line">        linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt;BalBlockSolver::PoseMatrixType&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(params.linear_solver == <span class="string">"sparse_schur"</span>)&#123;</span><br><span class="line">        linearSolver = <span class="keyword">new</span> g2o::LinearSolverCholmod&lt;BalBlockSolver::PoseMatrixType&gt;();</span><br><span class="line">        <span class="keyword">dynamic_cast</span>&lt;g2o::LinearSolverCholmod&lt;BalBlockSolver::PoseMatrixType&gt;* &gt;(linearSolver)-&gt;setBlockOrdering(<span class="literal">true</span>);  <span class="comment">// AMD ordering , only needed for sparse cholesky solver</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    solver_ptr = <span class="keyword">new</span> BalBlockSolver(linearSolver);</span><br><span class="line">    <span class="comment">//SetLinearSolver(solver_ptr, params);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SetMinimizerOptions(solver_ptr, params, optimizer);</span></span><br><span class="line">    g2o::OptimizationAlgorithmWithHessian* solver;</span><br><span class="line">    <span class="keyword">if</span>(params.trust_region_strategy == <span class="string">"levenberg_marquardt"</span>)&#123;</span><br><span class="line">        solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg(solver_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(params.trust_region_strategy == <span class="string">"dogleg"</span>)&#123;</span><br><span class="line">        solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmDogleg(solver_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please check your trust_region_strategy parameter again.."</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optimizer-&gt;setAlgorithm(solver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-实践-Ceres"><a href="#4-实践-Ceres" class="headerlink" title="4 实践:Ceres"></a>4 实践:Ceres</h1><h2 id="4-1-Ceres求解BA"><a href="#4-1-Ceres求解BA" class="headerlink" title="4.1 Ceres求解BA"></a>4.1 Ceres求解BA</h2><p>首先定义代价函数类型，并定义Create成员来使用Ceres当中的AutoDiff特性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnavelyReprojectionError</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SnavelyReprojectionError(<span class="keyword">double</span> observation_x, <span class="keyword">double</span> observation_y):observed_x(observation_x),observed_y(observation_y)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> camera,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> T* <span class="keyword">const</span> point,</span></span></span><br><span class="line"><span class="function"><span class="params">                T* residuals)</span><span class="keyword">const</span></span>&#123;                  </span><br><span class="line">        <span class="comment">// camera[0,1,2] are the angle-axis rotation</span></span><br><span class="line">        T predictions[<span class="number">2</span>];</span><br><span class="line">        CamProjectionWithDistortion(camera, point, predictions);</span><br><span class="line">        residuals[<span class="number">0</span>] = predictions[<span class="number">0</span>] - T(observed_x);</span><br><span class="line">        residuals[<span class="number">1</span>] = predictions[<span class="number">1</span>] - T(observed_y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ceres::<span class="function">CostFunction* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> observed_x, <span class="keyword">const</span> <span class="keyword">double</span> observed_y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;SnavelyReprojectionError,<span class="number">2</span>,<span class="number">9</span>,<span class="number">3</span>&gt;(</span><br><span class="line">            <span class="keyword">new</span> SnavelyReprojectionError(observed_x,observed_y)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> observed_x;</span><br><span class="line">    <span class="keyword">double</span> observed_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SnavelyReprojection.h</span></span></span><br></pre></td></tr></table></figure>
<p>定义好之后,我们就可以使用 SnavelyReprojectionError::Create 函数来轻松地构建这<br>个目标函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildProblem</span><span class="params">(BALProblem* bal_problem, Problem* problem, <span class="keyword">const</span> BundleParams&amp; params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> point_block_size = bal_problem-&gt;point_block_size();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> camera_block_size = bal_problem-&gt;camera_block_size();</span><br><span class="line">    <span class="keyword">double</span>* points = bal_problem-&gt;mutable_points();</span><br><span class="line">    <span class="keyword">double</span>* cameras = bal_problem-&gt;mutable_cameras();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Observations is 2 * num_observations long array observations</span></span><br><span class="line">    <span class="comment">// [u_1, u_2, ... u_n], where each u_i is two dimensional, the x </span></span><br><span class="line">    <span class="comment">// and y position of the observation. </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* observations = bal_problem-&gt;observations();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bal_problem-&gt;num_observations(); ++i)&#123;</span><br><span class="line">        CostFunction* cost_function;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Each Residual block takes a point and a camera as input </span></span><br><span class="line">        <span class="comment">// and outputs a 2 dimensional Residual</span></span><br><span class="line">      </span><br><span class="line">        cost_function = SnavelyReprojectionError::Create(observations[<span class="number">2</span>*i + <span class="number">0</span>], observations[<span class="number">2</span>*i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If enabled use Huber's loss function. </span></span><br><span class="line">        LossFunction* loss_function = params.robustify ? <span class="keyword">new</span> HuberLoss(<span class="number">1.0</span>) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Each observatoin corresponds to a pair of a camera and a point </span></span><br><span class="line">        <span class="comment">// which are identified by camera_index()[i] and point_index()[i]</span></span><br><span class="line">        <span class="comment">// respectively.</span></span><br><span class="line">        <span class="keyword">double</span>* camera = cameras + camera_block_size * bal_problem-&gt;camera_index()[i];</span><br><span class="line">        <span class="keyword">double</span>* point = points + point_block_size * bal_problem-&gt;point_index()[i];</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        problem-&gt;AddResidualBlock(cost_function, loss_function, camera, point);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用 Schur 消元,Ceres 采取的策略和 g2o 有很大的不同。Ceres采用额外的类型 ParameterBlockOrdering 来管理 schur 消元顺序,并且使用 AddElement-ToGroup 来对变量进行编号从而定义消元顺序。例如下面设置点云变量为 0,相机变量为1 就可以让点云变量先进行消元(优先消元编号最小的变量):<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetOrdering</span><span class="params">(BALProblem* bal_problem, ceres::Solver::Options* options, <span class="keyword">const</span> BundleParams&amp; params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_points = bal_problem-&gt;num_points();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> point_block_size = bal_problem-&gt;point_block_size();</span><br><span class="line">    <span class="keyword">double</span>* points = bal_problem-&gt;mutable_points();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_cameras = bal_problem-&gt;num_cameras();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> camera_block_size = bal_problem-&gt;camera_block_size();</span><br><span class="line">    <span class="keyword">double</span>* cameras = bal_problem-&gt;mutable_cameras();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (params.ordering == <span class="string">"automatic"</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ceres::ParameterBlockOrdering* ordering = <span class="keyword">new</span> ceres::ParameterBlockOrdering;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The points come before the cameras</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i)</span><br><span class="line">       ordering-&gt;AddElementToGroup(points + point_block_size * i, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cameras; ++i)</span><br><span class="line">        ordering-&gt;AddElementToGroup(cameras + camera_block_size * i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    options-&gt;linear_solver_ordering.reset(ordering);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetOrdering</span><span class="params">(BALProblem* bal_problem, ceres::Solver::Options* options, <span class="keyword">const</span> BundleParams&amp; params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_points = bal_problem-&gt;num_points();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> point_block_size = bal_problem-&gt;point_block_size();</span><br><span class="line">    <span class="keyword">double</span>* points = bal_problem-&gt;mutable_points();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num_cameras = bal_problem-&gt;num_cameras();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> camera_block_size = bal_problem-&gt;camera_block_size();</span><br><span class="line">    <span class="keyword">double</span>* cameras = bal_problem-&gt;mutable_cameras();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (params.ordering == <span class="string">"automatic"</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ceres::ParameterBlockOrdering* ordering = <span class="keyword">new</span> ceres::ParameterBlockOrdering;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The points come before the cameras</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_points; ++i)</span><br><span class="line">       ordering-&gt;AddElementToGroup(points + point_block_size * i, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cameras; ++i)</span><br><span class="line">        ordering-&gt;AddElementToGroup(cameras + camera_block_size * i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    options-&gt;linear_solver_ordering.reset(ordering);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-求解"><a href="#4-2-求解" class="headerlink" title="4.2 求解"></a>4.2 求解</h2><p>g2o<br>的设置全靠变量类型来选择不同的下降策略,以及选择稠密或者稀疏的线性方程组解法,<br>然而 ceres 全靠给 Solver::Options 的类型成员变量进行赋值来调整。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLinearSolver</span><span class="params">(ceres::Solver::Options* options, <span class="keyword">const</span> BundleParams&amp; params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// linear solver 的选取</span></span><br><span class="line">    CHECK(ceres::StringToLinearSolverType(params.linear_solver, &amp;options-&gt;linear_solver_type));</span><br><span class="line">    CHECK(ceres::StringToSparseLinearAlgebraLibraryType(params.sparse_linear_algebra_library, &amp;options-&gt;sparse_linear_algebra_library_type));</span><br><span class="line">    CHECK(ceres::StringToDenseLinearAlgebraLibraryType(params.dense_linear_algebra_library, &amp;options-&gt;dense_linear_algebra_library_type));</span><br><span class="line">    options-&gt;num_linear_solver_threads = params.num_threads;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetMinimizerOptions</span><span class="params">(Solver::Options* options, <span class="keyword">const</span> BundleParams&amp; params)</span></span>&#123;</span><br><span class="line">    options-&gt;max_num_iterations = params.num_iterations;</span><br><span class="line">    options-&gt;minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">    options-&gt;num_threads = params.num_threads;</span><br><span class="line">    <span class="comment">// options-&gt;eta = params.eta;</span></span><br><span class="line">    <span class="comment">// options-&gt;max_solver_time_in_seconds = params.max_solver_time;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下降策略的选取</span></span><br><span class="line">    CHECK(StringToTrustRegionStrategyType(params.trust_region_strategy,</span><br><span class="line">                                        &amp;options-&gt;trust_region_strategy_type));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSolverOptionsFromFlags</span><span class="params">(BALProblem* bal_problem,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> BundleParams&amp; params, Solver::Options* options)</span></span>&#123;</span><br><span class="line">    SetMinimizerOptions(options,params);</span><br><span class="line">    SetLinearSolver(options,params);</span><br><span class="line">    <span class="comment">//变量排序的设置</span></span><br><span class="line">    SetOrdering(bal_problem, options,params);</span><br></pre></td></tr></table></figure>
<p>ceres 的求解也很简单，只需要简单地设置一下关于梯度和相邻两次迭代之间目标函数之差的相关阈值就可以。Solve 函数负责 Ceres 的求解功能,只需要传给它对应的选项,目标函数即可。Summary 类型用来负责函数求解每一次迭代的统计结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">options.gradient_tolerance = <span class="number">1e-16</span>;</span><br><span class="line">options.function_tolerance = <span class="number">1e-16</span>;</span><br><span class="line">Solver::Summary summary;</span><br><span class="line">Solve(options, &amp;problem, &amp;summary);</span><br></pre></td></tr></table></figure>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h1><p>待写！！！</p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>建图——单目稠密重建</title>
    <url>/2019/05/28/%E5%BB%BA%E5%9B%BE%E2%80%94%E2%80%94%E5%8D%95%E7%9B%AE%E7%A8%A0%E5%AF%86%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="立体视觉"><a href="#立体视觉" class="headerlink" title="立体视觉"></a>立体视觉</h3><p>在稠密重建,我们需要知道每一个像素点(或大部分像素点)的距离,那么大致上有以下几种解决方案:</p><ol>
<li>使用单目相机,利用移动相机之后进行三角化,测量像素的距离。</li>
<li>使用双目相机,利用左右目的视差计算像素的距离(多目原理相同)。</li>
<li>使用 RGB-D 相机直接获得像素距离。</li>
</ol><h3 id="极线搜索与块匹配"><a href="#极线搜索与块匹配" class="headerlink" title="极线搜索与块匹配"></a>极线搜索与块匹配</h3><p><strong>极线搜索</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827134907280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p><ul>
<li><p>左边的相机观测到了某个像素 $p_1$ 。由于这是一个单目相机，无从知道它的深度,所以假设这个深度可能在某个区域之内,不妨说是某最小值到无穷远之间:(d min , +∞)。因此,该像素对应的空间点就分布在某条线段上。在另一个视角(右侧相机)看来,这条线段的投影也形成图像平面上的一条线,称为极线。当我们知道两个相机间的运动时,这条极线也是能够确定的。</p>
</li>
<li><p>在特征点法中，通过特征匹配得到p2的位置，然而现在没有描述子，只能在极线上搜索和p1想的比较相似的点。（可能沿着极线一直走比较每个像素与p1的相似程度。）</p>
</li>
</ul><a id="more"></a>



<p><strong>块匹配</strong></p>
<ul>
<li><p>在$p_1$周围取一个大小为w*w的小块，然后在极线上也取很多同样大小的小块进行比较，就可以在一定程度上提高区分性。这就是所谓的块匹配（只有假设在不同图像间整个小块的灰度值不变）。<br>取了$p_1$周围的小块，并且在极线上也取了很多个小块。不妨把p1周围的小块记成$A ∈ R^{w×w}$，把极线上的n个小块记成$B_i,i=1…n$。几种不同的方法计算小块与小块间的差异：</p>
<ol>
<li>SAD(Sum of Absolute Difference)。顾名思义,即取两个小块的差的绝对值之和:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827143259384.png#pic_center"></li>
<li>SSD(Sum of Squared Distance）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019082714335453.png#pic_center"></li>
<li>NCC(Normalized Cross Correlation)(归一化互相关)，计算的是两个小块的相关性:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827143444296.png#pic_center"></li>
</ol>
<p>除了这些简单的版本外，我们可以先把每个小块的均值去掉。去掉均值后，我们准许像“小块B比A整体上亮一些，但仍然很相似”这样的情况。因此比之前的更加可靠一些。</p>
</li>
</ul>
<h3 id="高斯分布的深度滤波器"><a href="#高斯分布的深度滤波器" class="headerlink" title="高斯分布的深度滤波器"></a>高斯分布的深度滤波器</h3><p> 对像素点深度的估计，本身亦可建模为一个状态估计问题，存在滤波器与非线性优化两种求解思路，采用计算量较少的滤波器方式。<br>下面介绍并演示高斯分布假设下的深度滤波器：</p>
<p> 设某个像素点的深度 d 服从:<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827145429633.png#pic_center"><br> 而每当新的数据到来,我们都会观测到它的深度。同样的,假设这次观测亦是一个高斯分布:<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827145500754.png#pic_center"><br> 由于我们仅有观测方程而没有运动方程，所以这里深度仅用到了信息融合部分。设融合后的 d的分布为 $N(μ_{f use} , σ_{fuse}^2$ )，有：<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827145629530.png#pic_center"><br> 只考虑由几何关系带来的不确定性（不考虑光度不确定性等），计算深度不确定性$σ_{obs}^2$<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827145919656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>考虑某次极线搜索，我们找到了p1对应的p2点，从而观测到了p1的深度值，认为p1对应的三维点为P。<br>记 $O_1P$ 为 p,$O_1O_2$ 为相机的平移 t ，$O_2P$ 记为 a。并且,把这个三角形的下面两个角记作 α, β。现在,考虑极线 $l_2$ 上存在着一个像素大小的误差,使得 β 角变成了 β ′ ,而 p 也变成了 p ′ ,并记上面那个角为 γ。我们要问的是,这一个像素的误差,会导致 p ′ 与 p 产生多大的差距呢?</p>
<p> 由集合关系得：<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827150302411.png#pic_center"><br> 对 $p_2$ 扰动一个像素,将使得 β 产生一个变化量 δβ,由于相机焦距为 f ,于是:<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827150355437.png#pic_center"><br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827150420372.png#pic_center"><br> p ′ 的大小可以求得:<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019082715045226.png#pic_center"><br>由此,我们确定了由单个像素的不确定引起的深度不确定性。如果认为极线搜索的块<br>匹配仅有一个像素的误差,那么就可以设:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827150521194.png#pic_center"><br>如果极线搜索的不确定性大于一个像素,我们亦可按照此推导来放大这个不确定性。</p>
<p>估计稠密深度的一个完整的过程:</p>
<ol>
<li><p>假设所有像素的深度满足某个初始的高斯分布。</p>
</li>
<li><p>当新数据产生时，通过极线搜索和块匹配确定投影点位置。</p>
</li>
<li><p>根据几何关系计算三角化后的深度及不确定性。</p>
<ol>
<li>将当前观测融合进上一次的估计中。若收敛则停止计算，否则返回第2步。</li>
</ol>
</li>
</ol>
<h3 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/timer.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for sophus </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/se3.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Sophus::SE3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for eigen </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">* 本程序演示了单目相机在已知轨迹下的稠密深度估计</span></span><br><span class="line"><span class="comment">* 使用极线搜索 + NCC 匹配的方式，与书本的 13.2 节对应</span></span><br><span class="line"><span class="comment">* 请注意本程序并不完美，你完全可以改进它——我其实在故意暴露一些问题。</span></span><br><span class="line"><span class="comment">***********************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// parameters </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> boarder = <span class="number">20</span>; 	<span class="comment">// 边缘宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> width = <span class="number">640</span>;  	<span class="comment">// 宽度 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> height = <span class="number">480</span>;  	<span class="comment">// 高度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> fx = <span class="number">481.2f</span>;	<span class="comment">// 相机内参</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> fy = <span class="number">-480.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> cx = <span class="number">319.5f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> cy = <span class="number">239.5f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ncc_window_size = <span class="number">2</span>;	<span class="comment">// NCC 取的窗口半宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ncc_area = (<span class="number">2</span>*ncc_window_size+<span class="number">1</span>)*(<span class="number">2</span>*ncc_window_size+<span class="number">1</span>); <span class="comment">// NCC窗口面积</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> min_cov = <span class="number">0.1</span>;	<span class="comment">// 收敛判定：最小方差</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> max_cov = <span class="number">10</span>;	<span class="comment">// 发散判定：最大方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 重要的函数 </span></span><br><span class="line"><span class="comment">// 从 REMODE 数据集读取数据  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readDatasetFiles</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; path, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; color_image_files, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;SE3&gt;&amp; poses </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据新的图像更新深度估计</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; ref, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; curr, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> SE3&amp; T_C_R, </span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; depth, </span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; depth_cov </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 极线搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">epipolarSearch</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; ref, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; curr, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> SE3&amp; T_C_R, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Vector2d&amp; pt_ref, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">double</span>&amp; depth_mu, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">double</span>&amp; depth_cov,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector2d&amp; pt_curr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新深度滤波器 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">updateDepthFilter</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Vector2d&amp; pt_ref, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Vector2d&amp; pt_curr, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> SE3&amp; T_C_R, </span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; depth, </span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; depth_cov</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 NCC 评分 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">NCC</span><span class="params">( <span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, <span class="keyword">const</span> Vector2d&amp; pt_ref, <span class="keyword">const</span> Vector2d&amp; pt_curr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双线性灰度插值 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">getBilinearInterpolatedValue</span><span class="params">( <span class="keyword">const</span> Mat&amp; img, <span class="keyword">const</span> Vector2d&amp; pt )</span> </span>&#123;</span><br><span class="line">    uchar* d = &amp; img.data[ <span class="keyword">int</span>(pt(<span class="number">1</span>,<span class="number">0</span>))*img.step+<span class="keyword">int</span>(pt(<span class="number">0</span>,<span class="number">0</span>)) ];</span><br><span class="line">    <span class="keyword">double</span> xx = pt(<span class="number">0</span>,<span class="number">0</span>) - <span class="built_in">floor</span>(pt(<span class="number">0</span>,<span class="number">0</span>)); </span><br><span class="line">    <span class="keyword">double</span> yy = pt(<span class="number">1</span>,<span class="number">0</span>) - <span class="built_in">floor</span>(pt(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>  (( <span class="number">1</span>-xx ) * ( <span class="number">1</span>-yy ) * <span class="keyword">double</span>(d[<span class="number">0</span>]) +</span><br><span class="line">            xx* ( <span class="number">1</span>-yy ) * <span class="keyword">double</span>(d[<span class="number">1</span>]) +</span><br><span class="line">            ( <span class="number">1</span>-xx ) *yy* <span class="keyword">double</span>(d[img.step]) +</span><br><span class="line">            xx*yy*<span class="keyword">double</span>(d[img.step+<span class="number">1</span>]))/<span class="number">255.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 一些小工具 </span></span><br><span class="line"><span class="comment">// 显示估计的深度图 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plotDepth</span><span class="params">( <span class="keyword">const</span> Mat&amp; depth )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像素到相机坐标系 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Vector3d <span class="title">px2cam</span> <span class="params">( <span class="keyword">const</span> Vector2d px )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Vector3d ( </span><br><span class="line">        (px(<span class="number">0</span>,<span class="number">0</span>) - cx)/fx,</span><br><span class="line">        (px(<span class="number">1</span>,<span class="number">0</span>) - cy)/fy, </span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机坐标系到像素 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Vector2d <span class="title">cam2px</span> <span class="params">( <span class="keyword">const</span> Vector3d p_cam )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Vector2d (</span><br><span class="line">        p_cam(<span class="number">0</span>,<span class="number">0</span>)*fx/p_cam(<span class="number">2</span>,<span class="number">0</span>) + cx, </span><br><span class="line">        p_cam(<span class="number">1</span>,<span class="number">0</span>)*fy/p_cam(<span class="number">2</span>,<span class="number">0</span>) + cy </span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测一个点是否在图像边框内</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">inside</span><span class="params">( <span class="keyword">const</span> Vector2d&amp; pt )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pt(<span class="number">0</span>,<span class="number">0</span>) &gt;= boarder &amp;&amp; pt(<span class="number">1</span>,<span class="number">0</span>)&gt;=boarder </span><br><span class="line">        &amp;&amp; pt(<span class="number">0</span>,<span class="number">0</span>)+boarder&lt;width &amp;&amp; pt(<span class="number">1</span>,<span class="number">0</span>)+boarder&lt;=height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示极线匹配 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showEpipolarMatch</span><span class="params">( <span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, <span class="keyword">const</span> Vector2d&amp; px_ref, <span class="keyword">const</span> Vector2d&amp; px_curr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示极线 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showEpipolarLine</span><span class="params">( <span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, <span class="keyword">const</span> Vector2d&amp; px_ref, <span class="keyword">const</span> Vector2d&amp; px_min_curr, <span class="keyword">const</span> Vector2d&amp; px_max_curr )</span></span>;</span><br><span class="line"><span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Usage: dense_mapping path_to_test_dataset"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从数据集读取数据</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; color_image_files; </span><br><span class="line">    <span class="built_in">vector</span>&lt;SE3&gt; poses_TWC;</span><br><span class="line">    <span class="keyword">bool</span> ret = readDatasetFiles( argv[<span class="number">1</span>], color_image_files, poses_TWC );</span><br><span class="line">    <span class="keyword">if</span> ( ret==<span class="literal">false</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Reading image files failed!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"read total "</span>&lt;&lt;color_image_files.size()&lt;&lt;<span class="string">" files."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一张图</span></span><br><span class="line">    Mat ref = imread( color_image_files[<span class="number">0</span>], <span class="number">0</span> );                <span class="comment">// gray-scale image </span></span><br><span class="line">    SE3 pose_ref_TWC = poses_TWC[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> init_depth   = <span class="number">3.0</span>;    <span class="comment">// 深度初始值</span></span><br><span class="line">    <span class="keyword">double</span> init_cov2    = <span class="number">3.0</span>;    <span class="comment">// 方差初始值 </span></span><br><span class="line">    <span class="function">Mat <span class="title">depth</span><span class="params">( height, width, CV_64F, init_depth )</span></span>;             <span class="comment">// 深度图</span></span><br><span class="line">    <span class="function">Mat <span class="title">depth_cov</span><span class="params">( height, width, CV_64F, init_cov2 )</span></span>;          <span class="comment">// 深度图方差 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> index=<span class="number">1</span>; index&lt;color_image_files.size(); index++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"*** loop "</span>&lt;&lt;index&lt;&lt;<span class="string">" ***"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        Mat curr = imread( color_image_files[index], <span class="number">0</span> );       </span><br><span class="line">        <span class="keyword">if</span> (curr.data == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">        SE3 pose_curr_TWC = poses_TWC[index];</span><br><span class="line">        SE3 pose_T_C_R = pose_curr_TWC.inverse() * pose_ref_TWC; <span class="comment">// 坐标转换关系： T_C_W * T_W_R = T_C_R </span></span><br><span class="line">        update( ref, curr, pose_T_C_R, depth, depth_cov );</span><br><span class="line">        plotDepth( depth );</span><br><span class="line">        imshow(<span class="string">"image"</span>, curr);</span><br><span class="line">        waitKey(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"estimation returns, saving depth map ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    imwrite( <span class="string">"depth.png"</span>, depth );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"done."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readDatasetFiles</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; path, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;&amp; color_image_files, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SE3&gt;&amp; poses</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">( path+<span class="string">"/first_200_frames_traj_over_table_input_sequence.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( !fin ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( !fin.eof() )</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 数据格式：图像文件名 tx, ty, tz, qx, qy, qz, qw ，注意是 TWC 而非 TCW</span></span><br><span class="line">        <span class="built_in">string</span> image; </span><br><span class="line">        fin&gt;&gt;image; </span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">double</span>&amp; d:data ) fin&gt;&gt;d;</span><br><span class="line">        </span><br><span class="line">        color_image_files.push_back( path+<span class="built_in">string</span>(<span class="string">"/images/"</span>)+image );</span><br><span class="line">        poses.push_back(</span><br><span class="line">            SE3( Quaterniond(data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>]), </span><br><span class="line">                 Vector3d(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>]))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> ( !fin.good() ) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对整个深度图进行更新</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, <span class="keyword">const</span> SE3&amp; T_C_R, Mat&amp; depth, Mat&amp; depth_cov )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x=boarder; x&lt;width-boarder; x++ )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> y=boarder; y&lt;height-boarder; y++ )</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// 遍历每个像素</span></span><br><span class="line">            <span class="keyword">if</span> ( depth_cov.ptr&lt;<span class="keyword">double</span>&gt;(y)[x] &lt; min_cov || depth_cov.ptr&lt;<span class="keyword">double</span>&gt;(y)[x] &gt; max_cov ) <span class="comment">// 深度已收敛或发散</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 在极线上搜索 (x,y) 的匹配 </span></span><br><span class="line">            Vector2d pt_curr; </span><br><span class="line">            <span class="keyword">bool</span> ret = epipolarSearch ( </span><br><span class="line">                ref, </span><br><span class="line">                curr, </span><br><span class="line">                T_C_R, </span><br><span class="line">                Vector2d(x,y), </span><br><span class="line">                depth.ptr&lt;<span class="keyword">double</span>&gt;(y)[x], </span><br><span class="line">                <span class="built_in">sqrt</span>(depth_cov.ptr&lt;<span class="keyword">double</span>&gt;(y)[x]),</span><br><span class="line">                pt_curr</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ( ret == <span class="literal">false</span> ) <span class="comment">// 匹配失败</span></span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 取消该注释以显示匹配</span></span><br><span class="line">            showEpipolarMatch( ref, curr, Vector2d(x,y), pt_curr );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 匹配成功，更新深度图 </span></span><br><span class="line">            updateDepthFilter( Vector2d(x,y), pt_curr, T_C_R, depth, depth_cov );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 极线搜索</span></span><br><span class="line"><span class="comment">// 方法见书 13.2 13.3 两节</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">epipolarSearch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> SE3&amp; T_C_R, <span class="keyword">const</span> Vector2d&amp; pt_ref, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">double</span>&amp; depth_mu, <span class="keyword">const</span> <span class="keyword">double</span>&amp; depth_cov, </span></span></span><br><span class="line"><span class="function"><span class="params">    Vector2d&amp; pt_curr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3d f_ref = px2cam( pt_ref );</span><br><span class="line">    f_ref.normalize();</span><br><span class="line">    Vector3d P_ref = f_ref*depth_mu;	<span class="comment">// 参考帧的 P 向量</span></span><br><span class="line">    </span><br><span class="line">    Vector2d px_mean_curr = cam2px( T_C_R*P_ref ); <span class="comment">// 按深度均值投影的像素</span></span><br><span class="line">    <span class="keyword">double</span> d_min = depth_mu<span class="number">-3</span>*depth_cov, d_max = depth_mu+<span class="number">3</span>*depth_cov;</span><br><span class="line">    <span class="keyword">if</span> ( d_min&lt;<span class="number">0.1</span> ) d_min = <span class="number">0.1</span>;</span><br><span class="line">    Vector2d px_min_curr = cam2px( T_C_R*(f_ref*d_min) );	<span class="comment">// 按最小深度投影的像素</span></span><br><span class="line">    Vector2d px_max_curr = cam2px( T_C_R*(f_ref*d_max) );	<span class="comment">// 按最大深度投影的像素</span></span><br><span class="line">    </span><br><span class="line">    Vector2d epipolar_line = px_max_curr - px_min_curr;	<span class="comment">// 极线（线段形式）</span></span><br><span class="line">    Vector2d epipolar_direction = epipolar_line;		<span class="comment">// 极线方向 </span></span><br><span class="line">    epipolar_direction.normalize();</span><br><span class="line">    <span class="keyword">double</span> half_length = <span class="number">0.5</span>*epipolar_line.norm();	<span class="comment">// 极线线段的半长度</span></span><br><span class="line">    <span class="keyword">if</span> ( half_length&gt;<span class="number">100</span> ) half_length = <span class="number">100</span>;   <span class="comment">// 我们不希望搜索太多东西 </span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 取消此句注释以显示极线（线段）</span></span><br><span class="line">    showEpipolarLine( ref, curr, pt_ref, px_min_curr, px_max_curr );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在极线上搜索，以深度均值点为中心，左右各取半长度</span></span><br><span class="line">    <span class="keyword">double</span> best_ncc = <span class="number">-1.0</span>;</span><br><span class="line">    Vector2d best_px_curr; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">double</span> l=-half_length; l&lt;=half_length; l+=<span class="number">0.7</span> )  <span class="comment">// l+=sqrt(2) </span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector2d px_curr = px_mean_curr + l*epipolar_direction;  <span class="comment">// 待匹配点</span></span><br><span class="line">        <span class="keyword">if</span> ( !inside(px_curr) )</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        <span class="comment">// 计算待匹配点与参考帧的 NCC</span></span><br><span class="line">        <span class="keyword">double</span> ncc = NCC( ref, curr, pt_ref, px_curr );</span><br><span class="line">        <span class="keyword">if</span> ( ncc&gt;best_ncc )</span><br><span class="line">        &#123;</span><br><span class="line">            best_ncc = ncc; </span><br><span class="line">            best_px_curr = px_curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( best_ncc &lt; <span class="number">0.85f</span> )      <span class="comment">// 只相信 NCC 很高的匹配</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    pt_curr = best_px_curr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">NCC</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Vector2d&amp; pt_ref, <span class="keyword">const</span> Vector2d&amp; pt_curr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 零均值-归一化互相关</span></span><br><span class="line">    <span class="comment">// 先算均值</span></span><br><span class="line">    <span class="keyword">double</span> mean_ref = <span class="number">0</span>, mean_curr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values_ref, values_curr; <span class="comment">// 参考帧和当前帧的均值</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x=-ncc_window_size; x&lt;=ncc_window_size; x++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> y=-ncc_window_size; y&lt;=ncc_window_size; y++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> value_ref = <span class="keyword">double</span>(ref.ptr&lt;uchar&gt;( <span class="keyword">int</span>(y+pt_ref(<span class="number">1</span>,<span class="number">0</span>)) )[ <span class="keyword">int</span>(x+pt_ref(<span class="number">0</span>,<span class="number">0</span>)) ])/<span class="number">255.0</span>;</span><br><span class="line">            mean_ref += value_ref;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> value_curr = getBilinearInterpolatedValue( curr, pt_curr+Vector2d(x,y) );</span><br><span class="line">            mean_curr += value_curr;</span><br><span class="line">            </span><br><span class="line">            values_ref.push_back(value_ref);</span><br><span class="line">            values_curr.push_back(value_curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    mean_ref /= ncc_area;</span><br><span class="line">    mean_curr /= ncc_area;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 计算 Zero mean NCC</span></span><br><span class="line">    <span class="keyword">double</span> numerator = <span class="number">0</span>, demoniator1 = <span class="number">0</span>, demoniator2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;values_ref.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> n = (values_ref[i]-mean_ref) * (values_curr[i]-mean_curr);</span><br><span class="line">        numerator += n;</span><br><span class="line">        demoniator1 += (values_ref[i]-mean_ref)*(values_ref[i]-mean_ref);</span><br><span class="line">        demoniator2 += (values_curr[i]-mean_curr)*(values_curr[i]-mean_curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numerator / <span class="built_in">sqrt</span>( demoniator1*demoniator2+<span class="number">1e-10</span> );   <span class="comment">// 防止分母出现零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">updateDepthFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Vector2d&amp; pt_ref, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Vector2d&amp; pt_curr, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> SE3&amp; T_C_R,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; depth, </span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; depth_cov</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我是一只喵</span></span><br><span class="line">    <span class="comment">// 不知道这段还有没有人看</span></span><br><span class="line">    <span class="comment">// 用三角化计算深度</span></span><br><span class="line">    SE3 T_R_C = T_C_R.inverse();</span><br><span class="line">    Vector3d f_ref = px2cam( pt_ref );</span><br><span class="line">    f_ref.normalize();</span><br><span class="line">    Vector3d f_curr = px2cam( pt_curr );</span><br><span class="line">    f_curr.normalize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方程</span></span><br><span class="line">    <span class="comment">// d_ref * f_ref = d_cur * ( R_RC * f_cur ) + t_RC</span></span><br><span class="line">    <span class="comment">// =&gt; [ f_ref^T f_ref, -f_ref^T f_cur ] [d_ref] = [f_ref^T t]</span></span><br><span class="line">    <span class="comment">//    [ f_cur^T f_ref, -f_cur^T f_cur ] [d_cur] = [f_cur^T t]</span></span><br><span class="line">    <span class="comment">// 二阶方程用克莱默法则求解并解之</span></span><br><span class="line">    Vector3d t = T_R_C.translation();</span><br><span class="line">    Vector3d f2 = T_R_C.rotation_matrix() * f_curr; </span><br><span class="line">    Vector2d b = Vector2d ( t.dot ( f_ref ), t.dot ( f2 ) );</span><br><span class="line">    <span class="keyword">double</span> A[<span class="number">4</span>];</span><br><span class="line">    A[<span class="number">0</span>] = f_ref.dot ( f_ref );</span><br><span class="line">    A[<span class="number">2</span>] = f_ref.dot ( f2 );</span><br><span class="line">    A[<span class="number">1</span>] = -A[<span class="number">2</span>];</span><br><span class="line">    A[<span class="number">3</span>] = - f2.dot ( f2 );</span><br><span class="line">    <span class="keyword">double</span> d = A[<span class="number">0</span>]*A[<span class="number">3</span>]-A[<span class="number">1</span>]*A[<span class="number">2</span>];</span><br><span class="line">    Vector2d lambdavec = </span><br><span class="line">        Vector2d (  A[<span class="number">3</span>] * b ( <span class="number">0</span>,<span class="number">0</span> ) - A[<span class="number">1</span>] * b ( <span class="number">1</span>,<span class="number">0</span> ),</span><br><span class="line">                    -A[<span class="number">2</span>] * b ( <span class="number">0</span>,<span class="number">0</span> ) + A[<span class="number">0</span>] * b ( <span class="number">1</span>,<span class="number">0</span> )) /d;</span><br><span class="line">    Vector3d xm = lambdavec ( <span class="number">0</span>,<span class="number">0</span> ) * f_ref;</span><br><span class="line">    Vector3d xn = t + lambdavec ( <span class="number">1</span>,<span class="number">0</span> ) * f2;</span><br><span class="line">    Vector3d d_esti = ( xm+xn ) / <span class="number">2.0</span>;  <span class="comment">// 三角化算得的深度向量</span></span><br><span class="line">    <span class="keyword">double</span> depth_estimation = d_esti.norm();   <span class="comment">// 深度值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算不确定性（以一个像素为误差）</span></span><br><span class="line">    Vector3d p = f_ref*depth_estimation;</span><br><span class="line">    Vector3d a = p - t; </span><br><span class="line">    <span class="keyword">double</span> t_norm = t.norm();</span><br><span class="line">    <span class="keyword">double</span> a_norm = a.norm();</span><br><span class="line">    <span class="keyword">double</span> alpha = <span class="built_in">acos</span>( f_ref.dot(t)/t_norm );</span><br><span class="line">    <span class="keyword">double</span> beta = <span class="built_in">acos</span>( -a.dot(t)/(a_norm*t_norm));</span><br><span class="line">    <span class="keyword">double</span> beta_prime = beta + <span class="built_in">atan</span>(<span class="number">1</span>/fx);</span><br><span class="line">    <span class="keyword">double</span> gamma = M_PI - alpha - beta_prime;</span><br><span class="line">    <span class="keyword">double</span> p_prime = t_norm * <span class="built_in">sin</span>(beta_prime) / <span class="built_in">sin</span>(gamma);</span><br><span class="line">    <span class="keyword">double</span> d_cov = p_prime - depth_estimation; </span><br><span class="line">    <span class="keyword">double</span> d_cov2 = d_cov*d_cov;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高斯融合</span></span><br><span class="line">    <span class="keyword">double</span> mu = depth.ptr&lt;<span class="keyword">double</span>&gt;( <span class="keyword">int</span>(pt_ref(<span class="number">1</span>,<span class="number">0</span>)) )[ <span class="keyword">int</span>(pt_ref(<span class="number">0</span>,<span class="number">0</span>)) ];</span><br><span class="line">    <span class="keyword">double</span> sigma2 = depth_cov.ptr&lt;<span class="keyword">double</span>&gt;( <span class="keyword">int</span>(pt_ref(<span class="number">1</span>,<span class="number">0</span>)) )[ <span class="keyword">int</span>(pt_ref(<span class="number">0</span>,<span class="number">0</span>)) ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> mu_fuse = (d_cov2*mu+sigma2*depth_estimation) / ( sigma2+d_cov2);</span><br><span class="line">    <span class="keyword">double</span> sigma_fuse2 = ( sigma2 * d_cov2 ) / ( sigma2 + d_cov2 );</span><br><span class="line">    </span><br><span class="line">    depth.ptr&lt;<span class="keyword">double</span>&gt;( <span class="keyword">int</span>(pt_ref(<span class="number">1</span>,<span class="number">0</span>)) )[ <span class="keyword">int</span>(pt_ref(<span class="number">0</span>,<span class="number">0</span>)) ] = mu_fuse; </span><br><span class="line">    depth_cov.ptr&lt;<span class="keyword">double</span>&gt;( <span class="keyword">int</span>(pt_ref(<span class="number">1</span>,<span class="number">0</span>)) )[ <span class="keyword">int</span>(pt_ref(<span class="number">0</span>,<span class="number">0</span>)) ] = sigma_fuse2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面这些太简单我就不注释了（其实是因为懒）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plotDepth</span><span class="params">(<span class="keyword">const</span> Mat&amp; depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    imshow( <span class="string">"depth"</span>, depth*<span class="number">0.4</span> );</span><br><span class="line">    waitKey(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showEpipolarMatch</span><span class="params">(<span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, <span class="keyword">const</span> Vector2d&amp; px_ref, <span class="keyword">const</span> Vector2d&amp; px_curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat ref_show, curr_show;</span><br><span class="line">    cv::cvtColor( ref, ref_show, CV_GRAY2BGR );</span><br><span class="line">    cv::cvtColor( curr, curr_show, CV_GRAY2BGR );</span><br><span class="line">    </span><br><span class="line">    cv::circle( ref_show, cv::Point2f(px_ref(<span class="number">0</span>,<span class="number">0</span>), px_ref(<span class="number">1</span>,<span class="number">0</span>)), <span class="number">5</span>, cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">250</span>), <span class="number">2</span>);</span><br><span class="line">    cv::circle( curr_show, cv::Point2f(px_curr(<span class="number">0</span>,<span class="number">0</span>), px_curr(<span class="number">1</span>,<span class="number">0</span>)), <span class="number">5</span>, cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">250</span>), <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    imshow(<span class="string">"ref"</span>, ref_show );</span><br><span class="line">    imshow(<span class="string">"curr"</span>, curr_show );</span><br><span class="line">    waitKey(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showEpipolarLine</span><span class="params">(<span class="keyword">const</span> Mat&amp; ref, <span class="keyword">const</span> Mat&amp; curr, <span class="keyword">const</span> Vector2d&amp; px_ref, <span class="keyword">const</span> Vector2d&amp; px_min_curr, <span class="keyword">const</span> Vector2d&amp; px_max_curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Mat ref_show, curr_show;</span><br><span class="line">    cv::cvtColor( ref, ref_show, CV_GRAY2BGR );</span><br><span class="line">    cv::cvtColor( curr, curr_show, CV_GRAY2BGR );</span><br><span class="line">    </span><br><span class="line">    cv::circle( ref_show, cv::Point2f(px_ref(<span class="number">0</span>,<span class="number">0</span>), px_ref(<span class="number">1</span>,<span class="number">0</span>)), <span class="number">5</span>, cv::Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">    cv::circle( curr_show, cv::Point2f(px_min_curr(<span class="number">0</span>,<span class="number">0</span>), px_min_curr(<span class="number">1</span>,<span class="number">0</span>)), <span class="number">5</span>, cv::Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">    cv::circle( curr_show, cv::Point2f(px_max_curr(<span class="number">0</span>,<span class="number">0</span>), px_max_curr(<span class="number">1</span>,<span class="number">0</span>)), <span class="number">5</span>, cv::Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">    cv::line( curr_show, Point2f(px_min_curr(<span class="number">0</span>,<span class="number">0</span>), px_min_curr(<span class="number">1</span>,<span class="number">0</span>)), Point2f(px_max_curr(<span class="number">0</span>,<span class="number">0</span>), px_max_curr(<span class="number">1</span>,<span class="number">0</span>)), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    imshow(<span class="string">"ref"</span>, ref_show );</span><br><span class="line">    imshow(<span class="string">"curr"</span>, curr_show );</span><br><span class="line">    waitKey(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解:</strong></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190827165724538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>位姿图(Pose Graph)优化</title>
    <url>/2019/05/28/%E4%BD%8D%E5%A7%BF%E5%9B%BE-Pose-Graph-%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="位姿图-Pose-Graph"><a href="#位姿图-Pose-Graph" class="headerlink" title="位姿图(Pose Graph)"></a>位姿图(Pose Graph)</h1><p>对于路标的优化，可能进行几次之后就已经收敛了，这时候每次插入一个帧都再次进行一次BA仿佛有点用力过猛。而且实际中，路标的数量远远大于位姿数量，因此BA在大规模建图时，它的计算量可能会越来越大，使得实时计算变得困难。</p><p>位姿图优化：仍然是用顶点表示优化变量，用边表示误差项。BA优化，是把相机位姿和路标点当成优化变量，把路标点的重投影误差当成误差项，只在相机位姿顶点和路标点之间建立边的连接。现在，为了减小运算量，我们只把相机位姿当成优化变量，让相邻的相机位姿之间用边连接起来。此时，边表达的就不是重投影误差了，而是两个相机位姿之间相对运动估计的误差。这个误差是用相机位姿顶点的值计算出的相对运动与用特征点法估计的相机运动之间的偏差，本质上与重投影误差没有区别，都是调整相机位姿使路标点在相机平面上的投影最准确。<br><img alt="## 1.1 Pose Graph 的意义" data-src="https://img-blog.csdnimg.cn/20190904094304577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">节点表示相机位姿，用$\xi_1,…,\xi_n$，而边则是两个位姿之间相对运动的估计，这个估计可能来自与特征点法或者是直接法，比如$\xi_i,\xi_j$之间一个相对运动$\Delta \xi_{ij}$，则：</p><a id="more"></a>

<script type="math/tex; mode=display">\Delta \xi_{ij} = \xi_i^{-1}\circ \xi_j = \ln(\exp((-\xi_i)^{\hat{}}) \exp (\xi_j^{\hat{}}))^{\hat{}}</script><p>或者按照李群的写法：</p>
<script type="math/tex; mode=display">T_{ij} = T_{i}^{-1} T_j.</script><p>实际中上式不会精确成立，因此我们需要设立最小二乘误差，然后讨论关于优化变量的导数。这里我们将上式的Tij移到右侧，为了让其满足误差最小为0的设定，加上一个ln:</p>
<script type="math/tex; mode=display">e_{ij} = \ln(T_{ij}^{-1}T_i^{-1}T_j)^{\hat{}} = \ln(\exp((-\xi_{ij})^{\hat{}})\exp((-\xi_{i})^{\hat{}})\exp(\xi_j^{\hat{}}))^{\hat {}}</script><p>优化变量有两个：$\xi_i,\xi_j$，需要求$e_{ij}$关于这两个变量的导数。按照李代数的求导方式，给$\xi_i,\xi_j$各一个左扰动$\delta \xi_i,\delta \xi_j$，于是误差变为：</p>
<script type="math/tex; mode=display">\hat e_{ij} = \ln(T_{ij}^{-1}T_i^{-1}\exp((-\delta \xi_i)^{\hat{}})\exp(\delta\xi_j)^{\hat{}}T_j)^{\hat{}}</script><p>我们希望将扰动项移到左侧或者右侧，需要利用到一个伴随性质：</p>
<script type="math/tex; mode=display">\exp((Ad(T)\xi)^{\hat{}}) = T\exp(\xi^{\hat{}})T^{-1}.</script><p>稍加改变，得到：</p>
<script type="math/tex; mode=display">\exp(\xi^{\hat{}})T = T\exp((Ad(T^{-1})\xi)^{\hat{}}).</script><p>注：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190904170342235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>通过引入一个伴随项，我们能够交换扰动项左右侧的T，利用它可以将扰动项移到最右，导出右乘形式的雅科比矩阵：</p>
<script type="math/tex; mode=display">\begin{aligned}
\hat e_{ij} &=\ln\left (T_{ij}^{-1}T_i^{-1}\exp((-\delta\xi_i)^{\hat{}})\exp(\delta\xi_j^{\hat{}})T_j\right)^{\hat{}}\\
&=\ln\left(T_{ij}^{-1}T_i^{-1}T_j \exp\left((-Ad(A_j^{-1})\delta\xi_i)^{\hat{}}\right)\exp\left((Ad(T_j^{-1})\delta \xi_j)^{\hat{}}\right)\right)\\
&\approx \ln(T_{ij}^{-1}T_i^{-1}T_j[I - (Ad(T_j^{-1})\delta \xi_i)^{\hat{}} + (Ad(T_j^{-1})\delta\xi_j)^{\hat{}}])^{\hat{}}\\
&\approx e_{ij}+\frac{\partial e_{ij}}{\partial \delta \xi_i}\delta \xi_i + \frac{\partial e_{ij}}{\partial \delta \xi_j}\delta \xi_j
\end{aligned}</script><p>因此，按照李代数上的求导规则，我们求出了误差关于两个位姿的雅科比矩阵。关于$T_i$的：</p>
<script type="math/tex; mode=display">\frac{\partial e_{ij}}{\partial \delta \xi_i} = -\mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1}).</script><p>关于Tj的：</p>
<script type="math/tex; mode=display">\frac{\partial e_{ij}}{\partial \delta \xi_i} = \mathcal{J}_r^{-1}(e_{ij})Ad(T_j^{-1}).</script><p>由于李群（se(3)）上的雅科比矩阵形式过于复杂，我们通常取近似。如果误差接近于0，可以取近似：</p>
<script type="math/tex; mode=display">\mathcal{J}_r^{-1}(e_{ij}) \approx I + \frac 1 2 \begin{bmatrix}
\phi _e ^{\hat{}} & \rho _e^{\hat{}}\\
0 & \phi _e ^{\hat{}}
\end{bmatrix}.</script><p>所有的位姿顶点和位姿——位姿边构成了一个图优化,本质上是一个最小二乘问题,优化变量为各个顶点的位姿,边来自于位姿观测约束。记$\varepsilon$为所有边的集合,那么总体目标函数为:</p>
<script type="math/tex; mode=display">\min_\xi \frac{1}{2} \sum_{i,j \in \varepsilon} e_{ij}^T\Sigma_{ij}^{-1}e_{ij}.</script><p>依然可以利用列文伯格或者高斯牛顿法来解决这个问题。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><ol>
<li><strong>g2o 原生位姿图</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/slam3d/types_slam3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/cholmod/linear_solver_cholmod.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment"> * 本程序演示如何用g2o solver进行位姿图优化</span></span><br><span class="line"><span class="comment"> * sphere.g2o是人工生成的一个Pose graph，我们来优化它。</span></span><br><span class="line"><span class="comment"> * 尽管可以直接通过load函数读取整个图，但我们还是自己来实现读取代码，以期获得更深刻的理解</span></span><br><span class="line"><span class="comment"> * 这里使用g2o/types/slam3d/中的SE3表示位姿，它实质上是四元数而非李代数.</span></span><br><span class="line"><span class="comment"> * **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Usage: pose_graph_g2o_SE3 sphere.g2o"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">( argv[<span class="number">1</span>] )</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( !fin )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"file "</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">" does not exist."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>,<span class="number">6</span>&gt;&gt; Block;  <span class="comment">// 6x6 BlockSolver</span></span><br><span class="line">    Block::LinearSolverType* linearSolver = <span class="keyword">new</span> g2o::LinearSolverCholmod&lt;Block::PoseMatrixType&gt;(); <span class="comment">// 线性方程求解器</span></span><br><span class="line">    Block* solver_ptr = <span class="keyword">new</span> Block( linearSolver );      <span class="comment">// 矩阵块求解器</span></span><br><span class="line">    <span class="comment">// 梯度下降方法，从GN, LM, DogLeg 中选</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg( solver_ptr );</span><br><span class="line">    g2o::SparseOptimizer optimizer;     <span class="comment">// 图模型</span></span><br><span class="line">    optimizer.setAlgorithm( solver );   <span class="comment">// 设置求解器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexCnt = <span class="number">0</span>, edgeCnt = <span class="number">0</span>; <span class="comment">// 顶点和边的数量</span></span><br><span class="line">    <span class="keyword">while</span> ( !fin.eof() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        fin&gt;&gt;name;</span><br><span class="line">        <span class="keyword">if</span> ( name == <span class="string">"VERTEX_SE3:QUAT"</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3 顶点</span></span><br><span class="line">            g2o::VertexSE3* v = <span class="keyword">new</span> g2o::VertexSE3();</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            fin&gt;&gt;index;</span><br><span class="line">            v-&gt;setId( index );</span><br><span class="line">            v-&gt;read(fin);</span><br><span class="line">            optimizer.addVertex(v);</span><br><span class="line">            vertexCnt++;</span><br><span class="line">            <span class="keyword">if</span> ( index==<span class="number">0</span> )</span><br><span class="line">                v-&gt;setFixed(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( name==<span class="string">"EDGE_SE3:QUAT"</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3-SE3 边</span></span><br><span class="line">            g2o::EdgeSE3* e = <span class="keyword">new</span> g2o::EdgeSE3();</span><br><span class="line">            <span class="keyword">int</span> idx1, idx2;     <span class="comment">// 关联的两个顶点</span></span><br><span class="line">            fin&gt;&gt;idx1&gt;&gt;idx2;</span><br><span class="line">            e-&gt;setId( edgeCnt++ );</span><br><span class="line">            e-&gt;setVertex( <span class="number">0</span>, optimizer.vertices()[idx1] );</span><br><span class="line">            e-&gt;setVertex( <span class="number">1</span>, optimizer.vertices()[idx2] );</span><br><span class="line">            e-&gt;read(fin);</span><br><span class="line">            optimizer.addEdge(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !fin.good() ) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"read total "</span>&lt;&lt;vertexCnt&lt;&lt;<span class="string">" vertices, "</span>&lt;&lt;edgeCnt&lt;&lt;<span class="string">" edges."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"prepare optimizing ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.setVerbose(<span class="literal">true</span>);</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"calling optimizing ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.optimize(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"saving optimization results ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.save(<span class="string">"result.g2o"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><strong>李代数上的位姿图优化</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_binary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/cholmod/linear_solver_cholmod.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/se3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sophus/so3.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> Sophus::SE3;</span><br><span class="line"><span class="keyword">using</span> Sophus::SO3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment"> * 本程序演示如何用g2o solver进行位姿图优化</span></span><br><span class="line"><span class="comment"> * sphere.g2o是人工生成的一个Pose graph，我们来优化它。</span></span><br><span class="line"><span class="comment"> * 尽管可以直接通过load函数读取整个图，但我们还是自己来实现读取代码，以期获得更深刻的理解</span></span><br><span class="line"><span class="comment"> * 本节使用李代数表达位姿图，节点和边的方式为自定义</span></span><br><span class="line"><span class="comment"> * **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">6</span>,<span class="number">6</span>&gt; Matrix6d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定误差求J_R^&#123;-1&#125;的近似</span></span><br><span class="line"><span class="function">Matrix6d <span class="title">JRInv</span><span class="params">( SE3 e )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix6d J;</span><br><span class="line">    J.block(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>) = SO3::hat(e.so3().<span class="built_in">log</span>());</span><br><span class="line">    J.block(<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>) = SO3::hat(e.translation());</span><br><span class="line">    J.block(<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>) = Eigen::Matrix3d::Zero(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    J.block(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>) = SO3::hat(e.so3().<span class="built_in">log</span>());</span><br><span class="line">    J = J*<span class="number">0.5</span> + Matrix6d::Identity();</span><br><span class="line">    <span class="keyword">return</span> J;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李代数顶点</span></span><br><span class="line"><span class="keyword">typedef</span> Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">6</span>, <span class="number">1</span>&gt; Vector6d;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexSE3LieAlgebra</span>:</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">6</span>, SE3&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span> <span class="params">( istream&amp; is )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++ )</span><br><span class="line">            is&gt;&gt;data[i];</span><br><span class="line">        setEstimate ( SE3 (</span><br><span class="line">                Eigen::Quaterniond ( data[<span class="number">6</span>],data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>] ),</span><br><span class="line">                Eigen::Vector3d ( data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>] )</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span> <span class="params">( ostream&amp; os )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os&lt;&lt;id()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        Eigen::Quaterniond q = _estimate.unit_quaternion();</span><br><span class="line">        os&lt;&lt;_estimate.translation().transpose()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        os&lt;&lt;q.coeffs()[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;q.coeffs()[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;q.coeffs()[<span class="number">2</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;q.coeffs()[<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate = Sophus::SE3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左乘更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">double</span>* update )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sophus::<span class="function">SE3 <span class="title">up</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Sophus::SO3 ( update[<span class="number">3</span>], update[<span class="number">4</span>], update[<span class="number">5</span>] ),</span></span></span><br><span class="line"><span class="function"><span class="params">            Eigen::Vector3d ( update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>] )</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">        _estimate = up*_estimate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个李代数节点之边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeSE3LieAlgebra</span>:</span> <span class="keyword">public</span> g2o::BaseBinaryEdge&lt;<span class="number">6</span>, SE3, VertexSE3LieAlgebra, VertexSE3LieAlgebra&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span> <span class="params">( istream&amp; is )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++ )</span><br><span class="line">            is&gt;&gt;data[i];</span><br><span class="line">        Eigen::<span class="function">Quaterniond <span class="title">q</span> <span class="params">( data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>] )</span></span>;</span><br><span class="line">        q.normalize();</span><br><span class="line">        setMeasurement (</span><br><span class="line">            Sophus::SE3 ( q, Eigen::Vector3d ( data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>] ) ) </span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;information().rows() &amp;&amp; is.good(); i++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j=i; j&lt;information().cols() &amp;&amp; is.good(); j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                is &gt;&gt; information() ( i,j );</span><br><span class="line">                <span class="keyword">if</span> ( i!=j )</span><br><span class="line">                    information() ( j,i ) =information() ( i,j );</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span> <span class="params">( ostream&amp; os )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VertexSE3LieAlgebra* v1 = <span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra*&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">        VertexSE3LieAlgebra* v2 = <span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra*&gt; (_vertices[<span class="number">1</span>]);</span><br><span class="line">        os&lt;&lt;v1-&gt;id()&lt;&lt;<span class="string">" "</span>&lt;&lt;v2-&gt;id()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        SE3 m = _measurement;</span><br><span class="line">        Eigen::Quaterniond q = m.unit_quaternion();</span><br><span class="line">        os&lt;&lt;m.translation().transpose()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        os&lt;&lt;q.coeffs()[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;q.coeffs()[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;q.coeffs()[<span class="number">2</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;q.coeffs()[<span class="number">3</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// information matrix </span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;information().rows(); i++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j=i; j&lt;information().cols(); j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                os &lt;&lt; information() ( i,j ) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        os&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 误差计算与书中推导一致</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sophus::SE3 v1 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra*&gt; (_vertices[<span class="number">0</span>]))-&gt;estimate();</span><br><span class="line">        Sophus::SE3 v2 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra*&gt; (_vertices[<span class="number">1</span>]))-&gt;estimate();</span><br><span class="line">        _error = (_measurement.inverse()*v1.inverse()*v2).<span class="built_in">log</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 雅可比计算</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sophus::SE3 v1 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra*&gt; (_vertices[<span class="number">0</span>]))-&gt;estimate();</span><br><span class="line">        Sophus::SE3 v2 = (<span class="keyword">static_cast</span>&lt;VertexSE3LieAlgebra*&gt; (_vertices[<span class="number">1</span>]))-&gt;estimate();</span><br><span class="line">        Matrix6d J = JRInv(SE3::<span class="built_in">exp</span>(_error));</span><br><span class="line">        <span class="comment">// 尝试把J近似为I？</span></span><br><span class="line">        _jacobianOplusXi = - J* v2.inverse().Adj();</span><br><span class="line">        _jacobianOplusXj = J*v2.inverse().Adj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Usage: pose_graph_g2o_SE3_lie sphere.g2o"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span> <span class="params">( argv[<span class="number">1</span>] )</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( !fin )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"file "</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">" does not exist."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>,<span class="number">6</span>&gt;&gt; Block;  <span class="comment">// BlockSolver为6x6</span></span><br><span class="line">    Block::LinearSolverType* linearSolver = <span class="keyword">new</span> g2o::LinearSolverCholmod&lt;Block::PoseMatrixType&gt;(); <span class="comment">// 线性方程求解器</span></span><br><span class="line">    Block* solver_ptr = <span class="keyword">new</span> Block ( linearSolver );     <span class="comment">// 矩阵块求解器</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg ( solver_ptr );</span><br><span class="line">    <span class="comment">// 试试G-N或Dogleg？</span></span><br><span class="line">    <span class="comment">// g2o::OptimizationAlgorithmDogleg* solver = new g2o::OptimizationAlgorithmDogleg( solver_ptr );</span></span><br><span class="line">    <span class="comment">// g2o::OptimizationAlgorithmGaussNewton* solver = new g2o::OptimizationAlgorithmGaussNewton ( solver_ptr );</span></span><br><span class="line">    </span><br><span class="line">    g2o::SparseOptimizer optimizer;     <span class="comment">// 图模型</span></span><br><span class="line">    optimizer.setAlgorithm ( solver );  <span class="comment">// 设置求解器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexCnt = <span class="number">0</span>, edgeCnt = <span class="number">0</span>; <span class="comment">// 顶点和边的数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;VertexSE3LieAlgebra*&gt; vectices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;EdgeSE3LieAlgebra*&gt; edges;</span><br><span class="line">    <span class="keyword">while</span> ( !fin.eof() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        fin&gt;&gt;name;</span><br><span class="line">        <span class="keyword">if</span> ( name == <span class="string">"VERTEX_SE3:QUAT"</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 顶点</span></span><br><span class="line">            VertexSE3LieAlgebra* v = <span class="keyword">new</span> VertexSE3LieAlgebra();</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            fin&gt;&gt;index;</span><br><span class="line">            v-&gt;setId( index );</span><br><span class="line">            v-&gt;read(fin);</span><br><span class="line">            optimizer.addVertex(v);</span><br><span class="line">            vertexCnt++;</span><br><span class="line">            vectices.push_back(v);</span><br><span class="line">            <span class="keyword">if</span> ( index==<span class="number">0</span> )</span><br><span class="line">                v-&gt;setFixed(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( name==<span class="string">"EDGE_SE3:QUAT"</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SE3-SE3 边</span></span><br><span class="line">            EdgeSE3LieAlgebra* e = <span class="keyword">new</span> EdgeSE3LieAlgebra();</span><br><span class="line">            <span class="keyword">int</span> idx1, idx2;     <span class="comment">// 关联的两个顶点</span></span><br><span class="line">            fin&gt;&gt;idx1&gt;&gt;idx2;</span><br><span class="line">            e-&gt;setId( edgeCnt++ );</span><br><span class="line">            e-&gt;setVertex( <span class="number">0</span>, optimizer.vertices()[idx1] );</span><br><span class="line">            e-&gt;setVertex( <span class="number">1</span>, optimizer.vertices()[idx2] );</span><br><span class="line">            e-&gt;read(fin);</span><br><span class="line">            optimizer.addEdge(e);</span><br><span class="line">            edges.push_back(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !fin.good() ) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"read total "</span>&lt;&lt;vertexCnt&lt;&lt;<span class="string">" vertices, "</span>&lt;&lt;edgeCnt&lt;&lt;<span class="string">" edges."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"prepare optimizing ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.setVerbose(<span class="literal">true</span>);</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"calling optimizing ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.optimize(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"saving optimization results ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 因为用了自定义顶点且没有向g2o注册，这里保存自己来实现</span></span><br><span class="line">    <span class="comment">// 伪装成 SE3 顶点和边，让 g2o_viewer 可以认出</span></span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"result_lie.g2o"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> ( VertexSE3LieAlgebra* v:vectices )</span><br><span class="line">    &#123;</span><br><span class="line">        fout&lt;&lt;<span class="string">"VERTEX_SE3:QUAT "</span>;</span><br><span class="line">        v-&gt;write(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( EdgeSE3LieAlgebra* e:edges )</span><br><span class="line">    &#123;</span><br><span class="line">        fout&lt;&lt;<span class="string">"EDGE_SE3:QUAT "</span>;</span><br><span class="line">        e-&gt;write(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>视觉slam十四讲 8.视觉里程计2</title>
    <url>/2019/05/25/%E8%A7%86%E8%A7%89slam%E5%8D%81%E5%9B%9B%E8%AE%B2-8-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A12/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-直接法的引出"><a href="#1-直接法的引出" class="headerlink" title="1 直接法的引出"></a>1 直接法的引出</h1><ol>
<li><p>特征点法的缺点：</p>
<ul>
<li>关键点的提取和描述子计算非常耗时</li>
<li>使用特征点忽略了除特征点以外的其他信息</li>
<li>相机可能运动到特征点缺失的地方，这些地方没有明显的纹理信息</li>
</ul>
</li>
<li><p>克服这些缺点的思路</p>
<ul>
<li>保留特征点，但是只计算关键点，不计算描述子，使用光流法（Optical Flow）来跟踪特征点的运动</li>
<li>只计算关键点，不计算描述子，使用直接法（Direct Method）计算特征点在下一个时刻出现的位置。</li>
<li>不计算关键字，也不计算描述子，根据像素灰度差异，直接计算相机运动</li>
</ul>
<p>第一种方法仍然使用特征点，只是把匹配描述子替换成光流跟踪，估计相机运动仍然使用对极几何、PnP或者ICP算法<br>提取特征点，而在后两种中，会根据图像的<strong>像素灰度信息</strong>来计算相机运动，特闷都称为<strong>直接法</strong></p>
<ol>
<li>特征点法和直接法区别：</li>
</ol>
<ul>
<li>特征点法：<strong>最小化重投影误差</strong>（Reprojection Error）优化相机运动，需要精确地知道空间点在两个相机中投影后的像素位置，这也是需要匹配跟踪的原因，但是计算量大。</li>
<li>直接法：不需要知道点和点的匹配关系，通过<strong>最小化光度误差</strong>（Photometric Error）</li>
</ul>
<ol>
<li>直接法根据 像素的亮度信息，估计相机的运动，可以完全不用计算关键点和描述子，于是，既避免了 特征的计算时间，也避免了特征缺失的情况。只要场景中存在明暗变化（可以是渐变，不形成局部的图像梯度），直接法就能工作。</li>
<li>根据使用像素的数量，直接法分为稀疏、稠密和 半稠密三种。相比于特征点法只能重构稀疏特征点（稀疏地图），直接法还具有恢复稠密或 半稠密结构的能力。</li>
</ol>
<h1 id="2-光流（Optical-Flow"><a href="#2-光流（Optical-Flow" class="headerlink" title="2 光流（Optical Flow)"></a>2 光流（Optical Flow)</h1></li>
<li><p>直接法是从光流演变而来的，光流描述了像素 在图像中的运动，而直接法则附带着一个相机运动模型。</p>
<p>（1）计算部分像素运动的稀疏光流<br>（2）计算所有像素运动的稠密光流</p>
</li>
</ol><a id="more"></a>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190625221823922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p> <strong>Lucas-Kanade光流</strong></p>
<ol>
<li><p>引入 光流法的基本假设：</p>
<p> <strong>灰度不变假设</strong>：同一个空间点的像素灰度值，在各个图像中是固定不变的。</p>
<script type="math/tex; mode=display">I(x+dx,y+dy,t+dt)=I(x,y,t)</script><p> 对左边进行泰勒一阶展开,保留一阶项</p>
<script type="math/tex; mode=display">I(x+dx,y+dy,t+dt)\approx I(x,y,t)+\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt</script><script type="math/tex; mode=display">\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt=0</script><p> 两边同时除以dt,得：</p>
<script type="math/tex; mode=display">\frac{\partial I}{\partial x}\frac{dx}{dt}+\frac{\partial I}{\partial y}\frac{dy}{dt}=-\frac{\partial I}{\partial t}</script><p> dx/dt 为像素在 x 轴上运动速度，而 dy/dt 为 y 轴速度，把它们记为 u, v。同 时$∂I/∂x$为图像在该点处 x 方向的梯度，另一项则是在 y 方向的梯度，记为 $I_{x}, I_{y}$。图像灰度对时间的变化量记为 $I_{t}$,写成矩阵形式：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
I_{x} & 
I_{y}\end{bmatrix}\begin{bmatrix}
u\\ 
v\end{bmatrix}=-I_{t}</script><p> <strong>运动相同假设</strong>：设某一个窗 口内的像素具有相同的运动。</p>
<p> 考虑一个大小ω∗ω窗口，含有$ω^{2}$个像素，得到$ω^{2}$个方程:</p>
<script type="math/tex; mode=display">\begin{bmatrix}
I_{x} & 
I_{y}\end{bmatrix}_{k}\begin{bmatrix}
u\\ 
v\end{bmatrix}=-I_{tk},\quad k=1,2...,ω^{2}.</script></li>
</ol>
<p>记：</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
\begin{bmatrix}
I_{x} & 
I_{y}\end{bmatrix}_{1}\\ 
\vdots \\ 
\begin{bmatrix}
I_{x} & 
I_{y}\end{bmatrix}_{k}\end{bmatrix},b=\begin{bmatrix}
I_{t1}\\ 
\vdots \\ 
I_{tk}\end{bmatrix}</script><p>整个方程为：</p>
<script type="math/tex; mode=display">A\begin{bmatrix}
u\\ 
v\end{bmatrix}=-b</script><p>这是一个关于 u, v 的超定线性方程，传统解法是求最小二乘解</p>
<script type="math/tex; mode=display">\begin{bmatrix}
u\\ 
v\end{bmatrix}^{*}=-(A^TA)^{-1}A^{T}b</script><p>可以得到像素在图像间的运动$u,v$,由于像素梯度仅在局部有效，如果一次迭代不够好，会多次迭代。在SLAM中，LK光流长被用来估计角点的运动。</p>
<h1 id="3-实践：LK光流"><a href="#3-实践：LK光流" class="headerlink" title="3 实践：LK光流"></a>3 实践：LK光流</h1><h2 id="3-1-使用TMU公开数据集"><a href="#3-1-使用TMU公开数据集" class="headerlink" title="3.1 使用TMU公开数据集"></a>3.1 使用TMU公开数据集</h2><h2 id="3-2-使用LK光流"><a href="#3-2-使用LK光流" class="headerlink" title="3.2 使用LK光流"></a>3.2 使用LK光流</h2><ul>
<li>角点处稳定，边缘处会滑动，<strong>沿边缘移动时特征快的内容基本不变</strong>。<ul>
<li>匹配描述子的方法在相机运动较大时仍能成功， 而光流必须要求相机运动是微小的。从这方面来说，光流的鲁棒性比描述子差一些。。</li>
<li>LK光流跟踪能够直接得到特征点的对应关系，大多数只会碰到特征点跟丢，不太会遇到误匹配。</li>
</ul>
</li>
<li>可以通过光流跟踪的特征点，用PnP、ICP或对极几何来估计相机运动。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/video/tracking.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    if ( argc != 2 )</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;"usage: useLK path_to_dataset"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    string path_to_dataset = argv[1];</span></span><br><span class="line"><span class="comment">//    string associate_file = path_to_dataset + "/associate.txt";</span></span><br><span class="line">    <span class="built_in">string</span> path_to_dataset =<span class="string">"/home/xiaohu//slambook-master/ch8/rgbd_dataset_freiburg1_desk"</span>;</span><br><span class="line">    <span class="built_in">string</span> associate_file = path_to_dataset+<span class="string">"/associate.txt"</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">( associate_file )</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( !fin ) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"I cann't find associate.txt!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    <span class="built_in">list</span>&lt; cv::Point2f &gt; keypoints;      <span class="comment">// 因为要删除跟踪失败的点，使用list</span></span><br><span class="line">    cv::Mat color, depth, last_color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> index=<span class="number">0</span>; index&lt;<span class="number">100</span>; index++ )</span><br><span class="line">    &#123;</span><br><span class="line">        fin&gt;&gt;time_rgb&gt;&gt;rgb_file&gt;&gt;time_depth&gt;&gt;depth_file;</span><br><span class="line">        color = cv::imread( path_to_dataset+<span class="string">"/"</span>+rgb_file );</span><br><span class="line">        depth = cv::imread( path_to_dataset+<span class="string">"/"</span>+depth_file, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> (index ==<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对第一帧提取FAST特征点</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;cv::KeyPoint&gt; kps;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::create();</span><br><span class="line">            detector-&gt;detect( color, kps );</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">auto</span> kp:kps )</span><br><span class="line">                keypoints.push_back( kp.pt );</span><br><span class="line">            last_color = color;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( color.data==<span class="literal">nullptr</span> || depth.data==<span class="literal">nullptr</span> )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 对其他帧用LK跟踪特征点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; next_keypoints; </span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; prev_keypoints;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> kp:keypoints )</span><br><span class="line">            prev_keypoints.push_back(kp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; status;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; error; </span><br><span class="line">        chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">        cv::calcOpticalFlowPyrLK( last_color, color, prev_keypoints, next_keypoints, status, error );</span><br><span class="line">        chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">        chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;( t2-t1 );</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"LK Flow use time："</span>&lt;&lt;time_used.count()&lt;&lt;<span class="string">" seconds."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 把跟丢的点删掉</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter=keypoints.begin(); iter!=keypoints.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( status[i] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                iter = keypoints.erase(iter);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *iter = next_keypoints[i];</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"tracked keypoints: "</span>&lt;&lt;keypoints.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (keypoints.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"all keypoints are lost."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 画出 keypoints</span></span><br><span class="line">        cv::Mat img_show = color.clone();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> kp:keypoints )</span><br><span class="line">            cv::circle(img_show, kp, <span class="number">10</span>, cv::Scalar(<span class="number">0</span>, <span class="number">240</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        cv::imshow(<span class="string">"corners"</span>, img_show);</span><br><span class="line">        cv::waitKey(<span class="number">0</span>);</span><br><span class="line">        last_color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-直接法"><a href="#4-直接法" class="headerlink" title="4 直接法"></a>4 直接法</h1><h2 id="4-1-直接法的推导"><a href="#4-1-直接法的推导" class="headerlink" title="4.1 直接法的推导"></a>4.1 直接法的推导</h2><p> 记P的世界坐标为$[X,Y,Z]$,它在两个相机上成像，记非齐次像素坐标为$p_{1}$,$p_{12}$。<br> 目标是求第一个相机到第二个相 机的相对位姿变换。我们以第一个相机为参照系，设第二个相机旋转和平移为 R, t（对应李代数为 ξ）。<br> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190626225849655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<script type="math/tex; mode=display">p_{1}=\begin{bmatrix}
u\\ 
v\\ 
1\end{bmatrix}_{1}=\frac{1}{Z_{1}}KP</script><script type="math/tex; mode=display">p_{1}=\begin{bmatrix}
u\\ 
v\\ 
1\end{bmatrix}_{2}=\frac{1}{Z_{1}}K(RP+t)=\frac{1}{Z_{2}}K(exp(\xi ^\wedge )P)_{1:3}</script><p>特征点法中，通过匹配描述子，知道了 p1, p2 的像素位置，可以计 算重投影的位置。<br>直接法中，由于没有特征匹配，无从知道哪一个 p2 与 p1 对应着同一个点<br>直接法的思路是根据当前相机的位姿估计值，来寻找 p2 的位置。但若相机位姿不够好，p2 的外观和 p1 会有明显差别。于是，为了减小这个差别，我们优化相机的位姿，来寻找与 p1 更相似的 p2。这同样可以通过解一个优化问题，但此时最小化的不是重投影误差，而是<strong>光度误差</strong>，也就是 P 的两个像的亮度误差:</p>
<script type="math/tex; mode=display">e=I_{1}\left ( p_{1} \right )-I_{2}\left ( p_{2} \right )</script><p>优化目标为该误差的二范数：</p>
<script type="math/tex; mode=display">\min_{ϵ}J(\xi )=\left \| e \right \|^{2}</script><p>仍是<strong>基于灰度不变假设</strong>，许多个（比如 N 个）空间点 $P_{i}$，那么，整 个相机位姿估计问题变为：</p>
<script type="math/tex; mode=display">\min_{ϵ}J(\xi )=\sum_{i=1}^{N}e^{T}_{i}e_{i},\quad e_{i}=I_{1}(p_{1,i})-I_{2}(p_{2,i})</script><p>优化变量：相机位姿$\xi$,误差 e 是如何随着相机位姿 ξ 变化的，需要分析它们的导数关系,因此，使用李代数上的扰动模型。我 们给 $exp(ξ)$ 左乘一个小扰动 $exp(δξ)$，得：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190626220949888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>q 为 P 在扰动之后，位于第二个相机坐标系下的坐标，而 u 为它的像素坐标。利用一阶泰勒展开，有：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190626222221875.png"></p>
<ol>
<li>∂I2/∂u 为 u 处的像素梯度；</li>
<li>∂u/∂q 为投影方程关于相机坐标系下的三维点的导数。记$q=[X,Y,Z]$<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190626222350574.png"></li>
<li><p>∂q/∂δξ 为变换后的三维点对变换的导数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190626222447792.png">后两项合并:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190626222510413.png"><br>对于 N 个点的问题，我们可以用这种方法计算优化问题的雅可比矩阵，然后使用 高斯牛顿法或列文伯格——马夸尔特方法计算增量，迭代求解。</p>
<h2 id="4-2-直接法的讨论"><a href="#4-2-直接法的讨论" class="headerlink" title="4.2 直接法的讨论"></a>4.2 直接法的讨论</h2><p>在上面的推导中，P是一个已知位置的空间点，在RGB-D相机下，我们可以把任意像素反投影到三维空间，然后投影到下一个图像中。如果在单目相机中，可以使用已经估计好位置的特征点（虽然是特征点，但直接法里是可以避免计算描述子的）。根据P的来源，把直接法进行分类：</p>
<ul>
<li>P来自于<strong>稀疏特征点</strong>，称之为<strong>稀疏直接法</strong>。通常我们使用数百个特征点，并且会像L-K光流那样，假设它周围像素也是不变的。这种稀疏直接法速度不必计算描述子，并且只使用数百个像素，因此速度最快，但只能计算稀疏的重构。</li>
<li>P来自<strong>部分像素</strong>, 这称之为<strong>半稠密（Semi-Dense）的直接法</strong>，考虑只使用带有梯度的像素点，舍弃像素梯度不明显的地方，可以重构一个半稠密结构。</li>
<li>P为<strong>所有像素</strong>，称为<strong>稠密直接法</strong>。稠密重构需要计算所有像素（一般几十万至几百万个），因此多数不能在现有的 CPU上实时计算，需要GPU的加速。</li>
</ul>
</li>
</ol>
<p>可以看到，从稀疏到稠密重构，都可以用直接法来计算。它们的计算量是逐渐增长的。<strong>稀疏方法可以快速地求解相机位姿，而稠密方法可以建立完整地图</strong>。</p>
<h1 id="5-实践：RGB-D的直接法"><a href="#5-实践：RGB-D的直接法" class="headerlink" title="5 实践：RGB-D的直接法"></a>5 实践：RGB-D的直接法</h1><p> 图优化：误差项为单个像素的光度误差。由于 g2o 中本身没有计算光度误差的边，我们需要 自己定义一种新的边。在上述的建模中，直接法图优化问题是由一个相机位姿顶点与许多条一元边组成的。</p>
<h2 id="5-1-稀梳直接法"><a href="#5-1-稀梳直接法" class="headerlink" title="5.1 稀梳直接法"></a>5.1 稀梳直接法</h2> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/robust_kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/types/sba/types_six_dof_expmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> g2o;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment"> * 本节演示了RGBD上的稀疏直接法 </span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次测量的值，包括一个世界坐标系下三维点与一个灰度值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Measurement</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Measurement ( Eigen::Vector3d p, <span class="keyword">float</span> g ) : pos_world ( p ), grayscale ( g ) &#123;&#125;</span><br><span class="line">    Eigen::Vector3d pos_world;</span><br><span class="line">    <span class="keyword">float</span> grayscale;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Eigen::<span class="function">Vector3d <span class="title">project2Dto3D</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, <span class="keyword">float</span> scale )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> zz = <span class="keyword">float</span> ( d ) /scale;</span><br><span class="line">    <span class="keyword">float</span> xx = zz* ( x-cx ) /fx;</span><br><span class="line">    <span class="keyword">float</span> yy = zz* ( y-cy ) /fy;</span><br><span class="line">    <span class="keyword">return</span> Eigen::Vector3d ( xx, yy, zz );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Eigen::<span class="function">Vector2d <span class="title">project3Dto2D</span> <span class="params">( <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> u = fx*x/z+cx;</span><br><span class="line">    <span class="keyword">float</span> v = fy*y/z+cy;</span><br><span class="line">    <span class="keyword">return</span> Eigen::Vector2d ( u,v );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接法估计位姿</span></span><br><span class="line"><span class="comment">// 输入：测量值（空间点的灰度），新的灰度图，相机内参； 输出：相机位姿</span></span><br><span class="line"><span class="comment">// 返回：true为成功，false失败</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">poseEstimationDirect</span> <span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Measurement&gt;&amp; measurements, cv::Mat* gray, Eigen::Matrix3f&amp; intrinsics, Eigen::Isometry3d&amp; Tcw )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// project a 3d point into an image plane, the error is photometric error</span></span><br><span class="line"><span class="comment">// an unary edge with one vertex SE3Expmap (the pose of camera)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeSE3ProjectDirect</span>:</span> <span class="keyword">public</span> BaseUnaryEdge&lt; <span class="number">1</span>, <span class="keyword">double</span>, VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line"></span><br><span class="line">    EdgeSE3ProjectDirect() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    EdgeSE3ProjectDirect ( Eigen::Vector3d point, <span class="keyword">float</span> fx, <span class="keyword">float</span> fy, <span class="keyword">float</span> cx, <span class="keyword">float</span> cy, cv::Mat* image )</span><br><span class="line">        : x_world_ ( point ), fx_ ( fx ), fy_ ( fy ), cx_ ( cx ), cy_ ( cy ), image_ ( image )</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> VertexSE3Expmap* v  =<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexSE3Expmap*&gt; ( _vertices[<span class="number">0</span>] );</span><br><span class="line">        <span class="comment">//.map函数，它的功能是把世界坐标系下三维点变换到相机坐标系，函数在g2o/types/sim3/sim3.h</span></span><br><span class="line">        Eigen::Vector3d x_local = v-&gt;estimate().<span class="built_in">map</span> ( x_world_ );</span><br><span class="line">        <span class="keyword">float</span> x = x_local[<span class="number">0</span>]*fx_/x_local[<span class="number">2</span>] + cx_;</span><br><span class="line">        <span class="keyword">float</span> y = x_local[<span class="number">1</span>]*fy_/x_local[<span class="number">2</span>] + cy_;</span><br><span class="line">        <span class="comment">// check x,y is in the image</span></span><br><span class="line">        <span class="keyword">if</span> ( x<span class="number">-4</span>&lt;<span class="number">0</span> || ( x+<span class="number">4</span> ) &gt;image_-&gt;cols || ( y<span class="number">-4</span> ) &lt;<span class="number">0</span> || ( y+<span class="number">4</span> ) &gt;image_-&gt;rows )</span><br><span class="line">        &#123;</span><br><span class="line">            _error ( <span class="number">0</span>,<span class="number">0</span> ) = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;setLevel ( <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _error ( <span class="number">0</span>,<span class="number">0</span> ) = getPixelValue ( x,y ) - _measurement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// plus in manifold</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( level() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            _jacobianOplusXi = Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">6</span>&gt;::Zero();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        VertexSE3Expmap* vtx = <span class="keyword">static_cast</span>&lt;VertexSE3Expmap*&gt; ( _vertices[<span class="number">0</span>] );</span><br><span class="line">        Eigen::Vector3d xyz_trans = vtx-&gt;estimate().<span class="built_in">map</span> ( x_world_ );   <span class="comment">// q in book</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> invz = <span class="number">1.0</span>/xyz_trans[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span> invz_2 = invz*invz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> u = x*fx_*invz + cx_;</span><br><span class="line">        <span class="keyword">float</span> v = y*fy_*invz + cy_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jacobian from se3 to u,v</span></span><br><span class="line">        <span class="comment">// NOTE that in g2o the Lie algebra is (\omega, \epsilon), where \omega is so(3) and \epsilon the translation</span></span><br><span class="line">        Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">2</span>, <span class="number">6</span>&gt; jacobian_uv_ksai;</span><br><span class="line">        <span class="comment">//旋转在前，平移在后</span></span><br><span class="line">        jacobian_uv_ksai ( <span class="number">0</span>,<span class="number">0</span> ) = - x*y*invz_2 *fx_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">0</span>,<span class="number">1</span> ) = ( <span class="number">1</span>+ ( x*x*invz_2 ) ) *fx_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">0</span>,<span class="number">2</span> ) = - y*invz *fx_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">0</span>,<span class="number">3</span> ) = invz *fx_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">0</span>,<span class="number">4</span> ) = <span class="number">0</span>;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">0</span>,<span class="number">5</span> ) = -x*invz_2 *fx_;</span><br><span class="line"></span><br><span class="line">        jacobian_uv_ksai ( <span class="number">1</span>,<span class="number">0</span> ) = - ( <span class="number">1</span>+y*y*invz_2 ) *fy_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">1</span>,<span class="number">1</span> ) = x*y*invz_2 *fy_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">1</span>,<span class="number">2</span> ) = x*invz *fy_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">1</span>,<span class="number">3</span> ) = <span class="number">0</span>;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">1</span>,<span class="number">4</span> ) = invz *fy_;</span><br><span class="line">        jacobian_uv_ksai ( <span class="number">1</span>,<span class="number">5</span> ) = -y*invz_2 *fy_;</span><br><span class="line"></span><br><span class="line">        Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">1</span>, <span class="number">2</span>&gt; jacobian_pixel_uv;</span><br><span class="line"></span><br><span class="line">        jacobian_pixel_uv ( <span class="number">0</span>,<span class="number">0</span> ) = ( getPixelValue ( u+<span class="number">1</span>,v )-getPixelValue ( u<span class="number">-1</span>,v ) ) /<span class="number">2</span>;</span><br><span class="line">        jacobian_pixel_uv ( <span class="number">0</span>,<span class="number">1</span> ) = ( getPixelValue ( u,v+<span class="number">1</span> )-getPixelValue ( u,v<span class="number">-1</span> ) ) /<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi = jacobian_pixel_uv*jacobian_uv_ksai;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dummy read and write functions because we don't care...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span> <span class="params">( <span class="built_in">std</span>::istream&amp; in )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span> <span class="params">( <span class="built_in">std</span>::ostream&amp; out )</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// get a gray scale value from reference image (bilinear interpolated)</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPixelValue</span> <span class="params">( <span class="keyword">float</span> x, <span class="keyword">float</span> y )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的值（灰度值或者RGB值）。</span></span><br><span class="line">        uchar* data = &amp; image_-&gt;data[ <span class="keyword">int</span> ( y ) * image_-&gt;step + <span class="keyword">int</span> ( x ) ];</span><br><span class="line">        <span class="keyword">float</span> xx = x - <span class="built_in">floor</span> ( x );</span><br><span class="line">        <span class="keyword">float</span> yy = y - <span class="built_in">floor</span> ( y );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float</span> (</span><br><span class="line">                   ( <span class="number">1</span>-xx ) * ( <span class="number">1</span>-yy ) * data[<span class="number">0</span>] +</span><br><span class="line">                   xx* ( <span class="number">1</span>-yy ) * data[<span class="number">1</span>] +</span><br><span class="line">                   ( <span class="number">1</span>-xx ) *yy*data[ image_-&gt;step ] +</span><br><span class="line">                   xx*yy*data[image_-&gt;step+<span class="number">1</span>]</span><br><span class="line">               );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Eigen::Vector3d x_world_;   <span class="comment">// 3D point in world frame</span></span><br><span class="line">    <span class="keyword">float</span> cx_=<span class="number">0</span>, cy_=<span class="number">0</span>, fx_=<span class="number">0</span>, fy_=<span class="number">0</span>; <span class="comment">// Camera intrinsics</span></span><br><span class="line">    cv::Mat* image_=<span class="literal">nullptr</span>;    <span class="comment">// reference image</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    if ( argc != 2 )</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;"usage: useLK path_to_dataset"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    srand ( ( <span class="keyword">unsigned</span> <span class="keyword">int</span> ) time ( <span class="number">0</span> ) );</span><br><span class="line"><span class="comment">//    string path_to_dataset = argv[1];</span></span><br><span class="line">    <span class="built_in">string</span> path_to_dataset =<span class="string">"/home/xiaohu//slambook-master/ch8/rgbd_dataset_freiburg1_desk"</span>;</span><br><span class="line">    <span class="built_in">string</span> associate_file = path_to_dataset + <span class="string">"/associate.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span> <span class="params">( associate_file )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> rgb_file, depth_file, time_rgb, time_depth;</span><br><span class="line">    cv::Mat color, depth, gray;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Measurement&gt; measurements;</span><br><span class="line">    <span class="comment">// 相机内参</span></span><br><span class="line">    <span class="keyword">float</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">float</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">float</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">float</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">float</span> depth_scale = <span class="number">1000.0</span>;</span><br><span class="line">    Eigen::Matrix3f K;</span><br><span class="line">    K&lt;&lt;fx,<span class="number">0.f</span>,cx,<span class="number">0.f</span>,fy,cy,<span class="number">0.f</span>,<span class="number">0.f</span>,<span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Isometry3d Tcw = Eigen::Isometry3d::Identity();</span><br><span class="line"></span><br><span class="line">    cv::Mat prev_color;</span><br><span class="line">    <span class="comment">// 我们以第一个图像为参考，对后续图像和参考图像做直接法</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> index=<span class="number">0</span>; index&lt;<span class="number">10</span>; index++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"*********** loop "</span>&lt;&lt;index&lt;&lt;<span class="string">" ************"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        fin&gt;&gt;time_rgb&gt;&gt;rgb_file&gt;&gt;time_depth&gt;&gt;depth_file;</span><br><span class="line">        color = cv::imread ( path_to_dataset+<span class="string">"/"</span>+rgb_file );</span><br><span class="line">        depth = cv::imread ( path_to_dataset+<span class="string">"/"</span>+depth_file, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( color.data==<span class="literal">nullptr</span> || depth.data==<span class="literal">nullptr</span> )</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        cv::cvtColor ( color, gray, cv::COLOR_BGR2GRAY );</span><br><span class="line">        <span class="keyword">if</span> ( index ==<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对第一帧提取FAST特征点</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;cv::KeyPoint&gt; keypoints;</span><br><span class="line">            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::create();</span><br><span class="line">            detector-&gt;detect ( color, keypoints );</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">auto</span> kp:keypoints )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 去掉邻近边缘处的点</span></span><br><span class="line">                <span class="keyword">if</span> ( kp.pt.x &lt; <span class="number">20</span> || kp.pt.y &lt; <span class="number">20</span> || ( kp.pt.x+<span class="number">20</span> ) &gt;color.cols || ( kp.pt.y+<span class="number">20</span> ) &gt;color.rows )</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ushort d = depth.ptr&lt;ushort&gt; ( cvRound ( kp.pt.y ) ) [ cvRound ( kp.pt.x ) ];</span><br><span class="line">                <span class="keyword">if</span> ( d==<span class="number">0</span> )</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                Eigen::Vector3d p3d = project2Dto3D ( kp.pt.x, kp.pt.y, d, fx, fy, cx, cy, depth_scale );</span><br><span class="line">                <span class="keyword">float</span> grayscale = <span class="keyword">float</span> ( gray.ptr&lt;uchar&gt; ( cvRound ( kp.pt.y ) ) [ cvRound ( kp.pt.x ) ] );</span><br><span class="line">                measurements.push_back ( Measurement ( p3d, grayscale ) );</span><br><span class="line">            &#125;</span><br><span class="line">            prev_color = color.clone();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用直接法计算相机运动</span></span><br><span class="line">        chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">        poseEstimationDirect ( measurements, &amp;gray, K, Tcw );</span><br><span class="line">        chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">        chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt; ( t2-t1 );</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"direct method costs time: "</span>&lt;&lt;time_used.count() &lt;&lt;<span class="string">" seconds."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Tcw="</span>&lt;&lt;Tcw.matrix() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// plot the feature points</span></span><br><span class="line">        cv::<span class="function">Mat <span class="title">img_show</span> <span class="params">( color.rows*<span class="number">2</span>, color.cols, CV_8UC3 )</span></span>;</span><br><span class="line">        prev_color.copyTo ( img_show ( cv::Rect ( <span class="number">0</span>,<span class="number">0</span>,color.cols, color.rows ) ) );</span><br><span class="line">        color.copyTo ( img_show ( cv::Rect ( <span class="number">0</span>,color.rows,color.cols, color.rows ) ) );</span><br><span class="line">        <span class="keyword">for</span> ( Measurement m:measurements )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//任何一次对 rand 的调用，都将得到一个 0~RAND_MAX 之间的伪随机数。</span></span><br><span class="line">            <span class="keyword">if</span> ( rand() &gt; RAND_MAX/<span class="number">5</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Eigen::Vector3d p = m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_prev = project3Dto2D ( p ( <span class="number">0</span>,<span class="number">0</span> ), p ( <span class="number">1</span>,<span class="number">0</span> ), p ( <span class="number">2</span>,<span class="number">0</span> ), fx, fy, cx, cy );</span><br><span class="line">            Eigen::Vector3d p2 = Tcw*m.pos_world;</span><br><span class="line">            Eigen::Vector2d pixel_now = project3Dto2D ( p2 ( <span class="number">0</span>,<span class="number">0</span> ), p2 ( <span class="number">1</span>,<span class="number">0</span> ), p2 ( <span class="number">2</span>,<span class="number">0</span> ), fx, fy, cx, cy );</span><br><span class="line">            <span class="keyword">if</span> ( pixel_now(<span class="number">0</span>,<span class="number">0</span>)&lt;<span class="number">0</span> || pixel_now(<span class="number">0</span>,<span class="number">0</span>)&gt;=color.cols || pixel_now(<span class="number">1</span>,<span class="number">0</span>)&lt;<span class="number">0</span> || pixel_now(<span class="number">1</span>,<span class="number">0</span>)&gt;=color.rows )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> b = <span class="number">255</span>*<span class="keyword">float</span> ( rand() ) /RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> g = <span class="number">255</span>*<span class="keyword">float</span> ( rand() ) /RAND_MAX;</span><br><span class="line">            <span class="keyword">float</span> r = <span class="number">255</span>*<span class="keyword">float</span> ( rand() ) /RAND_MAX;</span><br><span class="line">            cv::circle ( img_show, cv::Point2d ( pixel_prev ( <span class="number">0</span>,<span class="number">0</span> ), pixel_prev ( <span class="number">1</span>,<span class="number">0</span> ) ), <span class="number">8</span>, cv::Scalar ( b,g,r ), <span class="number">2</span> );</span><br><span class="line">            cv::circle ( img_show, cv::Point2d ( pixel_now ( <span class="number">0</span>,<span class="number">0</span> ), pixel_now ( <span class="number">1</span>,<span class="number">0</span> ) +color.rows ), <span class="number">8</span>, cv::Scalar ( b,g,r ), <span class="number">2</span> );</span><br><span class="line">            cv::line ( img_show, cv::Point2d ( pixel_prev ( <span class="number">0</span>,<span class="number">0</span> ), pixel_prev ( <span class="number">1</span>,<span class="number">0</span> ) ), cv::Point2d ( pixel_now ( <span class="number">0</span>,<span class="number">0</span> ), pixel_now ( <span class="number">1</span>,<span class="number">0</span> ) +color.rows ), cv::Scalar ( b,g,r ), <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        cv::imshow ( <span class="string">"result"</span>, img_show );</span><br><span class="line">        cv::waitKey ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">poseEstimationDirect</span> <span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Measurement &gt;&amp; measurements, cv::Mat* gray, Eigen::Matrix3f&amp; K, Eigen::Isometry3d&amp; Tcw )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">6</span>,<span class="number">1</span>&gt;&gt; DirectBlock;  <span class="comment">// 求解的向量是6＊1的</span></span><br><span class="line">    DirectBlock::LinearSolverType* linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt; DirectBlock::PoseMatrixType &gt; ();</span><br><span class="line">    DirectBlock* solver_ptr = <span class="keyword">new</span> DirectBlock ( linearSolver );</span><br><span class="line">    <span class="comment">// g2o::OptimizationAlgorithmGaussNewton* solver = new g2o::OptimizationAlgorithmGaussNewton( solver_ptr ); // G-N</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg ( solver_ptr ); <span class="comment">// L-M</span></span><br><span class="line">    g2o::SparseOptimizer optimizer;</span><br><span class="line">    optimizer.setAlgorithm ( solver );</span><br><span class="line">    optimizer.setVerbose( <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">    g2o::VertexSE3Expmap* pose = <span class="keyword">new</span> g2o::VertexSE3Expmap();</span><br><span class="line">    pose-&gt;setEstimate ( g2o::SE3Quat ( Tcw.rotation(), Tcw.translation() ) );</span><br><span class="line">    pose-&gt;setId ( <span class="number">0</span> );</span><br><span class="line">    optimizer.addVertex ( pose );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Measurement m: measurements )</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeSE3ProjectDirect* edge = <span class="keyword">new</span> EdgeSE3ProjectDirect (</span><br><span class="line">            m.pos_world,</span><br><span class="line">            K ( <span class="number">0</span>,<span class="number">0</span> ), K ( <span class="number">1</span>,<span class="number">1</span> ), K ( <span class="number">0</span>,<span class="number">2</span> ), K ( <span class="number">1</span>,<span class="number">2</span> ), gray</span><br><span class="line">        );</span><br><span class="line">        edge-&gt;setVertex ( <span class="number">0</span>, pose );</span><br><span class="line">        edge-&gt;setMeasurement ( m.grayscale );</span><br><span class="line">        edge-&gt;setInformation ( Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt;::Identity() );</span><br><span class="line">        edge-&gt;setId ( id++ );</span><br><span class="line">        optimizer.addEdge ( edge );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"edges in graph: "</span>&lt;&lt;optimizer.edges().size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize ( <span class="number">30</span> );</span><br><span class="line">    Tcw = pose-&gt;estimate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-半稠密直接法"><a href="#5-4-半稠密直接法" class="headerlink" title="5.4 半稠密直接法"></a>5.4 半稠密直接法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select the pixels with high gradiants </span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> x=<span class="number">10</span>; x&lt;gray.cols<span class="number">-10</span>; x++ )</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> y=<span class="number">10</span>; y&lt;gray.rows<span class="number">-10</span>; y++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::<span class="function">Vector2d <span class="title">delta</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            gray.ptr&lt;uchar&gt;(y)[x+<span class="number">1</span>] - gray.ptr&lt;uchar&gt;(y)[x<span class="number">-1</span>], </span></span></span><br><span class="line"><span class="function"><span class="params">            gray.ptr&lt;uchar&gt;(y+<span class="number">1</span>)[x] - gray.ptr&lt;uchar&gt;(y<span class="number">-1</span>)[x]</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">        <span class="keyword">if</span> ( delta.norm() &lt; <span class="number">50</span> )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ushort d = depth.ptr&lt;ushort&gt; (y)[x];</span><br><span class="line">        <span class="keyword">if</span> ( d==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Eigen::Vector3d p3d = project2Dto3D ( x, y, d, fx, fy, cx, cy, depth_scale );</span><br><span class="line">        <span class="keyword">float</span> grayscale = <span class="keyword">float</span> ( gray.ptr&lt;uchar&gt; (y) [x] );</span><br><span class="line">        measurements.push_back ( Measurement ( p3d, grayscale ) );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-直接法的讨论"><a href="#5-5-直接法的讨论" class="headerlink" title="5.5 直接法的讨论"></a>5.5 直接法的讨论</h2><ol>
<li>相比于特征点法，直接法完全依靠优化来求解相机位姿,像 素梯度引导着优化的方向。如果我们想要得到正确的优化结果，就必须保证大部分像素梯 度能够把优化引导到正确的方向。</li>
</ol>
<ol>
<li><p>在非线性优化过程中，这个位姿是由一个初值不断地优化迭代得到的（可以大致赋值初值），我们的初值比较差。</p>
</li>
<li><p>直接法的梯度是直接由图像梯度确定的，因此我们必须保证沿着图像梯度走时，灰度误差会不断下降。然而，图像通常是一个很强烈的非凸函数。实际当中， 如果我们沿着图像梯度前进，很容易由于图像本身的非凸性（或噪声）落进一个局部极小值中，无法继续优化。==只有当相机运动很小，图像中的梯度不会有很强的非凸性时，直接法才能成立==。</p>
<h2 id="5-6-直接法的优缺点总结"><a href="#5-6-直接法的优缺点总结" class="headerlink" title="5.6 直接法的优缺点总结"></a>5.6 直接法的优缺点总结</h2></li>
<li><p>优点：</p>
<ul>
<li>可以省去计算特征点、描述子的时间。<ul>
<li>只要求有像素梯度即可，无须特征点。因此，直接法可以在特征缺失的场合下使用。</li>
<li>可以构建半稠密乃至稠密的地图，这是特征点法无法做到的。</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>非凸性</strong>。直接法完全依靠梯度搜索，降低目标函数来计算相机位姿。其目标函数中需要取像素点的灰度值，而图像是强烈非凸的函数。这使得优化算法容易进入极小，只在运动很小时直接法才能成功。</li>
<li><strong>单个像素没有区分度</strong>。找一个和他像的实在太多了！——于是我们要么计算图像块，要么计算复杂的相关性。由于每个像素对改变相机运动的“意见”不一致。只能少数服从多数，以数量代替质量。</li>
<li><strong>灰度值不变是很强的假设</strong>。如果相机是自动曝光的，当它调整曝光参数时，会使得图像整体变亮或变暗。光照变化时亦会出现这种情况。特征点法对光照具有一定的容忍性，而直接法由于计算灰度间的差异，整体灰度变化会破坏灰度不变假设，使算法失败。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>视觉slam十四讲   7.视觉里程计1</title>
    <url>/2019/05/21/%E8%A7%86%E8%A7%89slam%E5%8D%81%E5%9B%9B%E8%AE%B2-7-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-特征点法"><a href="#1-特征点法" class="headerlink" title="1 特征点法"></a>1 特征点法</h1><ol>
<li>视觉slam主要分为视觉前段和优化后端。前段称为视觉里程计（VO），它根据相邻图象的信息估计出粗略的相机运动，给后端提供较好的初始值。</li>
<li>VO的实现方法可以根据是否需要提取特征分为两类：基于特征点的方法，不使用特征点的直接方法。 基于特征点的VO运行稳定，对光照、动态物体不敏感。<h2 id="1-1-特征点"><a href="#1-1-特征点" class="headerlink" title="1.1 特征点"></a>1.1 特征点</h2></li>
<li>为了能够更好的进行图像匹配，需要在图像中选择具有代表性的区域，例如：图像中的角点、边缘和一些区块。</li>
<li>更为稳定的的局部图像特征特征点，例如：SIFT,SURF,ORB等这些特征点不会随着相机的移动，旋转或者光照的变化而变化，其四个特征:<ul>
<li>可重复性Repeatability<ul>
<li>可区别性Distinctiveness</li>
<li>高效率Efficiency</li>
<li>本地性Locality</li>
</ul>
</li>
</ul>
</li>
<li>特征点由(关键点Key-Point)和描述子（Descriptor）。关键点指的是该特征点在图像中的位置，有些还具有方向、尺度信息；描述子通常是一个向量，按照人为的设计的方式，描述关键点周围像素的信息。通常描述子是按照<strong>外观相似的特征应该有相似的描述子</strong>设计的。</li>
<li>SIFT（Scale Invariant Feature Transform）尺度不变特征变换，SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。</li>
<li>SURF（ Speeded Up Robust Features），主要针对SIFT算法运算速度慢，计算量大的缺点进行了改进。</li>
<li>ORB（Oriented FAST and Rotated BRIEF）算法，改进了FAST检测子不具有方向性的问题，并使用速度极快的二进制描述子BRIEF。<h2 id="1-2-ORB特征"><a href="#1-2-ORB特征" class="headerlink" title="1.2 ORB特征"></a>1.2 ORB特征</h2></li>
<li><p>提取ORB（Oriented FAST and  Rotated BRIEF)特征分为两个步骤：</p>
<pre><code> 1. FAST 角点提取：找出图像中的” 角点”。相较于原版的 FAST, ORB 中计算了特征点的主方向，为后续的 BRIEF 描述子增加了旋转不变特性。
</code></pre><ol>
<li>BRIEF 描述子：对前一步提取出特征点的周围图像区域进行描述</li>
</ol>
</li>
<li><p><strong>Fast 角点检测</strong>，FAST 是一种角点，主要检测局部像素灰度变化明显的地方，以速度快著称。其思 想是：如果一个像素与它邻域的像素差别较大（过亮或过暗）, 那它更可能是角点。检测过程如下：</p>
<ol>
<li>在图像中选取像素 $p$，假设它的亮度为 $I_{p}$。</li>
<li>设置一个阈值 $T$(比如$I_{p}$的 20%)。</li>
<li>以像素 $p$为中心, 选取半径为 3 的圆上的 16 个像素点。</li>
<li>假如选取的圆上，有连续的 NNN 个点的亮度大于 $I_{p}+T$或小于$I_{p}+T$，那么像素 $p$可以被认为是特征点 (N通常取 12，即为 FAST-12。其它常用的 $N$ 取值为 9 和 11，他们分别被称为 FAST-9，FAST-11)。</li>
<li>循环以上四步，对每一个像素执行相同的操作。</li>
</ol>
</li>
<li><p>在 ORB 中，对原始的 FAST 算法进行了改进。可以指定最终要提取的角点数量N，对原始 FAST 角点分别计算 Harris 响应值，然后选取前N个具有最大响应值的角点，作为最终的角点集合。</p>
</li>
<li><p>FAST 角点不具有方向信息.针对 FAST 角点不具有方向性和尺度的弱点，ORB 添加了尺度和旋转的描述。</p>
<ul>
<li>尺度不变性由构建图像金字塔（金字塔是指对图像进行不同层次的降采样，以获得不同分辨率的图像），并在金字塔的每一层上检测角点来实现。</li>
<li><p>特征的旋转是由灰度质心法（Intensity Centroid）实现的。</p>
<ol>
<li><p>质心是指以图像块灰度值作为权重的中心。其具体操作步骤如下 ：</p>
<p>  （1）在一个小的图像块 BBB 中，定义图像块的矩为:</p>
<script type="math/tex; mode=display">m _ { p q } = \sum x ^ { p } y ^ { q } I ( x , y ) , \quad p , q = \{ 0,1 \}</script><p> （2）通过矩可以找到图像块的质心：</p>
<script type="math/tex; mode=display">CC = \left( \frac { m _ { 10 } } { m _ { 00 } } , \frac { m _ { 01 } } { m _ { 00 } } \right)</script><p> （3）连接图像块的几何中心 O 与质心 C，得到一个方向向量 $\vec { O C }$，于是特征点的方向可以定义为：</p>
<script type="math/tex; mode=display">\theta = \arctan \left( m _ { 01 } / m _ { 10 } \right)</script></li>
</ol>
</li>
</ul>
</li>
<li><strong>BRIEF 描述子</strong><ol>
<li>BRIEF 是一种二进制描述子，它的描述向量由许多个 0 和 1 组成，这里的 0 和 1 编码了关键点附近两个像素（比如说 p 和q）的大小关系：如果 p 比 q 大，则取 1，反之就取 0。如果我们取了 128 个这样的 p, q，最后就得到 128 维由 0，1 组成的向量。</li>
<li>BRIEF 使用了随机选点的比较，速度非常快，使用了二进制表达，存储起来也十分方便，适用于实时的图像匹配。</li>
<li>ORB 在 FAST 特征点提取阶段计算了关键点的方向，可以利用方向信息，计算了旋转之后的“Steer BRIEF”特征，使 ORB 的描述子具有较好的旋转不变性。<h2 id="1-3-特征匹配"><a href="#1-3-特征匹配" class="headerlink" title="1.3  特征匹配"></a>1.3  特征匹配</h2></li>
</ol>
</li>
<li><strong>暴力匹配</strong>：即对每一个特征点 $x _ { t } ^ { m }$，与所有的$x _ { t +1} ^ { m }$测量描述子的距离，然后排序，取最近的一个作为匹配点。描述子距离表示两个特征之间的相似程度。</li>
<li>浮点类型的描述子，使用<strong>欧氏距离</strong>进行度量即可。</li>
<li>二进制的描述子（比如 BRIEF 这样的），往往使用<strong>汉明距离（</strong>Hamming distance）做为度量——两个二进制串之间的汉明距离，指的是它们不同位数的个数。</li>
<li><strong>快速近似最近邻</strong>（FLANN）：更加适合匹配点数量极多的情况。<h1 id="2-特征提取与匹配"><a href="#2-特征提取与匹配" class="headerlink" title="2 特征提取与匹配"></a>2 特征提取与匹配</h1><strong>代码及注释：</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: feature_extraction img1 img2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = imread ( argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line">    Mat img_2 = imread ( argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    <span class="comment">//keypoint是opencv里的数据类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    Mat descriptors_1, descriptors_2;<span class="comment">//描述子</span></span><br><span class="line">    <span class="comment">//opencv3</span></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::create();<span class="comment">//特征检测器</span></span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::create();<span class="comment">//描述子提取器</span></span><br><span class="line">    <span class="comment">//opencv2</span></span><br><span class="line">    <span class="comment">// Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create(detector_name);</span></span><br><span class="line">    <span class="comment">// Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create(descriptor_name);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;detect ( img_1,keypoints_1 );<span class="comment">//固定用法，检测图一中的角点位置</span></span><br><span class="line">    detector-&gt;detect ( img_2,keypoints_2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    <span class="comment">//描述子通常是一个向量，保存在Mat中</span></span><br><span class="line">    descriptor-&gt;compute ( img_1, keypoints_1, descriptors_1 );<span class="comment">//计算图一特征点的描述子</span></span><br><span class="line">    descriptor-&gt;compute ( img_2, keypoints_2, descriptors_2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义输出检测特征点的图片</span></span><br><span class="line">    Mat outimg1;</span><br><span class="line">    <span class="comment">//随机像素值</span></span><br><span class="line">    drawKeypoints( img_1, keypoints_1, outimg1, Scalar::all(<span class="number">-1</span>), DrawMatchesFlags::DEFAULT );</span><br><span class="line">    namedWindow(<span class="string">"ORB特征点"</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    imshow(<span class="string">"ORB特征点"</span>,outimg1);</span><br><span class="line">    imwrite(<span class="string">"ORB特征点.jpg"</span>, outimg1);</span><br></pre></td></tr></table></figure>
<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190623231619397.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
</ol><a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配</span></span><br><span class="line"><span class="comment">//使用了opencv中封装后的暴力匹配算法BFMatcher,使用 Hamming 距离</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line"><span class="comment">//特征匹配算法：汉明距离</span></span><br><span class="line">Ptr&lt;DescriptorMatcher&gt; matcher  = DescriptorMatcher::create ( <span class="string">"BruteForce-Hamming"</span> );<span class="comment">//描述子匹配器</span></span><br><span class="line"><span class="comment">//BFMatcher matcher ( NORM_HAMMING );</span></span><br><span class="line">matcher-&gt;match ( descriptors_1, descriptors_2, matches );</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line"><span class="comment">//上面的匹配结果有大量的错误匹配，需要使用一些机制来过滤掉错误的匹配</span></span><br><span class="line"><span class="comment">//汉明距离小于最小距离的两倍</span></span><br><span class="line"><span class="keyword">double</span> min_dist=<span class="number">10000</span>, max_dist=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> dist = matches[i].distance;</span><br><span class="line">    <span class="keyword">if</span> ( dist &lt; min_dist ) min_dist = dist;</span><br><span class="line">    <span class="keyword">if</span> ( dist &gt; max_dist ) max_dist = dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅供娱乐的写法</span></span><br><span class="line"><span class="comment">//min_dist = min_element( matches.begin(), matches.end(), [](const DMatch&amp; m1, const DMatch&amp; m2) &#123;return m1.distance&lt;m2.distance;&#125; )-&gt;distance;</span></span><br><span class="line"><span class="comment">//max_dist = max_element( matches.begin(), matches.end(), [](const DMatch&amp; m1, const DMatch&amp; m2) &#123;return m1.distance&lt;m2.distance;&#125; )-&gt;distance;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"-- Max dist : %f \n"</span>, max_dist );</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"-- Min dist : %f \n"</span>, min_dist );</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt; good_matches;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( matches[i].distance &lt;= max ( <span class="number">2</span>*min_dist, <span class="number">30.0</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            good_matches.push_back ( matches[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第五步:绘制匹配结果</span></span><br><span class="line">    Mat img_match;</span><br><span class="line">    Mat img_goodmatch;</span><br><span class="line">    drawMatches ( img_1, keypoints_1, img_2, keypoints_2, matches, img_match );</span><br><span class="line">    drawMatches ( img_1, keypoints_1, img_2, keypoints_2, good_matches, img_goodmatch );</span><br><span class="line">    </span><br><span class="line">    namedWindow(<span class="string">"所有匹配点对"</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    imshow ( <span class="string">"所有匹配点对"</span>, img_match );</span><br><span class="line">    imwrite(<span class="string">"所有匹配点对.jpg"</span>, img_match);</span><br><span class="line">    namedWindow(<span class="string">"优化后匹配点对"</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    imshow ( <span class="string">"优化后匹配点对"</span>, img_goodmatch );</span><br><span class="line">    imwrite ( <span class="string">"优化后匹配点对.jpg"</span>, img_goodmatch );</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>所有匹配点对：</strong><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190623232028447.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><strong>优化后匹配点对：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190623232040943.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">根据匹配的点对,估计相机的运动。</p>
<ul>
<li>当相机为单目时,我们只知道 2D 的像素坐标,因而问题是根据两组 2D 点估计运<br>动。该问题用对极几何来解决。</li>
<li>当相机为双目、RGB-D 时,或者我们通过某种方法得到了距离信息,那问题就是根<br>据两组 3D 点估计运动。该问题通常用 ICP 来解决。</li>
<li>如果我们有 3D 点和它们在相机的投影位置,也能估计相机的运动。该问题通过 PnP<br>求解。<h1 id="3-2D-2D：对极几何"><a href="#3-2D-2D：对极几何" class="headerlink" title="3  2D-2D：对极几何"></a>3  2D-2D：对极几何</h1><h2 id="3-1-对极约束"><a href="#3-1-对极约束" class="headerlink" title="3.1 对极约束"></a>3.1 对极约束</h2><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190625165200724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>设第一帧到第二帧的运动为$R,t$,$O_{1},O_{2}$三个点平面为极平面，$e_{1},e_{2}$为极点，$O_{1}O_{2}$称为基线，$l_{1}l_{2}$为极线。</li>
<li>已知：匹配点对p1p1，p2p2的像素坐标。</li>
<li>给定：两张二维图像，二维图像上特征点的匹配关系。</li>
<li>未知：P的三维空间坐标，$I1$到$I2$的变换矩阵($T_{1,2}$，即R,t）。</li>
</ul>
<p><strong>对极约束</strong></p>
<p>设第一帧的坐标系下P的空间位置为：</p>
<script type="math/tex; mode=display">P=[X,Y,Z]^T</script><p>两个像素点$p1，p2$的像素坐标（单位像素）：</p>
<script type="math/tex; mode=display">s_{1}p_{1}=KP, \quad   s_{2}p_{2}=K(RP+t)</script><p>使用齐次坐标：</p>
<script type="math/tex; mode=display">p_{1}=KP, \quad   p_{2}=K(RP+t)</script><p>取：</p>
<script type="math/tex; mode=display">x_{1}=K^{−1}p_{1},\quad x_{2}=K^{−1}p_{2}</script><p>$x_{1},x_{2}$是两个像素点的归一化的坐标，代入上式得：</p>
<script type="math/tex; mode=display">x_{2}=Rx_{1}+t</script><p>两边同时左乘$t$^:</p>
<script type="math/tex; mode=display">t^{\wedge }x_{2}=t^{\wedge }Rx_{1}</script><p>再左乘一个$x^{T}_{2}$,有:</p>
<script type="math/tex; mode=display">x^{T}_{2}t^{\wedge }x_{2}=x^{T}_{2}t^{\wedge }Rx_{1}</script><p>由上式可得：</p>
<script type="math/tex; mode=display">x^{T}_{2}t^{\wedge }Rx_{1}=0</script><p>带入$p_{1}，p_{2}$：</p>
<script type="math/tex; mode=display">p^{T}_{2}K^{-T}t^{\wedge }Rk^{-1}p_{1}</script><p>本质矩阵E,基础矩阵F,简化对极约束：</p>
<script type="math/tex; mode=display">E=t^{\wedge }R,F=K^{-T}EK^{-1},x^{T}_{2}t^{\wedge }Ex_{1}=p^{T}
_{2}Fp_{1}=0</script><p>对极约束简化给出两个点的空间位置关系，相机位姿估计问题变成一下两部：</p>
<ol>
<li>根据匹配点的位置，求出E或者F。</li>
<li>根据E或者F，求出R,t。<h2 id="3-2-本质矩阵"><a href="#3-2-本质矩阵" class="headerlink" title="3.2 本质矩阵"></a>3.2 本质矩阵</h2>本质矩阵$E=t^{\wedge }R$,3x3矩阵<ul>
<li>E在不同尺度下等价的</li>
</ul>
</li>
</ol>
<ul>
<li>本质矩阵的内在性质：E的奇异值必定为$\left [ \sigma ,\sigma ,0 \right ]$的形式，</li>
<li>由平移和旋转定义，共有3+3=6个自由度，因为对极约束，E具有尺度等价性，自由度-1，共五个。</li>
</ul>
<p><strong>八点法</strong><br>根据对极约束，最少五对点就能求出来E，为了方便，一般使用八对点。</p>
<h2 id="3-3-单应矩阵"><a href="#3-3-单应矩阵" class="headerlink" title="3.3 单应矩阵"></a>3.3 单应矩阵</h2><p>它描述的是两个平面之间的映射关系，如果场景中的特征点都落在同一平面上(比如情面、地面)，则可以通过单应性进行运动估计。<br>假设特征点落在平面P上</p>
<script type="math/tex; mode=display">n^{T}P+d=0</script><script type="math/tex; mode=display">-\frac{n^{T}P}{d} =1</script><script type="math/tex; mode=display">p_{2}=K(RP+t)</script><p>得到一个从图像坐标p1p1到p2p2之间的变换:</p>
<script type="math/tex; mode=display">p_{2}=K(R−\frac{tn^T}{d})K^−1p_{1}</script><p>把中间部分记为H,于是:</p>
<pre><code>                      $$p_{2}=Hp_{1}$$
 **它的定义与平移、旋转和平面的参数相关。**
  把H矩阵看成向量，通过求解该向量的线性方程来恢复H,又称直线线性变换法(Direct Linear Transform)
  与求解本质矩阵类似，求出来后需要对其进行分解才能得到R,t,分解方法有数值法和解析法。分解同样得到四组解，最后根据先验信息进行排除得到唯一的一组R,t解。
</code></pre><p>为了避免退化现象造成的影响，通常会同时估计基础矩阵F和单应矩阵H，选择重投影误差比较小的那个最终的运动估计矩阵。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>由于 E 本身具有尺度等价性,它分解得到的 t, R 也有一个尺度等价性。通常把 t 进行归一化,让它的<br>长度等于 1。</p>
<ol>
<li><p>尺度不确定性<br>==对t长度的归一化，直接导致单目视觉的尺度不确定性(Scale Ambiguity)==,在单目视觉中对两张图像的t归一化相当于固定了制度，我们不知道长度是多少，==以这时t的单位是1，计算相机运动和特征点的3D的位置，称为单目视觉SLAM的初始化。==</p>
</li>
<li><p>初始化的纯旋转问题<br>==单目视觉初始化不能只有纯旋转，必须要有一定程度的平移==。如果没有平移，从E分解到R,t的过程中，导致t为零，那么得到的E也为零，这将导致无法求解R。不过此时可以依靠H求取旋转，但是仅有旋转时，无法使用三角测量估计特征点的空间位置。<br><strong>单目初始化不能只有纯旋转，必须有一定程度的平移</strong></p>
</li>
<li><p>对于8对点的情况<br>当给定匹配点多余8个的时候，比如算出79对匹配点，使用一个最小二乘计算：</p>
<script type="math/tex; mode=display">\min_{e}\left \| Ae \right \|_{2}^{2}=\min e^{T}A^TAe</script></li>
</ol>
<p>不过在存在错误匹配的情况下使用<strong>随机抽样一致算法</strong>(Random Sample Concensus,<strong>RANSAC</strong>)，可以处理带有错误匹配的数据。</p>
<h1 id="4-实践：对极约束求相机运动"><a href="#4-实践：对极约束求相机运动" class="headerlink" title="4 实践：对极约束求相机运动"></a>4 实践：对极约束求相机运动</h1><p><strong>代码及注释：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;//Features2D， 2D功能框架</span></span></span><br><span class="line"><span class="comment">//高层GUI图形用户界面，包含媒体的I / O输入输出，视频捕捉、图像和视频的编码解码、图形交互界面的接口等内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d/calib3d.hpp&gt;//主要是相机校准和三维重建相关的内容</span></span></span><br><span class="line"><span class="comment">// #include "extra.h" // use this if in OpenCV2 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment"> * 本程序演示了如何使用2D-2D的特征匹配估计相机运动</span></span><br><span class="line"><span class="comment"> * **************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; img_1, <span class="keyword">const</span> Mat&amp; img_2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_2d2d</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt; matches,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; R, Mat&amp; t )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像素坐标转相机归一化坐标</span></span><br><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: pose_estimation_2d2d img1 img2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = imread ( argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line">    Mat img_2 = imread ( argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">    find_feature_matches ( img_1, img_2, keypoints_1, keypoints_2, matches );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"一共找到了"</span>&lt;&lt;matches.size() &lt;&lt;<span class="string">"组匹配点"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 估计两张图像间运动</span></span><br><span class="line">    Mat R,t;</span><br><span class="line">    pose_estimation_2d2d ( keypoints_1, keypoints_2, matches, R, t );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 验证E=t^R*scale</span></span><br><span class="line">    Mat t_x = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt;</span><br><span class="line">                <span class="number">0</span>,                      -t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">0</span> ),     t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">0</span> ),</span><br><span class="line">                t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">0</span> ),      <span class="number">0</span>,                      -t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),</span><br><span class="line">                -t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">0</span> ),     t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),      <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"t^R="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;t_x*R&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 验证对极约束</span></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span> ( DMatch m: matches )</span><br><span class="line">    &#123;</span><br><span class="line">        Point2d pt1 = pixel2cam ( keypoints_1[ m.queryIdx ].pt, K );</span><br><span class="line">        Mat y1 = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">1</span> ) &lt;&lt; pt1.x, pt1.y, <span class="number">1</span> );</span><br><span class="line">        Point2d pt2 = pixel2cam ( keypoints_2[ m.trainIdx ].pt, K );</span><br><span class="line">        Mat y2 = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">1</span> ) &lt;&lt; pt2.x, pt2.y, <span class="number">1</span> );</span><br><span class="line">        Mat d = y2.t() * t_x * R * y1;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epipolar constraint = "</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>find_feature_matches 定义</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_feature_matches</span> <span class="params">( <span class="keyword">const</span> Mat&amp; img_1, <span class="keyword">const</span> Mat&amp; img_2,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_1,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt;&amp; keypoints_2,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-- 初始化</span></span><br><span class="line">    Mat descriptors_1, descriptors_2;</span><br><span class="line">    <span class="comment">// used in OpenCV3 </span></span><br><span class="line">    Ptr&lt;FeatureDetector&gt; detector = ORB::create();</span><br><span class="line">    Ptr&lt;DescriptorExtractor&gt; descriptor = ORB::create();</span><br><span class="line">    <span class="comment">// use this if you are in OpenCV2 </span></span><br><span class="line">    <span class="comment">// Ptr&lt;FeatureDetector&gt; detector = FeatureDetector::create ( "ORB" );</span></span><br><span class="line">    <span class="comment">// Ptr&lt;DescriptorExtractor&gt; descriptor = DescriptorExtractor::create ( "ORB" );</span></span><br><span class="line">    Ptr&lt;DescriptorMatcher&gt; matcher  = DescriptorMatcher::create ( <span class="string">"BruteForce-Hamming"</span> );</span><br><span class="line">    <span class="comment">//-- 第一步:检测 Oriented FAST 角点位置</span></span><br><span class="line">    detector-&gt;detect ( img_1,keypoints_1 );</span><br><span class="line">    detector-&gt;detect ( img_2,keypoints_2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第二步:根据角点位置计算 BRIEF 描述子</span></span><br><span class="line">    descriptor-&gt;compute ( img_1, keypoints_1, descriptors_1 );</span><br><span class="line">    descriptor-&gt;compute ( img_2, keypoints_2, descriptors_2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第三步:对两幅图像中的BRIEF描述子进行匹配，使用 Hamming 距离</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;DMatch&gt; match;</span><br><span class="line">    <span class="comment">//BFMatcher matcher ( NORM_HAMMING );</span></span><br><span class="line">    matcher-&gt;match ( descriptors_1, descriptors_2, match );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 第四步:匹配点对筛选</span></span><br><span class="line">    <span class="keyword">double</span> min_dist=<span class="number">10000</span>, max_dist=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出所有匹配之间的最小距离和最大距离, 即是最相似的和最不相似的两组点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dist = match[i].distance;</span><br><span class="line">        <span class="keyword">if</span> ( dist &lt; min_dist ) min_dist = dist;</span><br><span class="line">        <span class="keyword">if</span> ( dist &gt; max_dist ) max_dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"-- Max dist : %f \n"</span>, max_dist );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"-- Min dist : %f \n"</span>, min_dist );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当描述子之间的距离大于两倍的最小距离时,即认为匹配有误.但有时候最小距离会非常小,设置一个经验值30作为下限.</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; descriptors_1.rows; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( match[i].distance &lt;= max ( <span class="number">2</span>*min_dist, <span class="number">30.0</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            matches.push_back ( match[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像素坐标转相机归一化坐标</span></span><br><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Point2d</span><br><span class="line">           (</span><br><span class="line">               ( p.x - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),</span><br><span class="line">               ( p.y - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> )</span><br><span class="line">           );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>pose_estimation_2d2d 定义</strong><br>从特征点(keypoints)和匹配关系（matches）求解位姿(R,t)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_2d2d</span> <span class="params">( <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_2,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt; matches,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Mat&amp; R, Mat&amp; t )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 相机内参,TUM Freiburg2</span></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 把匹配点转换为vector&lt;Point2f&gt;的形式</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2f&gt; points1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2f&gt; points2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ( <span class="keyword">int</span> ) matches.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        points1.push_back ( keypoints_1[matches[i].queryIdx].pt );</span><br><span class="line">        <span class="comment">//queryIdx为query描述子的索引,match函数中前面的那个描述子 </span></span><br><span class="line">        points2.push_back ( keypoints_2[matches[i].trainIdx].pt );</span><br><span class="line">        <span class="comment">//trainIdx为train描述子的索引,match函数中后面的那个描述子 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 计算基础矩阵</span></span><br><span class="line">    Mat fundamental_matrix;</span><br><span class="line">    fundamental_matrix = findFundamentalMat ( points1, points2, CV_FM_8POINT );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"fundamental_matrix is "</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt; fundamental_matrix&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 计算本质矩阵</span></span><br><span class="line">    <span class="function">Point2d <span class="title">principal_point</span> <span class="params">( <span class="number">325.1</span>, <span class="number">249.7</span> )</span></span>;	<span class="comment">//相机光心, TUM dataset标定值</span></span><br><span class="line">    <span class="keyword">double</span> focal_length = <span class="number">521</span>;			<span class="comment">//相机焦距, TUM dataset标定值</span></span><br><span class="line">    Mat essential_matrix;</span><br><span class="line">    essential_matrix = findEssentialMat ( points1, points2, focal_length, principal_point );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"essential_matrix is "</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt; essential_matrix&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 计算单应矩阵</span></span><br><span class="line">    Mat homography_matrix;</span><br><span class="line">    homography_matrix = findHomography ( points1, points2, RANSAC, <span class="number">3</span> );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"homography_matrix is "</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;homography_matrix&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 从本质矩阵中恢复旋转和平移信息.</span></span><br><span class="line">    recoverPose ( essential_matrix, points1, points2, R, t, focal_length, principal_point );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"R is "</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;R&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"t is "</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pixel2cam 定义</strong><br>像素坐标转相机归一化坐标<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Point2d <span class="title">pixel2cam</span> <span class="params">( <span class="keyword">const</span> Point2d&amp; p, <span class="keyword">const</span> Mat&amp; K )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Point2d</span><br><span class="line">           (</span><br><span class="line">               ( p.x - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ),</span><br><span class="line">               ( p.y - K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ) / K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> )</span><br><span class="line">           );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>运行结果：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ INFO:<span class="number">0</span>] Initialize OpenCL runtime...</span><br><span class="line">-- Max dist : <span class="number">95.000000</span> </span><br><span class="line">-- Min dist : <span class="number">7.000000</span> </span><br><span class="line">一共找到了<span class="number">81</span>组匹配点</span><br><span class="line">fundamental_matrix is </span><br><span class="line">[<span class="number">5.435453065936354e-06</span>, <span class="number">0.0001366043242989653</span>, <span class="number">-0.02140890086948144</span>;</span><br><span class="line"> <span class="number">-0.0001321142229824715</span>, <span class="number">2.339475702778067e-05</span>, <span class="number">-0.006332906454396007</span>;</span><br><span class="line"> <span class="number">0.02107630352202796</span>, <span class="number">-0.003666833952953114</span>, <span class="number">0.9999999999999999</span>]</span><br><span class="line">essential_matrix is </span><br><span class="line">[<span class="number">0.01724015832721706</span>, <span class="number">0.328054335794133</span>, <span class="number">0.0473747783144249</span>;</span><br><span class="line"> <span class="number">-0.3243229585962962</span>, <span class="number">0.03292958445202408</span>, <span class="number">-0.6262554366073018</span>;</span><br><span class="line"> <span class="number">-0.005885857752320116</span>, <span class="number">0.6253830041920333</span>, <span class="number">0.0153167864909267</span>]</span><br><span class="line">homography_matrix is </span><br><span class="line">[<span class="number">0.9131751791807657</span>, <span class="number">-0.1092435315823255</span>, <span class="number">29.95860009984688</span>;</span><br><span class="line"> <span class="number">0.02223560352312278</span>, <span class="number">0.9826008005062553</span>, <span class="number">6.508910839573075</span>;</span><br><span class="line"> <span class="number">-0.0001001560381022834</span>, <span class="number">0.000103777943639824</span>, <span class="number">0.9999999999999999</span>]</span><br><span class="line">R is </span><br><span class="line">[<span class="number">0.9985534106102478</span>, <span class="number">-0.05339308467584758</span>, <span class="number">0.006345444621108698</span>;</span><br><span class="line"> <span class="number">0.05321959721496264</span>, <span class="number">0.9982715997131746</span>, <span class="number">0.02492965459802003</span>;</span><br><span class="line"> <span class="number">-0.007665548311697523</span>, <span class="number">-0.02455588961730239</span>, <span class="number">0.9996690690694516</span>]</span><br><span class="line">t is </span><br><span class="line">[<span class="number">-0.8829934995085544</span>;</span><br><span class="line"> <span class="number">-0.05539655431450562</span>;</span><br><span class="line"> <span class="number">0.4661048182498402</span>]</span><br><span class="line">t^R=</span><br><span class="line">[<span class="number">-0.02438126572381045</span>, <span class="number">-0.4639388908753606</span>, <span class="number">-0.06699805400667856</span>;</span><br><span class="line"> <span class="number">0.4586619266358499</span>, <span class="number">-0.04656946493536188</span>, <span class="number">0.8856589319599302</span>;</span><br><span class="line"> <span class="number">0.008323859859529846</span>, <span class="number">-0.8844251262060034</span>, <span class="number">-0.0216612071874423</span>]</span><br><span class="line">epipolar constraint = [<span class="number">0.004334754136721797</span>]</span><br><span class="line">epipolar constraint = [<span class="number">-0.0002809243685121809</span>]</span><br><span class="line">......</span><br><span class="line">epipolar constraint = [<span class="number">-0.004259380631293275</span>]</span><br><span class="line">epipolar constraint = [<span class="number">-0.0007738612238716719</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="5-三角测量"><a href="#5-三角测量" class="headerlink" title="5 三角测量"></a>5 三角测量</h1><h1 id="6-实践：三角测量"><a href="#6-实践：三角测量" class="headerlink" title="6 实践：三角测量"></a>6 实践：三角测量</h1><p>单目SLAM(2d-2d)中，使用对极约束估计R,tR,t，使用三角测量估计深度<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span> <span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; KeyPoint &gt;&amp; keypoint_1, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; KeyPoint &gt;&amp; keypoint_2, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; DMatch &gt;&amp; matches,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; R, <span class="keyword">const</span> Mat&amp; t, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt; Point3d &gt;&amp; points )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat T1 = (Mat_&lt;<span class="keyword">float</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    Mat T2 = (Mat_&lt;<span class="keyword">float</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2f&gt; pts_1, pts_2;</span><br><span class="line">    <span class="keyword">for</span> ( DMatch m:matches )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将像素坐标转换至相机坐标</span></span><br><span class="line">        pts_1.push_back ( pixel2cam( keypoint_1[m.queryIdx].pt, K) );</span><br><span class="line">        pts_2.push_back ( pixel2cam( keypoint_2[m.trainIdx].pt, K) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Mat pts_4d;</span><br><span class="line">    cv::triangulatePoints( T1, T2, pts_1, pts_2, pts_4d );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pts_4d.cols; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Mat x = pts_4d.col(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3d <span class="title">p</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="function"><span class="params">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="function"><span class="params">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>) </span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">        points.push_back( p );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: triangulation img1 img2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = imread ( argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line">    Mat img_2 = imread ( argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">    find_feature_matches ( img_1, img_2, keypoints_1, keypoints_2, matches );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"一共找到了"</span>&lt;&lt;matches.size() &lt;&lt;<span class="string">"组匹配点"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 估计两张图像间运动</span></span><br><span class="line">    Mat R,t;</span><br><span class="line">    pose_estimation_2d2d ( keypoints_1, keypoints_2, matches, R, t );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- 三角化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Point3d&gt; points;</span><br><span class="line">    triangulation( keypoints_1, keypoints_2, matches, R, t, points );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-- 验证三角化点与特征点的重投影关系</span></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matches.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Point2d pt1_cam = pixel2cam( keypoints_1[ matches[i].queryIdx ].pt, K );</span><br><span class="line">        <span class="function">Point2d <span class="title">pt1_cam_3d</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            points[i].x/points[i].z, </span></span></span><br><span class="line"><span class="function"><span class="params">            points[i].y/points[i].z </span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point in the first camera frame: "</span>&lt;&lt;pt1_cam&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point projected from 3D "</span>&lt;&lt;pt1_cam_3d&lt;&lt;<span class="string">", d="</span>&lt;&lt;points[i].z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二个图</span></span><br><span class="line">        Point2f pt2_cam = pixel2cam( keypoints_2[ matches[i].trainIdx ].pt, K );</span><br><span class="line">        Mat pt2_trans = R*( Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">1</span>) &lt;&lt; points[i].x, points[i].y, points[i].z ) + t;</span><br><span class="line">        pt2_trans /= pt2_trans.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point in the second camera frame: "</span>&lt;&lt;pt2_cam&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"point reprojected from second frame: "</span>&lt;&lt;pt2_trans.t()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="7-3D-2D-PnP"><a href="#7-3D-2D-PnP" class="headerlink" title="7 3D-2D:PnP"></a>7 3D-2D:PnP</h1><ul>
<li>PnP(Perspective-n-Point)是求解 3D 到 2D 点对运动的方法。最少只需三个点对(需要至少一个额外点验证结果)就可以估计相机运动。</li>
<li>PnP 问题有很多种求解方法,例如用三对点估计位姿的 P3P,直接线性变换(DLT),EPnP(Efficient PnP),UPnP等等)。此外,还能用非线性优化的方式,构建最小二乘问题并迭代求解,也就是万金油式的 Bundle Adjustment。<h2 id="7-1-直接线性变换"><a href="#7-1-直接线性变换" class="headerlink" title="7.1 直接线性变换"></a>7.1 直接线性变换</h2><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190909185144366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><h2 id="7-2-P3P"><a href="#7-2-P3P" class="headerlink" title="7.2 P3P"></a>7.2 P3P</h2><h2 id="7-3-Bundle-Adjustment"><a href="#7-3-Bundle-Adjustment" class="headerlink" title="7.3 Bundle Adjustment"></a>7.3 Bundle Adjustment</h2><h1 id="8-实践：求解PnP"><a href="#8-实践：求解PnP" class="headerlink" title="8 实践：求解PnP"></a>8 实践：求解PnP</h1><h2 id="8-1-使用EPnP求解位姿"><a href="#8-1-使用EPnP求解位姿" class="headerlink" title="8.1 使用EPnP求解位姿"></a>8.1 使用EPnP求解位姿</h2></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">5</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: pose_estimation_3d2d img1 img2 depth1 depth2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-- 读取图像</span></span><br><span class="line">    Mat img_1 = imread ( argv[<span class="number">1</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line">    Mat img_2 = imread ( argv[<span class="number">2</span>], CV_LOAD_IMAGE_COLOR );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints_1, keypoints_2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">    find_feature_matches ( img_1, img_2, keypoints_1, keypoints_2, matches );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"一共找到了"</span>&lt;&lt;matches.size() &lt;&lt;<span class="string">"组匹配点"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立3D点</span></span><br><span class="line">    Mat d1 = imread ( argv[<span class="number">3</span>], CV_LOAD_IMAGE_UNCHANGED );       <span class="comment">// 深度图为16位无符号数，单通道图像</span></span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">520.9</span>, <span class="number">0</span>, <span class="number">325.1</span>, <span class="number">0</span>, <span class="number">521.0</span>, <span class="number">249.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point3f&gt; pts_3d;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2f&gt; pts_2d;</span><br><span class="line">    <span class="keyword">for</span> ( DMatch m:matches )</span><br><span class="line">    &#123;</span><br><span class="line">        ushort d = d1.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; (<span class="keyword">int</span> ( keypoints_1[m.queryIdx].pt.y )) [ <span class="keyword">int</span> ( keypoints_1[m.queryIdx].pt.x ) ];</span><br><span class="line">        <span class="keyword">if</span> ( d == <span class="number">0</span> )   <span class="comment">// bad depth</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">float</span> dd = d/<span class="number">5000.0</span>;</span><br><span class="line">        Point2d p1 = pixel2cam ( keypoints_1[m.queryIdx].pt, K );</span><br><span class="line">        pts_3d.push_back ( Point3f ( p1.x*dd, p1.y*dd, dd ) );</span><br><span class="line">        pts_2d.push_back ( keypoints_2[m.trainIdx].pt );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"3d-2d pairs: "</span>&lt;&lt;pts_3d.size() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Mat r, t;</span><br><span class="line">    solvePnP ( pts_3d, pts_2d, K, Mat(), r, t, <span class="literal">false</span> ); <span class="comment">// 调用OpenCV 的 PnP 求解，可选择EPNP，DLS等方法</span></span><br><span class="line">    Mat R;</span><br><span class="line">    cv::Rodrigues ( r, R ); <span class="comment">// r为旋转向量形式，用Rodrigues公式转换为矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"R="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;R&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"t="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"calling bundle adjustment"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    bundleAdjustment ( pts_3d, pts_2d, K, R, t );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-- Max dist : <span class="number">95.000000</span> </span><br><span class="line">-- Min dist : <span class="number">7.000000</span> </span><br><span class="line">一共找到了<span class="number">81</span>组匹配点</span><br><span class="line"><span class="number">3</span>d<span class="number">-2</span>d pairs: <span class="number">77</span></span><br><span class="line">R=</span><br><span class="line">[<span class="number">0.9979193252225089</span>, <span class="number">-0.05138618904650331</span>, <span class="number">0.03894200717386666</span>;</span><br><span class="line"> <span class="number">0.05033852907733834</span>, <span class="number">0.9983556574295412</span>, <span class="number">0.02742286944793203</span>;</span><br><span class="line"> <span class="number">-0.04028712992734059</span>, <span class="number">-0.02540552801469367</span>, <span class="number">0.9988651091656532</span>]</span><br><span class="line">t=</span><br><span class="line">[<span class="number">-0.1255867099750398</span>;</span><br><span class="line"> <span class="number">-0.007363525258777434</span>;</span><br><span class="line"> <span class="number">0.06099926588678889</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="8-2-使用BA优化"><a href="#8-2-使用BA优化" class="headerlink" title="8.2 使用BA优化"></a>8.2 使用BA优化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Point3f &gt; points_3d,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Point2f &gt; points_2d,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; K,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; R, Mat&amp; t )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt; g2o::BlockSolverTraits&lt;<span class="number">6</span>,<span class="number">3</span>&gt; &gt; Block;  <span class="comment">// pose 维度为 6, landmark 维度为 3</span></span><br><span class="line">    Block::LinearSolverType* linearSolver = <span class="keyword">new</span> g2o::LinearSolverCSparse&lt;Block::PoseMatrixType&gt;(); <span class="comment">// 线性方程求解器</span></span><br><span class="line">    Block* solver_ptr = <span class="keyword">new</span> Block ( linearSolver );     <span class="comment">// 矩阵块求解器</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg ( solver_ptr );</span><br><span class="line">    g2o::SparseOptimizer optimizer;</span><br><span class="line">    optimizer.setAlgorithm ( solver );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vertex</span></span><br><span class="line">    g2o::VertexSE3Expmap* pose = <span class="keyword">new</span> g2o::VertexSE3Expmap(); <span class="comment">// camera pose</span></span><br><span class="line">    Eigen::Matrix3d R_mat;</span><br><span class="line">    R_mat &lt;&lt;</span><br><span class="line">          R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">1</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ),</span><br><span class="line">               R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">0</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ),</span><br><span class="line">               R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">0</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">1</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">2</span> );</span><br><span class="line">    pose-&gt;setId ( <span class="number">0</span> );</span><br><span class="line">    pose-&gt;setEstimate ( g2o::SE3Quat (</span><br><span class="line">                            R_mat,</span><br><span class="line">                            Eigen::Vector3d ( t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ), t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">0</span> ), t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">0</span> ) )</span><br><span class="line">                        ) );</span><br><span class="line">    optimizer.addVertex ( pose );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">const</span> Point3f p:points_3d )   <span class="comment">// landmarks</span></span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSBAPointXYZ* point = <span class="keyword">new</span> g2o::VertexSBAPointXYZ();</span><br><span class="line">        point-&gt;setId ( index++ );</span><br><span class="line">        point-&gt;setEstimate ( Eigen::Vector3d ( p.x, p.y, p.z ) );</span><br><span class="line">        point-&gt;setMarginalized ( <span class="literal">true</span> ); <span class="comment">// g2o 中必须设置 marg 参见第十讲内容</span></span><br><span class="line">        optimizer.addVertex ( point );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parameter: camera intrinsics</span></span><br><span class="line">    g2o::CameraParameters* camera = <span class="keyword">new</span> g2o::CameraParameters (</span><br><span class="line">        K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ), Eigen::Vector2d ( K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ), K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ), <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">    camera-&gt;setId ( <span class="number">0</span> );</span><br><span class="line">    optimizer.addParameter ( camera );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// edges</span></span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">const</span> Point2f p:points_2d )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV* edge = <span class="keyword">new</span> g2o::EdgeProjectXYZ2UV();</span><br><span class="line">        edge-&gt;setId ( index );</span><br><span class="line">        edge-&gt;setVertex ( <span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt; ( optimizer.vertex ( index ) ) );</span><br><span class="line">        edge-&gt;setVertex ( <span class="number">1</span>, pose );</span><br><span class="line">        edge-&gt;setMeasurement ( Eigen::Vector2d ( p.x, p.y ) );</span><br><span class="line">        edge-&gt;setParameterId ( <span class="number">0</span>,<span class="number">0</span> );</span><br><span class="line">        edge-&gt;setInformation ( Eigen::Matrix2d::Identity() );</span><br><span class="line">        optimizer.addEdge ( edge );</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">    optimizer.setVerbose ( <span class="literal">true</span> );</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize ( <span class="number">100</span> );</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt; ( t2-t1 );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"optimization costs time: "</span>&lt;&lt;time_used.count() &lt;&lt;<span class="string">" seconds."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"after optimization:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"T="</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;Eigen::Isometry3d ( pose-&gt;estimate() ).matrix() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">calling bundle adjustment</span><br><span class="line">iteration= <span class="number">0</span>	 chi2= <span class="number">0.001292</span>	 time= <span class="number">0.000468135</span>	 cumTime= <span class="number">0.000468135</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">80.003723</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">1</span>	 chi2= <span class="number">0.000000</span>	 time= <span class="number">2.6183e-05</span>	 cumTime= <span class="number">0.000494318</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">53.335815</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">2</span>	 chi2= <span class="number">0.000000</span>	 time= <span class="number">2.541e-05</span>	 cumTime= <span class="number">0.000519728</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">35.557210</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">3</span>	 chi2= <span class="number">0.000000</span>	 time= <span class="number">2.3129e-05</span>	 cumTime= <span class="number">0.000542857</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">23.704807</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">4</span>	 chi2= <span class="number">0.000000</span>	 time= <span class="number">2.3182e-05</span>	 cumTime= <span class="number">0.000566039</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">15.803205</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">5</span>	 chi2= <span class="number">0.000000</span>	 time= <span class="number">2.2782e-05</span>	 cumTime= <span class="number">0.000588821</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">10.535470</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">6</span>	 chi2= <span class="number">0.000000</span>	 time= <span class="number">7.2227e-05</span>	 cumTime= <span class="number">0.000661048</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">230150.846755</span>	 levenbergIter= <span class="number">6</span></span><br><span class="line">iteration= <span class="number">7</span>	 chi2= <span class="number">0.000000</span>	 time= <span class="number">5.2096e-05</span>	 cumTime= <span class="number">0.000713144</span>	 edges= <span class="number">77</span>	 schur= <span class="number">1</span>	 lambda= <span class="number">235674467.076671</span>	 levenbergIter= <span class="number">4</span></span><br><span class="line">optimization costs time: <span class="number">0.000928678</span> seconds.</span><br><span class="line"></span><br><span class="line">after optimization:</span><br><span class="line">T=</span><br><span class="line">   <span class="number">0.997841</span>  <span class="number">-0.0518393</span>   <span class="number">0.0403291</span>   <span class="number">-0.127516</span></span><br><span class="line">  <span class="number">0.0507013</span>      <span class="number">0.9983</span>    <span class="number">0.028745</span> <span class="number">-0.00947167</span></span><br><span class="line"> <span class="number">-0.0417507</span>  <span class="number">-0.0266382</span>    <span class="number">0.998773</span>   <span class="number">0.0595037</span></span><br><span class="line">          <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="9-3D-3D-ICP"><a href="#9-3D-3D-ICP" class="headerlink" title="9 3D-3D:ICP"></a>9 3D-3D:ICP</h1><p>迭代最近点ICP（ Iterative Closest Point） ，指代匹配好的两组点云间运动估计问题。求解 3D坐标 到 3D坐标的转换矩阵(不用求解距离 激光SLAM 以及 RGB-D SLAM)</p>
<h2 id="9-1-SVD方法"><a href="#9-1-SVD方法" class="headerlink" title="9.1 SVD方法"></a>9.1 SVD方法</h2><p>先定义第i对点的误差项：</p>
<script type="math/tex; mode=display">e_{i}=p_{i}-(Rp^{'}_{i}+t)</script><p>然后，构建最小二乘问题，求使误差平方和达到极小的R,t:</p>
<script type="math/tex; mode=display">\min_{R,t}=\frac{1}{2}\sum_{1}^{n}\left \| \left ( p_{i} -\left ( Rp^{'}_{i}+t \right )\right ) \right \|\tfrac{2}{2}</script><h2 id="9-2-非线性优化方法"><a href="#9-2-非线性优化方法" class="headerlink" title="9.2 非线性优化方法"></a>9.2 非线性优化方法</h2><script type="math/tex; mode=display">\min_{\xi}=\frac{1}{2}\sum_{i=1}^{n}\left \| (p_{i}-exp\left ( \xi ^{\wedge } \right )) p_{i}^{'}\right
 \|\tfrac{2}{2}$$代数扰动模型：
 $$\frac{\partial e}{\partial \delta \xi }=-\left ( exp\left ( \xi ^{\wedge }  \right )p^{'}_{i} \right )^{\bigodot }</script><p> 在非线性优化中，只需要不断的迭代，就能找到极小值<br> 这里ICP指已由图像特征给定了匹配的情况下进行位姿估计的问题。在匹配已知情况下，最小二乘解具有解析解，没必要进行迭代优化<br> 在RGB-D SLAM中，由于一个像素的深度数据可能测不到，可以混合使用PnP和ICP优化：</p>
<ol>
<li>对深度已知的特征点，建模3D-3D误差。</li>
<li>对于深度未知的特征点，建模3D-2D的重投影误差<h1 id="10-实践：求解ICP"><a href="#10-实践：求解ICP" class="headerlink" title="10 实践：求解ICP"></a>10 实践：求解ICP</h1><h2 id="10-1-SVD方法"><a href="#10-1-SVD方法" class="headerlink" title="10.1 SVD方法"></a>10.1 SVD方法</h2></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pose_estimation_3d3d</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; pts1,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point3f&gt;&amp; pts2,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; R, Mat&amp; t</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point3f p1, p2;     <span class="comment">// center of mass</span></span><br><span class="line">    <span class="keyword">int</span> N = pts1.size();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p1 += pts1[i];</span><br><span class="line">        p2 += pts2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    p1 = Point3f( Vec3f(p1) /  N);</span><br><span class="line">    p2 = Point3f( Vec3f(p2) / N);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point3f&gt;     q1 ( N ), q2 ( N ); <span class="comment">// remove the center</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q1[i] = pts1[i] - p1;</span><br><span class="line">        q2[i] = pts2[i] - p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute q1*q2^T</span></span><br><span class="line">    Eigen::Matrix3d W = Eigen::Matrix3d::Zero();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        W += Eigen::Vector3d ( q1[i].x, q1[i].y, q1[i].z ) * Eigen::Vector3d ( q2[i].x, q2[i].y, q2[i].z ).transpose();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"W="</span>&lt;&lt;W&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SVD on W</span></span><br><span class="line">    Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; svd ( W, Eigen::ComputeFullU|Eigen::ComputeFullV );</span><br><span class="line">    Eigen::Matrix3d U = svd.matrixU();</span><br><span class="line">    Eigen::Matrix3d V = svd.matrixV();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (U.determinant() * V.determinant() &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            U(x, <span class="number">2</span>) *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"U="</span>&lt;&lt;U&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"V="</span>&lt;&lt;V&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3d R_ = U* ( V.transpose() );</span><br><span class="line">    Eigen::Vector3d t_ = Eigen::Vector3d ( p1.x, p1.y, p1.z ) - R_ * Eigen::Vector3d ( p2.x, p2.y, p2.z );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert to cv::Mat</span></span><br><span class="line">    R = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt;</span><br><span class="line">          R_ ( <span class="number">0</span>,<span class="number">0</span> ), R_ ( <span class="number">0</span>,<span class="number">1</span> ), R_ ( <span class="number">0</span>,<span class="number">2</span> ),</span><br><span class="line">          R_ ( <span class="number">1</span>,<span class="number">0</span> ), R_ ( <span class="number">1</span>,<span class="number">1</span> ), R_ ( <span class="number">1</span>,<span class="number">2</span> ),</span><br><span class="line">          R_ ( <span class="number">2</span>,<span class="number">0</span> ), R_ ( <span class="number">2</span>,<span class="number">1</span> ), R_ ( <span class="number">2</span>,<span class="number">2</span> )</span><br><span class="line">        );</span><br><span class="line">    t = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">1</span> ) &lt;&lt; t_ ( <span class="number">0</span>,<span class="number">0</span> ), t_ ( <span class="number">1</span>,<span class="number">0</span> ), t_ ( <span class="number">2</span>,<span class="number">0</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-- Max dist : <span class="number">95.000000</span> </span><br><span class="line">-- Min dist : <span class="number">7.000000</span> </span><br><span class="line">一共找到了<span class="number">81</span>组匹配点</span><br><span class="line"><span class="number">3</span>d<span class="number">-3</span>d pairs: <span class="number">75</span></span><br><span class="line">W=  <span class="number">11.8688</span> <span class="number">-0.717698</span>   <span class="number">1.89486</span></span><br><span class="line"> <span class="number">-1.88065</span>   <span class="number">3.83391</span>  <span class="number">-5.78219</span></span><br><span class="line">  <span class="number">3.25846</span>  <span class="number">-5.82734</span>   <span class="number">9.65267</span></span><br><span class="line">U=  <span class="number">0.592295</span>  <span class="number">-0.805658</span> <span class="number">-0.0101195</span></span><br><span class="line"> <span class="number">-0.418171</span>  <span class="number">-0.318113</span>   <span class="number">0.850845</span></span><br><span class="line">  <span class="number">0.688709</span>   <span class="number">0.499719</span>   <span class="number">0.525319</span></span><br><span class="line">V=   <span class="number">0.64736</span>  <span class="number">-0.761401</span> <span class="number">-0.0345329</span></span><br><span class="line"> <span class="number">-0.388765</span>  <span class="number">-0.368829</span>   <span class="number">0.844291</span></span><br><span class="line">  <span class="number">0.655581</span>   <span class="number">0.533135</span>   <span class="number">0.534772</span></span><br><span class="line">ICP via SVD results: </span><br><span class="line">R = [<span class="number">0.9972065647956201</span>, <span class="number">0.05834273442898391</span>, <span class="number">-0.04663895869192625</span>;</span><br><span class="line"> <span class="number">-0.05787745545449197</span>, <span class="number">0.998260122172866</span>, <span class="number">0.01126626067193237</span>;</span><br><span class="line"> <span class="number">0.04721511705620757</span>, <span class="number">-0.008535444848613793</span>, <span class="number">0.9988482762174666</span>]</span><br><span class="line">t = [<span class="number">0.1379879629890433</span>;</span><br><span class="line"> <span class="number">-0.06551699470729988</span>;</span><br><span class="line"> <span class="number">-0.02981649388290575</span>]</span><br><span class="line">R_inv = [<span class="number">0.9972065647956201</span>, <span class="number">-0.05787745545449197</span>, <span class="number">0.04721511705620757</span>;</span><br><span class="line"> <span class="number">0.05834273442898391</span>, <span class="number">0.998260122172866</span>, <span class="number">-0.008535444848613793</span>;</span><br><span class="line"> <span class="number">-0.04663895869192625</span>, <span class="number">0.01126626067193237</span>, <span class="number">0.9988482762174666</span>]</span><br><span class="line">t_inv = [<span class="number">-0.1399866702492459</span>;</span><br><span class="line"> <span class="number">0.05709791102272541</span>;</span><br><span class="line"> <span class="number">0.03695589996443214</span>]</span><br></pre></td></tr></table></figure>
<h2 id="10-2-非线性优化方法"><a href="#10-2-非线性优化方法" class="headerlink" title="10.2 非线性优化方法"></a>10.2 非线性优化方法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g2o edge</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeProjectXYZRGBDPoseOnly</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">3</span>, Eigen::Vector3d, g2o::VertexSE3Expmap&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;</span><br><span class="line">    EdgeProjectXYZRGBDPoseOnly( <span class="keyword">const</span> Eigen::Vector3d&amp; point ) : _point(point) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> g2o::VertexSE3Expmap* pose = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> g2o::VertexSE3Expmap*&gt; ( _vertices[<span class="number">0</span>] );</span><br><span class="line">        <span class="comment">// measurement is p, point is p'</span></span><br><span class="line">        _error = _measurement - pose-&gt;estimate().<span class="built_in">map</span>( _point );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g2o::VertexSE3Expmap* pose = <span class="keyword">static_cast</span>&lt;g2o::VertexSE3Expmap *&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line">        g2o::<span class="function">SE3Quat <span class="title">T</span><span class="params">(pose-&gt;estimate())</span></span>;</span><br><span class="line">        Eigen::Vector3d xyz_trans = T.<span class="built_in">map</span>(_point);</span><br><span class="line">        <span class="keyword">double</span> x = xyz_trans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> y = xyz_trans[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> z = xyz_trans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">1</span>) = -z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">2</span>) = y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">3</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">0</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">0</span>) = z;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">2</span>) = -x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">4</span>) = <span class="number">-1</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">0</span>) = -y;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">1</span>) = x;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">        _jacobianOplusXi(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span> <span class="params">( istream&amp; in )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span> <span class="params">( ostream&amp; out )</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Eigen::Vector3d _point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">calling bundle adjustment</span><br><span class="line">iteration= <span class="number">0</span>	 chi2= <span class="number">18157.747747</span>	 time= <span class="number">3.7213e-05</span>	 cumTime= <span class="number">3.7213e-05</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">1</span>	 chi2= <span class="number">18151.933202</span>	 time= <span class="number">1.1232e-05</span>	 cumTime= <span class="number">4.8445e-05</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">2</span>	 chi2= <span class="number">18151.932131</span>	 time= <span class="number">1.0144e-05</span>	 cumTime= <span class="number">5.8589e-05</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">3</span>	 chi2= <span class="number">18151.932130</span>	 time= <span class="number">1.097e-05</span>	 cumTime= <span class="number">6.9559e-05</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">4</span>	 chi2= <span class="number">18151.932130</span>	 time= <span class="number">9.71e-06</span>	 cumTime= <span class="number">7.9269e-05</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">5</span>	 chi2= <span class="number">18151.932130</span>	 time= <span class="number">9.615e-06</span>	 cumTime= <span class="number">8.8884e-05</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">6</span>	 chi2= <span class="number">18151.932130</span>	 time= <span class="number">9.521e-06</span>	 cumTime= <span class="number">9.8405e-05</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">7</span>	 chi2= <span class="number">18151.932130</span>	 time= <span class="number">9.583e-06</span>	 cumTime= <span class="number">0.000107988</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">8</span>	 chi2= <span class="number">18151.932130</span>	 time= <span class="number">9.505e-06</span>	 cumTime= <span class="number">0.000117493</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">iteration= <span class="number">9</span>	 chi2= <span class="number">18151.932130</span>	 time= <span class="number">9.484e-06</span>	 cumTime= <span class="number">0.000126977</span>	 edges= <span class="number">75</span>	 schur= <span class="number">0</span></span><br><span class="line">optimization costs time: <span class="number">0.000380717</span> seconds.</span><br><span class="line"></span><br><span class="line">after optimization:</span><br><span class="line">T=</span><br><span class="line">   <span class="number">0.997207</span>   <span class="number">0.0583427</span>   <span class="number">-0.046639</span>    <span class="number">0.137988</span></span><br><span class="line"> <span class="number">-0.0578775</span>     <span class="number">0.99826</span>   <span class="number">0.0112663</span>   <span class="number">-0.065517</span></span><br><span class="line">  <span class="number">0.0472151</span> <span class="number">-0.00853546</span>    <span class="number">0.998848</span>  <span class="number">-0.0298169</span></span><br><span class="line">          <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span></span><br><span class="line">p1 = [<span class="number">-0.0374123</span>, <span class="number">-0.830816</span>, <span class="number">2.7448</span>]</span><br><span class="line">p2 = [<span class="number">-0.0111479</span>, <span class="number">-0.746763</span>, <span class="number">2.7652</span>]</span><br><span class="line">(R*p2+t) = [<span class="number">-0.04566300488482969</span>;</span><br><span class="line"> <span class="number">-0.7791822151698653</span>;</span><br><span class="line"> <span class="number">2.738046267661636</span>]</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">-0.243698</span>, <span class="number">-0.117719</span>, <span class="number">1.5848</span>]</span><br><span class="line">p2 = [<span class="number">-0.299118</span>, <span class="number">-0.0975683</span>, <span class="number">1.6558</span>]</span><br><span class="line">(R*p2+t) = [<span class="number">-0.243212054430598</span>;</span><br><span class="line"> <span class="number">-0.1269486029625337</span>;</span><br><span class="line"> <span class="number">1.610786345002579</span>]</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">-0.627753</span>, <span class="number">0.160186</span>, <span class="number">1.3396</span>]</span><br><span class="line">p2 = [<span class="number">-0.709645</span>, <span class="number">0.159033</span>, <span class="number">1.4212</span>]</span><br><span class="line">(R*p2+t) = [<span class="number">-0.6266796777024644</span>;</span><br><span class="line"> <span class="number">0.1503229238263245</span>;</span><br><span class="line"> <span class="number">1.354883323538178</span>]</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">-0.323443</span>, <span class="number">0.104873</span>, <span class="number">1.4266</span>]</span><br><span class="line">p2 = [<span class="number">-0.399079</span>, <span class="number">0.12047</span>, <span class="number">1.4838</span>]</span><br><span class="line">(R*p2+t) = [<span class="number">-0.3221508525590339</span>;</span><br><span class="line"> <span class="number">0.09455772952719482</span>;</span><br><span class="line"> <span class="number">1.432403794814274</span>]</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">-0.627221</span>, <span class="number">0.101454</span>, <span class="number">1.3116</span>]</span><br><span class="line">p2 = [<span class="number">-0.709709</span>, <span class="number">0.100216</span>, <span class="number">1.3998</span>]</span><br><span class="line">(R*p2+t) = [<span class="number">-0.6291763602679332</span>;</span><br><span class="line"> <span class="number">0.09137127679150184</span>;</span><br><span class="line"> <span class="number">1.334006907588644</span>]</span><br></pre></td></tr></table></figure>
<p>待写！！！</p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu16 小觅双目摄像头 MYNT-EYE-S-SDK安装</title>
    <url>/2019/05/19/ubuntu16-%E5%B0%8F%E8%A7%85%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4-MYNT-EYE-S-SDK%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190620200415708.png"><br>注：下载安装前保证opencv等已安装</p><h1 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h1><p>链接：<a href="https://github.com/slightech/MYNT-EYE-S-SDK" target="_blank" rel="noopener">https://github.com/slightech/MYNT-EYE-S-SDK</a><br>下载SDK解压右击打开终端</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cd &lt;sdk&gt;<span class="comment">#&lt;sdk&gt; 是指解压后文件名</span></span><br><span class="line">make init</span><br><span class="line">make install</span><br><span class="line"><span class="comment">#Building samples</span></span><br><span class="line">make samples</span><br><span class="line"><span class="comment">#Building tools</span></span><br><span class="line">make tools</span><br><span class="line"></span><br><span class="line"><span class="comment">#Run samples:</span></span><br><span class="line">./samples/_output/bin/api/camera_a</span><br></pre></td></tr></table></figure><a id="more"></a>


<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190620195602356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="ros安装"><a href="#ros安装" class="headerlink" title="ros安装"></a>ros安装</h1><p>提前装好ros<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cd</span> <span class="string">&lt;sdk&gt;</span></span><br><span class="line"><span class="attr">make</span> <span class="string">ros</span></span><br><span class="line"><span class="comment">#运行节点</span></span><br><span class="line"><span class="attr">source</span> <span class="string">wrappers/ros/devel/setup.bash</span></span><br><span class="line"><span class="attr">roslaunch</span> <span class="string">mynt_eye_ros_wrapper mynteye.launch  # 这个节点没有图像显示</span></span><br></pre></td></tr></table></figure><br>运行节点，同时打开 RViz 预览：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">source wrappers/ros/devel/<span class="built_in">setup</span>.bash</span><br><span class="line">roslaunch mynt_eye_ros_wrapper <span class="built_in">display</span>.launch</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190622195615316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>获得当前工作设备的图像校准参数与imu校准参数：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">cd <span class="params">&lt;sdk&gt;</span></span><br><span class="line">.<span class="meta-keyword">/samples/</span>_output<span class="meta-keyword">/bin/</span>tutorials/get_img_params     <span class="comment">//获取相机标定参数</span></span><br><span class="line">.<span class="meta-keyword">/samples/</span>_output<span class="meta-keyword">/bin/</span>tutorials/get_imu_params    <span class="comment">//获取IMU标定参数</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>视觉slam十四讲  6.非线性优化</title>
    <url>/2019/05/15/%E8%A7%86%E8%A7%89slam%E5%8D%81%E5%9B%9B%E8%AE%B2-6-%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>公式编辑：<a href="https://codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">https://codecogs.com/latex/eqneditor.php</a></p><h1 id="1-状态估计问题"><a href="#1-状态估计问题" class="headerlink" title="1.状态估计问题"></a>1.状态估计问题</h1><p> 1.1 最大后验与最大似然</p><ol>
<li><p>经典 SLAM 模型：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190620095930583.png"></div></p>
<p>其中 $x_{k}$为相机的位姿，$u$ 为输入数据，即为采集到的数据<br>假如我们在$x_{k}$处观测到路标 $y_{j}$，对应到图像上的像素位置$z_{k,j}$，那么我们的观测方程可以表示为：</p>
<script type="math/tex; mode=display">sz_{k,j}=Kexp\left ( \xi ^{\wedge } \right )y_{i}</script></li>
<li><p>在运动和观测方程中，通常假设两个噪声项 $w_{k}$，$v_{k}$满足零均值的高斯分布：</p>
<script type="math/tex; mode=display">w_{k}~N\left ( 0,R_{k} \right ),v_{k}~N\left ( 0,Q_{k,j} \right )</script></li>
<li><p>状态估计问题：通过带噪声的数据 $z$和 $u$ ，推断位姿 $x$ 和地图 $y$（以及它们的概率分布），其中有优化方法有：<br>（1）扩展卡尔曼滤波器（EKF）求解，关心的是当前时刻的状态估计，而对直之前的状态没有多加考虑。<br>（2）非线性优化，使用所有时刻采集到的数据进行状态估计，被认为优于传统滤波器，成为当前视觉slam的主流。<br>  非线性优化把所待估计的变量都放在一个状态变量中：</p>
<script type="math/tex; mode=display">x=\left \{ x_{1},...,x_{N},y_{1},...,y_{M} \right \}</script><p>  已知：输入读数$u$，观测值$z$。（带噪声）<br>目标：$P\left ( x|z,u \right )$，只考虑$z$时：$P\left ( x|z \right )$</p>
</li>
<li><p>贝叶斯法则：</p>
<script type="math/tex; mode=display">{\color{Red} P\left ( x|z \right )=\frac{P\left ( z|x \right )P\left ( x \right )}{P\left ( z \right )} \rightarrow {\color{Red} } P\left ( z|x \right )P\left ( x \right )}</script></li>
<li>贝叶斯法则左侧通常称为后验概率。它右侧的$P\left ( z|x \right )$称为似然，另一部分$P\left ( x\right )$称为先验.</li>
<li><p>直接求后验分布较困难，转而求一个状态最优估计，使得在该状态下，后验概率最大化(MPA): </p>
<script type="math/tex; mode=display">x^{*}MAP=argmax P\left ( x|z \right )=arg maxP\left ( z \right )</script><p>若不知道机器人位姿大概在什么地方，此时就没有了先验。进而可以求解$x$的最大似然估计：</p>
<script type="math/tex; mode=display">x^{*}_{MLE}=argmaxP\left ( z|x \right )</script><p>  最大似然估计，可以理解成：“<strong>在什么样的状态下，最可能产生现在观测到的数据</strong>”</p>
<h2 id="1-2-最小二乘的引出"><a href="#1-2-最小二乘的引出" class="headerlink" title="1.2 最小二乘的引出"></a>1.2 最小二乘的引出</h2></li>
<li>对于某一次观测：<script type="math/tex; mode=display">z_{k,j}=h\left ( y_{j} ,x_{k}\right )+v_{k,j}</script></li>
</ol><a id="more"></a>


<p>   假设噪声项 $v_{k}$∼$N\left ( 0,Q_{k,j} \right )$，所以观测数据的条件概率为：</p>
<script type="math/tex; mode=display">P\left ( z_{k,j}|x_{k} ,y_{j}\right )=N\left ( h\left ( y_{i},x_{k} \right ) ,Q_{k,j}\right )</script><ol>
<li>为了计算使它最大化的$x_{k},y_{k}$,使用<strong>最小化负对数</strong>的方式，来<strong>求</strong>一个<strong>高斯分布的最大似然</strong>。考虑一个任意的高维高斯分布$v_{k}$∼$N\left ( μ,Σ\right )$ ，它的概率密度函数展开形式为:<script type="math/tex; mode=display">P\left ( x \right )=\frac{1}{\sqrt{\left ( 2\pi  \right )^Ndet(\sum )}}exp(-\frac{1}{2}\left ( x-\mu  \right )^T
\Sigma ^{-1}\left ( x-\mu  \right ))</script> <strong>取负对数：</strong><script type="math/tex; mode=display">-\ln \left ( P\left ( x \right ) \right )=\frac{1}{2}\ln \left ( \left ( 2\pi  \right ) ^N det\left ( \Sigma  \right )\right )+\frac{1}{2}\left ( x-\mu  \right )^T\Sigma ^{-1}\left ( x-\mu  \right )</script></li>
<li>第一项与 $x$ 无关，可以略去。代入 SLAM 的观测模型，相当于在求：<br><script type="math/tex">x^{*}=arg min\left ( (z_{k,j}-h(x_{k},y_{j})) ^TQ_{k,j}^{-1}(z_{k,j}-h(x_{k},y_{j}))\right )</script> 该式等价于最小化噪声项（即误差）的平方（$Σ$ 范数意义下）</li>
<li>对于所有的运动和任意的观测，定义数据与估计值之间的误差：<script type="math/tex">e_{v,k}=x_{k}-f\left ( x_{k-1} ,u_{k}\right )\\
e_{v,j,k}=z_{k,j}-f\left ( x_{k} ,y_{}\right )</script></li>
</ol>
<p>   并求该误差的平方之和：</p>
<script type="math/tex; mode=display">J(x)=\sum _{k}e_{T}^{v,k}R_{k}^{-1}e_{v,k}+\sum _{k}\sum _{j}e_{y,k,j}^{T}Q_{k,j}^{-1}e_{y,k,j}</script><p>这样就得到一个总体意义下的<strong>最小二乘问题</strong>，它的<strong>最优解等价于状态的最大似然估计</strong>。由于噪声的存在，当我们把估计的轨迹与地图代入SLAM的运动、观测方程时，并不会很完美，可以对状态进行微调，使得整体的误差下降到一个极小值。</p>
<ol>
<li>SLAM中的最小二乘问题具有一些特定的结构：<br>(1)整个问题的目标函数由许多个误差的（加权的）平方和组成。虽然总体的状态变量维数很高，但每个误差项都是简单的，仅与一俩个状态变量有关，运动误差只与$x_{k-1},x_{k}$有关，观测误差只与$x_{k},y_{j}$有关，每个误差是个小规模约束，把这误差项的小雅克比矩阵放在整体的雅克比矩阵中。称每个误差项对应优化变量为<strong>参数快</strong>。<br>整体误差由很多小误差项之和组成的问题，其增量方程具有一定的<strong>稀疏性</strong>。<br>(2)如果使用<strong>李代数表示</strong>，那么该问题转换成<em>*无约束最小二乘问题</em>，用旋转矩阵描述姿态会引入自身的约束<br>(3)使用二范数度量误差，相当于欧式空间中距离的平方。<h1 id="2-非线性最小二乘"><a href="#2-非线性最小二乘" class="headerlink" title="2.非线性最小二乘"></a>2.非线性最小二乘</h1>最简单的最小二乘问题: <script type="math/tex; mode=display">\min_{x}\frac{1}{2}\left \| f(x) \right \|_{2}^{2}</script>为求其最小值，则需要求其导数，然后得到其求解 x的最优解<br>对于不方便求解的最小二乘问题，可以用迭代的方法，从初始值出发，不断的跟新当前的优化变量，使目标函数下降，具体步骤有：<br>（1）给定某个初始值。<br>（2）对于第k次迭代，寻找增量Δxk, 使得$\left | f(x_{k}+\Delta x_{k}) \right |_{2}^{2}$这里应该是二范数）达到最小。<br>（3）若$\Delta x_{k}$足够小，则停止。<br>（4）否则,令$x_{k+1}=x_{k}+\Delta x_{k}$,返回第2步。<h2 id="2-1-一阶和二阶梯度法"><a href="#2-1-一阶和二阶梯度法" class="headerlink" title="2.1 一阶和二阶梯度法"></a>2.1 一阶和二阶梯度法</h2></li>
<li>将目标函数在 $x$ 附近进行泰勒展开：<script type="math/tex; mode=display">\left \| f(x+\Delta x) \right \|_{2}^{2}\approx \left \| f(x) \right \|_{2}^{2}+J(x)\Delta x+\frac{1}{2}\Delta x^TH\Delta x</script>$J$是$\left | f(x) \right |_{2}^{2}$关于$x$的导数（雅克比矩阵），$H$是二阶导数（海塞矩阵）</li>
<li>最速梯度下降法：只保留一阶梯度，增量的方向为：<script type="math/tex; mode=display">\Delta x^{*}=-J^T(x)</script></li>
<li>牛顿法：保留二阶梯度，增量方程为：<script type="math/tex; mode=display">\Delta x^{*}=arg min\left \| f(x) \right \|_{2}^{2}+J(x)\Delta x+\frac{1}{2}x^TH\Delta x</script> 求右侧等式关于 ∆x的导数并令它为零，得到了增量的解：<script type="math/tex; mode=display">H\Delta X=-J^T</script><ol>
<li>两种方法的问题：<br>（1）最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。<br>（2）牛顿法则需要计算目标函数的 H矩阵，这在问题规模较大时非常困难，通常倾向于避免 $H$ 的计算。</li>
</ol>
</li>
</ol>
<h2 id="2-2-高斯牛顿法"><a href="#2-2-高斯牛顿法" class="headerlink" title="2.2 高斯牛顿法"></a>2.2 高斯牛顿法</h2><ol>
<li><p>高斯牛顿法，它的思想是将$f\left (x  \right )$进行泰勒展开（目标函数不是$f\left (x  \right )$）：</p>
<script type="math/tex; mode=display">f(x+\Delta x)\approx f(x)+J(x)\Delta x</script><p> $f\left (J  \right )$是一个$m*n$雅克比矩阵，当前的目标是为了寻找下降矢量 ∆x，使得$\left | f\left ( x+\Delta x \right )^2 \right |$达到最小。</p>
</li>
<li><p>为了求 $\Delta x_{k}$，需要解一个线性的最小二乘问题</p>
<script type="math/tex; mode=display">\Delta x^*=arg \min_{\Delta x}\frac{1}{2}\left \| f(x)+J(x) \Delta x\right \|^{2}</script><p>考虑的是$\Delta x_{k}$的导数（而不是$x$） ，先展开目标函数的平方项</p>
<script type="math/tex; mode=display">\frac{1}{2}\left \| f(x)+J(x) \Delta x\right \|^{2}=\frac{1}{2}(f(x)+J(x)\Delta x)^T(f(x)+J(x)\Delta x)\\
=\frac{1}{2}(\left \| f(x) \right \|)_{2}^{2}+2f(x)^TJ(x)\Delta x+\Delta xJ(x)^TJ(x)\Delta x)</script><p>上式关于$\Delta x$的导数，并令其为零：</p>
<script type="math/tex; mode=display">J(x)^TJ(x)\Delta x=-J(x)^Tf(x)</script><p> 这个方程称之为<strong>增量方程</strong>，也称之为<strong>高斯牛顿方程</strong>或<strong>正规方程</strong>，将左边的系数设为$H$，右边的系数设为$g$，则有$HΔx=g$。</p>
</li>
<li><p>高斯牛顿法求解的算法步骤可写成：<br>（1）给定初始值$x_{0}$<br>（2）对于第$k$次迭代，求出当前的雅克比矩阵$J\left ( x_{k} \right )$ 和误差$f\left ( x_{k} \right )$ 。<br>（3）求解增量方程：$H\Delta x_{k}=g$<br>（4）若$\Delta x_{k}$足够小，则停止。否则，令$x_{k+1}=x_{k}+\Delta x_{k}$，返回第二步</p>
</li>
<li><p>高斯牛顿法的缺点：<br>（1）要求$H$是可逆的，而且是正定的，如果出现$H$矩阵奇异或者病态，此时增量的稳定性较差，导致算法不收敛<br>（2）步长问题，若求出来的$\Delta x_{k}$太长，则可能出现局部近似不够准确，无法保证迭代收敛。</p>
</li>
</ol>
<h2 id="2-3-列文伯格-马夸尔特方法（阻尼牛顿法"><a href="#2-3-列文伯格-马夸尔特方法（阻尼牛顿法" class="headerlink" title="2.3 列文伯格-马夸尔特方法（阻尼牛顿法)"></a>2.3 列文伯格-马夸尔特方法（阻尼牛顿法)</h2><ol>
<li>信赖区域方法 (Trust Region Method)：给 $\Delta x$添加一个信赖区域（Trust Region），不能让它太大而使得近似不准确</li>
<li><p>考虑使用如下公式来判断泰勒近似是否够好</p>
<script type="math/tex; mode=display">\rho =\frac{f(x+\Delta x)-\Delta x}{J(x)\Delta x}</script><p>（1）如果 $ρ$ 接近于 1，则近似是好的。<br>（2）如果 $ρ$太小，说明实际减小的值远少于近似减小的值，则认为近似比较差，需要缩小近似范围。<br>（3）如果 $ρ$ 比较大，则说明实际下降的比预计的更大，我们可以放大近似范围。</p>
</li>
<li><p>改良版的非线性优化框架<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190620113545697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>这里近似范围扩大的倍数和阈值都是经验值，可以替换成其他数值。上述约束中相当于把增量限定在半径为$\mu$的球里面，认为在球内的才有效。带上$D$后成为椭圆，把$D$取成单位阵$I$,相当于把$\Delta x$约束在一个球内。$D$也可为非负数对角阵。 </p>
</li>
<li><p>由于是有约束优化，可以利用拉格朗日乘子将其转化为一个无约束优化问题：</p>
<script type="math/tex; mode=display">\min_{\Delta x_{k}}\frac{1}{2}\left \| f(x_{k}+J(x_{k}\Delta x_{k})) \right \|^2+\frac{\lambda }{2}\left \| D\Delta x \right \|^2</script><p>类似高斯牛顿法展开，可得其增量的线性方程：</p>
<script type="math/tex; mode=display">(H+\lambda D^TD)\Delta X=g</script><p>考虑它的简化形式，即$D=I$，那么相当于求解：</p>
<script type="math/tex; mode=display">(H+\lambda I)\Delta x=g</script></li>
</ol>
<p> （1）当参数$λ$较小时，$H$占主导地位，说明二次近似模型在该范围内是比较好的，该方法接近于高斯牛顿法。<br>（2）当参数$λ$较大时，列文伯格-马夸尔特方法接近于一阶梯度下降法，说明二次近似不好。<br>（3）该方法可在一定程度上避免线性方程组的系数矩阵的非奇异和病态问题)，提供更稳定、更准确的增量$Δx$。</p>
<ol>
<li>非线性优化的框架分为Line Search和Trust Region两类。<br>（1）Line Search：先固定搜索方向，后寻找步长，以最速梯度法和高斯牛顿法为代表。<br>（2）Trust Region：先固定搜索区域，再考虑找该区域的最优点，以列文伯格-马夸尔特方法为代表<h1 id="3-实践：Ceres"><a href="#3-实践：Ceres" class="headerlink" title="3.实践：Ceres"></a>3.实践：Ceres</h1><h2 id="3-1-Ceres简介"><a href="#3-1-Ceres简介" class="headerlink" title="3.1 Ceres简介"></a>3.1 Ceres简介</h2>Ceres库面向通用的最小二乘问题的求解，需要定义优化问题，设置一些选项，输入Ceres求解。一般形式如下（带边界核函数最小二乘）：</li>
</ol>
<script type="math/tex; mode=display">\min_{x}  \frac{1}{2}\sum _{i}\left ( \left \| (f_{i}(x_{i1},...x_{in})) \right \|^2 \right )\\
s.t      \qquad   \qquad  l_{j}\leq x_{j}\leq \mu _{j}</script><p>优化变量：$x_{i1},…x_{in}$ ，代价函数$f_{i}$ ,$\rho$为恒等函数时，得到一个无约束的最小二乘问题。</p>
<h3 id="3-2-使用Ceres拟合曲线"><a href="#3-2-使用Ceres拟合曲线" class="headerlink" title="3.2 使用Ceres拟合曲线"></a>3.2 使用Ceres拟合曲线</h3><p>曲线方程的形式为：</p>
<script type="math/tex; mode=display">y=exp(ax^2+bx+c)+w</script><p>$a,b,c为参数，$w$为噪声，假设我们有N个关于$x,y$观测数据点，根据这些点求曲线的参数，可以求解下面的最小二乘来狙击曲线参数。</p>
<script type="math/tex; mode=display">\min_{a,b,c}\frac{1}{2}\sum _{i=1}^{N}\left \| y_{i}-exp(ax_{i}^2+bx_{i}+c)\right \|^2</script><p><strong>参考：</strong>。<br>Ceres官网：<a href="http://www.ceres-solver.org/" target="_blank" rel="noopener">http://www.ceres-solver.org/</a><br> 一文助你Ceres 入门——Ceres Solver新手向全攻略：<a href="https://blog.csdn.net/cqrtxwd/article/details/78956227" target="_blank" rel="noopener">https://blog.csdn.net/cqrtxwd/article/details/78956227</a><br>Ceres: Tutorial: Non-linear Least Squares：<a href="http://www.ceres-solver.org/nnls_tutorial.html" target="_blank" rel="noopener">http://www.ceres-solver.org/nnls_tutorial.html</a><br>基于范围的for循环:<a href="https://blog.csdn.net/lixiaogang_theanswer/article/details/79969012" target="_blank" rel="noopener">https://blog.csdn.net/lixiaogang_theanswer/article/details/79969012</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代价函数的计算模型</span></span><br><span class="line"><span class="comment">//首先要定义求解问题的cost function&lt;CURVE_FITTING_COST&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CURVE_FITTING_COST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//在结构体中首先构造构造函</span></span><br><span class="line">    CURVE_FITTING_COST ( <span class="keyword">double</span> x, <span class="keyword">double</span> y ) : _x ( x ), _y ( y ) &#123;&#125;<span class="comment">////结构体的构造函数初始化列表</span></span><br><span class="line">    <span class="comment">//相当于CURVE_FITTING_COST ( double x,double y) &#123;_x=x; _y=y&#125;</span></span><br><span class="line">    <span class="comment">// 残差的计算</span></span><br><span class="line">    <span class="comment">//template的使用是为了简化不同类型的函数和类的重复定义，模版实例化时可以替换任意类型，不仅包括内置类型（int等），也包括自定义类型class,实例化之后才知道的数据的类型。</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> T* <span class="keyword">const</span> abc,     <span class="comment">// 模型参数，有3维</span></span></span></span><br><span class="line"><span class="function"><span class="params">        T* residual )</span> <span class="keyword">const</span>     <span class="comment">// 残差</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = T ( _y ) - ceres::<span class="built_in">exp</span> ( abc[<span class="number">0</span>]*T ( _x ) *T ( _x ) + abc[<span class="number">1</span>]*T ( _x ) + abc[<span class="number">2</span>] ); <span class="comment">// y-exp(ax^2+bx+c)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> _x, _y;    <span class="comment">// x,y数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=<span class="number">1.0</span>, b=<span class="number">2.0</span>, c=<span class="number">1.0</span>;         <span class="comment">// 真实参数值</span></span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">100</span>;                          <span class="comment">// 数据点</span></span><br><span class="line">    <span class="keyword">double</span> w_sigma=<span class="number">1.0</span>;                 <span class="comment">// 噪声Sigma值</span></span><br><span class="line">    cv::RNG rng;                        <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line">    <span class="keyword">double</span> abc[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;            <span class="comment">// abc参数的估计值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x_data, y_data;      <span class="comment">// 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"generating data: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = i/<span class="number">100.0</span>;</span><br><span class="line">        x_data.push_back ( x );</span><br><span class="line">        y_data.push_back (</span><br><span class="line">            <span class="built_in">exp</span> ( a*x*x + b*x + c ) + rng.gaussian ( w_sigma )</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x_data[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;y_data[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最小二乘问题</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        problem.AddResidualBlock (     <span class="comment">// 向问题中添加误差项</span></span><br><span class="line">        <span class="comment">// 使用自动求导，模板参数：误差类型，输出维度，输入维度，维数要与前面struct中一致</span></span><br><span class="line">            <span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;CURVE_FITTING_COST, <span class="number">1</span>, <span class="number">3</span>&gt; ( </span><br><span class="line">                <span class="keyword">new</span> CURVE_FITTING_COST ( x_data[i], y_data[i] )</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">nullptr</span>,            <span class="comment">// 核函数，这里不使用，为空</span></span><br><span class="line">            abc                 <span class="comment">// 待估计参数</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置求解器</span></span><br><span class="line">    ceres::Solver::Options options;     <span class="comment">// 这里有很多配置项可以填</span></span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR;  <span class="comment">// 增量方程如何求解</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;   <span class="comment">// 输出到cout</span></span><br><span class="line"></span><br><span class="line">    ceres::Solver::Summary summary;                <span class="comment">// 优化信息</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">    ceres::Solve ( options, &amp;problem, &amp;summary );  <span class="comment">// 开始优化</span></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;( t2-t1 );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"solve time cost = "</span>&lt;&lt;time_used.count()&lt;&lt;<span class="string">" seconds. "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;summary.BriefReport() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"estimated a,b,c = "</span>;</span><br><span class="line">    <span class="comment">//表示的则是基于范围的for循环</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> a:abc ) <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码中需要关注的有这么几点：</p>
<p>（1）定义代价函数的方式是自定义一个结构体。只需要在结构体中实现operator()方法，就算是给Ceres提供了一个调用接口，由Ceres内部在合适的时候调用该方法计算代价函数。<br>（2）构建最小二乘问题时，需要将所有误差项依次添加进去。而每个误差项又是由前面定义的结构体构成的。需要注意的是，每个误差项需要指定代价函数求导的方法，有三种方法可供选择：自动求导、数值求导和自行推导。一般采用自动求导，既方便，又节约运行时时间。<br>（3）以自动求导为例，ceres::AutoDiffCostFunction是个模板类，后两个模板参数为输出维度和输入维度，必须与前面定义的结构体中的residual和abc的维度一样。<br>（4）使用ceres::Solver::Options配置求解器。这个类有许多字段，每个字段都提供了一些枚举值供用户选择。所以需要时只要查一查文档就知道怎么设置了。</p>
<p>调用build/curve_fitting查看优化结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">generating data: </span><br><span class="line"><span class="number">0</span> <span class="number">2.71828</span></span><br><span class="line"><span class="number">0.01</span> <span class="number">2.93161</span></span><br><span class="line"><span class="number">0.02</span> <span class="number">2.12942</span></span><br><span class="line"><span class="number">0.03</span> <span class="number">2.46037</span></span><br><span class="line"><span class="number">0.04</span> <span class="number">4.18814</span></span><br><span class="line"><span class="number">0.05</span> <span class="number">2.73368</span></span><br><span class="line"><span class="number">0.06</span> <span class="number">2.42751</span></span><br><span class="line">……</span><br><span class="line"><span class="number">0.94</span> <span class="number">44.285</span></span><br><span class="line"><span class="number">0.95</span> <span class="number">42.8312</span></span><br><span class="line"><span class="number">0.96</span> <span class="number">47.7941</span></span><br><span class="line"><span class="number">0.97</span> <span class="number">48.5931</span></span><br><span class="line"><span class="number">0.98</span> <span class="number">51.8487</span></span><br><span class="line"><span class="number">0.99</span> <span class="number">51.0258</span></span><br><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   <span class="number">0</span>  <span class="number">1.824887e+04</span>    <span class="number">0.00e+00</span>    <span class="number">1.38e+03</span>   <span class="number">0.00e+00</span>   <span class="number">0.00e+00</span>  <span class="number">1.00e+04</span>        <span class="number">0</span>    <span class="number">3.88e-05</span>    <span class="number">9.01e-05</span></span><br><span class="line">   <span class="number">1</span>  <span class="number">2.748700e+39</span>   <span class="number">-2.75e+39</span>    <span class="number">0.00e+00</span>   <span class="number">7.67e+01</span>  <span class="number">-1.52e+35</span>  <span class="number">5.00e+03</span>        <span class="number">1</span>    <span class="number">6.85e-05</span>    <span class="number">1.82e-04</span></span><br><span class="line">   <span class="number">2</span>  <span class="number">2.429783e+39</span>   <span class="number">-2.43e+39</span>    <span class="number">0.00e+00</span>   <span class="number">7.62e+01</span>  <span class="number">-1.35e+35</span>  <span class="number">1.25e+03</span>        <span class="number">1</span>    <span class="number">2.18e-05</span>    <span class="number">2.16e-04</span></span><br><span class="line">   <span class="number">3</span>  <span class="number">1.213227e+39</span>   <span class="number">-1.21e+39</span>    <span class="number">0.00e+00</span>   <span class="number">7.30e+01</span>  <span class="number">-6.73e+34</span>  <span class="number">1.56e+02</span>        <span class="number">1</span>    <span class="number">1.87e-05</span>    <span class="number">2.44e-04</span></span><br><span class="line">   <span class="number">4</span>  <span class="number">1.852387e+37</span>   <span class="number">-1.85e+37</span>    <span class="number">0.00e+00</span>   <span class="number">5.56e+01</span>  <span class="number">-1.03e+33</span>  <span class="number">9.77e+00</span>        <span class="number">1</span>    <span class="number">1.80e-05</span>    <span class="number">2.69e-04</span></span><br><span class="line">   <span class="number">5</span>  <span class="number">6.714689e+31</span>   <span class="number">-6.71e+31</span>    <span class="number">0.00e+00</span>   <span class="number">2.96e+01</span>  <span class="number">-3.85e+27</span>  <span class="number">3.05e-01</span>        <span class="number">1</span>    <span class="number">1.82e-05</span>    <span class="number">2.95e-04</span></span><br><span class="line">   <span class="number">6</span>  <span class="number">9.500531e+12</span>   <span class="number">-9.50e+12</span>    <span class="number">0.00e+00</span>   <span class="number">9.50e+00</span>  <span class="number">-8.39e+08</span>  <span class="number">4.77e-03</span>        <span class="number">1</span>    <span class="number">1.78e-05</span>    <span class="number">3.20e-04</span></span><br><span class="line">   <span class="number">7</span>  <span class="number">1.776982e+04</span>    <span class="number">4.79e+02</span>    <span class="number">1.83e+03</span>   <span class="number">2.58e-01</span>   <span class="number">1.18e+00</span>  <span class="number">1.43e-02</span>        <span class="number">1</span>    <span class="number">4.06e-05</span>    <span class="number">3.68e-04</span></span><br><span class="line">   <span class="number">8</span>  <span class="number">1.599969e+04</span>    <span class="number">1.77e+03</span>    <span class="number">3.45e+03</span>   <span class="number">5.53e-01</span>   <span class="number">1.46e+00</span>  <span class="number">4.29e-02</span>        <span class="number">1</span>    <span class="number">3.86e-05</span>    <span class="number">4.15e-04</span></span><br><span class="line">   <span class="number">9</span>  <span class="number">1.060557e+04</span>    <span class="number">5.39e+03</span>    <span class="number">7.62e+03</span>   <span class="number">7.33e-01</span>   <span class="number">1.68e+00</span>  <span class="number">1.29e-01</span>        <span class="number">1</span>    <span class="number">3.92e-05</span>    <span class="number">4.62e-04</span></span><br><span class="line">  <span class="number">10</span>  <span class="number">3.669783e+03</span>    <span class="number">6.94e+03</span>    <span class="number">9.60e+03</span>   <span class="number">5.25e-01</span>   <span class="number">1.39e+00</span>  <span class="number">3.86e-01</span>        <span class="number">1</span>    <span class="number">3.76e-05</span>    <span class="number">5.06e-04</span></span><br><span class="line">  <span class="number">11</span>  <span class="number">5.397541e+02</span>    <span class="number">3.13e+03</span>    <span class="number">5.00e+03</span>   <span class="number">2.66e-01</span>   <span class="number">1.12e+00</span>  <span class="number">1.16e+00</span>        <span class="number">1</span>    <span class="number">3.74e-05</span>    <span class="number">5.51e-04</span></span><br><span class="line">  <span class="number">12</span>  <span class="number">1.484444e+02</span>    <span class="number">3.91e+02</span>    <span class="number">1.22e+03</span>   <span class="number">8.46e-02</span>   <span class="number">1.02e+00</span>  <span class="number">3.48e+00</span>        <span class="number">1</span>    <span class="number">3.74e-05</span>    <span class="number">5.95e-04</span></span><br><span class="line">  <span class="number">13</span>  <span class="number">1.216815e+02</span>    <span class="number">2.68e+01</span>    <span class="number">3.76e+02</span>   <span class="number">4.17e-02</span>   <span class="number">1.01e+00</span>  <span class="number">1.04e+01</span>        <span class="number">1</span>    <span class="number">3.73e-05</span>    <span class="number">6.40e-04</span></span><br><span class="line">  <span class="number">14</span>  <span class="number">9.290109e+01</span>    <span class="number">2.88e+01</span>    <span class="number">2.42e+02</span>   <span class="number">9.10e-02</span>   <span class="number">1.01e+00</span>  <span class="number">3.13e+01</span>        <span class="number">1</span>    <span class="number">3.86e-05</span>    <span class="number">6.85e-04</span></span><br><span class="line">  <span class="number">15</span>  <span class="number">6.674330e+01</span>    <span class="number">2.62e+01</span>    <span class="number">1.09e+02</span>   <span class="number">1.33e-01</span>   <span class="number">1.00e+00</span>  <span class="number">9.39e+01</span>        <span class="number">1</span>    <span class="number">3.73e-05</span>    <span class="number">7.30e-04</span></span><br><span class="line">  <span class="number">16</span>  <span class="number">5.936574e+01</span>    <span class="number">7.38e+00</span>    <span class="number">2.14e+01</span>   <span class="number">1.08e-01</span>   <span class="number">9.94e-01</span>  <span class="number">2.82e+02</span>        <span class="number">1</span>    <span class="number">3.72e-05</span>    <span class="number">7.75e-04</span></span><br><span class="line">  <span class="number">17</span>  <span class="number">5.653118e+01</span>    <span class="number">2.83e+00</span>    <span class="number">1.36e+01</span>   <span class="number">1.57e-01</span>   <span class="number">9.98e-01</span>  <span class="number">8.45e+02</span>        <span class="number">1</span>    <span class="number">4.25e-05</span>    <span class="number">8.26e-04</span></span><br><span class="line">  <span class="number">18</span>  <span class="number">5.310764e+01</span>    <span class="number">3.42e+00</span>    <span class="number">8.50e+00</span>   <span class="number">2.81e-01</span>   <span class="number">9.89e-01</span>  <span class="number">2.53e+03</span>        <span class="number">1</span>    <span class="number">3.74e-05</span>    <span class="number">8.71e-04</span></span><br><span class="line">  <span class="number">19</span>  <span class="number">5.125939e+01</span>    <span class="number">1.85e+00</span>    <span class="number">2.84e+00</span>   <span class="number">2.98e-01</span>   <span class="number">9.90e-01</span>  <span class="number">7.60e+03</span>        <span class="number">1</span>    <span class="number">3.77e-05</span>    <span class="number">9.16e-04</span></span><br><span class="line">  <span class="number">20</span>  <span class="number">5.097693e+01</span>    <span class="number">2.82e-01</span>    <span class="number">4.34e-01</span>   <span class="number">1.48e-01</span>   <span class="number">9.95e-01</span>  <span class="number">2.28e+04</span>        <span class="number">1</span>    <span class="number">3.72e-05</span>    <span class="number">9.60e-04</span></span><br><span class="line">  <span class="number">21</span>  <span class="number">5.096854e+01</span>    <span class="number">8.39e-03</span>    <span class="number">3.24e-02</span>   <span class="number">2.87e-02</span>   <span class="number">9.96e-01</span>  <span class="number">6.84e+04</span>        <span class="number">1</span>    <span class="number">3.69e-05</span>    <span class="number">1.00e-03</span></span><br><span class="line">solve time cost = <span class="number">0.00104852</span> seconds. </span><br><span class="line">Ceres Solver Report: Iterations: <span class="number">22</span>, Initial cost: <span class="number">1.824887e+04</span>, Final cost: <span class="number">5.096854e+01</span>, Termination: CONVERGENCE</span><br><span class="line">estimated a,b,c = <span class="number">0.891943</span> <span class="number">2.17039</span> <span class="number">0.944142</span></span><br></pre></td></tr></table></figure>
<h1 id="4-实践：g2o"><a href="#4-实践：g2o" class="headerlink" title="4.实践：g2o"></a>4.实践：g2o</h1><h2 id="4-1-图优化理论简介"><a href="#4-1-图优化理论简介" class="headerlink" title="4.1 图优化理论简介"></a>4.1 图优化理论简介</h2><p>图优化，是把优化问题表现成图的一种形式，<strong>顶点表示优化变量</strong>，<strong>边表示误差项</strong>，对于任意一个形式的非最小二乘问题，可以构建与之对应的一个图。</p>
<h2 id="4-2-使用g2o拟合曲线"><a href="#4-2-使用g2o拟合曲线" class="headerlink" title="4.2 使用g2o拟合曲线"></a>4.2 使用g2o拟合曲线</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点，模板参数：优化变量维度和数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingVertex</span>:</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="comment">// 重置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">( <span class="keyword">const</span> <span class="keyword">double</span>* update )</span> <span class="comment">// 更新</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _estimate += Eigen::Vector3d(update);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存盘和读盘：留空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">( istream&amp; in )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">( ostream&amp; out )</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 误差模型 模板参数：观测值维度，类型，连接顶点类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurveFittingEdge</span>:</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>,<span class="keyword">double</span>,CurveFittingVertex&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">    CurveFittingEdge( <span class="keyword">double</span> x ): BaseUnaryEdge(), _x(x) &#123;&#125;</span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> CurveFittingVertex* v = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> CurveFittingVertex*&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">const</span> Eigen::Vector3d abc = v-&gt;estimate();</span><br><span class="line">        _error(<span class="number">0</span>,<span class="number">0</span>) = _measurement - <span class="built_in">std</span>::<span class="built_in">exp</span>( abc(<span class="number">0</span>,<span class="number">0</span>)*_x*_x + abc(<span class="number">1</span>,<span class="number">0</span>)*_x + abc(<span class="number">2</span>,<span class="number">0</span>) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">( istream&amp; in )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">( ostream&amp; out )</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> _x;  <span class="comment">// x 值， y 值为 _measurement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=<span class="number">1.0</span>, b=<span class="number">2.0</span>, c=<span class="number">1.0</span>;         <span class="comment">// 真实参数值</span></span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">100</span>;                          <span class="comment">// 数据点</span></span><br><span class="line">    <span class="keyword">double</span> w_sigma=<span class="number">1.0</span>;                 <span class="comment">// 噪声Sigma值</span></span><br><span class="line">    cv::RNG rng;                        <span class="comment">// OpenCV随机数产生器</span></span><br><span class="line">    <span class="keyword">double</span> abc[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;            <span class="comment">// abc参数的估计值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x_data, y_data;      <span class="comment">// 数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"generating data: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = i/<span class="number">100.0</span>;</span><br><span class="line">        x_data.push_back ( x );</span><br><span class="line">        y_data.push_back (</span><br><span class="line">            <span class="built_in">exp</span> ( a*x*x + b*x + c ) + rng.gaussian ( w_sigma )</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x_data[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;y_data[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建图优化，先设定g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt; g2o::BlockSolverTraits&lt;<span class="number">3</span>,<span class="number">1</span>&gt; &gt; Block;  <span class="comment">// 每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">    Block::LinearSolverType* linearSolver = <span class="keyword">new</span> g2o::LinearSolverDense&lt;Block::PoseMatrixType&gt;(); <span class="comment">// 线性方程求解器</span></span><br><span class="line">    Block* solver_ptr = <span class="keyword">new</span> Block( linearSolver );      <span class="comment">// 矩阵块求解器</span></span><br><span class="line">    <span class="comment">// 梯度下降方法，从GN, LM, DogLeg 中选</span></span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg( solver_ptr );</span><br><span class="line">    <span class="comment">// g2o::OptimizationAlgorithmGaussNewton* solver = new g2o::OptimizationAlgorithmGaussNewton( solver_ptr );</span></span><br><span class="line">    <span class="comment">// g2o::OptimizationAlgorithmDogleg* solver = new g2o::OptimizationAlgorithmDogleg( solver_ptr );</span></span><br><span class="line">    g2o::SparseOptimizer optimizer;     <span class="comment">// 图模型</span></span><br><span class="line">    optimizer.setAlgorithm( solver );   <span class="comment">// 设置求解器</span></span><br><span class="line">    optimizer.setVerbose( <span class="literal">true</span> );       <span class="comment">// 打开调试输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往图中增加顶点</span></span><br><span class="line">    CurveFittingVertex* v = <span class="keyword">new</span> CurveFittingVertex();</span><br><span class="line">    v-&gt;setEstimate( Eigen::Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) );</span><br><span class="line">    v-&gt;setId(<span class="number">0</span>);</span><br><span class="line">    optimizer.addVertex( v );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往图中增加边</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        CurveFittingEdge* edge = <span class="keyword">new</span> CurveFittingEdge( x_data[i] );</span><br><span class="line">        edge-&gt;setId(i);</span><br><span class="line">        edge-&gt;setVertex( <span class="number">0</span>, v );                <span class="comment">// 设置连接的顶点</span></span><br><span class="line">        edge-&gt;setMeasurement( y_data[i] );      <span class="comment">// 观测数值</span></span><br><span class="line">        edge-&gt;setInformation( Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt;::Identity()*<span class="number">1</span>/(w_sigma*w_sigma) ); <span class="comment">// 信息矩阵：协方差矩阵之逆</span></span><br><span class="line">        optimizer.addEdge( edge );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"start optimization"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize(<span class="number">100</span>);</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;( t2-t1 );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"solve time cost = "</span>&lt;&lt;time_used.count()&lt;&lt;<span class="string">" seconds. "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出优化值</span></span><br><span class="line">    Eigen::Vector3d abc_estimate = v-&gt;estimate();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"estimated model: "</span>&lt;&lt;abc_estimate.transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化结果：</strong><br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">generating data: </span><br><span class="line"><span class="number">0</span> <span class="number">2.71828</span></span><br><span class="line"><span class="number">0.01</span> <span class="number">2.93161</span></span><br><span class="line"><span class="number">0.02</span> <span class="number">2.12942</span></span><br><span class="line"><span class="number">0.03</span> <span class="number">2.46037</span></span><br><span class="line">……</span><br><span class="line"><span class="number">0.96</span> <span class="number">47.7941</span></span><br><span class="line"><span class="number">0.97</span> <span class="number">48.5931</span></span><br><span class="line"><span class="number">0.98</span> <span class="number">51.8487</span></span><br><span class="line"><span class="number">0.99</span> <span class="number">51.0258</span></span><br><span class="line">start optimization</span><br><span class="line">iteration= <span class="number">0</span>	 chi2= <span class="number">30373.727656</span>	 time= <span class="number">9.4326e-05</span>	 cumTime= <span class="number">9.4326e-05</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">699.050482</span>	 levenbergIter= <span class="number">7</span></span><br><span class="line">iteration= <span class="number">1</span>	 chi2= <span class="number">13336.948288</span>	 time= <span class="number">5.0567e-05</span>	 cumTime= <span class="number">0.000144893</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">1864.134619</span>	 levenbergIter= <span class="number">3</span></span><br><span class="line">iteration= <span class="number">2</span>	 chi2= <span class="number">6946.262996</span>	 time= <span class="number">4.1451e-05</span>	 cumTime= <span class="number">0.000186344</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">1242.756412</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">3</span>	 chi2= <span class="number">271.023166</span>	 time= <span class="number">4.0473e-05</span>	 cumTime= <span class="number">0.000226817</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">414.252137</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">4</span>	 chi2= <span class="number">118.903887</span>	 time= <span class="number">4.2708e-05</span>	 cumTime= <span class="number">0.000269525</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">138.084046</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">5</span>	 chi2= <span class="number">113.568660</span>	 time= <span class="number">4.0511e-05</span>	 cumTime= <span class="number">0.000310036</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">46.028015</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">6</span>	 chi2= <span class="number">107.476457</span>	 time= <span class="number">4.0557e-05</span>	 cumTime= <span class="number">0.000350593</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">15.342672</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">7</span>	 chi2= <span class="number">103.014522</span>	 time= <span class="number">4.0922e-05</span>	 cumTime= <span class="number">0.000391515</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">5.114224</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">8</span>	 chi2= <span class="number">101.988348</span>	 time= <span class="number">4.0378e-05</span>	 cumTime= <span class="number">0.000431893</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">1.704741</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">9</span>	 chi2= <span class="number">101.937388</span>	 time= <span class="number">4.0728e-05</span>	 cumTime= <span class="number">0.000472621</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">0.568247</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">10</span>	 chi2= <span class="number">101.937021</span>	 time= <span class="number">4.226e-05</span>	 cumTime= <span class="number">0.000514881</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">0.378831</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">11</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">4.0703e-05</span>	 cumTime= <span class="number">0.000555584</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">0.252554</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">12</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">4.9381e-05</span>	 cumTime= <span class="number">0.000604965</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">1.346956</span>	 levenbergIter= <span class="number">3</span></span><br><span class="line">iteration= <span class="number">13</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">4.1188e-05</span>	 cumTime= <span class="number">0.000646153</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">0.897971</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">14</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">5.331e-05</span>	 cumTime= <span class="number">0.000699463</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">38.313418</span>	 levenbergIter= <span class="number">4</span></span><br><span class="line">iteration= <span class="number">15</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">6.0704e-05</span>	 cumTime= <span class="number">0.000760167</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">204.338228</span>	 levenbergIter= <span class="number">3</span></span><br><span class="line">iteration= <span class="number">16</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">4.0342e-05</span>	 cumTime= <span class="number">0.000800509</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">136.225485</span>	 levenbergIter= <span class="number">1</span></span><br><span class="line">iteration= <span class="number">17</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">7.0952e-05</span>	 cumTime= <span class="number">0.000871461</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">24378500205.440712</span>	 levenbergIter= <span class="number">8</span></span><br><span class="line">iteration= <span class="number">18</span>	 chi2= <span class="number">101.937020</span>	 time= <span class="number">4.9227e-05</span>	 cumTime= <span class="number">0.000920688</span>	 edges= <span class="number">100</span>	 schur= <span class="number">0</span>	 lambda= <span class="number">1560224013148.205566</span>	 levenbergIter= <span class="number">3</span></span><br><span class="line">solve time cost = <span class="number">0.00200526</span> seconds. </span><br><span class="line">estimated model: <span class="number">0.890912</span>   <span class="number">2.1719</span> <span class="number">0.943629</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>视觉slam十四讲   5.相机与图像</title>
    <url>/2019/05/10/%E8%A7%86%E8%A7%89slam%E5%8D%81%E5%9B%9B%E8%AE%B2-5-%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-针孔相机模型"><a href="#1-针孔相机模型" class="headerlink" title="1 针孔相机模型"></a>1 针孔相机模型</h1><p>相机是将三维世界坐标系中的坐标点映射到二维图像平面的过程能够用一个几何过程描述，最简单模型称为<strong>针孔模型</strong>。<br>因为相机镜头透镜的存在，使得光线投影到成像平面过程中产生了<strong>畸变</strong>。</p><h2 id="1-1-针孔相机模型"><a href="#1-1-针孔相机模型" class="headerlink" title="1.1 针孔相机模型"></a>1.1 针孔相机模型</h2><ol>
<li>针孔相机模型模型的建立：设 O−x−y−z 为相机坐标系，O 为摄像机的光心，也是针孔模型中的针孔。现实世界的空间点 P，经过小孔 O 投影之后，落在物理成像平面 O′−x′−y′O′−x′−y′ 上，成像点为 P′ 。设 P 的坐标为 [X,Y,Z]T，P′ 为 [X′,Y′,Z′]T，并且设物理成像平面到小孔的距离为 f（焦距）。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619161118673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><script type="math/tex; mode=display">\frac{Z}{f}=-\frac{X}{X'}=-\frac{Y}{Y'}</script> 将成像平面对称至镜头前方，有：<script type="math/tex; mode=display">\frac{Z}{f}=\frac{X}{X'}=\frac{Y}{Y'}</script> 所以：<script type="math/tex; mode=display">X'=f\frac{X}{Z}$$   $$Y'=f\frac{Y}{Z}</script></li>
</ol><a id="more"></a>

<p>​                                          </p>
<ol>
<li><p>在相机中，最终获得的是一个个的像素，这需要在成像平面上对像进行采样和量化，设在物理成像平面上固定着一个像素平面 o−u−v，得到了 P′ 的像素坐标： [u,v]T，像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移。</p>
<pre><code>                                   &lt;div align=center&gt; ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190619162628449.png)   
                                                             ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190619163041281.png)
</code></pre><p><strong>矩阵形式：</strong><br> <div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619165014245.png"></div></p>
</li>
<li><p>中间的量组成的矩阵称为相机的内参数矩阵（Camera Intrinsics） K ，通常情况下，相机的内参在出厂之后是固定的，不会在使用过程中发生变化。有时需要自己确定相机的参数，称为标定。         <div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619164304556.png"></div></p>
</li>
<li><p>相机坐标P是由它的世界坐标Pw变换而来，由于相机运动，所以P的坐标应该是它的世界坐标Pw。<br>相机位姿由外参数R,t决定 。相比于不变的内参，外参随着相机运动发生改变 ，同时也是 SLAM中待估计的目标，代表着机器人的轨迹。<br>右侧的TPw是把一个世界坐标系下的齐次坐标转为相机坐标系，为了使它与K相乘，把最后以为进行归一化处理。即P 在相机归一化平面上的投影：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619165910747.png"></div></p>
<p>  Pc可以看成二维的齐次坐标，称为归一化坐标，，它位于相机前方z=1的平面上，叫做归一化平面。</p>
</li>
<li><p><strong>变换过程总结</strong>：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619170715129.png"></div></p>
</li>
</ol>
<h2 id="1-2-畸变"><a href="#1-2-畸变" class="headerlink" title="1.2 畸变"></a>1.2 畸变</h2><ol>
<li><p>为了获得良好的成像效果，在相机前方加入透镜，其影响：</p>
<p>  （1）透镜自身的形状对光线传播的影响<br>  （2）在机械组装过程中，透镜和成像平面不可能完全平行，使得光线穿过透镜投影到成像面时的位置发生变化。</p>
</li>
</ol>
<ol>
<li><p>径向畸变：由透镜形状引起，越靠近图像的边缘，这种现象越明显。径向畸变分为<strong>桶形畸变</strong>和<strong>枕形畸变</strong>，穿过图像中心和光轴有交点的直线还能保持形状不变。</p>
<pre><code>   （1）桶形畸变是由于图像放大率随着离光轴的距离增加而减小。
   （2）枕形畸变是由于图像放大率随着离光轴的距离增加而增加。   &lt;div align=center&gt;          ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190619172313930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70)
</code></pre></li>
<li><p>切向畸变：在相机的组装过程中由于不能使得透镜和成像面严格平行而导致的畸变。<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019061917475311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></div></p>
</li>
<li><p>r表示平面任意一点p与坐标原点的距离，θ表示与水平轴的夹角。径向畸变可看成坐标点沿着长度方向发生了变化 δr , 也就是其距离原点的长度发生了变化。切向畸变可以看成坐标点沿着切线方向发生了变化，也就是水平夹角发生了变化 δθ 。</p>
<ol>
<li><p>径向畸变的纠正：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619172926711.png"></div></p>
<p>其中 [x,y]T是归一化平面点的坐标，[xcorrected,ycorrected]T是畸变后的点的坐标。<br>对于畸变较小的图像中心区域，畸变纠正主要是 k1 起作用。而对于畸变较大的边缘区域主要是 k2起作用。普通摄像头用这两个系数就能很好的纠正径向畸变。对畸变很大的摄像头，比如鱼眼镜头，可以加入 k3畸变项对畸变进行纠正。</p>
</li>
</ol>
</li>
<li><p>切向畸变的纠正：   <div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619173413343.png"></div></p>
</li>
<li><p>对于相机坐标系中的一点 P(X,Y,Z)P(X,Y,Z)，我们能够通过五个畸变系数找到这个点在像素平面上的正确位置:<br>（1）将三维空间点投影到归一化图像平面。设它的归一化坐标为 [x,y]T<br>（2）对归一化平面上的点进行径向畸变和切向畸变纠正。<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619173711878.png"><br>（3）将纠正后的点通过内参数矩阵投影到像素平面，得到该点在图像上的正确位置。<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619173756796.png"></div></div></p>
</li>
<li><p>单目相机的成像过程：<br>（1）首先，世界坐标系下有一个固定的点 P，世界坐标为 Pw。<br> （2）由于相机在运动，它的运动由 R,t或变换矩阵 T∈SE(3）描述。P 的相机坐标为P˜c=RPw+t。<br>（3）这时的 P˜c仍有 X,Y,Z三个量，把它们投影到归一化平面 Z = 1 上，得到 P 的归一化相机坐标： Pc=[X/Z,Y/Z,1]T<br>（4）最后， P 的归一化坐标经过内参后，对应到它的像素坐标： Puv=KPc。</p>
</li>
</ol>
<h2 id="1-3-双目相机模型"><a href="#1-3-双目相机模型" class="headerlink" title="1.3 双目相机模型"></a>1.3 双目相机模型</h2><ol>
<li>仅根据一个像素，无法确定这个空间点的具体位置，因为，从相机光心到归一化平面连线上的所有点，都可以投影至该像素上，深度确定时，才能确切地知道它的空间位置。</li>
<li><p>双目相机原理：通过同步采集左右相机的图像，计算图像间视差，来估计每一个像素的深度。<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619175323423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></div></p>
</li>
<li><p>双目相机深度公式<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619180050660.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619180102507.png"></div></p>
<p>  d 为左右图的横坐标之差，称为视差（Disparity）。根据视差，我们可以估计一个像素离相机的距离。视差与距离成反比：视差越大，距离越近。当基线越长时，双目最大能测到的距离b就会变远。</p>
<h2 id="1-4-RGB-D-相机模型"><a href="#1-4-RGB-D-相机模型" class="headerlink" title="1.4 RGB-D 相机模型"></a>1.4 RGB-D 相机模型</h2></li>
<li><p>RGB-D 相机按原理可分为两大类</p>
<p> (1)通过<strong>红外结构光</strong>（Structured Light）来测量像素距离。 Kinect 1 代、 Project Tango 1 代、 Intel RealSense 等<br> (2)通过<strong>飞行时间法</strong>（Time-of-flight, ToF）原理测量像素距离。 Kinect 2 代和一些现有的 ToF 传感器等</p>
<h1 id="2-图像"><a href="#2-图像" class="headerlink" title="2 图像"></a>2 图像</h1><p>在数学中，图像可以用一个矩阵来描述，在计算机中，它们占据一段连续的磁盘或内存空间，可以用二维数组来表示<br><strong>计算机中图像的表示</strong></p>
</li>
<li>在一张灰度图中，每个像素位置 (x,y)(x,y) 对应到一个灰度值 II，所以一张宽度为 w，高度为 h 的图像，数学形式可以记成一个矩阵：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619181054272.png"></div></li>
<li>用 0−2550−255 之间的数，即一个 unsigned char，一个字节来表达灰度的大小。<br>一张宽度为 640，高度为 480 分辨率的灰图度就可以这样表示：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> image[<span class="number">480</span>][<span class="number">640</span>];</span><br></pre></td></tr></table></figure>
<ol>
<li><p>图像的宽度和列数，对应着 X 轴；而图像的行数或高度，则对应着它的 Y 轴<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619181152573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></div></p>
<p>如果我们讨论一个位于 x, y 处的像素，那么它在程序中的访问方式应该是：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#它对应着灰度值 I(x,y)的读数。请注意这里的 x 和 y 的顺序。</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> pixel = image[y][x];</span><br></pre></td></tr></table></figure>
<ol>
<li>RGB-D 相机的量程通常在十几米范围左右，采用十六位整数（C++ 中的 unsigned short）来记录一个深度图的信息，最大可表示65米。</li>
<li>彩色图像有 R,G,B 三个数值，每一个数值就称为一个通道，通常情况下，每一个通道占8位。OpenCV中的顺序是 B,G,R。<h1 id="3-实践：图像的存取与访问"><a href="#3-实践：图像的存取与访问" class="headerlink" title="3 实践：图像的存取与访问"></a>3 实践：图像的存取与访问</h1><h2 id="3-1-安装Opencv"><a href="#3-1-安装Opencv" class="headerlink" title="3.1 安装Opencv"></a>3.1 安装Opencv</h2><h2 id="3-2-操作Opencv图像"><a href="#3-2-操作Opencv图像" class="headerlink" title="3.2 操作Opencv图像"></a>3.2 操作Opencv图像</h2></li><li>imageBasics.cpp</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取argv[1]指定的图像</span></span><br><span class="line">    cv::Mat image;</span><br><span class="line">    image = cv::imread ( argv[<span class="number">1</span>] ); <span class="comment">//cv::imread函数读取指定路径下的图像</span></span><br><span class="line">    <span class="comment">// 判断图像文件是否正确读取</span></span><br><span class="line">    <span class="keyword">if</span> ( image.data == <span class="literal">nullptr</span> ) <span class="comment">//数据不存在,可能是文件不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"文件"</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">"不存在."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件顺利读取, 首先输出一些基本信息</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"图像宽为"</span>&lt;&lt;image.cols&lt;&lt;<span class="string">",高为"</span>&lt;&lt;image.rows&lt;&lt;<span class="string">",通道数为"</span>&lt;&lt;image.channels()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    cv::imshow ( <span class="string">"image"</span>, image );      <span class="comment">// 用cv::imshow显示图像</span></span><br><span class="line">    cv::waitKey ( <span class="number">0</span> );                  <span class="comment">// 暂停程序,等待一个按键输入</span></span><br><span class="line">    <span class="comment">// 判断image的类型</span></span><br><span class="line">    <span class="keyword">if</span> ( image.type() != CV_8UC1 &amp;&amp; image.type() != CV_8UC3 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 图像类型不符合要求</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入一张彩色图或灰度图."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历图像, 请注意以下遍历方式亦可使用于随机像素访问</span></span><br><span class="line">    <span class="comment">// 使用 std::chrono 来给算法计时</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">size_t</span> y=<span class="number">0</span>; y&lt;image.rows; y++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用cv::Mat::ptr获得图像的行指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* row_ptr = image.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; ( y );  <span class="comment">// row_ptr是第y行的头指针</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> x=<span class="number">0</span>; x&lt;image.cols; x++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 访问位于 x,y 处的像素</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span>* data_ptr = &amp;row_ptr[ x*image.channels() ]; <span class="comment">// data_ptr 指向待访问的像素数据</span></span><br><span class="line">            <span class="comment">// 输出该像素的每个通道,如果是灰度图就只有一个通道</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> c = <span class="number">0</span>; c != image.channels(); c++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> data = data_ptr[c]; <span class="comment">// data为I(x,y)第c个通道的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;( t2-t1 );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"遍历图像用时："</span>&lt;&lt;time_used.count()&lt;&lt;<span class="string">" 秒。"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于 cv::Mat 的拷贝</span></span><br><span class="line">    <span class="comment">// 直接赋值并不会拷贝数据</span></span><br><span class="line">    cv::Mat image_another = image;</span><br><span class="line">    <span class="comment">// 修改 image_another 会导致 image 发生变化</span></span><br><span class="line">    image_another ( cv::Rect ( <span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span> ) ).setTo ( <span class="number">0</span> ); <span class="comment">// 将左上角100*100的块置零</span></span><br><span class="line">    cv::imshow ( <span class="string">"image"</span>, image );</span><br><span class="line">    cv::waitKey ( <span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用clone函数来拷贝数据</span></span><br><span class="line">    cv::Mat image_clone = image.clone();</span><br><span class="line">    image_clone ( cv::Rect ( <span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span> ) ).setTo ( <span class="number">255</span> );</span><br><span class="line">    cv::imshow ( <span class="string">"image"</span>, image );</span><br><span class="line">    cv::imshow ( <span class="string">"image_clone"</span>, image_clone );</span><br><span class="line">    cv::waitKey ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于图像还有很多基本的操作,如剪切,旋转,缩放等,限于篇幅就不一一介绍了,请参看OpenCV官方文档查询每个函数的调用方法.</span></span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><li>CMakeLists.txt</li></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required( VERSION <span class="number">2.8</span> )</span><br><span class="line">project( imageBasics )</span><br><span class="line"></span><br><span class="line"># 添加c++ <span class="number">11</span>标准支持</span><br><span class="line"><span class="built_in">set</span>( CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span> )</span><br><span class="line"></span><br><span class="line"># 寻找OpenCV库</span><br><span class="line">find_package( OpenCV REQUIRED )</span><br><span class="line"># 添加头文件</span><br><span class="line">include_directories( $&#123;OpenCV_INCLUDE_DIRS&#125; )</span><br><span class="line"></span><br><span class="line">add_executable( imageBasics imageBasics.cpp )</span><br><span class="line"># 链接OpenCV库</span><br><span class="line">target_link_libraries( imageBasics $&#123;OpenCV_LIBS&#125; )</span><br></pre></td></tr></table></figure>
<p>测试执行如下操作：<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"><span class="function"><span class="title">cmake</span></span> ..</span><br><span class="line">make</span><br><span class="line"><span class="function"><span class="title">cd</span></span> ..</span><br><span class="line">build/imageBasics ubuntu.png</span><br></pre></td></tr></table></figure><br>结果如图：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619193548295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="4-实践：拼接点云"><a href="#4-实践：拼接点云" class="headerlink" title="4 实践：拼接点云"></a>4 实践：拼接点云</h1><p>本节程序提供了五张 RGB-D 图像，并且知道了每个图像的内参和外参。根据 RGB-D 图像和相机内参，可以计算任何一个像素在相机坐标系下的位置。根据相机位姿，又能计算这些像素在世界坐标系下的位置。如果把所有像素的空间坐标都求出来，相当于构建一张类似于地图的东西。</p>
<p>在 color/下有 1.png 到 5.png五张 RGB 图，而在 depth/下有五张对应的深度图。同时， pose.txt 文件给出了五张图像的相机位姿（以 Tw c 形式）。位姿记录的形式是平移向量加旋转四元数：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619194212871.png"></div></p>
<p>完成两件事：<br> (1). 根据内参计算一对 RGB-D 图像对应的点云；<br> (2). 根据各张图的相机位姿（也就是外参），把点云加起来，组成地图。</p>
<p><li> joinMap.cpp<br>注释参考：<a href="https://www.cnblogs.com/newneul/p/8407369.html" target="_blank" rel="noopener">https://www.cnblogs.com/newneul/p/8407369.html</a></li></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Geometry&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/format.hpp&gt;  // for formating strings</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用vector&lt;cv::Mat&gt;和vector&lt;Eigen::Isometry3d&gt;定义图片变量和相机位姿</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Mat&gt; colorImgs, depthImgs;    <span class="comment">// 彩色图和深度图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Eigen::Isometry3d, Eigen::aligned_allocator&lt;Eigen::Isometry3d&gt;&gt; poses;         <span class="comment">// 相机位姿</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先设地址，位姿地址就一个</span></span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"./pose.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"请在有pose.txt的目录下运行此程序"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        boost::<span class="function">format <span class="title">fmt</span><span class="params">( <span class="string">"./%s/%d.%s"</span> )</span></span>; <span class="comment">//图像文件格式</span></span><br><span class="line">        <span class="comment">//找到图像存储的路径，然后放入先前创建好的vector中</span></span><br><span class="line">        colorImgs.push_back( cv::imread( (fmt%<span class="string">"color"</span>%(i+<span class="number">1</span>)%<span class="string">"png"</span>).str() ));</span><br><span class="line">        depthImgs.push_back( cv::imread( (fmt%<span class="string">"depth"</span>%(i+<span class="number">1</span>)%<span class="string">"pgm"</span>).str(), <span class="number">-1</span> )); <span class="comment">// 使用-1读取原始图像</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//位姿数据里面定义的有7个量，前面3个是位移，后面四个是四元数，最后一个是实部</span></span><br><span class="line">        <span class="keyword">double</span> data[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; d:data )<span class="comment">//auto自动类型转换</span></span><br><span class="line">            <span class="comment">//文件流类型的变量fin将pose.txt中的数据给了d数组,将上面的每个图片的外参都给了d</span></span><br><span class="line">            fin&gt;&gt;d;</span><br><span class="line">        Eigen::<span class="function">Quaterniond <span class="title">q</span><span class="params">( data[<span class="number">6</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>] )</span></span>;</span><br><span class="line">        Eigen::<span class="function">Isometry3d <span class="title">T</span><span class="params">(q)</span></span>; <span class="comment">//变换矩阵初始化旋转部分</span></span><br><span class="line">        T.pretranslate( Eigen::Vector3d( data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>] ));<span class="comment">//变换矩阵初始化平移向量部分</span></span><br><span class="line">        poses.push_back( T ); <span class="comment">//存储变换矩阵到位姿数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算点云并拼接</span></span><br><span class="line">    <span class="comment">// 相机内参 </span></span><br><span class="line">    <span class="keyword">double</span> cx = <span class="number">325.5</span>;</span><br><span class="line">    <span class="keyword">double</span> cy = <span class="number">253.5</span>;</span><br><span class="line">    <span class="keyword">double</span> fx = <span class="number">518.0</span>;</span><br><span class="line">    <span class="keyword">double</span> fy = <span class="number">519.0</span>;</span><br><span class="line">    <span class="keyword">double</span> depthScale = <span class="number">1000.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"正在将图像转换为点云..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义点云使用的格式：这里用的是XYZRGB</span></span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointXYZRGB PointT; </span><br><span class="line">    <span class="keyword">typedef</span> pcl::PointCloud&lt;PointT&gt; PointCloud;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建一个点云,PointCoud::Ptr是一个智能指针类 通过构造函数初始化指针指向的申请的空间</span></span><br><span class="line">    <span class="comment">//pointCloud 是一个智能指针类型的对象 </span></span><br><span class="line">    PointCloud::<span class="function">Ptr <span class="title">pointCloud</span><span class="params">( <span class="keyword">new</span> PointCloud )</span></span>; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"转换图像中: "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">        cv::Mat color = colorImgs[i]; </span><br><span class="line">        cv::Mat depth = depthImgs[i];</span><br><span class="line">        Eigen::Isometry3d T = poses[i];</span><br><span class="line">        <span class="comment">/*对图像像素进行坐标转换，将图像的坐标通过内参矩阵K转换为相机坐标系下的坐标，之后通过外参矩阵T 转化为世界坐标系下的坐标*/</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> v=<span class="number">0</span>; v&lt;color.rows; v++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> u=<span class="number">0</span>; u&lt;color.cols; u++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> d = depth.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; ( v )[u]; <span class="comment">// 深度值</span></span><br><span class="line">                <span class="keyword">if</span> ( d==<span class="number">0</span> ) <span class="keyword">continue</span>; <span class="comment">// 为0表示没有测量到</span></span><br><span class="line">                Eigen::Vector3d point; </span><br><span class="line">                point[<span class="number">2</span>] = <span class="keyword">double</span>(d)/depthScale; <span class="comment">//对实际尺度的一个缩放</span></span><br><span class="line">                point[<span class="number">0</span>] = (u-cx)*point[<span class="number">2</span>]/fx;</span><br><span class="line">                point[<span class="number">1</span>] = (v-cy)*point[<span class="number">2</span>]/fy; </span><br><span class="line">                Eigen::Vector3d pointWorld = T*point;<span class="comment">//将相机坐标系转换为世界坐标系</span></span><br><span class="line">                <span class="comment">//将世界坐标系下的坐标用pcl专门的点云格式存储起来</span></span><br><span class="line">                <span class="comment">//定义一个pcl点p.这个p有六个值，x,y,z，b,g,r</span></span><br><span class="line">                PointT p ;</span><br><span class="line">                p.x = pointWorld[<span class="number">0</span>];</span><br><span class="line">                p.y = pointWorld[<span class="number">1</span>];</span><br><span class="line">                p.z = pointWorld[<span class="number">2</span>];</span><br><span class="line">                p.b = color.data[ v*color.step+u*color.channels() ];</span><br><span class="line">                p.g = color.data[ v*color.step+u*color.channels()+<span class="number">1</span> ];</span><br><span class="line">                p.r = color.data[ v*color.step+u*color.channels()+<span class="number">2</span> ];</span><br><span class="line">                pointCloud-&gt;points.push_back( p );</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里有可能深度图中某些像素没有深度信息，那么就是包含无效的像素，所以先置为假，但是如果设置成true的话 也没有看出来有什么不一样的地方pointCloud-&gt;is_dense = false;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"点云共有"</span>&lt;&lt;pointCloud-&gt;size()&lt;&lt;<span class="string">"个点."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//拼接点云,点云是指针形式</span></span><br><span class="line">    <span class="comment">//获取pointCloud指向的对象 这个就当做获取普通指针指向的对象来理解，这个对象是在定义的时候new出来的一段内存空间。</span></span><br><span class="line">    pcl::io::savePCDFileBinary(<span class="string">"map.pcd"</span>, *pointCloud );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器的基本使用：<a href="http://blog.csdn.net/ws_20100/article/details/50829327" target="_blank" rel="noopener">http://blog.csdn.net/ws_20100/article/details/50829327</a><br>计算位于 (u, v)，深度为 d 的像素，在相机坐标系下的位置。并根据外参把它们变换到世界坐标。我们知道相机坐标 pc 到像素坐标 (u, v, d) 的关系为：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619204112624.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619203722247.png"></div></p>
<p>反推 pc 的形式亦非常简单。设 pc=[x,y,z]那么：<div align="center">  </div></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619203836659.png"></p>
<p><li>CMakeLists.txt</li></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required( VERSION <span class="number">2.8</span> )</span><br><span class="line">project( joinMap )</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>( CMAKE_BUILD_TYPE Release )</span><br><span class="line"><span class="built_in">set</span>( CMAKE_CXX_FLAGS <span class="string">"-std=c++11 -O3"</span> )</span><br><span class="line"></span><br><span class="line"><span class="meta"># opencv </span></span><br><span class="line">find_package( OpenCV REQUIRED )</span><br><span class="line">include_directories( $&#123;OpenCV_INCLUDE_DIRS&#125; )</span><br><span class="line"></span><br><span class="line"><span class="meta"># eigen </span></span><br><span class="line">include_directories( <span class="string">"/usr/include/eigen3/"</span> )</span><br><span class="line"></span><br><span class="line"><span class="meta"># pcl </span></span><br><span class="line">find_package( PCL REQUIRED COMPONENT common io )</span><br><span class="line">include_directories( $&#123;PCL_INCLUDE_DIRS&#125; )</span><br><span class="line">add_definitions( $&#123;PCL_DEFINITIONS&#125; )</span><br><span class="line"><span class="built_in">list</span>(REMOVE_ITEM PCL_LIBRARIES <span class="string">"vtkproj4"</span>)</span><br><span class="line"></span><br><span class="line">add_executable( joinMap joinMap.cpp )</span><br><span class="line">target_link_libraries( joinMap $&#123;OpenCV_LIBS&#125; $&#123;PCL_LIBRARIES&#125; )</span><br></pre></td></tr></table></figure>
<p>执行如下操作：<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cmake</span> <span class="string">..</span></span><br><span class="line"><span class="attr">make</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">..</span></span><br><span class="line"><span class="attr">build/joinMap</span></span><br><span class="line"><span class="attr">pcl_viewer</span> <span class="string">map.pcd</span></span><br></pre></td></tr></table></figure><br>结果如图：<div align="center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190619195744627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="未完待续！" data-src="https://img-blog.csdnimg.cn/20190619195725290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></div></p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>视觉slam 十四讲 环境配置</title>
    <url>/2019/04/19/%E8%A7%86%E8%A7%89slam-%E5%8D%81%E5%9B%9B%E8%AE%B2-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>新系统装很顺畅，没遇到什么问题</p><h1 id="Kdevelop安装"><a href="#Kdevelop安装" class="headerlink" title="Kdevelop安装"></a>Kdevelop安装</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install kdevelop</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装相应的cmake编译器</span></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install automake autoconf g++ libtool cmake</span><br></pre></td></tr></table></figure><h1 id="eigen安装"><a href="#eigen安装" class="headerlink" title="eigen安装"></a>eigen安装</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">apt-get install libeigen3-dev</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">updatedb</span></span><br><span class="line"><span class="attr">locate</span> <span class="string">eigen3</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="Sophus安装"><a href="#Sophus安装" class="headerlink" title="Sophus安装"></a>Sophus安装</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">clone http://github.com/strasdat/Sophus.git</span></span><br><span class="line"><span class="attr">git</span> <span class="string">checkout a621ff</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cmake</span> <span class="string">..</span></span><br><span class="line"><span class="attr">make</span></span><br></pre></td></tr></table></figure>
<h1 id="Pangolin安装"><a href="#Pangolin安装" class="headerlink" title="Pangolin安装"></a>Pangolin安装</h1><p>用于可视化和用户接口<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装依赖库</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">apt-get install libglew-dev libpython2.7-dev libboost-dev libboost-thread-dev libboost-filesystem-dev -y</span></span><br><span class="line"><span class="comment">#下载Pangolin、编译并安装</span></span><br><span class="line"><span class="attr">git</span> <span class="string">clone https://github.com/stevenlovegrove/Pangolin </span></span><br><span class="line"><span class="attr">cd</span> <span class="string">Pangolin</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">build </span></span><br><span class="line"><span class="attr">cd</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cmake</span> <span class="string">..</span></span><br><span class="line"><span class="attr">make</span> <span class="string">-j4</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">make install</span></span><br></pre></td></tr></table></figure></p>
<h1 id="opencv安装"><a href="#opencv安装" class="headerlink" title="opencv安装"></a>opencv安装</h1><p>参考：<a href="https://www.jianshu.com/p/f646448da265" target="_blank" rel="noopener">https://www.jianshu.com/p/f646448da265</a><br>官网下载opencv,我选用opencv3.4.６，下载链接 <a href="http://opencv.org/releases.html，选择sources版本。" target="_blank" rel="noopener">http://opencv.org/releases.html，选择sources版本。</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">＃解压zip包</span><br><span class="line">unzip opencv<span class="number">-3.4</span>.６.zip</span><br><span class="line">cd opencv<span class="number">-3.4</span>.６</span><br><span class="line"></span><br><span class="line">＃安装依赖库和cmake</span><br><span class="line">sudo apt-get install build-essential libgtk2<span class="number">.0</span>-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff4.dev libswscale-dev libjasper-dev  </span><br><span class="line"></span><br><span class="line">＃执行cmake和make</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#将OpenCV的库添加到路径</span></span><br><span class="line">sudo gedit /etc/ld.so.conf.d/opencv.conf</span><br><span class="line"><span class="comment">#执行此命令后打开的可能是一个空白的文件，不用管，只需要在文件末尾添加</span></span><br><span class="line">/usr/local/lib</span><br><span class="line"></span><br><span class="line"><span class="comment">#生效配置文件</span></span><br><span class="line">sudo ldconfig </span><br><span class="line"></span><br><span class="line"><span class="comment">#配置bash</span></span><br><span class="line">sudo gedit /etc/bash.bashrc</span><br><span class="line">在末尾追加：</span><br><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig  </span><br><span class="line">export PKG_CONFIG_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#使得配置生效</span></span><br><span class="line">source /etc/bash.bashrc</span><br><span class="line"><span class="comment">#更新</span></span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure>
<p>依赖包安装：<a href="https://www.jianshu.com/p/259a6140da9d" target="_blank" rel="noopener">https://www.jianshu.com/p/259a6140da9d</a></p>
<h1 id="pcl安装"><a href="#pcl安装" class="headerlink" title="pcl安装"></a>pcl安装</h1><p>参考：<a href="https://blog.csdn.net/lilywri823/article/details/86583269" target="_blank" rel="noopener">https://blog.csdn.net/lilywri823/article/details/86583269</a><br><strong>安装各种依赖</strong><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> git <span class="keyword">build</span>-essential linux-libc-dev</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> cmake cmake-gui</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libusb<span class="number">-1.0</span><span class="number">-0</span>-dev libusb-dev libudev-dev</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> mpi-<span class="keyword">default</span>-dev openmpi-<span class="keyword">bin</span> openmpi-common</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libflann1<span class="number">.8</span> libflann-dev</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libeigen3-dev</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libboost-<span class="keyword">all</span>-dev</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libqhull* libgtest-dev  </span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> freeglut3-dev pkg-config  </span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libxmu-dev libxi-dev   </span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> mono-<span class="keyword">complete</span>   </span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libopenni-dev   </span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> libopenni2-dev</span><br></pre></td></tr></table></figure></p>
<p><strong>下载vtk源码</strong><br>在VTK官网下载，<a href="https://www.vtk.org/download/" target="_blank" rel="noopener">https://www.vtk.org/download/</a> ，我下载的版本7.1.1,下载完成后，提取到Home目录下。<br>（1）在vtk-7.1.1目录下，打开终端，输入cmake-gui打开cmake图形界面<br>（2）配置“where is the source code”的路径为vtk-7.1.1所在的目录<br>（3）在vtk-7.1.1目录新建build文件夹，配置“where to build the binaries”为build文件夹<br>（4）点击Configure，配置完成后提示configure done<br>（5）选择“VTK_GROUP_QT”再次点击configure<br>（6）配置完成后点击generate按钮，会在build文件夹下生成工程文件<br>（7）切换文件目录到vtk-7.1.1文件夹下的build文件夹，然后打开终端，输入：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span></span><br><span class="line">sudo <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure>
<p><strong>下载PCL源码</strong><br>在官网下载，<a href="https://github.com/PointCloudLibrary/pcl/releases" target="_blank" rel="noopener">https://github.com/PointCloudLibrary/pcl/releases</a><br>我下载的是最新的版本1.8.0,下载完成后，提取到Home目录下。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cd pcl-pcl<span class="number">-1.8</span><span class="number">.0</span></span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=<span class="literal">None</span> ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<h1 id="ceres安装"><a href="#ceres安装" class="headerlink" title="ceres安装"></a>ceres安装</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装所需要依赖</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">apt-get install liblapack-dev libsuitesparse-dev libcxsparse3.1.4 libgflags-dev libgoogle-glog-dev libgtest-dev</span></span><br><span class="line"><span class="comment">#编译安装</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">ceres</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cmake</span> <span class="string">..</span></span><br><span class="line"><span class="attr">make</span> <span class="string">-j4</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">make install</span></span><br></pre></td></tr></table></figure>
<h1 id="g2o安装"><a href="#g2o安装" class="headerlink" title="g2o安装"></a>g2o安装</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装所需要依赖</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">apt-get install libqt4-dev qt4-qmake libqglviewer-dev libsuitesparse-dev libcxsparse3.1.4 libcholmod3.0.6</span></span><br><span class="line"><span class="comment">#编译安装</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">g2o</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cmake</span> <span class="string">..</span></span><br><span class="line"><span class="attr">make</span> <span class="string">-j4</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">make install</span></span><br></pre></td></tr></table></figure>
<h1 id="Meshlab安装"><a href="#Meshlab安装" class="headerlink" title="Meshlab安装"></a>Meshlab安装</h1><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:zarquon42/meshlab</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install meshlab</span><br></pre></td></tr></table></figure>
<h1 id="gtsam-3-2-1安装"><a href="#gtsam-3-2-1安装" class="headerlink" title="gtsam-3.2.1安装"></a>gtsam-3.2.1安装</h1><p>1、下载gtsam-3.2.1.gz文件并解压<a href="http://borg.cc.gatech.edu/download.html" target="_blank" rel="noopener">http://borg.cc.gatech.edu/download.html</a></p>
<p>2、在gtsam-3.2.1文件路径下打开终端：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">sudo mkdir build</span><br><span class="line">cd build</span><br><span class="line"><span class="function"><span class="title">sudo</span></span> cmake ..</span><br><span class="line"><span class="symbol">$</span> sudo make install</span><br></pre></td></tr></table></figure>
<p>报错：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190716083752541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>解决：<br>在gtsam/inference/Ordering.cpp和usr/include/boost/serialization/detail/stack_constructor.hpp文件中，添加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/serialization/serialization.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="octomap-安装"><a href="#octomap-安装" class="headerlink" title="octomap 安装"></a>octomap 安装</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">apt-get install build-essential cmake doxygen libqt4-dev libqt4-opengl-dev qt4-qmake libqglviewer-dev-qt4</span></span><br><span class="line"><span class="attr">git</span> <span class="string">clone https：//github.com/OctoMap/octomap</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">octomap</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">build</span></span><br><span class="line"><span class="attr">cmake</span> <span class="string">..</span></span><br><span class="line"><span class="attr">make</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
  </entry>
  <entry>
    <title>扩展卡尔曼滤波(EKF)</title>
    <url>/2019/04/15/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://mp.csdn.net/mdeditor/99690849#" target="_blank" rel="noopener">卡尔曼滤波详细推导</a><br>把卡尔曼滤波扩展到非线性系统中，称为卡尔曼滤波器（EKF），通常的做法，在某个点附近考虑运动方程及观测方程的一阶泰勒展开，只保留一阶项，即线性部分，然后按照线性系统进行推到。<br>令k-1时刻的均值和协方差矩阵为$\hat{x}_{k-1},\hat{P}_{k-1}$.在k时刻，把运动方程和观测方程在$\hat{x}_{k-1},\hat{P}_{k-1}$处线性化（相当于一阶泰勒展开），有：</p><a id="more"></a>
<script type="math/tex; mode=display">x_{k}\approx f(\hat{x}_{k-1},u_k)+\frac{\partial f}{\partial x_{k-1}}|_{\hat{x}_{k-1}}(x_{k-1}-\hat{x}_{k-1})+w_k</script><p>记偏导数：</p>
<script type="math/tex; mode=display">F=\frac{\partial f}{\partial {x}_{k-1}}|_{\hat{x}_{k-1}}</script><p> 对于观测方程：</p>
<script type="math/tex; mode=display">z_k\approx h(\bar{x}_k)+\frac{\partial h}{\partial x_k}|_{\bar{x}_k}(x_k-\bar{x}_k)+n_k</script><p>记偏导数：</p>
<script type="math/tex; mode=display">H=\frac{\partial h}{\partial {x}_{k}}|_{\bar{x}_{k}}</script><p>在预测步骤中，根据运动方程有：</p>
<script type="math/tex; mode=display">P(x_k|x_0,u_{1:k},z_{0:k-1})=N(f(\hat{x}_{k-1},u_k),F\hat{P}_{k-1}F^T+R_k)</script><p>记：</p>
<script type="math/tex; mode=display">\bar{x}_k=f(\hat{x}_{k-1},u_k),\qquad\bar{P}_k=F\hat{P}_{k-1}F^T+R_k.</script><p>观测方程有：</p>
<script type="math/tex; mode=display">P(z_k|x_k)=N(h(\bar{x}_k)+H(x_k-\bar{x}_k),Q_k)</script><p>卡尔曼增益$K_k$:</p>
<script type="math/tex; mode=display">K_k=\bar{P}_kH^T(H\bar{P}_k H^T+Q_k)^{-1}</script><p>后验概率的形式：</p>
<script type="math/tex; mode=display">\hat{x}_k=\bar{x}_k+K_k(z_k-h(\bar{x}_k)),\hat{P}_k=(I-K_kH)\bar{P}_k</script>]]></content>
      <categories>
        <category>滤波算法</category>
      </categories>
  </entry>
  <entry>
    <title>卡尔曼滤波（KF）</title>
    <url>/2019/04/10/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener">英文原文</a></p><h1 id="卡尔曼滤波器简介——追踪介绍"><a href="#卡尔曼滤波器简介——追踪介绍" class="headerlink" title="卡尔曼滤波器简介——追踪介绍"></a>卡尔曼滤波器简介——追踪介绍</h1><p><strong>什么是卡尔曼滤波?</strong>　　<br>你可以在任何含有<strong>不确定信息</strong>的动态系统中使用卡尔曼滤波，对系统下一步的走向做出<strong>有根据的预测</strong>，即使伴随着各种干扰，卡尔曼滤波总是能指出真实发生的情况</p><p>在连续变化的系统中使用卡尔曼滤波是非常理想的，它具有占用内存小的优点（除了前一个状态量外，不需要保留其它历史数据），并且速度很快，很适合应用于实时问题和嵌入式系统。</p><a id="more"></a>


<p>自动驾驶汽车使用激光雷达跟踪其他车辆，如何找到其他车辆？我想找到其他车辆的原因是我不想和其他车辆发生碰撞。</p>
<p>为了进行评估 我们必须得先明白如何解释传感器数据。不知是明白其他车辆在那，还要知道速度是多少，这样你就可以避免与他们进行碰撞，这对行人和其他物体也很重要。</p>
<p>知道其他车在那里，并且对他们将要去那里做出预测。</p>
<p>卡尔曼滤波是一个非常流行的系统状态估计的方法，他和概率定位相当相似，我们之前学过的蒙特卡罗定位方法，主要区别是 卡尔曼是对一个连续状态进行估计，而蒙特卡罗将世界分成很多离散的小块，作为结果，卡尔曼给我们一个单峰分布，蒙特卡罗是多峰分布。这两种方法都适用与定位和对其他车辆的追踪。事实上粒子滤波也适用于定位和预测，粒子滤波是连续多峰分布的。</p>
<p><strong>卡尔曼滤波器的美妙之处在于，它将不够准确的传感器测量结果和不够准确的运动预测相结合，得到一个筛选后的位置估计值，这个估计值比所有仅来自传感器读数或运动预测的估计值更好。</strong></p>
<h2 id="1-卡尔曼滤波原理"><a href="#1-卡尔曼滤波原理" class="headerlink" title="1.卡尔曼滤波原理"></a>1.卡尔曼滤波原理</h2><p>卡尔曼滤波假设两个变量（位置和速度，在这个例子中）都是随机的，并且服从高斯分布。每个变量都有一个均值 μ，表示随机分布的中心（最可能的状态），以及方差，表示不确定性</p>
<h3 id="1-1-使用矩阵来描述问题"><a href="#1-1-使用矩阵来描述问题" class="headerlink" title="1.1 使用矩阵来描述问题"></a>1.1 使用矩阵来描述问题</h3><p>我们基于高斯分布来建立状态变量，所以在时刻 k 需要两个信息：最佳估计（即均值，其它地方常用 μ 表示），以及协方差矩阵。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817112851953.png#pic_center"><br>（当然，在这里我们只用到了位置和速度，实际上这个状态可以包含多个变量，代表任何你想表示的信息）。接下来，我们需要根据当前状态（k-1 时刻）来预测下一状态（k 时刻）。记住，我们并不知道对下一状态的所有预测中哪个是“真实”的，但我们的预测函数并不在乎。它对所有的可能性进行预测，并给出新的高斯分布。<br>我们可以用矩阵Fk来表示这个预测过程：</p>
<p>　　它将我们原始估计中的每个点都移动到了一个新的预测位置，如果原始估计是正确的话，这个新的预测位置就是系统下一步会移动到的位置。那我们又如何用矩阵来预测下一个时刻的位置和速度呢？下面用一个基本的运动学公式来表示：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817125216840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>现在，我们有了一个预测矩阵来表示下一时刻的状态，但是，我们仍然不知道怎么更新协方差矩阵。此时，我们需要引入另一个公式，如果我们将分布中的每个点都乘以矩阵 A，那么它的协方差矩阵 这里写图片描述 会怎样变化呢？很简单，下面给出公式：　　<br>　<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113154367.png#pic_center"><br>结合方程（4）和（3）得到<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113216117.png#pic_center"></p>
<h3 id="1-2-外部控制量"><a href="#1-2-外部控制量" class="headerlink" title="1.2 外部控制量"></a>1.2 外部控制量</h3><p>我们并没有捕捉到一切信息，可能存在外部因素会对系统进行控制，带来一些与系统自身状态没有相关性的改变。 　　</p>
<p>以火车的运动状态模型为例，火车司机可能会操纵油门，让火车加速。相同地，在我们机器人这个例子中，导航软件可能会发出一个指令让轮子转向或者停止。如果知道这些额外的信息，我们可以用一个向量Uk来表示，将它加到我们的预测方程中做修正。</p>
<p>假设由于油门的设置或控制命令，我们知道了期望的加速度a，根据基本的运动学方程可以得到：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113318171.png#pic_center"><br>以矩阵的形式表示就是：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113330252.png#pic_center"><br>$B_k$称为控制矩阵，$U_k$称为控制向量（对于没有外部控制的简单系统来说，这部分可以忽略）。让我们再思考一下，如果我们的预测并不是100%准确的，该怎么办呢？</p>
<h3 id="1-3-外部干扰"><a href="#1-3-外部干扰" class="headerlink" title="1.3 外部干扰"></a>1.3 外部干扰</h3><p>如果这些状态量是基于系统自身的属性或者已知的外部控制作用来变化的，则不会出现什么问题。 　　</p>
<p>但是，如果存在未知的干扰呢？例如，假设我们跟踪一个四旋翼飞行器，它可能会受到风的干扰，如果我们跟踪一个轮式机器人，轮子可能会打滑，或者路面上的小坡会让它减速。这样的话我们就不能继续对这些状态进行跟踪，如果没有把这些外部干扰考虑在内，我们的预测就会出现偏差。 　</p>
<p>在每次预测之后，我们可以添加一些新的不确定性来建立这种与“外界”（即我们没有跟踪的干扰）之间的不确定性模型：</p>
<p>原始估计中的每个状态变量更新到新的状态后，仍然服从高斯分布。我们可以说Xk-1的每个状态变量移动到了一个新的服从高斯分布的区域，协方差为Qk。换句话说就是，我们将这些没有被跟踪的干扰当作协方差为Qk的噪声来处理。</p>
<p>这产生了具有不同协方差（但是具有相同的均值）的新的高斯分布。</p>
<p>我们通过简单地添加Qk得到扩展的协方差，下面给出预测步骤的完整表达式:<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113439985.png#pic_center"><br>由上式可知，<strong>新的最优估计</strong>是根据<strong>上一最优估计预测</strong>得到的，并<strong>加上已知外部控制量的修正</strong>。 　　而<strong>新的不确定性</strong>由<strong>上一不确定性预测</strong>得到，并<strong>加上外部环境的干扰</strong>。</p>
<p>好了，我们对系统可能的动向有了一个模糊的估计，用$x_k$和$P_k$ 来表示。如果再结合传感器的数据会怎样呢？</p>
<h3 id="1-4-用测量值来修正估计值"><a href="#1-4-用测量值来修正估计值" class="headerlink" title="1.4 用测量值来修正估计值"></a>1.4 用测量值来修正估计值</h3><p>我们可能会有多个传感器来测量系统当前的状态，哪个传感器具体测量的是哪个状态变量并不重要，也许一个是测量位置，一个是测量速度，每个传感器间接地告诉了我们一些状态信息。</p>
<p>注意，传感器读取的数据的单位和尺度有可能与我们要跟踪的状态的单位和尺度不一样，我们用矩阵Hk来表示传感器的数据。</p>
<p>我们可以计算出传感器读数的分布，用之前的表示方法如下式所示<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113545696.png#pic_center"><br>卡尔曼滤波的一大优点就是能处理传感器噪声，换句话说，我们的传感器或多或少都有点不可靠，并且原始估计中的每个状态可以和一定范围内的传感器读数对应起来</p>
<p>从测量到的传感器数据中，我们大致能猜到系统当前处于什么状态。但是由于存在不确定性，某些状态可能比我们得到的读数更接近真实状态。</p>
<p>我们将这种不确定性（例如：传感器噪声）用协方差Rk 表示，该分布的均值就是我们读取到的传感器数据，称之为$z_k$。</p>
<p>现在我们有了两个高斯分布，一个是在预测值附近，一个是在传感器读数附近。</p>
<p>我们必须在预测值和传感器测量值之间找到最优解</p>
<p>那么，我们最有可能的状态是什么呢？对于任何可能的读数(z1,z2)，有两种情况：（1）传感器的测量值；（2）由前一状态得到的预测值。如果我们想知道这两种情况都可能发生的概率，将这两个高斯分布相乘就可以了。<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113632588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>剩下的就是重叠部分了，这个重叠部分的均值就是两个估计最可能的值，也就是给定的所有信息中的最优估计。 　</p>
<p>把两个具有不同均值和方差的高斯分布相乘，你会得到一个新的具有独立均值和方差的高斯分布！下面用公式讲解</p>
<h4 id="1-4-1-融合高斯分布"><a href="#1-4-1-融合高斯分布" class="headerlink" title="1.4.1 融合高斯分布"></a>1.4.1 融合高斯分布</h4><p>一维高斯分布来分析比较简单点<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113718375.png#pic_center"><br>两个服从高斯分布的函数相乘<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817132507870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>重新归一化，使总概率为1，可以得到：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113851764.png#pic_center"><br>将式（11）中的两个式子相同的部分用 k 表示<br>下面进一步将式（12）和（13）写成矩阵的形式，如果 Σ 表示高斯分布的协方差，u 表示每个维度的均值，则：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019081711393516.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817113940124.png#pic_center"><br>矩阵K称为卡尔曼增益</p>
<h4 id="1-4-2-整合公式"><a href="#1-4-2-整合公式" class="headerlink" title="1.4.2 整合公式"></a>1.4.2 整合公式</h4><p>预测部分：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817114029226.png#pic_center"><br>测量部分：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817114058531.png#pic_center"><br>将它们放到式（15）中算出它们之间的重叠部分<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817114125142.png#pic_center"><br>由式（14）可得卡尔曼增益为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817114142974.png#pic_center"><br>将式（16）和式（17）得：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817114158765.png#pic_center"><br>$x_k’$就是新的最优估计，我们可以将它和$P_k’$放到下一个预测和更新方程中不断迭代。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190817114212747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>当方差很小时，分布具有更高的确定性,如果我们用无人驾驶汽车追踪另一輛汽车，应该选择那一个高斯分布？<br>应选择方差小的，确定性高</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(mu, sigma2, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/sqrt(<span class="number">2.</span>*pi*sigma2) * exp(<span class="number">-.5</span>*(x-mu)**<span class="number">2</span> / sigma2)</span><br></pre></td></tr></table></figure>
<p><strong>New Mean and Variance</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(mean1,var1,mean2,var2)</span>:</span></span><br><span class="line">    new_mean=(var2*mean1+var1*mean2)/(var1+var2)</span><br><span class="line">    new_var=<span class="number">1</span>/(<span class="number">1</span>/var1+<span class="number">1</span>/var2)</span><br><span class="line">    <span class="keyword">return</span>[new_mean,new_var]</span><br></pre></td></tr></table></figure>
<p><strong>Predict Function</strong><br>卡尔曼过滤器，即使没有测量物体的速度，也可以通过物体的位置变化，得到物体的速度，进而预测追踪的物体以该速度出现的下一个位置。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(mean1,var1,mean2,var2)</span>:</span></span><br><span class="line">    new_mean=mean1+mean2</span><br><span class="line">    new_var=var1+var2</span><br><span class="line">    <span class="keyword">return</span> [new_mean,new_var]</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">measurements=[<span class="number">5.</span>,<span class="number">6.</span>,<span class="number">7.</span>,<span class="number">9.</span>,<span class="number">10.</span>]</span><br><span class="line">motion=[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">1.</span>,<span class="number">1.</span>]</span><br><span class="line">measurement_sig=<span class="number">4.</span></span><br><span class="line">motion_sig=<span class="number">2.</span></span><br><span class="line">mu=<span class="number">0.</span></span><br><span class="line">sig=<span class="number">10000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Please print out ONLY the final values of the mean</span></span><br><span class="line"><span class="comment">#and the variance in a list [mu, sig]. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Insert code here</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(len(measurements)):</span><br><span class="line">    [mu,sig]=update(mu,sig,measurements[n],measurement_sig)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'update:'</span>,[mu,sig])</span><br><span class="line">    [mu,sig]=predict(mu,sig,motion[n],motion_sig)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'predict:'</span>,[mu,sig])</span><br><span class="line"></span><br><span class="line">print( [mu, sig])</span><br><span class="line"></span><br><span class="line"><span class="comment">#update: [4.998000799680128, 3.9984006397441023]</span></span><br><span class="line"><span class="comment"># predict: [5.998000799680128, 5.998400639744102]</span></span><br><span class="line"><span class="comment"># update: [5.999200191953932, 2.399744061425258]</span></span><br><span class="line"><span class="comment"># predict: [6.999200191953932, 4.399744061425258]</span></span><br><span class="line"><span class="comment"># update: [6.999619127420922, 2.0951800575117594]</span></span><br><span class="line"><span class="comment"># predict: [8.999619127420921, 4.09518005751176]</span></span><br><span class="line"><span class="comment"># update: [8.999811802788143, 2.0235152416216957]</span></span><br><span class="line"><span class="comment"># predict: [9.999811802788143, 4.023515241621696]</span></span><br><span class="line"><span class="comment"># update: [9.999906177177365, 2.0058615808441944]</span></span><br><span class="line"><span class="comment"># predict: [10.999906177177365, 4.005861580844194]</span></span><br><span class="line"><span class="comment"># [10.999906177177365, 4.005861580844194]</span></span><br></pre></td></tr></table></figure>
<p>这段代码部署了整个卡尔曼滤波器，它检查了所有测量元素并默认测量值的个数为运动的n次幂，它使用update 递归公式更新mu和sigma. 如果我们导入第n个测量值和测量不确定性，他会对运动进行同样的操作，这里的预测部分，它使用第n个运动和运动不确定性递归地更新mu和sigma 并把这些全部打印出来。</p>
<p>在跟踪应用程序中，卡尔曼滤波器最令人惊奇的功能之一是即使他没有直接测量，他也能得出对象的速度</p>
<p>然后根据速度预测出该速度出现的未来位置。这就是卡尔曼滤波器在人工智能和控制理论方面成为流行的原因。</p>
<h3 id="Kalman-Filter-Land"><a href="#Kalman-Filter-Land" class="headerlink" title="Kalman Filter Land"></a>Kalman Filter Land</h3><p><strong>多变量高斯分布</strong><br>比如，当机器人的位置有多个维度，每一个维度都是高斯分布时，这个位置变量即服从多维高斯分布。不用去关注它的概率分布公式是啥，没用。它的均值是一个向量，方差为协方差矩阵，反应各维度两两之间的（线性）相关性。举个例子，当我们得知二维高斯变量的两个变量的相关系数为正，那么当x大于均值时，它的y也很可能大于均值，在概率分布上表现为右上方倾斜的等高线图</p>
<p><strong>More Kalman Filters</strong><br>对车辆状态（state）的估计：1.location（observation） 2.velocity（hidden）。我们假设，当前的速度等于上一次的速度，由之前的分布，得出当前可能的概率分布。再通过当前观测到的位置信息推断出隐藏的速度信息。以此方式，不断更新位置概率分布，这很关键！通过假设和一系列的位置，可以不断地推断出速度信息~~~（这是一个Bayes Rule)</p>
<h3 id="Kalman-Filter-Design"><a href="#Kalman-Filter-Design" class="headerlink" title="Kalman Filter Design"></a>Kalman Filter Design</h3><ol>
<li>状态转换函数:表示从当前状态到后一个状态的过程<br>Nx1 的新状态向量 = nxn 状态转换矩阵 * nx1 的当前状态向量<br>nxn 状态转换矩阵 被称为 F （在后续代码中）</li>
<li>测量函数<br>Z = 1xn 矩阵 * nx1状态向量<br>这里的 1xn矩阵被称为 H（在后续代码中）</li>
<li><p>卡尔曼滤波器的实际更新方程<br>下面讲一些代码中会出现的相关变量名的含义：</p>
<blockquote>
<p>x  估计值<br>P 不确定性协方差矩阵<br>F 状态转换矩阵<br>u 移动向量<br>Z 测量值<br>H 测量方程<br>R  测量噪声<br>K 卡尔曼增益<br>I   单位矩阵</p>
</blockquote>
</li>
</ol>
<p>   预测(prediction)过程：</p>
<pre><code>   x’ = F*x + u               预测新的x值

   p’ = F*P*FT                预测新的P值，其中FT表示F的转置矩阵
</code></pre><p>   测量更新过程（measurementupdate）：</p>
<pre><code>   y = Z – H*x                  y表示误差（error）

   S = H*P*HT + R               y被映射到S中

   K = P*HT*S-1                 K通常被称为卡尔曼增益，S-1 是S的反转矩阵

   x’ = x + (K * y)

   p’ = (I – K*H)*P
</code></pre><p>一维空间的运动估计，其中state包含位置和速度，是一个二维变量。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write a function 'kalman_filter' that implements a multi-</span></span><br><span class="line"><span class="comment"># dimensional Kalman Filter for the example given</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义，实现矩阵的各种操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">matrix</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># implements basic operations of a matrix class</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.dimx = len(value)</span><br><span class="line">        self.dimy = len(value[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> value == [[]]:</span><br><span class="line">            <span class="comment"># (1, 0)</span></span><br><span class="line">            self.dimx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero</span><span class="params">(self, dimx, dimy)</span>:</span></span><br><span class="line">        <span class="comment"># check if valid dimensions</span></span><br><span class="line">        <span class="keyword">if</span> dimx &lt; <span class="number">1</span> <span class="keyword">or</span> dimy &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Invalid sizeof matrix"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dimx = dimx</span><br><span class="line">            self.dimy = dimy</span><br><span class="line">            self.value = [[<span class="number">0</span> <span class="keyword">for</span> row <span class="keyword">in</span> range(dimy)] <span class="keyword">for</span> col <span class="keyword">in</span> range(dimx)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">identity</span><span class="params">(self, dim)</span>:</span></span><br><span class="line">        <span class="comment"># check if valid dimension</span></span><br><span class="line">        <span class="keyword">if</span> dim &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Invalid sizeof matrix"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dimx = dim</span><br><span class="line">            self.dimy = dim</span><br><span class="line">            self.value = [[<span class="number">0</span> <span class="keyword">for</span> row <span class="keyword">in</span> range(dim)] <span class="keyword">for</span> col <span class="keyword">in</span> range(dim)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(dim):</span><br><span class="line">                self.value[i][i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.dimx):</span><br><span class="line">            print(self.value[i])</span><br><span class="line">        print(<span class="string">' '</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># check if correct dimensions</span></span><br><span class="line">        <span class="keyword">if</span> self.dimx != other.dimx <span class="keyword">or</span> self.dimy != other.dimy:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Matrices must be of equal dimensions to add"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># add if correct dimensions</span></span><br><span class="line">            res = matrix([[]])</span><br><span class="line">            res.zero(self.dimx, self.dimy)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.dimx):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(self.dimy):</span><br><span class="line">                    res.value[i][j] = self.value[i][j] + other.value[i][j]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># check if correct dimensions</span></span><br><span class="line">        <span class="keyword">if</span> self.dimx != other.dimx <span class="keyword">or</span> self.dimy != other.dimy:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Matrices must be of equal dimensions to subtract"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># subtract if correct dimensions</span></span><br><span class="line">            res = matrix([[]])</span><br><span class="line">            res.zero(self.dimx, self.dimy)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.dimx):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(self.dimy):</span><br><span class="line">                    res.value[i][j] = self.value[i][j] - other.value[i][j]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># check if correct dimensions</span></span><br><span class="line">        <span class="keyword">if</span> self.dimy != other.dimx:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Matrices must be m*n and n*p to multiply"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># multiply if correct dimensions</span></span><br><span class="line">            res = matrix([[]])</span><br><span class="line">            res.zero(self.dimx, other.dimy)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.dimx):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(other.dimy):</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(self.dimy):</span><br><span class="line">                        res.value[i][j] += self.value[i][k] * other.value[k][j]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># compute transpose</span></span><br><span class="line">        res = matrix([[]])</span><br><span class="line">        res.zero(self.dimy, self.dimx)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.dimx):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.dimy):</span><br><span class="line">                res.value[j][i] = self.value[i][j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Thanks to Ernesto P. Adorio for use of Cholesky and CholeskyInverse functions</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Cholesky</span><span class="params">(self, ztol=<span class="number">1.0e-5</span>)</span>:</span></span><br><span class="line">        <span class="comment"># Computes the upper triangular Cholesky factorization of</span></span><br><span class="line">        <span class="comment"># a positive definite matrix.</span></span><br><span class="line">        res = matrix([[]])</span><br><span class="line">        res.zero(self.dimx, self.dimx)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.dimx):</span><br><span class="line">            S = sum([(res.value[k][i])**<span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(i)])</span><br><span class="line">            d = self.value[i][i] - S</span><br><span class="line">            <span class="keyword">if</span> abs(d) &lt; ztol:</span><br><span class="line">                res.value[i][i] = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> d &lt; <span class="number">0.0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">"Matrix not positive-definite"</span>)</span><br><span class="line">                res.value[i][i] = sqrt(d)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, self.dimx):</span><br><span class="line">                S = sum([res.value[k][i] * res.value[k][j] <span class="keyword">for</span> k <span class="keyword">in</span> range(self.dimx)])</span><br><span class="line">                <span class="keyword">if</span> abs(S) &lt; ztol:</span><br><span class="line">                    S = <span class="number">0.0</span></span><br><span class="line">                res.value[i][j] = (self.value[i][j] - S)/res.value[i][i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CholeskyInverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Computes inverse of matrix given its Cholesky upper Triangular</span></span><br><span class="line">        <span class="comment"># decomposition of matrix.</span></span><br><span class="line">        res = matrix([[]])</span><br><span class="line">        res.zero(self.dimx, self.dimx)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Backward step for inverse.</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(self.dimx)):</span><br><span class="line">            tjj = self.value[j][j]</span><br><span class="line">            S = sum([self.value[j][k]*res.value[j][k] <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, self.dimx)])</span><br><span class="line">            res.value[j][j] = <span class="number">1.0</span>/tjj**<span class="number">2</span> - S/tjj</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(j)):</span><br><span class="line">                res.value[j][i] = res.value[i][j] = -sum([self.value[i][k]*res.value[k][j] <span class="keyword">for</span> k <span class="keyword">in</span> range(i+<span class="number">1</span>, self.dimx)])/self.value[i][i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        aux = self.Cholesky()</span><br><span class="line">        res = aux.CholeskyInverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self.value)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Implement the filter function below</span></span><br><span class="line"><span class="comment"># 用均值x 和 协方差P 描述分布的情况，迭代就是不断地更新这两个量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kalman_filter</span><span class="params">(x, P)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(measurements)):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># measurement update</span></span><br><span class="line">        Z = matrix([[measurements[n]]])</span><br><span class="line">        y = Z - (H * x)  <span class="comment"># error</span></span><br><span class="line">        S = H * P * H.transpose() + R</span><br><span class="line">        K = P * H.transpose() * S.inverse()</span><br><span class="line">        </span><br><span class="line">        x = x + (K * y)</span><br><span class="line">        P = (I - (K * H)) * P</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># prediction</span></span><br><span class="line">        x = F * x + u</span><br><span class="line">        P = F * P * F.transpose()</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">'x= '</span>)</span><br><span class="line">        x.show()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'P= '</span>)</span><br><span class="line">        P.show()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> x,P</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># use the code below to test your filter!</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">measurements = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># Z</span></span><br><span class="line"> </span><br><span class="line">x = matrix([[<span class="number">0.</span>], [<span class="number">0.</span>]]) <span class="comment"># initial state (location and velocity)            # estimate</span></span><br><span class="line">P = matrix([[<span class="number">1000.</span>, <span class="number">0.</span>], [<span class="number">0.</span>, <span class="number">1000.</span>]]) <span class="comment"># initial uncertainty 协方差矩阵     # uncertainty convariance</span></span><br><span class="line"><span class="comment"># 计算下一时刻 状态state 的prediction需要的变量</span></span><br><span class="line">u = matrix([[<span class="number">0.</span>], [<span class="number">0.</span>]]) <span class="comment"># external motion                # motion vector</span></span><br><span class="line">F = matrix([[<span class="number">1.</span>, <span class="number">1.</span>], [<span class="number">0</span>, <span class="number">1.</span>]]) <span class="comment"># next state function     # state transition matrix</span></span><br><span class="line"><span class="comment"># 计算 measurement update需要的变量</span></span><br><span class="line">H = matrix([[<span class="number">1.</span>, <span class="number">0.</span>]])                                    <span class="comment"># measurement function 取x轴坐标值</span></span><br><span class="line">R = matrix([[<span class="number">1.</span>]]) <span class="comment"># measurement uncertainty              # measurement noise方差</span></span><br><span class="line"> </span><br><span class="line">I = matrix([[<span class="number">1.</span>, <span class="number">0.</span>], [<span class="number">0.</span>, <span class="number">1.</span>]]) <span class="comment"># identity matrix</span></span><br><span class="line"> </span><br><span class="line">print(kalman_filter(x, P))</span><br><span class="line"></span><br><span class="line">x= </span><br><span class="line"><span class="comment"># [0.9990009990009988]</span></span><br><span class="line"><span class="comment"># [0.0]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># P= </span></span><br><span class="line"><span class="comment"># [1000.9990009990012, 1000.0]</span></span><br><span class="line"><span class="comment"># [1000.0, 1000.0]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># x= </span></span><br><span class="line"><span class="comment"># [2.998002993017953]</span></span><br><span class="line"><span class="comment"># [0.9990019950129659]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># P= </span></span><br><span class="line"><span class="comment"># [4.990024935169789, 2.9930179531228447]</span></span><br><span class="line"><span class="comment"># [2.9930179531228305, 1.9950129660888933]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># x= </span></span><br><span class="line"><span class="comment"># [3.9996664447958645]</span></span><br><span class="line"><span class="comment"># [0.9999998335552873]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># P= </span></span><br><span class="line"><span class="comment"># [2.3318904241194827, 0.9991676099921091]</span></span><br><span class="line"><span class="comment"># [0.9991676099921067, 0.49950058263974184]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># ([[3.9996664447958645], [0.9999998335552873]], [[2.3318904241194827, 0.9991676099921091], [0.9991676099921067, 0.49950058263974184]])</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上的情况是一维空间，在Google自动驾驶车中，用的是二维空间，有x,y的位置及其速度，相应的，状态转移矩阵也就变成4*4了。<br>【注：感觉Kalman filter的精华在于引入了速度，对物体state进行了预先prediction，再结合实际measure到的位置，确定state，在这个过程中，间接求得了速度】</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>扩展到2D的程序，很小的改动。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"### 4-dimensional example ###"</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(x, P)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(measurements)):</span><br><span class="line">        <span class="comment"># 注意 这里改变了顺序，先预测，再measurement</span></span><br><span class="line">        <span class="comment"># prediction</span></span><br><span class="line">        x = (F * x) + u</span><br><span class="line">        P = F * P * F.transpose()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># measurement update</span></span><br><span class="line">        Z = matrix([measurements[n]])</span><br><span class="line">        y = Z.transpose() - (H * x)</span><br><span class="line">        S = H * P * H.transpose() + R</span><br><span class="line">        K = P * H.transpose() * S.inverse()</span><br><span class="line">        x = x + (K * y)</span><br><span class="line">        P = (I - (K * H)) * P</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'x= '</span>) </span><br><span class="line">    x.show()</span><br><span class="line">    print(<span class="string">'P= '</span>)</span><br><span class="line">    P.show()</span><br><span class="line"> </span><br><span class="line">measurements = [[<span class="number">5.</span>, <span class="number">10.</span>], </span><br><span class="line">                [<span class="number">6.</span>, <span class="number">8.</span>], </span><br><span class="line">                [<span class="number">7.</span>, <span class="number">6.</span>], </span><br><span class="line">                [<span class="number">8.</span>, <span class="number">4.</span>], </span><br><span class="line">                [<span class="number">9.</span>, <span class="number">2.</span>], </span><br><span class="line">                [<span class="number">10.</span>, <span class="number">0.</span>]]</span><br><span class="line">initial_xy = [<span class="number">4.</span>, <span class="number">12.</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># measurements = [[1., 4.], </span></span><br><span class="line"><span class="comment">#                 [6., 0.], </span></span><br><span class="line"><span class="comment">#                 [11., -4.], </span></span><br><span class="line"><span class="comment">#                 [16., -8.]]</span></span><br><span class="line"><span class="comment"># initial_xy = [-4., 8.]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># measurements = [[1., 17.], </span></span><br><span class="line"><span class="comment">#                 [1., 15.], </span></span><br><span class="line"><span class="comment">#                 [1., 13.], </span></span><br><span class="line"><span class="comment">#                 [1., 11.]]</span></span><br><span class="line"><span class="comment"># initial_xy = [1., 19.]</span></span><br><span class="line"> </span><br><span class="line">dt = <span class="number">0.1</span></span><br><span class="line"> </span><br><span class="line">x = matrix([[initial_xy[<span class="number">0</span>]], [initial_xy[<span class="number">1</span>]], [<span class="number">0.</span>], [<span class="number">0.</span>]]) <span class="comment"># initial state (location and velocity)</span></span><br><span class="line">u = matrix([[<span class="number">0.</span>], [<span class="number">0.</span>], [<span class="number">0.</span>], [<span class="number">0.</span>]]) <span class="comment"># external motion</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#### fill this in, remember to use the matrix() function!: ####</span></span><br><span class="line"> </span><br><span class="line">P =  matrix([[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1000.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1000.</span>]]) <span class="comment"># initial uncertainty: 0 for positions x and y, 1000 for the two velocities</span></span><br><span class="line">F =  matrix([[<span class="number">1.</span>,<span class="number">0.</span>,dt,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">0.</span>,dt],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1.</span>]])   <span class="comment"># next state function: generalize the 2d version to 4d</span></span><br><span class="line">H =  matrix([[<span class="number">1.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">0.</span>,<span class="number">0.</span>]])   <span class="comment"># measurement function: reflect the fact that we observe x and y but not the two velocities</span></span><br><span class="line">R =  matrix([[<span class="number">0.1</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.1</span>]])        <span class="comment"># measurement uncertainty: use 2x2 matrix with 0.1 as main diagonal</span></span><br><span class="line">I =  matrix([[<span class="number">1.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">0.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">0.</span>],</span><br><span class="line">             [<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1.</span>]])   <span class="comment"># 4d identity matrix</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">###### DO NOT MODIFY ANYTHING HERE #######</span></span><br><span class="line"> </span><br><span class="line">filter(x, P)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">### <span class="number">4</span>-dimensional example ###</span><br><span class="line">x= </span><br><span class="line">[<span class="number">9.999340731787717</span>]</span><br><span class="line">[<span class="number">0.001318536424568617</span>]</span><br><span class="line">[<span class="number">9.998901219646193</span>]</span><br><span class="line">[<span class="number">-19.997802439292386</span>]</span><br><span class="line"> </span><br><span class="line">P= </span><br><span class="line">[<span class="number">0.03955609273706198</span>, <span class="number">0.0</span>, <span class="number">0.06592682122843721</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.03955609273706198</span>, <span class="number">0.0</span>, <span class="number">0.06592682122843721</span>]</span><br><span class="line">[<span class="number">0.06592682122843718</span>, <span class="number">0.0</span>, <span class="number">0.10987803538073201</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.06592682122843718</span>, <span class="number">0.0</span>, <span class="number">0.10987803538073201</span>]</span><br></pre></td></tr></table></figure>
<p>关于motion vecter u 的含义：有可能车辆不是匀速运动，而是有一个加速度。</p>
<p>关于measurement noise R 的含义：对位置测量的准确性。</p>
]]></content>
      <categories>
        <category>滤波算法</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习练习 6 - 支持向量机</title>
    <url>/2019/03/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%83%E4%B9%A0-6-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在本练习中，我们将使用支持向量机（SVM）来构建垃圾邮件分类器。 我们将从一些简单的2D数据集开始使用SVM来查看它们的工作原理。 然后，我们将对一组原始电子邮件进行一些预处理工作，并使用SVM在处理的电子邮件上构建分类器，以确定它们是否为垃圾邮件。</p><h1 id="6-Support-Vector-Machines"><a href="#6-Support-Vector-Machines" class="headerlink" title="6 Support Vector Machines"></a>6 Support Vector Machines</h1><h2 id="6-1-Linear-SVM"><a href="#6-1-Linear-SVM" class="headerlink" title="6.1 Linear SVM"></a>6.1 Linear SVM</h2><a id="more"></a>
<h3 id="6-1-1-load-data"><a href="#6-1-1-load-data" class="headerlink" title="6.1.1 load data"></a>6.1.1 load data</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">raw_data = loadmat(<span class="string">'data/ex6data1.mat'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-1-2-visualize-data"><a href="#6-1-2-visualize-data" class="headerlink" title="6.1.2 visualize data"></a>6.1.2 visualize data</h3><p>我们将其用散点图表示，其中类标签由符号表示（+表示正类，o表示负类）。.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(raw_data[<span class="string">'X'</span>], columns=[<span class="string">'X1'</span>, <span class="string">'X2'</span>])</span><br><span class="line">data[<span class="string">'y'</span>] = raw_data[<span class="string">'y'</span>]</span><br><span class="line"></span><br><span class="line">positive = data[data[<span class="string">'y'</span>].isin([<span class="number">1</span>])]</span><br><span class="line">negative = data[data[<span class="string">'y'</span>].isin([<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax.scatter(positive[<span class="string">'X1'</span>], positive[<span class="string">'X2'</span>], s=<span class="number">50</span>, marker=<span class="string">'x'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">ax.scatter(negative[<span class="string">'X1'</span>], negative[<span class="string">'X2'</span>], s=<span class="number">50</span>, marker=<span class="string">'o'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>   <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190323110554887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>有一个异常的正例在其他样本之外。 这些类仍然是线性分离的，但它非常紧凑。 我们要训练线性支持向量机来学习类边界。 在这个练习中，我们没有从头开始执行SVM的任务，所以我要用scikit-learn。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#画决策边界    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBoundary</span><span class="params">(clf,data)</span>:</span></span><br><span class="line">x_min,x_max=np.array(data[<span class="string">'X1'</span>]).min(),np.array(data[<span class="string">'X1'</span>]).max()</span><br><span class="line">y_min,y_max=np.array(data[<span class="string">'X2'</span>]).min(),np.array(data[<span class="string">'X2'</span>]).max()</span><br><span class="line">xx,yy=np.meshgrid(np.linspace(x_min,x_max,<span class="number">500</span>),np.linspace(y_min,y_max,<span class="number">500</span>))</span><br><span class="line">Z=clf.predict(np.c_[xx.ravel(),yy.ravel()])</span><br><span class="line">Z=Z.reshape(xx.shape)</span><br><span class="line">plt.contour(xx,yy,Z,colors = <span class="string">'red'</span>, linewidth = <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-C-1"><a href="#6-1-3-C-1" class="headerlink" title="6.1.3 C=1"></a>6.1.3 C=1</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">svc1 = svm.LinearSVC(C=<span class="number">1</span>, loss=<span class="string">'hinge'</span>, max_iter=<span class="number">1000</span>)</span><br><span class="line">clfs1=svc1.fit(data[[<span class="string">'X1'</span>, <span class="string">'X2'</span>]], data[<span class="string">'y'</span>])</span><br><span class="line">svc1.score(data[[<span class="string">'X1'</span>, <span class="string">'X2'</span>]], data[<span class="string">'y'</span>])  <span class="comment">#0.9803921568627451</span></span><br></pre></td></tr></table></figure>
<p>这次我们得到了训练数据的完美分类，但是通过增加C的值，我们创建了一个不再适合数据的决策边界。 我们可以通过查看每个类别预测的置信水平来看出这一点，这是该点与超平面距离的函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'SVM 1 Confidence'</span>] = svc1.decision_function(data[[<span class="string">'X1'</span>, <span class="string">'X2'</span>]])</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax.scatter(data[<span class="string">'X1'</span>], data[<span class="string">'X2'</span>], s=<span class="number">50</span>, c=data[<span class="string">'SVM 1 Confidence'</span>],cmap=<span class="string">'rainbow'</span>)</span><br><span class="line">plotBoundary(clfs1,data) </span><br><span class="line">ax.set_title(<span class="string">'SVM (C=1) Decision Confidence'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>  <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190323110822281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h3 id="6-1-4-C-100"><a href="#6-1-4-C-100" class="headerlink" title="6.1.4 C=100"></a>6.1.4 C=100</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'SVM 2 Confidence'</span>] = svc2.decision_function(data[[<span class="string">'X1'</span>, <span class="string">'X2'</span>]])</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax.scatter(data[<span class="string">'X1'</span>], data[<span class="string">'X2'</span>], s=<span class="number">50</span>, c=data[<span class="string">'SVM 2 Confidence'</span>], cmap=<span class="string">'rainbow'</span>)</span><br><span class="line">plotBoundary(clfs2,data)</span><br><span class="line">ax.set_title(<span class="string">'SVM (C=100) Decision Confidence'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>  <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190323110835695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="6-2-SVM-with-Gaussian-Kernels"><a href="#6-2-SVM-with-Gaussian-Kernels" class="headerlink" title="6.2 SVM with Gaussian Kernels"></a>6.2 SVM with Gaussian Kernels</h2><p>使用SVM做非线性分类。我们将使用高斯核函数。</p>
<p>为了用SVM找出一个非线性的决策边界，我们首先要实现高斯核函数。<br>我可以把高斯核函数想象成一个相似度函数，用来测量一对样本的距离，(x(i),y(j))<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_kernel</span><span class="params">(x1, x2, sigma)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.exp(-(np.sum((x1 - x2) ** <span class="number">2</span>) / (<span class="number">2</span> * (sigma ** <span class="number">2</span>))))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x1 = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>])</span><br><span class="line">x2 = np.array([<span class="number">0.0</span>, <span class="number">4.0</span>, <span class="number">-1.0</span>])</span><br><span class="line">sigma = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">gaussian_kernel(x1, x2, sigma)</span><br><span class="line"><span class="comment">#0.32465246735834974</span></span><br></pre></td></tr></table></figure>
<p>该结果与练习中的预期值相符。 接下来，我们将检查另一个数据集，这次用非线性决策边界。</p>
<h3 id="6-2-1-load-data"><a href="#6-2-1-load-data" class="headerlink" title="6.2.1 load data"></a>6.2.1 load data</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">raw_data2 = loadmat(<span class="string">'data/ex6data2.mat'</span>)</span><br><span class="line">data2 = pd.DataFrame(raw_data2[<span class="string">'X'</span>], columns=[<span class="string">'X1'</span>, <span class="string">'X2'</span>])</span><br><span class="line">data2[<span class="string">'y'</span>] = raw_data2[<span class="string">'y'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-visualize-data"><a href="#6-2-2-visualize-data" class="headerlink" title="6.2.2 visualize data"></a>6.2.2 visualize data</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">positive = data2[data2[<span class="string">'y'</span>].isin([<span class="number">1</span>])]</span><br><span class="line">negative = data2[data2[<span class="string">'y'</span>].isin([<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax.scatter(positive[<span class="string">'X1'</span>], positive[<span class="string">'X2'</span>], s=<span class="number">30</span>, marker=<span class="string">'x'</span>, label=<span class="string">'Positive'</span>)</span><br><span class="line">ax.scatter(negative[<span class="string">'X1'</span>], negative[<span class="string">'X2'</span>], s=<span class="number">30</span>, marker=<span class="string">'o'</span>, label=<span class="string">'Negative'</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190323111138425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>对于该数据集，我们将使用内置的RBF内核构建支持向量机分类器，并检查其对训练数据的准确性。 为了可视化决策边界，这一次我们将根据实例具有负类标签的预测概率来对点做阴影。 从结果可以看出，它们大部分是正确的。</p>
<h3 id="6-2-3-try-built-in-Gaussian-Kernel-of-sklearn"><a href="#6-2-3-try-built-in-Gaussian-Kernel-of-sklearn" class="headerlink" title="6.2.3 try built-in Gaussian Kernel of sklearn"></a>6.2.3 try built-in Gaussian Kernel of sklearn</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">svc3 = svm.SVC(C=<span class="number">100</span>, gamma=<span class="number">10</span>, probability=<span class="literal">True</span>)</span><br><span class="line">svc3</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">SVC(C=100, cache_size=200, class_weight=None, coef0=0.0,</span></span><br><span class="line"><span class="string">  decision_function_shape='ovr', degree=3, gamma=10, kernel='rbf',</span></span><br><span class="line"><span class="string">  max_iter=-1, probability=True, random_state=None, shrinking=True,</span></span><br><span class="line"><span class="string">  tol=0.001, verbose=False)'''</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">clfs3=svc3.fit(data2[[<span class="string">'X1'</span>, <span class="string">'X2'</span>]], data2[<span class="string">'y'</span>])</span><br><span class="line">svc3.score(data2[[<span class="string">'X1'</span>, <span class="string">'X2'</span>]], data2[<span class="string">'y'</span>])</span><br><span class="line"><span class="comment">#0.9698725376593279</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data2[<span class="string">'Probability'</span>] = svc3.predict_proba(data2[[<span class="string">'X1'</span>, <span class="string">'X2'</span>]])[:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">fig, ax2 = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax2.scatter(data2[<span class="string">'X1'</span>], data2[<span class="string">'X2'</span>], s=<span class="number">30</span>, c=data2[<span class="string">'Probability'</span>])</span><br><span class="line">plotBoundary(clfs3,data2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190323111148827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="6-3-寻找最优参数"><a href="#6-3-寻找最优参数" class="headerlink" title="6.3 寻找最优参数"></a>6.3 寻找最优参数</h2><p>对于第三个数据集，我们给出了训练和验证集，并且基于验证集性能为SVM模型找到最优超参数。 虽然我们可以使用scikit-learn的内置网格搜索来做到这一点，但是本着遵循练习的目的，我们将从头开始实现一个简单的网格搜索</p>
<h3 id="6-3-1-load-data"><a href="#6-3-1-load-data" class="headerlink" title="6.3.1 load data"></a>6.3.1 load data</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">raw_data = loadmat(<span class="string">'data/ex6data3.mat'</span>)</span><br><span class="line"></span><br><span class="line">X = raw_data[<span class="string">'X'</span>]</span><br><span class="line">Xval = raw_data[<span class="string">'Xval'</span>]</span><br><span class="line">y = raw_data[<span class="string">'y'</span>].ravel()</span><br><span class="line">yval = raw_data[<span class="string">'yval'</span>].ravel()</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-manual-grid-search-for-and-σ"><a href="#6-3-2-manual-grid-search-for-and-σ" class="headerlink" title="6.3.2 manual grid search for ? and σ"></a>6.3.2 manual grid search for ? and σ</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">C_values = [<span class="number">0.01</span>, <span class="number">0.03</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">100</span>]</span><br><span class="line">gamma_values = [<span class="number">0.01</span>, <span class="number">0.03</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">best_score = <span class="number">0</span></span><br><span class="line">best_params = &#123;<span class="string">'C'</span>: <span class="literal">None</span>, <span class="string">'gamma'</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> C <span class="keyword">in</span> C_values:</span><br><span class="line">    <span class="keyword">for</span> gamma <span class="keyword">in</span> gamma_values:</span><br><span class="line">        svc = svm.SVC(C=C, gamma=gamma)</span><br><span class="line">        svc.fit(X, y)</span><br><span class="line">        score = svc.score(Xval, yval)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_score = score</span><br><span class="line">            best_params[<span class="string">'C'</span>] = C</span><br><span class="line">            best_params[<span class="string">'gamma'</span>] = gamma</span><br><span class="line"></span><br><span class="line">best_score, best_params</span><br><span class="line"><span class="comment">#    (0.965, &#123;'C': 0.3, 'gamma': 100&#125;)</span></span><br></pre></td></tr></table></figure>
<p>我们的目标是使用SVM来构建垃圾邮件过滤器。 在练习文本中，有一个任务涉及一些文本预处理，以获得适合SVM处理的格式的数据。 然而，这个任务很简单（将字词映射到为练习提供的字典中的ID），而其余的预处理步骤（如HTML删除，词干，标准化等）已经完成。 我将跳过机器学习任务，而不是重现这些预处理步骤，其中包括从预处理过的训练集构建分类器，以及将垃圾邮件和非垃圾邮件转换为单词出现次数的向量的测试数据集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">spam_train = loadmat(<span class="string">'data/spamTrain.mat'</span>)</span><br><span class="line">spam_test = loadmat(<span class="string">'data/spamTest.mat'</span>)</span><br><span class="line"></span><br><span class="line">spam_train</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'__header__'</span>: <span class="string">b'MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Nov 13 14:27:25 2011'</span>,</span><br><span class="line"> <span class="string">'__version__'</span>: <span class="string">'1.0'</span>,</span><br><span class="line"> <span class="string">'__globals__'</span>: [],</span><br><span class="line"> <span class="string">'X'</span>: array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        ...,</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8),</span><br><span class="line"> <span class="string">'y'</span>: array([[<span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>],</span><br><span class="line">        ...,</span><br><span class="line">        [<span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>]], dtype=uint8)&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">X = spam_train[<span class="string">'X'</span>]</span><br><span class="line">Xtest = spam_test[<span class="string">'Xtest'</span>]</span><br><span class="line">y = spam_train[<span class="string">'y'</span>].ravel()</span><br><span class="line">ytest = spam_test[<span class="string">'ytest'</span>].ravel()</span><br><span class="line"></span><br><span class="line">X.shape, y.shape, Xtest.shape, ytest.shape</span><br><span class="line"><span class="comment">#   ((4000, 1899), (4000,), (1000, 1899), (1000,))</span></span><br></pre></td></tr></table></figure>
<p>每个文档已经转换为一个向量，其中1,899个维对应于词汇表中的1,899个单词。 它们的值为二进制，表示文档中是否存在单词。 在这一点上，训练评估是用一个分类器拟合测试数据的问题。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">svc = svm.SVC()</span><br><span class="line">svc.fit(X, y)</span><br><span class="line">print(<span class="string">'Training accuracy = &#123;0&#125;%'</span>.format(np.round(svc.score(X, y) * <span class="number">100</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># Training accuracy = 94.4%</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Test accuracy = &#123;0&#125;%'</span>.format(np.round(svc.score(Xtest, ytest) * <span class="number">100</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># Test accuracy = 95.3%</span></span><br></pre></td></tr></table></figure>
<p>这个结果是使用使用默认参数的。 我们可能会使用一些参数调整来获得更高的精度</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
</search>
