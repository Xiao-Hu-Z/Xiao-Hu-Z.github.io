<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ORB-SLAM2——Tracking</title>
    <url>/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94Tracking/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAM2——系统入口System</title>
    <url>/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E5%85%A5%E5%8F%A3System/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191104191938848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">
 </p><p>在主函数中，我们创建了一个ORB_SLAM2::System的对象SLAM，这个时候就会进入到SLAM系统的主接口System.cc。这个代码是所有调用SLAM系统的主入口。</p><h1 id="system-h"><a href="#system-h" class="headerlink" title="system.h"></a>system.h</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Input sensor</span></span><br><span class="line">    <span class="keyword">enum</span> eSensor&#123;</span><br><span class="line">        MONOCULAR=<span class="number">0</span>,</span><br><span class="line">        STEREO=<span class="number">1</span>,</span><br><span class="line">        RGBD=<span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the SLAM system. It launches the Local Mapping, Loop Closing and Viewer threads.</span></span><br><span class="line">    System(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strVocFile, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingsFile, <span class="keyword">const</span> eSensor sensor, <span class="keyword">const</span> <span class="keyword">bool</span> bUseViewer = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracking函数:输出相机位姿</span></span><br><span class="line">    <span class="comment">// Proccess the given stereo frame. Images must be synchronized and rectified.</span></span><br><span class="line">    <span class="comment">// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line">    <span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">    cv::<span class="function">Mat <span class="title">TrackStereo</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;imLeft, <span class="keyword">const</span> cv::Mat &amp;imRight, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process the given rgbd frame. Depthmap must be registered to the RGB frame.</span></span><br><span class="line">    <span class="comment">// Input image: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line">    <span class="comment">// Input depthmap: Float (CV_32F).</span></span><br><span class="line">    <span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">    cv::<span class="function">Mat <span class="title">TrackRGBD</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> cv::Mat &amp;depthmap, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proccess the given monocular frame</span></span><br><span class="line">    <span class="comment">// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line">    <span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">    cv::<span class="function">Mat <span class="title">TrackMonocular</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This stops local mapping thread (map building) and performs only camera tracking.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ActivateLocalizationMode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// This resumes local mapping thread and performs SLAM again.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeactivateLocalizationMode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if there have been a big map change (loop closure, global BA)</span></span><br><span class="line">    <span class="comment">// since last call to this function</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">MapChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the system (clear map)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All threads will be requested to finish.</span></span><br><span class="line">    <span class="comment">// It waits until all threads have finished.</span></span><br><span class="line">    <span class="comment">// This function must be called before saving the trajectory.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save camera trajectory in the TUM RGB-D dataset format.</span></span><br><span class="line">    <span class="comment">// Only for stereo and RGB-D. This method does not work for monocular.</span></span><br><span class="line">    <span class="comment">// Call first Shutdown()</span></span><br><span class="line">    <span class="comment">// See format details at: http://vision.in.tum.de/data/datasets/rgbd-dataset</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveTrajectoryTUM</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save keyframe poses in the TUM RGB-D dataset format.</span></span><br><span class="line">    <span class="comment">// This method works for all sensor input.</span></span><br><span class="line">    <span class="comment">// Call first Shutdown()</span></span><br><span class="line">    <span class="comment">// See format details at: http://vision.in.tum.de/data/datasets/rgbd-dataset</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveKeyFrameTrajectoryTUM</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save camera trajectory in the KITTI dataset format.</span></span><br><span class="line">    <span class="comment">// Only for stereo and RGB-D. This method does not work for monocular.</span></span><br><span class="line">    <span class="comment">// Call first Shutdown()</span></span><br><span class="line">    <span class="comment">// See format details at: http://www.cvlibs.net/datasets/kitti/eval_odometry.php</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveTrajectoryKITTI</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Save/Load functions</span></span><br><span class="line">    <span class="comment">// SaveMap(const string &amp;filename);</span></span><br><span class="line">    <span class="comment">// LoadMap(const string &amp;filename);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Information from most recent processed frame</span></span><br><span class="line">    <span class="comment">// You can call this right after TrackMonocular (or stereo or RGBD)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTrackingState</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MapPoint*&gt; GetTrackedMapPoints();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::KeyPoint&gt; GetTrackedKeyPointsUn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Input sensor</span></span><br><span class="line">    eSensor mSensor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ORB vocabulary used for place recognition and feature matching.</span></span><br><span class="line">    ORBVocabulary* mpVocabulary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KeyFrame database for place recognition (relocalization and loop detection).</span></span><br><span class="line">    KeyFrameDatabase* mpKeyFrameDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map structure that stores the pointers to all KeyFrames and MapPoints.</span></span><br><span class="line">    Map* mpMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracker. It receives a frame and computes the associated camera pose.</span></span><br><span class="line">    <span class="comment">// It also decides when to insert a new keyframe, create some new MapPoints and</span></span><br><span class="line">    <span class="comment">// performs relocalization if tracking fails.</span></span><br><span class="line">    Tracking* mpTracker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local Mapper. It manages the local map and performs local bundle adjustment.</span></span><br><span class="line">    LocalMapping* mpLocalMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop Closer. It searches loops with every new keyframe. If there is a loop it performs</span></span><br><span class="line">    <span class="comment">// a pose graph optimization and full bundle adjustment (in a new thread) afterwards.</span></span><br><span class="line">    LoopClosing* mpLoopCloser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The viewer draws the map and the current camera pose. It uses Pangolin.</span></span><br><span class="line">    Viewer* mpViewer;</span><br><span class="line"></span><br><span class="line">    FrameDrawer* mpFrameDrawer;</span><br><span class="line">    MapDrawer* mpMapDrawer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// System threads: Local Mapping, Loop Closing, Viewer.</span></span><br><span class="line">    <span class="comment">// The Tracking thread "lives" in the main execution thread that creates the System object.</span></span><br><span class="line">    <span class="built_in">std</span>::thread* mptLocalMapping;</span><br><span class="line">    <span class="built_in">std</span>::thread* mptLoopClosing;</span><br><span class="line">    <span class="built_in">std</span>::thread* mptViewer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset flag</span></span><br><span class="line">    <span class="built_in">std</span>::mutex mMutexReset;</span><br><span class="line">    <span class="keyword">bool</span> mbReset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change mode flags</span></span><br><span class="line">    <span class="built_in">std</span>::mutex mMutexMode;</span><br><span class="line">    <span class="keyword">bool</span> mbActivateLocalizationMode;</span><br><span class="line">    <span class="keyword">bool</span> mbDeactivateLocalizationMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracking state</span></span><br><span class="line">    <span class="keyword">int</span> mTrackingState;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MapPoint*&gt; mTrackedMapPoints;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::KeyPoint&gt; mTrackedKeyPointsUn;</span><br><span class="line">    <span class="built_in">std</span>::mutex mMutexState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="构造函数ORB-SLAM2-System"><a href="#构造函数ORB-SLAM2-System" class="headerlink" title="构造函数ORB_SLAM2::System"></a>构造函数ORB_SLAM2::System</h1><blockquote>
<ol>
<li>系统参数设置文件读取</li>
<li>ORB词袋文件读取(txt)</li>
<li>创建关键帧数据库mpKeyFrameDatabase</li>
<li>创建地图对象mpMap</li>
<li>创建两个显示窗口mpFrameDrawer， mpMapDrawer</li>
<li>初始化Tracking对象mpTracker</li>
<li>初始化Local Mapping对象mpLocalMapper并发布Local Mapping线程mptLocalMapping       </li>
<li>初始化Loop Closing对象mpLoopCloser，并开启线程运行mptLoopClosing</li>
<li>初始化窗口，开启线程显示图像和地图点                    </li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//创建ORB_SLAM系统对象</span></span><br><span class="line">    <span class="comment">//ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::STEREO,true);</span></span><br><span class="line">System::System(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strVocFile, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingsFile, <span class="keyword">const</span> eSensor sensor,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">bool</span> bUseViewer):mSensor(sensor), mpViewer(<span class="keyword">static_cast</span>&lt;Viewer*&gt;(<span class="literal">NULL</span>)), mbReset(<span class="literal">false</span>),mbActivateLocalizationMode(<span class="literal">false</span>),</span><br><span class="line">        mbDeactivateLocalizationMode(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Output welcome message</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">    <span class="string">"ORB-SLAM2 Copyright (C) 2014-2016 Raul Mur-Artal, University of Zaragoza."</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">    <span class="string">"This program comes with ABSOLUTELY NO WARRANTY;"</span> &lt;&lt; <span class="built_in">endl</span>  &lt;&lt;</span><br><span class="line">    <span class="string">"This is free software, and you are welcome to redistribute it"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;</span><br><span class="line">    <span class="string">"under certain conditions. See LICENSE.txt."</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input sensor was set to: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mSensor==MONOCULAR)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Monocular"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mSensor==STEREO)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stereo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mSensor==RGBD)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"RGB-D"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check settings file</span></span><br><span class="line">    <span class="comment">//1.读取参数文件，内参、帧率、基线、深度, XXX.yaml</span></span><br><span class="line">    cv::<span class="function">FileStorage <span class="title">fsSettings</span><span class="params">(strSettingsFile.c_str(), cv::FileStorage::READ)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!fsSettings.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open settings file at: "</span> &lt;&lt; strSettingsFile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Load ORB Vocabulary</span></span><br><span class="line">    <span class="comment">//2.下载ORB词袋  .txt</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Loading ORB Vocabulary. This could take a while..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    mpVocabulary = <span class="keyword">new</span> ORBVocabulary();</span><br><span class="line">    <span class="keyword">bool</span> bVocLoad = mpVocabulary-&gt;loadFromTextFile(strVocFile);</span><br><span class="line">    <span class="keyword">if</span>(!bVocLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Wrong path to vocabulary. "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Falied to open at: "</span> &lt;&lt; strVocFile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Vocabulary loaded!"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create KeyFrame Database</span></span><br><span class="line">    <span class="comment">//3.创建关键帧数据库</span></span><br><span class="line">    mpKeyFrameDatabase = <span class="keyword">new</span> KeyFrameDatabase(*mpVocabulary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create the Map</span></span><br><span class="line">    <span class="comment">//4.创建地图</span></span><br><span class="line">    mpMap = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create Drawers. These are used by the Viewer</span></span><br><span class="line">    <span class="comment">//创建两个显示窗口</span></span><br><span class="line">    mpFrameDrawer = <span class="keyword">new</span> FrameDrawer(mpMap);</span><br><span class="line">    mpMapDrawer = <span class="keyword">new</span> MapDrawer(mpMap, strSettingsFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Tracking thread</span></span><br><span class="line">    <span class="comment">//5.1初始化 Tracking</span></span><br><span class="line">    <span class="comment">//(it will live in the main thread of execution, the one that called this constructor)</span></span><br><span class="line">    mpTracker = <span class="keyword">new</span> Tracking(<span class="keyword">this</span>, mpVocabulary, mpFrameDrawer, mpMapDrawer,</span><br><span class="line">                             mpMap, mpKeyFrameDatabase, strSettingsFile, mSensor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Local Mapping thread and launch</span></span><br><span class="line">    <span class="comment">//5.2初始化并发布 Local Mapping 线程</span></span><br><span class="line">    mpLocalMapper = <span class="keyword">new</span> LocalMapping(mpMap, mSensor==MONOCULAR);</span><br><span class="line">    mptLocalMapping = <span class="keyword">new</span> thread(&amp;ORB_SLAM2::LocalMapping::Run,mpLocalMapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Loop Closing thread and launch</span></span><br><span class="line">    <span class="comment">//5.3初始化并发布 Loop Closing 线程</span></span><br><span class="line">    mpLoopCloser = <span class="keyword">new</span> LoopClosing(mpMap, mpKeyFrameDatabase, mpVocabulary, mSensor!=MONOCULAR);</span><br><span class="line">    mptLoopClosing = <span class="keyword">new</span> thread(&amp;ORB_SLAM2::LoopClosing::Run, mpLoopCloser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize the Viewer thread and launch</span></span><br><span class="line">    <span class="comment">//5.4初始化并发布 Viewer 线程</span></span><br><span class="line">    <span class="comment">//初始化窗口，开启线程显示图像和地图点</span></span><br><span class="line">    <span class="keyword">if</span>(bUseViewer)</span><br><span class="line">    &#123;</span><br><span class="line">        mpViewer = <span class="keyword">new</span> Viewer(<span class="keyword">this</span>, mpFrameDrawer,mpMapDrawer,mpTracker,strSettingsFile);</span><br><span class="line">        mptViewer = <span class="keyword">new</span> thread(&amp;Viewer::Run, mpViewer);</span><br><span class="line">        mpTracker-&gt;SetViewer(mpViewer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set pointers between threads</span></span><br><span class="line">    mpTracker-&gt;SetLocalMapper(mpLocalMapper);</span><br><span class="line">    mpTracker-&gt;SetLoopClosing(mpLoopCloser);</span><br><span class="line"></span><br><span class="line">    mpLocalMapper-&gt;SetTracker(mpTracker);</span><br><span class="line">    mpLocalMapper-&gt;SetLoopCloser(mpLoopCloser);</span><br><span class="line"></span><br><span class="line">    mpLoopCloser-&gt;SetTracker(mpTracker);</span><br><span class="line">    mpLoopCloser-&gt;SetLocalMapper(mpLocalMapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="System-TrackStereo"><a href="#System-TrackStereo" class="headerlink" title="System::TrackStereo"></a>System::TrackStereo</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat System::TrackStereo(<span class="keyword">const</span> cv::Mat &amp;imLeft, <span class="keyword">const</span> cv::Mat &amp;imRight, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mSensor!=STEREO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: you called TrackStereo but input sensor was not set to STEREO."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check mode change</span></span><br><span class="line">    &#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lock(mMutexMode);</span><br><span class="line">        <span class="keyword">if</span>(mbActivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpLocalMapper-&gt;RequestStop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until Local Mapping has effectively stopped</span></span><br><span class="line">            <span class="keyword">while</span>(!mpLocalMapper-&gt;isStopped())</span><br><span class="line">            &#123;</span><br><span class="line">                usleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">true</span>);</span><br><span class="line">            mbActivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mbDeactivateLocalizationMode)</span><br><span class="line">        &#123;</span><br><span class="line">            mpTracker-&gt;InformOnlyTracking(<span class="literal">false</span>);</span><br><span class="line">            mpLocalMapper-&gt;Release();</span><br><span class="line">            mbDeactivateLocalizationMode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check reset</span></span><br><span class="line">    &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(mMutexReset);</span><br><span class="line">    <span class="keyword">if</span>(mbReset)</span><br><span class="line">    &#123;</span><br><span class="line">        mpTracker-&gt;Reset();</span><br><span class="line">        mbReset = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat Tcw = mpTracker-&gt;GrabImageStereo(imLeft,imRight,timestamp);</span><br><span class="line"></span><br><span class="line">    unique_lock&lt;mutex&gt; lock2(mMutexState);</span><br><span class="line">    mTrackingState = mpTracker-&gt;mState;</span><br><span class="line">    mTrackedMapPoints = mpTracker-&gt;mCurrentFrame.mvpMapPoints;</span><br><span class="line">    mTrackedKeyPointsUn = mpTracker-&gt;mCurrentFrame.mvKeysUn;</span><br><span class="line">    <span class="keyword">return</span> Tcw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="System-SaveTrajectoryKITTI"><a href="#System-SaveTrajectoryKITTI" class="headerlink" title="System::SaveTrajectoryKITTI"></a>System::SaveTrajectoryKITTI</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> System::SaveTrajectoryKITTI(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Saving camera trajectory to "</span> &lt;&lt; filename &lt;&lt; <span class="string">" ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(mSensor==MONOCULAR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: SaveTrajectoryKITTI cannot be used for monocular."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;KeyFrame*&gt; vpKFs = mpMap-&gt;GetAllKeyFrames();<span class="comment">//获得所有关键帧</span></span><br><span class="line">    sort(vpKFs.begin(),vpKFs.end(),KeyFrame::lId);<span class="comment">//对关键帧排序，闭环检测后第一关键帧可能就不在起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform all keyframes so that the first keyframe is at the origin.</span></span><br><span class="line">    <span class="comment">// After a loop closure the first keyframe might not be at the origin.</span></span><br><span class="line">    cv::Mat Two = vpKFs[<span class="number">0</span>]-&gt;GetPoseInverse();<span class="comment">//获得第一帧相对于世界坐标系的位姿</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有帧</span></span><br><span class="line">    ofstream f;</span><br><span class="line">    f.open(filename.c_str());</span><br><span class="line">    f &lt;&lt; fixed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Frame pose is stored relative to its reference keyframe (which is optimized by BA and pose graph).</span></span><br><span class="line">    <span class="comment">// We need to get first the keyframe pose and then concatenate the relative transformation.</span></span><br><span class="line">    <span class="comment">// Frames not localized (tracking failure) are not saved.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each frame we have a reference keyframe (lRit), the timestamp (lT) and a flag</span></span><br><span class="line">    <span class="comment">// which is true when tracking failed (lbL).</span></span><br><span class="line">    <span class="built_in">list</span>&lt;ORB_SLAM2::KeyFrame*&gt;::iterator lRit = mpTracker-&gt;mlpReferences.begin();<span class="comment">//参考关键帧迭代器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator lT = mpTracker-&gt;mlFrameTimes.begin();<span class="comment">//时间戳迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;cv::Mat&gt;::iterator lit=mpTracker-&gt;mlRelativeFramePoses.begin(), lend=mpTracker-&gt;mlRelativeFramePoses.end();lit!=lend;lit++, lRit++, lT++)</span><br><span class="line">    &#123;</span><br><span class="line">        ORB_SLAM2::KeyFrame* pKF = *lRit;</span><br><span class="line"></span><br><span class="line">        cv::Mat Trw = cv::Mat::eye(<span class="number">4</span>,<span class="number">4</span>,CV_32F);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//追踪成功但是关键帧不好，则获取当前关键帧相对于上一帧的位姿，并将上一帧设为关键帧，依次不断的判断关键帧的质量，直到选取合适的关键帧</span></span><br><span class="line">        <span class="keyword">while</span>(pKF-&gt;isBad())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//  cout &lt;&lt; "bad parent" &lt;&lt; endl;</span></span><br><span class="line">            Trw = Trw*pKF-&gt;mTcp;</span><br><span class="line">            pKF = pKF-&gt;GetParent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trw = Trw*pKF-&gt;GetPose()*Two;<span class="comment">//将关键帧的位姿乘第一帧相对于世界坐标的位姿得到关键帧相对于世界坐标的位姿</span></span><br><span class="line"></span><br><span class="line">        cv::Mat Tcw = (*lit)*Trw;<span class="comment">////在将关键帧相对于世界坐标的位姿乘当前帧相对于关键帧的位姿得到当前帧相对于世界坐标的位姿</span></span><br><span class="line">        cv::Mat Rwc = Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).colRange(<span class="number">0</span>,<span class="number">3</span>).t();<span class="comment">//求旋转矩阵R</span></span><br><span class="line">        cv::Mat twc = -Rwc*Tcw.rowRange(<span class="number">0</span>,<span class="number">3</span>).col(<span class="number">3</span>);<span class="comment">//求平移矩阵t</span></span><br><span class="line">        <span class="comment">// 变换矩阵f</span></span><br><span class="line">        f &lt;&lt; setprecision(<span class="number">9</span>) &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">1</span>)  &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">2</span>) &lt;&lt; <span class="string">" "</span>  &lt;&lt; twc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">             Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>)  &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">" "</span>  &lt;&lt; twc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">             Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">1</span>)  &lt;&lt; <span class="string">" "</span> &lt;&lt; Rwc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="string">" "</span>  &lt;&lt; twc.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f.close();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"trajectory saved!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAM2——整体框架</title>
    <url>/2019/11/04/ORB-SLAM2%E2%80%94%E2%80%94%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191104184711727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p> ORB_SLAM2由3+1个平行线程组成，包括跟踪、局部建图、回环检测以及在回环检测后的全局BA优化。之所以说是3+1，因为第四个线程仅在回环检测并确认后才执行。</p><p>三个主要并行线程：<br>Tracking：寻找局部地图特征点并进行匹配，运用纯运动BA最小化重投影误差，定位每帧相机位姿。<br>Local Mapping：运用局部BA算法优化相机位姿和特征点云。<br>Loop Closing：检测回环并通过位姿图优化消除累计漂移误差。在位姿图优化后会启动第4个线程执行全局BA算法，计算整个系统最优结构和运动结果。</p><a id="more"></a>


<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>以双目stereo_kitti.cc这个主程序来看整个代码：</p>
<ol>
<li>首先使用LoadImages读取图片目录和时间戳文件 </li>
<li>创建ORB_SLAM2::System对象 </li>
<li>循环读取数据<br>3.1 读取图片<br>3.2 读取时间戳<br>3.3 将图片传给SLAM系统 </li>
<li>将相机轨线保存到硬盘中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Usage: ./stereo_kitti path_to_vocabulary path_to_settings path_to_sequence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve paths to images</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstrImageLeft;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstrImageRight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vTimestamps;</span><br><span class="line">    LoadImages(<span class="built_in">string</span>(argv[<span class="number">3</span>]), vstrImageLeft, vstrImageRight, vTimestamps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nImages = vstrImageLeft.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create SLAM system. It initializes all system threads and gets ready to process frames.</span></span><br><span class="line">    ORB_SLAM2::<span class="function">System <span class="title">SLAM</span><span class="params">(argv[<span class="number">1</span>],argv[<span class="number">2</span>],ORB_SLAM2::System::STEREO,<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vector for tracking time statistics</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; vTimesTrack;</span><br><span class="line">    vTimesTrack.resize(nImages);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"-------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Start processing sequence ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Images in the sequence: "</span> &lt;&lt; nImages &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    cv::Mat imLeft, imRight;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ni=<span class="number">0</span>; ni&lt;nImages; ni++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Read left and right images from file</span></span><br><span class="line">        imLeft = cv::imread(vstrImageLeft[ni],CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">        imRight = cv::imread(vstrImageRight[ni],CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">        <span class="keyword">double</span> tframe = vTimestamps[ni];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(imLeft.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Failed to load image at: "</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">string</span>(vstrImageLeft[ni]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t1 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t1 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass the images to the SLAM system</span></span><br><span class="line">        SLAM.TrackStereo(imLeft,imRight,tframe);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t2 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t2 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ttrack= <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(t2 - t1).count();</span><br><span class="line"></span><br><span class="line">        vTimesTrack[ni]=ttrack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait to load the next frame</span></span><br><span class="line">        <span class="keyword">double</span> T=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ni&lt;nImages<span class="number">-1</span>)</span><br><span class="line">            T = vTimestamps[ni+<span class="number">1</span>]-tframe;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ni&gt;<span class="number">0</span>)</span><br><span class="line">            T = tframe-vTimestamps[ni<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ttrack&lt;T)</span><br><span class="line">            usleep((T-ttrack)*<span class="number">1e6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop all threads</span></span><br><span class="line">    SLAM.Shutdown();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracking time statistics</span></span><br><span class="line">    sort(vTimesTrack.begin(),vTimesTrack.end());</span><br><span class="line">    <span class="keyword">float</span> totaltime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ni=<span class="number">0</span>; ni&lt;nImages; ni++)</span><br><span class="line">    &#123;</span><br><span class="line">        totaltime+=vTimesTrack[ni];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"median tracking time: "</span> &lt;&lt; vTimesTrack[nImages/<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mean tracking time: "</span> &lt;&lt; totaltime/nImages &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save camera trajectory</span></span><br><span class="line">    SLAM.SaveTrajectoryKITTI(<span class="string">"CameraTrajectory.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>LoadImages()函数</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadImages</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strPathToSequence, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vstrImageLeft,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vstrImageRight, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;vTimestamps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fTimes;</span><br><span class="line">    <span class="built_in">string</span> strPathTimeFile = strPathToSequence + <span class="string">"/times.txt"</span>;</span><br><span class="line">    fTimes.open(strPathTimeFile.c_str());</span><br><span class="line">    <span class="keyword">while</span>(!fTimes.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//strstream类同时可以支持C风格的串流的输入输出操作</span></span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        getline(fTimes,s);</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; s;<span class="comment">//输入</span></span><br><span class="line">            <span class="keyword">double</span> t;</span><br><span class="line">            ss &gt;&gt; t;<span class="comment">//输出</span></span><br><span class="line">            vTimestamps.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> strPrefixLeft = strPathToSequence + <span class="string">"/image_0/"</span>;</span><br><span class="line">    <span class="built_in">string</span> strPrefixRight = strPathToSequence + <span class="string">"/image_1/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nTimes = vTimestamps.size();</span><br><span class="line">    vstrImageLeft.resize(nTimes);<span class="comment">//改变当前使用数据的大小</span></span><br><span class="line">    vstrImageRight.resize(nTimes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; i;</span><br><span class="line">        vstrImageLeft[i] = strPrefixLeft + ss.str() + <span class="string">".png"</span>;</span><br><span class="line">        vstrImageRight[i] = strPrefixRight + ss.str() + <span class="string">".png"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="https://blog.csdn.net/hzy925/article/details/85488031" target="_blank" rel="noopener">ORB-SLAM2 程序解读</a><br><a href="https://blog.csdn.net/zxcqlf/article/details/80198298" target="_blank" rel="noopener">ORB-SLAM2论文解读与总结</a></p>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>C ++ 学习（1）——vector</title>
    <url>/2019/11/04/C-%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94vector/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是vector？"><a href="#一、什么是vector？" class="headerlink" title="一、什么是vector？"></a>一、什么是vector？</h1><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 </p><h1 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h1><ol>
<li><p>顺序序列</p>
<p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p>
</li>
</ol><a id="more"></a>

<ol>
<li><p>动态数组</p>
<p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p>
</li>
<li><p>能够感知内存分配器的（Allocator-aware）</p>
<p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p>
</li>
</ol>
<h1 id="三、基本函数实现"><a href="#三、基本函数实现" class="headerlink" title="三、基本函数实现"></a>三、基本函数实现</h1><p>1.构造函数</p>
<blockquote>
<p>vector():创建一个空vector<br>   vector(int nSize):创建一个vector,元素个数为nSize<br>   vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>   vector(const vector&amp;):复制构造函数<br>   vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p>
</blockquote>
<p>2.增加函数</p>
<blockquote>
<p> void push_back(const T&amp; x):向量尾部增加一个元素X<br> iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>     iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>     iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p>
</blockquote>
<p>3.删除函数</p>
<blockquote>
<p>  iterator erase(iterator it):删除向量中迭代器指向元素<br>      iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>      void pop_back():删除向量中最后一个元素<br>      void clear():清空向量中所有元素</p>
</blockquote>
<p>4.遍历函数</p>
<blockquote>
<p>   reference at(int pos):返回pos位置元素的引用<br>       reference front():返回首元素的引用<br>       reference back():返回尾元素的引用<br>       iterator begin():返回向量头指针，指向第一个元素<br>       iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>       reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>       reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</p>
</blockquote>
<p>5.判断函数</p>
<blockquote>
<p>bool empty() const:判断向量是否为空，若为空，则向量中无元素</p>
</blockquote>
<p>6.大小函数</p>
<blockquote>
<p>  int size() const:返回向量中元素的个数<br>      int capacity() const:返回当前向量张红所能容纳的最大元素值<br>      int max_size() const:返回最大可允许的vector元素数量值</p>
</blockquote>
<p>7.其他函数</p>
<blockquote>
<p>  void swap(vector&amp;):交换两个同类型向量的数据<br>      void assign(int n,const T&amp; x):设置向量中第n个元素的值为x<br>      void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p>
</blockquote>
<p>8.看着清楚</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>push_back 在数组的最后添加一个数据</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>pop_back 去掉数组的最后一个数据</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>at 得到编号位置的数据</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>begin 得到数组头的指针</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>end 得到数组的最后一个单元+<span class="number">1</span>的指针</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>．front 得到数组头的引用</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>back 得到数组的最后一个单元的引用</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>max_size 得到<span class="type">vector</span>最大可以是多大</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>capacity 当前<span class="type">vector</span>分配的大小</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>size 当前使用数据的大小</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span>resize 改变当前使用数据的大小</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span>reserve 改变当前vecotr所分配空间的大小</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span>erase 删除指针指向的数据项</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span>clear 清空当前的<span class="type">vector</span></span><br><span class="line"></span><br><span class="line"><span class="number">15.</span>rbegin 将<span class="type">vector</span>反转后的开始指针返回(其实就是原来的end<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span>rend 将<span class="type">vector</span>反转构的结束指针返回(其实就是原来的begin<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span>empty 判断<span class="type">vector</span>是否为空</span><br><span class="line"></span><br><span class="line"><span class="number">18.</span>swap 与另一个<span class="type">vector</span>交换数据</span><br></pre></td></tr></table></figure>
<h1 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p><strong>eg：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; veci;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		veci.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (it = veci.begin(); it != veci.end(); )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it = veci.erase(it);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; veci.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"========将vector值传递给其他参数，同时判断是否满足删除要求========"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itc = veci.begin();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecTemp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size(),itc!=veci.end();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vecTemp.push_back(veci.at(i));</span><br><span class="line">		<span class="keyword">if</span> (*itc % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			itc = veci.erase(itc);</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++itc;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; veci.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; veci.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTemp.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; vecTemp.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190903112647360.png"><br><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">参考：https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>27.二叉树的镜像</title>
    <url>/2019/11/04/27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>26.树的子结构</title>
    <url>/2019/11/04/26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>注意检测空指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1!=<span class="literal">NULL</span>&amp;&amp; pRoot2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(pRoot1-&gt;val-pRoot2-&gt;val)&lt;<span class="number">1e-8</span>)</span><br><span class="line">                result=Tree1HaveTree2(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Tree1HaveTree2</span><span class="params">(TreeNode* pRoot1,TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(pRoot1-&gt;val-pRoot2-&gt;val)&gt;=<span class="number">1e-8</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Tree1HaveTree2(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>25.合并两个排序的链表表</title>
    <url>/2019/11/03/25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果有一个链表为空，则直接返回另外一个链表；否则就对两个链表的每个元素进行大小判断，建立一个新的合并链表，把元素依次放进去，直到一个链表为空，这时把另外一个链表的剩余部分添加到合并链表的尾部即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><a id="more"></a>

<p><strong>法1：循环</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* pHead3=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//利用了构造方法创建一个链表</span></span><br><span class="line">        ListNode* root=pHead3;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">NULL</span> &amp;&amp; pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead1;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead1=pHead1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead2;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead2=pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pHead3=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个链表中哪个头结点的值小，就以此作为新链表的头结点</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;=pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead1;</span><br><span class="line">            pHead1=pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead2;</span><br><span class="line">            pHead2=pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* head=pHead3;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">NULL</span> &amp;&amp; pHead2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead1;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead1=pHead1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pHead3-&gt;next=pHead2;</span><br><span class="line">                pHead3=pHead3-&gt;next;</span><br><span class="line">                pHead2=pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">NULL</span>)</span><br><span class="line">            pHead3-&gt;next=pHead1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pHead3-&gt;next=pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>
<p><strong>法2：递归</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pHead3=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead1;</span><br><span class="line">            pHead3-&gt;next=Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead3=pHead2;</span><br><span class="line">            pHead3-&gt;next=Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pHead3;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>24.反转链表</title>
    <url>/2019/11/03/24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191103101356721.png#pic_center"><br>在调整节点i的next指针，需要知道节点i的前一个节点h，事先还要保存i的下一个节点j，以防止链表断开。需要定定义三个指针</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* pRversedHead=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pNode=pHead;</span><br><span class="line">        ListNode* pPrev=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* pNext=pNode-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pNext==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pRversedHead=pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pNode-&gt;next=pPrev;</span><br><span class="line">            pPrev=pNode;</span><br><span class="line">            pNode=pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRversedHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>22.链表中倒数第k个结点</title>
    <url>/2019/11/02/22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>先统计链表节点的个数n，再从头遍历到第n-k+1个节点</li>
<li>为了实现只遍历一次，可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动，从第k步开始，第二个指针也开始从链表的头指针开始遍历</li>
</ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>思维全面，注意代码的鲁棒性 。</p><a id="more"></a>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* Ahead=pListHead;</span><br><span class="line">        ListNode* Behind=pListHead;</span><br><span class="line">        <span class="keyword">if</span>(pListHead==<span class="literal">NULL</span> || k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Ahead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">                Ahead=Ahead-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Ahead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ahead=Ahead-&gt;next;</span><br><span class="line">            Behind=Behind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Behind;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>题目：求链表的中间节点，如果节点的总数为奇数，则返回中间节点，若节点的总数为偶数，返回中间两个节点的任意一个。</p>
<p>思路：定义两个指针，一个指针一次走一步，一个指针一次走两部</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>C ++ 学习（16）——&的用法</title>
    <url>/2019/11/02/C-%E5%AD%A6%E4%B9%A0%EF%BC%8816%EF%BC%89%E2%80%94%E2%80%94-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二进制的位与运算。"><a href="#二进制的位与运算。" class="headerlink" title="二进制的位与运算。"></a>二进制的位与运算。</h1><p>例如 二进制数字 100 &amp; 111 = 100；</p><h1 id="表示取地址。"><a href="#表示取地址。" class="headerlink" title="表示取地址。"></a>表示取地址。</h1><p>eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用，顾名思义是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价</p><a id="more"></a>


<p>   <strong>注意：</strong></p>
<p> ==引用的类型必须和其所绑定的变量的类型相同==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=<span class="number">10.3</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b=a;<span class="comment">//错误，引用的类型必须和其所绑定的变量的类型相同</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>  ==声明引用的同时必须对其初始化==</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;a;<span class="comment">//错误，声明引用的同时必须对其初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==引用相当于变量或对象的别名，因此不能再将已有的引用名作为其他变量或对象的名字或别名==<br>==引用不是定义一个新的变量或对象，因此内存不会为引用开辟新的空间存储这个引用==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;new_value=value;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"value在内存中的地址:"</span>&lt;&lt;&amp;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"new_value在内存中的地址:"</span>&lt;&lt;&amp;new_value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190927105109522.png#pic_center"></p>
<p><strong>引用作为函数的参数</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a ,<span class="keyword">int</span> &amp;b)</span></span>&#123;<span class="comment">//引用作为函数的形参</span></span><br><span class="line">    <span class="keyword">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>当用引用作为函数的参数时，其==效果和用指针作为函数参数的效果相当==。当调用函数时，==函数中的形参就会被当成实参变量或对象的一个别名来使用==，也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参。</li>
<li>通常函数调用时，系统采用值传递的方式将实参变量的值传递给函数的形参变量。此时，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，也就是说形参变量只是实参变量的副本而已；并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象。而使用引用作为函数的形参时，由于此时==形参只是要传递给函数的实参变量或对象的别名而非副本==，故==系统不会耗费时间来在内存中开辟空间来存储形参==。因此如果参数传递的数据较大时，==建议使用引用作为函数的形参，这样会提高函数的时间效率，并节省内存空间==。</li>
<li>使用指针作为函数的形参虽然达到的效果和使用引用一样，但==当调用函数时仍需要为形参指针变量在内存中分配空间，而引用则不需要这样==，故在C++中推荐使用引用而非指针作为函数的参数</li>
<li><p>如果在编程过程中既希望通过让引用作为函数的参数来提高函数的编程效率，又希望保护传递的参数使其在函数中不被改变，则此时应当使用对常量的引用作为函数的参数。</p>
</li>
<li><p>数组的引用作为函数的参数：C++的数组类型是带有长度信息的，==引用传递时如果指明的是数组则必须指定数组的长度==</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(&amp;a) [<span class="number">5</span>])</span></span>&#123;<span class="comment">//数组引用作为函数的参数，必须制定数组的长度</span></span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常引用</strong><br>语法：const 类型 &amp;引用名=目标变量名；<br>==常引用不允许通过该引用对其所绑定的变量或对象进行修改==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;new_a=a;</span><br><span class="line">new_a=<span class="number">11</span>;<span class="comment">//错误，不允许通过常引用对其所绑定的变量或对象进行修改</span></span><br></pre></td></tr></table></figure>
<p><strong>引用作为函数的返回值</strong><br>语法：类型 &amp;函数名（形参列表）{ 函数体 }</p>
<p>注意：<br>==引用作为函数的返回值时，必须在定义函数时在函数名前将&amp;==</p>
<p>==用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">fn1</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123;</span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">float</span> &amp;<span class="title">fn2</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123; <span class="comment">//&amp;说明返回的是temp的引用，换句话说就是返回temp本身</span></span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a=fn1(<span class="number">5.0</span>); <span class="comment">//case 1：返回值</span></span><br><span class="line">    <span class="comment">//float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type 'float&amp;' from an rvalue of type 'float'</span></span><br><span class="line">                           <span class="comment">//（有些编译器可以成功编译该语句，但会给出一个warning） </span></span><br><span class="line">   <span class="keyword">float</span> c=fn2(<span class="number">5.0</span>);<span class="comment">//case 3：返回引用</span></span><br><span class="line">   <span class="keyword">float</span> &amp;d=fn2(<span class="number">5.0</span>);<span class="comment">//case 4：用函数返回的引用作为新引用的初始化值</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;b&lt;&lt;endl;//78.5</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用引用实现多态</strong><br>在C++中，引用是除了指针外另一个可以产生多态效果的手段。也就是说一个基类的引用可以用来绑定其派生类的实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>;</span><span class="comment">//基类（父类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>：<span class="title">public</span> <span class="title">Father</span>&#123;</span>.....&#125;<span class="comment">//Son是Father的派生类</span></span><br><span class="line">Son son;<span class="comment">//son是类Son的一个实例</span></span><br><span class="line">Father &amp;ptr=son;<span class="comment">//用派生类的对象初始化基类对象的使用</span></span><br></pre></td></tr></table></figure>
<p>ptr只能用来访问派生类对象中从基类继承下来的成员。如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li><p>在引用的使用中，单纯给某个变量去别名是毫无意义的，引用的目的主要用于在函数参数的传递中，解决大块数据或对象的传递效率和空间不如意的问题</p>
</li>
<li><p>用引用传递函数的参数，能保证参数在传递的过程中不产生副本，从而提高传递效率，同时通过const的使用，还可以保证参数在传递过程中的安全性</p>
</li>
<li><p>引用本身是目标变量或对象的别名，对引用的操作本质上就是对目标变量或对象的操作。因此能使用引用时尽量使用引用而非指针</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>21.调整数组顺序使奇数位于偶数前面</title>
    <url>/2019/11/02/21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul>
<li>最简单从头遍历，每碰到一个偶数，拿出这个数字，把位于这个偶数后面的所有数字往前移一位，再把这个数字放在数组末尾，时间复杂度$O(n^2)$</li>
<li><p>需要两个指针分别指向数组的头和尾，依次比较。</p>
<ol>
<li>如果头指针指向的数组位置为奇数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则头指针后移一个位置，如果是偶数，则尾指针前移一个位置。</li>
<li>如果头指针指向的数组位置为偶数，那么就判断尾指针指向的数组位置的奇偶性。如果是奇数，则交换头尾指针指向的数组元素，如果是偶数，则尾指针前移一个位置。</li>
</ol>
</li>
</ul><a id="more"></a>

<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_1</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin，直到它指向偶数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; <span class="number">0x1</span>) != <span class="number">0</span>)</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd，直到它指向奇数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_2</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reorder(pData, length, isEven);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; !func(*pBegin))</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; func(*pEnd))</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>vector表示</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> reOrderArray(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> j=<span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">array</span>[i]&amp;<span class="number">0x1</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>((<span class="built_in">array</span>[j]&amp;<span class="number">0x1</span>)==<span class="number">0</span>)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp=<span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i]=<span class="built_in">array</span>[j];</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并==保证奇数和奇数，偶数和偶数之间的相对位置不变==。</p>
<p>时间复杂度$O(n)$,空间复杂度$O(n)$</p>
<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时间：3ms,占用内存：492k</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1,vec2 ;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&amp; <span class="number">0x1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vec1.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vec2.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">array</span>.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">            <span class="built_in">array</span>.push_back(vec1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="built_in">array</span>.push_back(vec2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时间：3ms,占用内存：484k</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录第一个为奇数的位置</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&amp;<span class="number">0x1</span>)<span class="comment">//找到第一个奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="built_in">array</span>[i];<span class="comment">//记录第一个奇数</span></span><br><span class="line">                <span class="keyword">int</span> k=i;</span><br><span class="line">                <span class="keyword">for</span>(;k&gt;j;k--)<span class="comment">//将奇数之前的所有元素往后移一个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">array</span>[k]=<span class="built_in">array</span>[k<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">array</span>[j]=temp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>ORB-SLAM——论文翻译（ORB-SLAM:a Versatile and Accurate Monocular SLAM System）</title>
    <url>/2019/11/01/ORB-SLAM%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88ORB-SLAM-a-Versatile-and-Accurate-Monocular-SLAM-System%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><center>ORB-SLAM：一种通用的(全能的)精确的单目SLAM系统<center></center></center></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文提出了ORB-SLAM，在大小场景、室内室外环境下都可以实时操作的一种基于特征的单目SLAM系统。系统对复杂的剧烈运动具有鲁棒性，允许宽基线的闭环和重定位，且包含完整的自动初始化。基于最近几年的优秀算法之上，我们从头开始设计了一种新颖的系统，它对所有SLAM任务使用相同的特征：追踪、建图、重定位和闭环。合适策略的存在使得选择的重建点和关键帧具有很好的鲁棒性，并能够生成紧凑的可追踪的地图，只有当场景内容发生变化地图才改变，从而允许长时间操作。本文从最受欢迎的数据集中提供了27个序列的详尽评估。相对于其他最先进的单目SLAM方法，ORB-SLAM实现了前所未有的性能。为了社会的利益，我们将源代码公开。</p><a id="more"></a>

<p>关键字：持续建图，定位，单目视觉，识别，同时定位和制图（SLAM）。</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>BA提供相机定位的精确估计以及稀疏几何重建[1,2]，并且提供了强烈的匹配网络和良好的初始猜测。一段长的时间，这种方法被认为不符合实时性的应用，如视觉VSLAM。VSLAM系统在构建环境的同时需要估计相机的轨迹。现在，我们为了不以过高的计算成本获得准确的结果，实时SLAM算法必须向BA提供以下信息。</p>
<ul>
<li>在候选图像帧子集中（关键帧）匹配观测的场景特征（地图云点）</li>
<li>由于关键帧数量的增长，需要做筛选避免冗余</li>
<li>关键帧和云点的网络配置可以产生精确的结果，也就是，分布良好的关键帧集合和有明显视差、大量回环匹配的观测云点</li>
<li>关键帧和云点位置的初始估计，采用非线性优化的方法</li>
<li>在构建局部地图的过程中，优化的关键是获得良好的稳定性</li>
<li>本系统可以实时执行快速全局优化（比如位姿图）以实现闭环回路</li>
</ul>
<p>BA第一次实时应用是在Mouragon等人[13]提出的视觉里程计算法中，其次是在Klein和Murray的突破性工作PTAM[4]算法中。尽管受制于小场景的应用，PTAM算法对关键帧的选择，特征匹配，点的三角化，相机位姿估计，追踪失败后的重定位非常有效。然而，由于缺少闭环检测和对遮挡场景的处理，再加上其视图不变性差，在地图初始化时需要人工干预等多个因素，使得PTAM算法的应用收到了严重的限制。</p>
<p>在本文中，我们基于PTAM算法的主要框架，采用Gálvez-López和Tardós提出的place recognition（场景/位置识别）算法，Strasdat等人提出的scale-aware loop closing（具备尺度感知的闭环检测）算法以及文献[7][8]中的大尺度操作中Covisibility信息的使用，重新设计了一种新的单目SLAM系统ORB-SLAM，本文的贡献主要包括：</p>
<ul>
<li>对所有的任务采用相同的特征：追踪、地图构建、重定位和闭环检测。这使得我们的系统更有效率、简单可靠。采用的ORB特征[9]在没有GPU的情况下也有很好的实时性，且具有旋转不变性和光照不变性。</li>
<li>算法支持在宽阔环境中实时操作。由于covisibility graph的使用，特征点的跟踪与构图主要集中在局部共视区域，而与全局地图的大小无关。</li>
<li>使用Essential Graph来优化位姿实现回环检测。构建生成树，并由系统、闭环检测链接和covisibility graph的强边缘进行维护。</li>
<li>算法的实时相机重定位具有明显的旋转不变特性和光照不变性。这就使得点跟踪丢失后可以恢复，增强了地图的重用性。</li>
<li>提出了一种合适的方法来选择地图点云和关键帧，通过严格删选关键帧和地图点，剔除冗余信息，使得特征点的跟踪具备了更好的稳定性，从而增强算法的可持续操作性。好的挑选方法可以增强追踪的鲁棒性，同时舍弃多余的关键帧加强系统长时间操作性</li>
</ul>
<p>我们在公共数据集上对算法的性能在室内和室外环境下进行了评估，包括手持设备、汽车和机器人。值得一提的是，与目前最新的直接SLAM算法[10]相比——直接SLAM方法通过直接对像素点的灰度进行优化而不是最小化特征重投影误差，我们的方法能够实现更精确的摄像头定位精度。我们在文章的第IX-B部分还讨论了基于特征的SLAM方法定位比直接法更准确的原因。</p>
<p>闭环检测和重定位的方法是基于我们之前的论文[11]。系统最初的版本是论文[12]。本文中我们添加了初始化的方法，Essential graph ，并完善其他模块。我们详细了描述了系统的各个板块，并且开展了实验验证。<br>据我们所知，这是目前最完整最可靠的单目SLAM系统，为了使更多人获益，我们将源代码开放。视频演示和源代码放在我们的项目网站上。</p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h2 id="A、位置识别"><a href="#A、位置识别" class="headerlink" title="A、位置识别"></a>A、位置识别</h2><p>Williams等人在综述[13]中比较了几种基于景象的位置识别方法，即图像到图像的匹配，这种方法在大环境下比地图到地图或图像到地图的方法更准确。在景象匹配方法中，bags of words（词袋）[14]的使用以其效率很高而脱颖而出，比如概率方法FAB-MAP[15]算法,。DBoW2方法[5]则首次使用了BRIEF描述子[16]生成的二进制词袋和非常高效的FAST特征检测算法[17]与SURF和SIFT相比，FAST算法的运时间减小了至少一个数量级。然而，尽管系统运行效率高、鲁棒性好，采用BRIEF描述子不具有旋转不变性和尺度不变性，系统只能运行在同一平面内（否则会造成尺度变化）  ，闭环检测也只能从相似的视角中进行。在我们之前的工作[11]中，我们提出了一个使用ORB特征检测子的DBoW2位置识别器。ORB特征是具有旋转不变和尺度不变特性的二进制特征，因此，用它生成的快速识别器具有较好的视角不变性。我们在4组不同的数据集上演示了位置识别功能，从10K图像数据库中提取一个候选闭合回路的运算时间少于39毫秒。在本文的工作中，我们提出了一种改进版本的位置识别方法，采用covisibility信息，在检索数据库时返回几个假设情况而不是最好的匹配。</p>
<h2 id="B、地图初始化"><a href="#B、地图初始化" class="headerlink" title="B、地图初始化"></a>B、地图初始化</h2><p>单目SLAM系统需要设计专门的策略来生成初始化地图，因为单幅图像不具备深度信息。解决这个问题的一种方法是一开始跟踪一个已知结构的对象，正如文献[20]。另一个方法是用一个具有高不确定度的逆深度参数[21]来初始化点的深度信息，理想情况下，该参数会在后期逐渐收敛到真值。最近Engel提出的半稠密方法[10]中就采用类似的方法将像素的深度信息初始化为一个随机数值。</p>
<p>如果是从两个视角来初始化特征，就可以采用以下方法：一种是假设局部场景在同一平面内[4]，[22]，然后利用Faugeras等人论文[23]中的单应性来重构摄像头相对位姿。第二种是将场景建模为通用情况（不一定为平面），通过Nister提出的五点算法[26]来计算本征矩阵[24],[25]，但该方法存在多解的问题。这两种摄像头位姿重构方法在低视差下都没有很好的约束，如果平面场景内的所有点都靠近摄像机的中心，则结果会出现双重歧义[27]。另一方面，非平面场景可以通过线性8点算法[2]来计算基础矩阵，相机的相对位姿就可以无歧义的重构出来。</p>
<p>针对这一问题，我们在本文的第四部分提出了一个新的基于模型选择的自动初始化方法，对平面场景算法选择单应性矩阵，而对于非平面场景，算法选择基础矩阵。模型选择的综述方法可参见Torr等人的论文[28]。基于类似的理论，我们设计了一种启发式初始化算法，算法考虑到在接近退化情况（比如：平面，近平面，或是低视差）下选择基础矩阵进行位姿估计可能存在的问题，则选择单应性计算。在平面的情况下，为了保险起见，如果最终存在双重歧义，则算法避免进行初始化，因为可能会因为错误选择而导致算法崩溃。因此，我们会延迟初始化过程，直到所选的模型在明显的视差下产生唯一的解。</p>
<h2 id="C、单目SLAM"><a href="#C、单目SLAM" class="headerlink" title="C、单目SLAM"></a>C、单目SLAM</h2><p>单目SLAM最初采用滤波框架[20],[21],[29],[30]来建模。在该类方法中，每一帧都通过滤波器联合估计地图特征位置和相机位姿。这样做带来的问题是在处理连续帧图像上对计算资源的浪费和线性误差的累积。而另外一种SLAM框架是基于关键帧的，即采用少数筛选过的图像（关键帧）来构建地图，因为构图不再与帧率相关联，因此基于关键帧的SLAM方法不但节省了计算资源，还可以进行高精度的BA优化。Strasdar等人在论文[31]中证明了基于关键帧的单目SLAM方法比滤波器方法在相同的运算代价上定位结果更精确。</p>
<p>基于关键帧的SLAM系统最具代表性可能是由Klein和Murray等人提出的PTAM算法[4]。它第一次将相机追踪和地图构建拆分成两个并行的线程运行，并成功用于小环境的实时增强现实中。后来文献[32]引入边缘特征对PTAM算法进行了改进，在跟踪过程中增加了旋转估计步骤，实现了更好的重定位效果。由于PTAM中的地图云点通过图像区块与FAST角点匹配，因此仅适合于特征跟踪并不适合用于后期的位置识别。而实际上，PTAM算法并没有进行大闭环检测，其重定位也仅是基于关键帧低分辨率缩略图的相关性进行的，因此视角不变性较差。</p>
<p>Strasdat等人在文献[6]中提出了一个基于GPU实现的大尺度单目SLAM系统，该系统前端采用光流算法，其次用FAST特征匹配和运动BA；后端是基于滑动窗口的BA。闭环检测通过具有相似性约束（7自由度）的位姿图优化来进行，该方法可以矫正在单目SLAM系统中出现的尺度偏移问题。在本文中，我们也将采用这种7自由度的位姿图优化方法，并将其应用到我们的Essential Graph中，更多细节将在第三部分D节里面描述。</p>
<p>Strasdat等人在文献[7]中采用了PTAM的前端，但其跟踪部分仅在一个从covisibility graph提取的局部图中进行。他们提出了一个双窗口优化后端，在内部窗口中连续进行BA，在有限大小的外部窗口中构建位姿图。然而， 只有当外部窗口尺寸足够大到可以包含整个闭环回路的情况下，闭环检测才能起作用。在我们的算法中，我们利用了Strasdat等人提出的基于covisibility的局部地图的优势，并且通过covisibility map来构建位姿图，同时重新设计前端和后端。另一个区别是，我们并没有用特别的特征提取方法做闭合回路检测（比如SURF方法），而是基于相同的追踪和建图的特征进行位置识别，获得具有鲁棒性的重定位和闭环检测。</p>
<p>在Pirker等人的论文[33]中作者提出了CD-SLAM方法，一个非常复杂的系统，包括闭环检测，重定位，大尺度操作以及对算法在动态环境运行所做的改进。但文中并没有提及地图初始化。因此不利于后期读者对算法的复现，也致使我们没法对其进行精确性、鲁棒性和大场景下的测试对比。</p>
<p>Song等人在论文[34]提出的视觉里程计方法中使用了ORB特征做追踪和处理BA后端滑动窗口。相比之下，我们的方法更加全面，因为他们的算法中没有涉及全局重定位，闭环回路检测，而且地图也不能重用。他们也使用了相机到地面的真实距离来限制单目SLAM算法的尺度漂移。Lim等人在我们提交本文最初的版本[12]之后发表了论文[25]，他们也采用相同的特征进行跟踪，地图构建和闭环检测。但是，由于Lim等人的算法选择的BRIEF描述子不具备尺度不变性，因此其算法运行受限在平面轨迹上。他们的算法仅从上一帧关键帧开始跟踪特征点，因此访问过的地图不能重用，这样的处理方式与视觉里程计很像，存在系统无限增长的问题。我们在第三部分E小节里面与该算法进行了定性比较。</p>
<p>Engel等人在最近的论文[10]里提出了LSD-SLAM算法，其可以构建大场景的半稠密地图。算法并没有采用特征提取和BA方法，而是选择直接法（优化也是直接通过图像像素灰度进行）。算法的结果让人印象深刻，其在没有GPU加速的情况下实时构建了一个半稠密地图，相比基于特征的稀疏地图SLAM系统而言，LSD-SLAM方法在机器人领域有更大的应用潜力。然而，该算法的运行仍然需要基于特征做闭环检测，且相机定位的精度也明显低于PTAM和我们的算法，相关实验结果我们将在第8部分的B小节中展示，对该结果的讨论在文章IX部分B小节进行。</p>
<p>Forster等人在论文[22]中提出了介于直接方式和基于特征的方法之间的半直接视觉里程计算法SVO方法。该方法不需要对每帧图像都提取特征点，且可以以很高的帧率运行，在四轴飞行器上取得了令人惊叹的定位效果。然而，SVO算法没有进行闭环检测，且目前主要基于下视摄像头运行。</p>
<p>最后，我们想讨论一下目前关键帧的选择方法。由于所有的视觉SLAM算法选择所有的云点和图像帧运行BA是不可行的。因此，在论文[31]中，Strasdat等人证明最合理的选择是保留尽可能多地点云和非冗余关键帧。PTAM方法非常谨慎插入关键帧避免运算量增长过大。然而，这种严格限制关键帧插入的策略在算法运行困难的情况下可能会导致追踪失败。在本文中，为了达到更好的稳定性，我们选择一种更为合适的关键帧插入策略，当算法运行困难的时候算法选择尽快的插入关键帧，然后在后期将冗余的关键帧删除以避免额外的计算成本。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="A、特征选择"><a href="#A、特征选择" class="headerlink" title="A、特征选择"></a>A、特征选择</h2><p>我们系统设计的中心思想是对SLAM系统的构图、跟踪、重定位以及闭环检测等模块都采用相同的特征，这将使得我们的系统更有效率，避免了像以往文章[6],[7]一样还需要额外插入一些额外的识别性强的特征以用于后期的闭环检测。我们每张图像的特征提取远少于33毫秒，远小于目前的SIFT算法（~300ms）,SURF算法(~300ms)，或最近提出的A-KAZE（~100ms）算法。为了使算法的位置识别能力能更加通用化，我们需要提取的特征具备旋转不变性，而BRIEF和LDB不具备这样的特性。</p>
<p>为此，我们选择了ORB[9]特征，其是具有256位描述符的带方向的多尺度FAST角点。他们计算和匹配的速度非常快，同时对视角具有旋转不变的特性。这样可以在更宽的基准线上匹配他们，增强了BA的精度。我们已经在论文[11]中演示了基于ORB特征的位置识别性能。需要申明的是，虽然本文的方案中采用ORB算法，但所提出的技术并不仅限于该特征。</p>
<h2 id="B、三个线程：追踪、局部地图构建和闭环检测"><a href="#B、三个线程：追踪、局部地图构建和闭环检测" class="headerlink" title="B、三个线程：追踪、局部地图构建和闭环检测"></a>B、三个线程：追踪、局部地图构建和闭环检测</h2><blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101155613105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">&gt;图1 ORB-SLAM系统框架，图中显示了算法的三个线程——跟踪、局部构图与闭环检测的所有步骤。另外还有场景识别和地图的主要组成部分。</p>
</blockquote>
<p>我们的系统框架如图1所示，包括三个并行的线程：跟踪、局部地图构建和闭环回路检测。跟踪线程负责对每帧图像的相机位置进行定位，并决定什么时候插入新的关键帧。我们首先通过与前一帧图像匹配得到初始特征点，然后采用运动BA优化摄像头位姿。如果特征跟丢（比如由于遮挡或是突然运动），则由位置识别模块进行全局重定位。一旦获得最初的相机位姿估计和特征匹配，则使用由系统维护的关键帧的covisibility graph提取一个局部可视化地图，如图2(a),图2(b)所示。然后通过重投影方法搜索当前帧与局部地图点对应的匹配点，并利用所有的匹配点优化当前相机位姿。最后，跟踪线程决定是否插入新的关键帧。所有的跟踪步骤将在第5部分详细阐述。创建初始化地图的新方法将在第4部分进行说明。</p>
<p>局部地图构建模块负责处理新的关键帧，对周围的相机位姿进行局部BA以优化重构。在covisibility graph已连接的关键帧中搜索新的关键帧中ORB特征的匹配点，然后三角化新的地图点。有时尽管已经创建了新的点云，但基于跟踪线程过程中新收集的信息，为了保证点云的高质量，可能会根据点云筛选策略临时删除一些点。局部地图构建模块也负责删除冗余的关键帧。我们将在第6章详细说明局部地图构建的步骤。</p>
<p>对每个新的关键帧都要进行闭环搜索，以确认是否形成闭环。如果闭环被侦测到，我们就计算相似变换来查看闭环的累积误差。这样闭环的两端就可以对齐，重复的云点就可以被融合。最后，为了确保全局地图的一致性，利用相似性约束[6]对位姿图进行优化。这里值得一提的是，本文主要对Essential Graph进行优化，它是一个covisibility graph中的一个更稀疏的子图，更多细节将在第三部分D小节描述。闭环检测和校验步骤将在第7部分详细描述。</p>
<p>我们使用g2o[37]库中的Levenverg-Marquardt算法执行所有的优化。我们在附录中描述了每个优化的误差，计算成本和变量。</p>
<h2 id="C、地图点云、关键帧及其选择标准"><a href="#C、地图点云、关键帧及其选择标准" class="headerlink" title="C、地图点云、关键帧及其选择标准"></a>C、地图点云、关键帧及其选择标准</h2><p>对每个地图点云pi保存以下信息：</p>
<ul>
<li>它在世界坐标系中的3D坐标$X_{w.i}$</li>
<li>视图方向$n_i$，即所有视图方向的平均单位向量（该方向是指连接该点云和其对应观测关键帧光心的射线方向）</li>
<li>ORB特征描述子$D_i$，与其他所有能观测到该点云的关键帧中ORB描述子相比，该描述子的汉明距离最小</li>
<li>根据ORB特征尺度不变性约束，可观测的点云的最大距离$d_{max}$和最小距离$d_{min}$</li>
</ul>
<p>对每个关键帧$K_i$保存以下信息：</p>
<ul>
<li>相机位姿$T_(i,w)$，从世界坐标系转换到相机坐标系下的变换矩阵</li>
<li>相机内参，包括主点和焦距</li>
<li>从图像帧提取的所有ORB特征，不管其是否已经关联了地图云点， 这些ORB特征点都经过畸变模型矫正过</li>
</ul>
<p>地图点云和关键帧的创建条件较为宽松，但是之后则会通过一个非常严格苛刻的删选机制进行挑选，该机制会检测出冗余的关键帧和匹配错误的或不可跟踪的云点进行删除。这样做的好处在于地图在构建过程中具有一定的弹性，在外界条件比较困难的情况下（比如：旋转，相机快速运动），算法仍然可以实现鲁棒的跟踪，而与此同时，当相机对同一个环境重访问时，地图的尺度大小是可控的，这就利于该系统的长期工作。另外，与PTAM算法相比，我们构建的地图中基本不包含局外点，因为秉持的原则是很苛刻的，宁缺毋滥。地图云点和关键帧的筛选过程将在第6部分B节和E节分别解释。</p>
<h2 id="D、Covisibility-Graph和Essential-Graph"><a href="#D、Covisibility-Graph和Essential-Graph" class="headerlink" title="D、Covisibility Graph和Essential Graph"></a>D、Covisibility Graph和Essential Graph</h2><p>关键帧之间的Covisibility信息在本文的SLAM系统中几个模块上都非常有用，像论文[7]一样，我们将其表示成一个间接的权重图。图中每个节点代表一个关键帧，如果两个关键帧都能同时观测到地图云点中至少15个点，则这两个关键帧之间用一条边线相连，我们用权重θ表示两个关键帧能共同观测到的云点数量</p>
<p>为了矫正闭环回路，我们像论文[6]那样做位姿图优化，优化方法延着位姿图将闭环回路的误差进行分散。考虑到covisibility graph可能非常密集的边缘，我们提出构建一个（Essential Graph），该图中保留了covisibility graph的所有节点（关键帧），但是边缘更少，仍旧保持一个强大的网络以获得精确的结果。系统从初始关键帧开始增量式地构建一个生成树，它是一个边缘数量最少的covisibility graph的子图像。当插入新的关键帧时，则判断其与树上的关键帧能共同观测到多少云点，然后将其与共同观测点最多的关键帧相连反之，当一个关键帧通过筛选策略被删除时，系统会重新更新与其相关的连接。Essential Graph包含了一个生成树，一个高covisibility（θmin=100）的covisibility graph边缘子集，以及闭环回路的边缘，这样的组合共同构建了一个强大的相机网络。图2展示了一个covisibility graph，生成树和相关的essential graph的例子。在本文第8部分第E节的实验里，当算法运行位姿图优化时，结果可以达到非常高的精度以至于即便是全局BA优化都很难达到。。essential graph的效用和θmin对算法的影响将在第8部分E节的最后讨论。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160115593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center">&gt;图2 对TUM RGB-D标准库[38]中fr3_long_office_household图像序列进行重构以及本文用到的各种姿态图的例子</p>
</blockquote>
<h2 id="E、基于图像词袋模型的位置识别"><a href="#E、基于图像词袋模型的位置识别" class="headerlink" title="E、基于图像词袋模型的位置识别"></a>E、基于图像词袋模型的位置识别</h2><p>为了实现闭环检测与重定位，系统嵌入了基于DBoW2[5]算法来执行闭环检测和重定位。视觉词汇（Visual words）是一个离散化的特征描述子空间，被称为视觉词典。这部视觉词典是通过从大量图像中提取ORB描述子离线创建的。如果图像的通用性强，则同一部视觉词典在不同的环境下也能获得很好的性能，正如我们之前的论文[11]那样。SLAM系统增量式地构建一个数据库，该数据库中包含了一个反向指针，用于存储每个视觉词典里的视觉单词，关键帧可以通过这个数据库查询视觉词典，从而实现高效检索。当一个关键帧通过筛选程序删除时，数据库也会相应更新。</p>
<p>由于关键帧之间可能会存在视图上的重叠，因此检索数据库时，可能返回的结果不止一个高分值的关键帧。原版的DBoW2认为是图像重叠的问题，就将时间上接近的图像的分值相加。但这并没有包括观测同一地点但在不同时间插入的关键帧。为了解决这一问题，我们将这些与covisibility graph相连的关键帧进行分类。另外，我们的数据库返回的是分值高于最好分值75%的所有关键帧。<br>用词袋模型来表示特征匹配的另外一个优势在论文[5]里有详细介绍。如果我们想计算两个ORB特征的对应关系，我们可以强制匹配视觉字典树上某一层（我们在6层里面选第2层）的相同节点（关键帧）里的特征，这可以加快搜索速度。在本文中，我们就利用这个小技巧来搜索匹配的特征点，用于三角化新的点云，闭环检测和重定位。我们还引入一个方向一致性测试来改进匹配点，具体如论文[11]，这可以去掉无效数据，保证所有对应匹配点的旋转方向一致。</p>
<h1 id="IV-地图自动初始化"><a href="#IV-地图自动初始化" class="headerlink" title="IV. 地图自动初始化"></a>IV. 地图自动初始化</h1><p>地图初始化的目的是计算两帧图像之间的相对位姿来三角化一组初始的地图云点。这个方法应该与场景无关（平面的或一般的）而且不需要人工干预去选择良好的双视图配置，比如两幅图应具有明显的视差。本文算法提出并行计算两个几何模型，一个是面向平面视图的单映矩阵，另一个是面向非平面视图的基础矩阵。然后，采用启发式的方法选择模型，并使用所选的模型从两图像的相对位姿中对地图点云进行重构。本文算法只有当两个视图之间的视差达到安全阈值时，才进行地图初始化。如果检测到低视差的情况或已知两视图模糊的情况（如论文[27]所示），则为了避免生成一个有缺陷的地图而推迟初始化。算法的步骤是：</p>
<ul>
<li>1.查找初始的匹配点对：<br>从当前帧中提取ORB特征$F_c$（只在最好的尺度上），与在参考帧$Ｆ_r$搜索匹配点对 $x_c\leftrightarrow x_r$。如果找不到足够的匹配点对，就重置参考帧。</li>
<li>2.并行计算两个模型：<br>在两个线程上并行计算单应矩阵$H_{cr}$和基础矩阵$F_{cr}$ ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160909286.png#pic_center"><br>在文献[2]中详细解释了基于RANSAC的归一化DLT算法和8点算法计算原理。为了使两个模型的计算流程尽量一样，将两个模型的迭代循环次数预先设置成一样，每次迭代的特征点数目也预先设置好，基础矩阵是8个特征点对，单映矩阵是4个特征点对。每次迭代中，我们给每个模型M（H表示单映射，F表示基本矩阵）计算一个分值SM：</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101160949854.png#pic_center"></p>
<p>其中，$d_{cr}^2$和$d_{rc}^2$是帧到帧之间的对称传递误差，其计算方法参见文献[2]。$T_M$是无效数据的排除阈值，它的依据是$\chi ^2$测试的95%（$T_H=5.99, T_F=3.84$，假设在测量误差上有1个像素的标准偏差）。 等于$T_H$，这样两个模型在有效数据上对于同一误差d的分值相同，同样使得运算流程保持一致。<br>我们从单应矩阵和基本矩阵的计算中选择分值最高的，但如果两个模型分值都不高（没有足够的局内点），则算法流程重启，从step1开始重新计算。</p>
<ul>
<li><p>3.模型选择：</p>
<p>如果场景是平面，近平面或存在低视差的情况，则可以通过单映矩阵来求解。同样地，我们也可以找到一个基础矩阵，但问题是基础矩阵不能够很好的约束该问题[2]，而且从基础矩阵中计算得到的运动结果是错误的。在这种情况下，我们应该选择单映矩阵才能保证地图初始的正确性，或者如果检测到低视差的情况则不进行初始化工作。另一方面，对于非平面场景且有足够的视差的情况则可以通过基础矩阵来计算，而在这种情况下单映矩阵只有基于平面点或者低视差的匹配点才能找到。因此，在这种情况下我们应该选择基础矩阵。我们利用如下强大的启发式进行计算：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161616755.png#pic_center"><br>如果$R_H&gt;0.45$ , 这表示二维平面和低视差的情况，我们将选择计算单应矩阵。其他的情况，我们选择基础矩阵。</p>
</li>
<li>4.运动和从运动到结构的重构</li>
<li>一旦选择好模型，我们就可以获得相应的运动状态。如果选择单映矩阵，我们按照Faugeras等人发表的论文[23]中提到的方法，提取8种运动假设，该方法提出用cheriality测试来选择有效解。然而，如果在低视差的情况下，这些测试就会失效，因为云点很容易在相机的前面或后面移动，会导致选解错误。我们提出的方法是直接按这8种解将二维点三角化，然后检查是否有一种解可以使得所有的云点都位于两个相机的前面，且重投影误差较小。如果没有一个明确的解胜出，我们就不执行初始化，重新从第一步开始。这种方法使初始化程序在低视差和两个交叉的视图情况下更具鲁棒性，这也是我们整个算法体现鲁棒性的关键所在。<br>在基本矩阵的情况下，我们使用标定矩阵K用下式将其转换为本质矩阵：．<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161803488.png#pic_center"><br>然后用文献[2]中的奇异值分解方法计算4个运动解，然后就像上文中叙述的一样，我们将四个解用于三角化特征点，以选择正解。</li>
<li>C5.Bundle adjustment<br>最后我们执行一个全局BA，详细优化过程参见附录，以优化初始重构得到的点云地图。<br>如图3所示是对论文[39]中的室外NewCollege机器人图像序列进行地图初始化的例子，室外环境下初始化工作具有很大挑战性。从图中可以看出，PTAM算法和LSD-SLAM算法对位于同一平面上的所有点都进行了初始化，而我们的方法是当两幅图像有足够视差之后才进行初始化，并基于基础矩阵得到了正确的结果。<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101161919724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图3 基于NewCollege图像序列[39]进行地图初始化，最上面一行：PTAM算法,中间一行：LSD-SLAM算法，底下一行：ORB-SLAM算法。其中，PTAM算法和LSD-SLAM算法初始化了一个错误的平面地图，而我们的方法自动选择在两帧图像存在足够视差的情况下再利用基础矩阵初始化。如果人工选择关键帧，则PTAM算法也能够初始化得很好。</p>
<h1 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h1><p>在这一部分，我们将详细介绍跟踪线程在相机每帧图像上执行的步骤。在几个步骤中都提到的相机位姿优化，包括运动BA，将在附录部分进行阐述。</p>
<h2 id="A、ORB特征提取"><a href="#A、ORB特征提取" class="headerlink" title="A、ORB特征提取"></a>A、ORB特征提取</h2><p>我们在8层图像金字塔上提取FAST角点，金字塔图像尺度因子为1.2。如果图像分辨率从512<em>384到752</em>480，我们发现提取1000个角点比较合适，如果分辨率提高，如KITTI数据集[40]，则提取2000个角点。为了确保特征点均匀分布，我们将每层图像分成网格，每格提取至少5个角点。然后检测每格角点，如果角点数量不够，就调整阈值。如果某些单元格内检测不出角点，则其对应提取的角点数量也相应减少。最后，根据保留的FAST的角点计算方向和ORB特征描述子。ORB特征描述子将用于算法后续所有的特征匹配，而不是像PTAM算法中那样根据图像区块的相关性进行搜索。</p>
<h2 id="B、通过前一图像帧估计相机的初始位姿"><a href="#B、通过前一图像帧估计相机的初始位姿" class="headerlink" title="B、通过前一图像帧估计相机的初始位姿"></a>B、通过前一图像帧估计相机的初始位姿</h2><p>如果上一帧图像跟踪成功，我们就用运动速率恒定模型来预测当前相机的位置（即认为摄像头处于匀速运动），然后搜索上一帧图像中的特征点在地图中的对应云点与当前帧图像的匹配点，最后利用搜索到的匹配点对当前相机的位姿进一步优化。但是，如果没有找到足够的匹配点（比如，运动模型失效，非匀速运动），我们就加大搜索范围，搜索地图云点附近的点在当前帧图像中是否有匹配点，然后通过寻找到的对应匹配点对来优化当前时刻的相机位姿。</p>
</blockquote>
</li>
</ul>
<h2 id="C、通过全局重定位来初始化位姿"><a href="#C、通过全局重定位来初始化位姿" class="headerlink" title="C、通过全局重定位来初始化位姿"></a>C、通过全局重定位来初始化位姿</h2><p>如果扩大了搜索范围还是跟踪不到特征点，（那么运动模型已经失效），则计算当前帧图像的词袋（BoW）向量,并利用BoW词典选取若干关键帧作为备选匹配帧（这样可以加快匹配速度）；然后，在每个备选关键帧中计算与地图云点相对应的ORB特征，就如第三部分E节所描述的。接着，对每个备选关键帧轮流执行PnP算法[41]计算当前帧的位姿（RANSAC迭代求解）。如果我们找到一个姿态能涵盖足够多的有效点，则搜索该关键帧对应的更多匹配云点。最后，基于找到的所有匹配点对相机位置进一步优化，如果有效数据足够多，则跟踪程序将持续执行。</p>
<h2 id="D、跟踪局部地图"><a href="#D、跟踪局部地图" class="headerlink" title="D、跟踪局部地图"></a>D、跟踪局部地图</h2><p>一旦我们获得了初始相机位姿和一组初始特征匹配点，我们就可以将更多的地图云点投影到图像上以寻找更多的匹配点。为了降低大地图的复杂性，我们只映射局部地图。该局部地图包含一组关键帧K1，它们和当前关键帧有共同的地图云点，还包括与关键帧K1在covisibility graph中相邻的一组关键帧K2。这个局部地图中有一个参考关键帧$K_{ref}∈K1$，它与当前帧具有最多共同的地图云点。现在对K1, K2中可见的每个地图云点，在当前帧中进行如下搜索：</p>
<ul>
<li>1.计算地图云点在当前帧图像中的投影点x。如果投影位置超出图像边缘，就将对应的地图云点删除</li>
<li>2.计算当前视图射线v和地图云点平均视图方向n的夹角。如果n&lt;cos(60o)，就删除对应云点</li>
<li>3.计算地图云点到相机中心的距离d。如果它不在地图云点的尺度不变区间内，即d∉[dmin,dmax]，就删除该云点</li>
<li>4.计算每帧图像的尺度比d/dmin</li>
<li>5.对比地图云点的特征描述子D和当前帧中还未匹配的ORB特征，在预测的尺度层和靠近x的云点作最优匹配</li>
</ul>
<p>相机位姿最后通过当前帧中获得所有的地图云点进行优化。（这个环节的目的是在当前帧和局部地图之间找到更多的匹配点对，来优化当前帧的位姿）。</p>
<h2 id="新关键帧的判断"><a href="#新关键帧的判断" class="headerlink" title="新关键帧的判断"></a>新关键帧的判断</h2><p>最后一步是决定当前帧是否可以作为关键帧。由于局部地图构建的过程中有一个机制去筛选冗余的关键帧，所以我们需要尽快地插入新的关键帧以保证跟踪线程对相机的运动更具鲁棒性，尤其是对旋转运动。我们根据以下要求插入新的关键帧：</p>
<ul>
<li>1.距离上一次全局重定位后需要超过20帧图像。</li>
<li>2.局部地图构建处于空闲状态，或距上一个关键帧插入后，已经有超过20帧图像。</li>
<li>3.当前帧跟踪少于50个地图云点。</li>
<li>4.当前帧跟踪少于参考关键帧K_ref云点的90%。</li>
</ul>
<p>与PTAM中用关键帧之间的距离作为判断标准不同，我们加入一个最小的视图变换，如条件4。条件1 确保一个好的重定位，条件3保证好的跟踪。如果局部地图构建处于忙状态（条件2的后半部分）的时候插入关键帧，就会发信号去暂停局部BA，这样就可以尽可能快地去处理新的关键帧。</p>
<h1 id="局部建图"><a href="#局部建图" class="headerlink" title="局部建图"></a>局部建图</h1><p>这章我们将描述根据每个新的关键帧$K_i$构建局部地图的步骤。</p>
<h2 id="A、关键帧插入"><a href="#A、关键帧插入" class="headerlink" title="A、关键帧插入"></a>A、关键帧插入</h2><p>首先更新covisibility graph，具体包括：添加一个关键帧节点$K_i$，检查与$K_i$有共同云点的其他关键帧，用边线连接。然后，更新生成树上与$K_i$有最多共享点的其他关键帧的链接。计算表示该关键帧的词袋，并利用三角法生成新的地图云点。</p>
<h2 id="地图点云筛选"><a href="#地图点云筛选" class="headerlink" title="地图点云筛选"></a>地图点云筛选</h2><p>三角化的云点为了已知保留在地图中，必须在其创建后的头三个关键帧中通过一个严格的测试，该测试确保留下的云点都是能被跟踪的，不是由于错误的数据而被三角化的。一个云点必须满足如下条件：</p>
<ul>
<li>1.跟踪线程必须在超过25%的图像中找到该特征点。</li>
<li>2.如果创建地图云点经过了多个关键帧，那么它必须至少是能够被其他3个关键帧观测到。</li>
</ul>
<p>一旦一个地图云点通过测试，它只能在被少于3个关键帧观测到的情况下移除。这样的情况在关键帧被删除以及局部BA排除异值点的情况下发生。这个策略使得我们的地图包含很少的无效数据。</p>
<h2 id="C、新地图点云创建"><a href="#C、新地图点云创建" class="headerlink" title="C、新地图点云创建"></a>C、新地图点云创建</h2><p>新的地图云点的创建是通过对covisibility graph中连接的关键帧Kc中的ORB特征点进行三角化实现的。对Ki中每个未匹配的ORB特征，我们在其他关键帧的未匹配云点中进行查找，看是否有匹配上的特征点。这个匹配过程在第三部分第E节中有详细阐述，然后将那些不满足对级约束的匹配点删除。ORB特征点对三角化后，需要对其在摄像头坐标系中的深度信息，视差，重投影误差和尺度一致性进行审查，通过后则将其作为新点插入地图。起初，一个地图云点通过2个关键帧观测，但它在其他关键帧中也有对应匹配点，所以它可以映射到其他相连的关键帧中，搜索算法的细则在本文第5部分D节中有讲述。</p>
<h2 id="D、局部BA"><a href="#D、局部BA" class="headerlink" title="D、局部BA"></a>D、局部BA</h2><p>局部BA主要对当前处理的关键帧$K_i$,以及在covisibility graph中与$K_i$连接的其他关键帧$K_c$，以及这些关键帧观测到的地图云点进行优化所有其他能够观测到这些云点的关键帧但没有连接$K_i$的会被保留在优化线程中，但保持不变。优化期间以及优化后，所有被标记为无效的观测数据都会被丢弃，附录有详细的优化细节。</p>
<h2 id="E、局部关键帧筛选"><a href="#E、局部关键帧筛选" class="headerlink" title="E、局部关键帧筛选"></a>E、局部关键帧筛选</h2><p>为了使重构保持简洁，局部地图构建尽量检测冗余的关键帧，删除它们。这样对BA过程会有很大帮助，因为随着关键帧数量的增加，BA优化的复杂度也随之增加。当算法在同一场景下运行时，关键帧的数量则会控制在一个有限的情况下，只有当场景内容改变了，关键帧的数量才会增加，这样一来，就增加了系统的可持续操作性。如果关键帧Kc中90%的点都可以被其他至少三个关键帧同时观测到，那认为Kc的存在是冗余的，我们则将其删除。尺度条件保证了地图点以最准确的方式保持它们对应的关键帧（这句翻译没理解透：The scale condition ensures that map points maintain keyframes from which they are measured with most accuracy.）这个策略受Tan等人的工作[24]的启发，在这项工作中，作者在经过一系列变化检测后即将关键帧删除。</p>
<h1 id="闭环检测"><a href="#闭环检测" class="headerlink" title="闭环检测"></a>闭环检测</h1><p>闭环检测线程抽取$K_i$——最后一帧局部地图关键帧，用于检测和闭合回环。具体步骤如下：</p>
<h2 id="A、候选关键帧"><a href="#A、候选关键帧" class="headerlink" title="A、候选关键帧"></a>A、候选关键帧</h2><p>我们先计算Ki的词袋向量和它在covisibility graph中相邻图像（θmin=30）的相似度，保留最低分值Smin。然后，我们检索图像识别数据库，丢掉那些分值低于Smin的关键帧。这和DBoW2中均值化分值的操作类似，可以获得好的鲁棒性，DBoW2中计算的是前一帧图像，而我们是使用的covisibility信息。另外，所有连接到Ki的关键帧都会从结果中删除。为了获得候选回环，我们必须检测3个一致的候选回环（covisibility graph中相连的关键帧）。如果对Ki来说环境样子都差不多，就可能有几个候选回环。</p>
<h2 id="B、计算相似变换"><a href="#B、计算相似变换" class="headerlink" title="B、计算相似变换"></a>B、计算相似变换</h2><p>单目SLAM系统有7个自由度，3个平移，3个旋转，1个尺度因子 [6]。因此，闭合回环，我们需要计算从当前关键帧Ki到回环关键帧Kl的相似变换，以获得回环的累积误差。计算相似变换也可以作为回环的几何验证。</p>
<p>我们先计算ORB特征关联的当前关键帧的地图云点和回环候选关键帧的对应关系，具体步骤如第3部分E节所示。此时，对每个候选回环，我们有了一个3D到3D的对应关系。我们对每个候选回环执行RANSAC迭代，通过Horn方法（如论文[42]）找到相似变换。如果我们用足够的有效数据找到相似变换Sil，我们就可以优化它，并搜索更多的对应关系。如果Sil有足够的有效数据，我们再优化它，直到Kl回环被接受。</p>
<h2 id="C、回环融合"><a href="#C、回环融合" class="headerlink" title="C、回环融合"></a>C、回环融合</h2><p>回环矫正的第一步是融合重复的地图云点，在covisibility graph中插入与回环相关的的新边缘。先通过相似变换Sil矫正当前关键帧位姿Tiw，这种矫正方法应用于所有与Ki相邻的关键帧，这样回环两端就可以对齐。然后，回环关键帧及其近邻能观测到的所有地图云点都映射到Ki及其近邻中，并在映射的区域附近小范围内搜索它的对应匹配点，如第5部分D节所述。所有匹配的地图云点和计算Sil过程中的有效数据进行融合。融合过程中所有的关键帧将会更新它们在covisibility graph中的边缘，创建的新边缘将用于回环检测。</p>
<h2 id="D、Essential-Graph优化"><a href="#D、Essential-Graph优化" class="headerlink" title="D、Essential Graph优化"></a>D、Essential Graph优化</h2><p>为了有效地闭合回环，我们通过Essential Graph优化位姿图，如第三部分D节所示，这样可以将回环闭合的误差分散到图像中去。优化程序通过相似变换校正尺度偏移，如论文[6]。误差和成本计算如附录所示。优化过后，每一个地图云点都根据关键帧的校正进行变换。</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>我们采用NewCollege[39]的大场景机器人图像序列对本文提出的系统进行了较全面的实验评估，首先采用TUM的室内16个手持RGB-D数据集[38]对系统的总体性能进行了评估，包括算法的定位精度，重定位和程序运行能力；然后，用KITTI的10个汽车户外图像数据集[40]，评估算法在实时大场景下的操作及其定位精度和位姿图的优化效率。</p>
<p>算法运行在Intel Core i7-4700MQ （4核@2.40GHz）和8GB RAM的实验平台上，运算速率可达到实时，且以帧率对图像进行准确处理。ORB-SLAM有3个主线程，它们和其他ROS线程并行运行，由于引入了ROS操作系统，因此算法结果具有一定的随机性，针对这个原因，我们在一些实验中公布了算法运行的中间结果。</p>
<h2 id="A、基于Newcollege数据集测试系统性能"><a href="#A、基于Newcollege数据集测试系统性能" class="headerlink" title="A、基于Newcollege数据集测试系统性能"></a>A、基于Newcollege数据集测试系统性能</h2><p>NewCollege数据集[39]包含了一个2.2公里的校园的机器人图像序列。它是由双目相机拍摄，帧率为20fps，分辨率512x38。图像序列中包含几个回环和快速的旋转，这对单目视觉定位非常具有挑战性。据我们所知，目前没有单目系统可以处理整个图像序列。例如论文[7]，尽管其算法可以实现回环检测，也可以应用于大场景环境，但只有小部分序列图像能够显示单目结果。.<br>如图4显示的是我们的算法检测到的闭合回路，从图中可以看出，我们选择的有效数据点都支持相似性变换。图5则对比了回环闭合前后的环境地图重构状况。其中，红色标注的是局部地图，回环检测后可以看到其两端扩展到连接整个运行轨迹。图6是以实时帧率速度运行整个图像序列后的全局地图，从图中可以看出，后边的大回环并没有完全闭合，它从另外一个方向穿过，位置识别程序没能发现闭合回路。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164011644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201911011640368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164055751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>我们统计了ORB_SLAM算法每个线程所用的时间。表1显示了算法跟踪和局部构图的时间。可以看出，跟踪的帧率大概在25-30Hz，这是跟踪局部地图所需的最多时间。如果需要的话，这个时间还可以更快，只要减少局部地图中所包含的关键帧数量即可。局部地图构建线程中需时最高的是局部BA优化。局部BA的时间根据机器人探索环境的状态变动，即在未探索环境下所需时间多，在已经探索过的环境下运行所需时间少，因为在未知环境中如果跟踪线程插入一个新的关键帧，BA优化会被中断，如第5部分E节所示。如果不需要插入新的关键帧，局部BA优化则会执行大量已经设置的迭代程序。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164133928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>表2显示了6个闭合回路的结果。可以看到回环检测是如何亚线性地随关键帧数量的增多而增加。这主要是由于高效的数据库检索，表2中只比较了具有相同图像单词的图像子集，由此可见用于位置识别词袋模型的潜力。我们的Essential Graoh中包含的边缘是关键帧数量的5倍，它是一个稀疏图。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164204706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B、基于TUM-RGB-D标准库的定位精度"><a href="#B、基于TUM-RGB-D标准库的定位精度" class="headerlink" title="B、基于TUM RGB-D标准库的定位精度"></a>B、基于TUM RGB-D标准库的定位精度</h2><p>TUM RGB-D数据集[38]是一个用于估计摄像头定位精度的优秀数据库，它提供了许多图像序列，还包括外部运动捕捉系统提供的对应轨迹真值。我们去掉那些不适合纯单目SLAM系统的图像序列，这些序列包含强烈的旋转，没有纹理或没有运动。</p>
</blockquote>
<p>为了验证算法性能，我们选择了最近提出的直接法半稠密LSD-SLAM（论文[10]）和经典算法PTAM（论文[4]）作为对比。除此之外，我们还比较了由RGBD-SLAM（论文[43]）算法生成的轨迹。为了在相同的基准下比较ORB-SLAM，LSD-SLAM和PTAM，我们用相似变换对齐关键帧轨迹，在尺度未知的情况下，检测轨迹的绝对误差（论文[38]）。对RGBD-SLAM算法，我们通过相机坐标变换来对齐轨迹，也采用同样的方法检测尺度是否重构良好。LSD-SLAM从随机深度值开始初始化，然后随机值逐渐收敛，因此与基准对比的时候，我们会丢掉前10个关键帧。对于PTAM算法，我们从一个好的初始化中，手动选择两个关键帧。表3 是对我们选择的16个图像序列运行5次的中间结果。<br>TUM RGB-D数据集[38]是一个用于估计摄像头定位精度的优秀数据库，它提供了许多图像序列，还包括外部运动捕捉系统提供的对应轨迹真值。我们去掉那些不适合纯单目SLAM系统的图像序列，这些序列包含强烈的旋转，没有纹理或没有运动。</p>
<p>为了验证算法性能，我们选择了最近提出的直接法半稠密LSD-SLAM（论文[10]）和经典算法PTAM（论文[4]）作为对比。除此之外，我们还比较了由RGBD-SLAM（论文[43]）算法生成的轨迹。为了在相同的基准下比较ORB-SLAM，LSD-SLAM和PTAM，我们用相似变换对齐关键帧轨迹，在尺度未知的情况下，检测轨迹的绝对误差（论文[38]）。对RGBD-SLAM算法，我们通过相机坐标变换来对齐轨迹，也采用同样的方法检测尺度是否重构良好。LSD-SLAM从随机深度值开始初始化，然后随机值逐渐收敛，因此与基准对比的时候，我们会丢掉前10个关键帧。对于PTAM算法，我们从一个好的初始化中，手动选择两个关键帧。表3 是对我们选择的16个图像序列运行5次的中间结果。</p>
<p>从表中可以看出，ORB-SLAM可以处理所有的图像序列，除了fr3 nostructure texture far (fr3 nstr tex far)以外。这是一个平面的场景，相机的轨迹在这种情况下有两种可能，正如论文[27]中的描述的。我们的初始化方法检测到这种模棱两可的情况，为了保证算法的安全运行选择不进行初始化。PTAM初始化有时会选择对的方案，有些可能会选择错的方案，且导致的错误可能不能接受。我们没有注意到LSD-SLAM的2种不同的重构方案，但在这个图像序列出现的错误非常多。针对其他的图像序列，PTAM和LSD-SLAM算法的鲁棒性都比我们的方法差，且分别有八组序列和三组序列中地图点容易跟踪丢失。</p>
<p>关于精度问题，没有回环检测期间，ORB-SLAM和PTAM算法的定位精度相当，但回环检测成功后，ORB-SLAM算法将达到更高的定位精度，正如在图像序列fr3 nostructure texture near withloop (fr3 nstr tex near)中表现的。非常意外的一个结果是PTAM和ORB-SLAM都非常明显地表现出精度高于LSD-SLAM和RGBD-SLAM。一个可能的原因是它们将地图的优化过程简化为一个单纯的姿态图优化过程，这样就造成了传感器测量信息的丢失，但在我们的算法中，采用BA优化，同时通过传感器测量优化相机的姿态和地图的云点位置，这是解决运动到结构[2]的经典标准算法。。我们将在第9部分B节进一步讨论了这个结果。另一个有趣的结果是在图像序列fr2 desk with person 和 fr3 walking xyz中，LSD-SLAM对动态物体的鲁棒性相比ORB-SLAM差一些。</p>
<p>我们注意到RGBD-SLAM在图像序列fr2上尺度上有一个偏差，用7自由度对齐轨迹则误差明显减少。最后我们注意到Engle等人在论文[10]中提出在f2_xyz上PTAM的精度比LSD-SLAM算法低，RMSE是24.28cm。然而，论文没有给出足够的细节说明如何获得这些结果的，因此我们没有办法复现它。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164359174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="C、基于TUM-RGB-D标准数据库的重定位"><a href="#C、基于TUM-RGB-D标准数据库的重定位" class="headerlink" title="C、基于TUM RGB-D标准数据库的重定位"></a>C、基于TUM RGB-D标准数据库的重定位</h2><p>我们在TUM RGB-D数据集上进行了两组重定位实验。在第一个实验中，我们选择fr2_xyz图像序列，通过前30秒构建了一个地图，然后对后来的每一帧图像都进行全局重定位，并评估重构出来的相机位姿精度。我们对PTAM算法进行了相同的实验。如图7所示是创建初始地图的关键帧，重定位的图像帧位姿和这些帧对应的真值。从图中可以看出PTAM算法只能够对重定位关键帧附近的图像帧，这是因为其算法中重定位方法并不具备不变形导致的。表4显示了PTAM算法和ORB_SLAM算法相对地面真值的误差。从表中数据可以看出，ORB-SLAM比PTAM可以更精准地多定位2倍的图像帧。在第2个实验中，我们采用fr3_sitting_xyz图像序列来初始化地图，然后用fr3_walking_xyz图像序列重定位所有的图像帧。这是一个颇具挑战性的实验，由于图像中有人移动，会造成图像局部区域的遮挡。在该试验中，PTAM并没有实现重定位，而ORB-SLAM重定位了78%的图像帧，如表4所示。图8显示了ORB-SLAM重定位的一些实验图例。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164542153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164634243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164649369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="D、基于TUM-RGB-D标准数据集测试算法的运行生命"><a href="#D、基于TUM-RGB-D标准数据集测试算法的运行生命" class="headerlink" title="D、基于TUM RGB-D标准数据集测试算法的运行生命"></a>D、基于TUM RGB-D标准数据集测试算法的运行生命</h2></blockquote>
<p>之前的重定位实验表明我们的系统可以从非常不同的视角定位地图，在中等动态环境中的鲁棒性也较好。这个特性和关键帧筛选程序使得算法在不同的视角和局部动态环境中能够一直运行到图像结束。</p>
<p>在全静态场景情况下，即使相机从不同视角观测场景，ORB-SLAM也可以使关键帧数量保持在一个有限的水平内。我们在一个自定义的图像序列中验证了这一点，手持相机在93秒以内都拍摄同一张桌子，但视角一直变换，形成一个轨迹。我们对比了我们地图的关键帧数量和PTAM生成的关键帧，如图9所示。可以看到PTAM一直都在插入关键帧，而ORB-SLAM会删除冗余的关键帧，将其总数保持在一个稳定的范围内。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164757407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>当然，在整个程序运行过程中，静态环境下的正常操作是任何SLAM系统的一个基本要求，更引人关注的是动态环境下的状况。我们在几个fr3的图像序列中分析了ORB-SLAM系统的状况，图像序列有：sitting xyz, sitting halfsphere, sitting rpy, walking xyz, walking halfspehere 和walking rpy。所有的视频中，相机都对着桌子，但运动轨迹不同，拍摄场景中有人在移动，椅子也被移动了。如图10（a）所示是ORB_SLAM算法生成的地图中所有关键帧的总数量，图10（b）显示从图像帧中创建或删除关键帧，从中可以看出从关键帧到地图构建需要多久时间。可以看到前2个图像序列中新看到（增加）场景时地图的大小一直在增加。图10（b）是前2个视频中创建的关键帧。在视频sitting_rpy和walking_xyz中，地图没有增加，地图是通过已有场景创建。相反，在最后两个视频中，有更多的关键帧插入但没有在场景中表示出来，可能由于场景的动态变化。图10（C）是关键帧的柱状图，它们是从视频中挑选出来的。大部分的关键帧被筛选程序删除了，只有一小部分留下来了。ORB-SLAM有大量关键帧的生成策略，在未知环境下非常有用；后面系统会生成一个小的子集来代表这些关键帧。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101164845644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>在整个实验中，我们系统的地图根据场景上内容来增加，而不是根据时间，它可以存储场景的动态变化，对场景的理解非常有用。</p>
<h2 id="E、基于KITTI数据集测试算法在大场景大回环下的性能对比"><a href="#E、基于KITTI数据集测试算法在大场景大回环下的性能对比" class="headerlink" title="E、基于KITTI数据集测试算法在大场景大回环下的性能对比"></a>E、基于KITTI数据集测试算法在大场景大回环下的性能对比</h2><p>KITTI数据集中里程计的数据包括11个视频，它的获取是在一个住宅区驾驶汽车，基准精度非常高，有一个GPS和一个Velodyne Laser Scanner。这个数据集对单目系统非常有挑战性，因为视频中有快速旋转，区域内有大量树叶，这使数据关联变得更困难，而且车速相对较快，视频记录的频率为10fps。除了视频01外，ORB-SLAM可以处理其他所有的视频，01是高速路上的视频，可追踪的物体非常少。视频00,02,05,06,07,09，有闭环回路，系统可以检测到，并使它闭合。其中视频09的闭环只能在视频的最后几个图像帧里检测到，并不是每次都能成功检测到（结果显示的是针对其被检测到的运行情况）。<br>对于轨迹与基准的定性比较如图11和12所示。在TUM RGB-D数据集中，我们可以通过相似变换对齐轨迹的关键帧和基准。图11是定性比较的结果，图12是论文[25]中的最新单目SLAM在视频00,05,06,07和08上执行的结果。除了08有一些偏移以外，ORB-SLAM在这些视频上的轨迹都很精准。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165216473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165258286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>表5显示了每个视频的关键帧轨迹中间的RMSE误差。我们基于地图尺寸提供了轨迹的误差。结果表明我们的轨迹误差是地图尺寸的1%左右。大致范围低的是视频03的0.3%高的是视频08的5%。视频08中没有闭环，漂移也没办法纠正，因为闭环控制需要获得更精确的重构。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165353994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<p>在本次实验中，我们还确认了到底全局BA的20层迭代最终能优化多少地图重构，相关细节如附录所示。我们还注意到全局BA优化可以稍微增加闭环轨迹的精度，但这对开环轨迹有负面影响，这意味着我们的系统已经非常精确了。在有些应用中，如果需要非常精确的结果我们的算法会提供一组匹配，需要定义一个比较强的相机网络，一个初始估计，这样全局BA优化迭代次数就会变少。</p>
<p>最后讲一下我们算法的闭环检测和用于essential graph边缘的θmin的效率。我们选择视频09（一段非常长的图像序列，在最后有一个闭环），然后评估不同的闭环检测算法。表6是关键帧轨迹RMSE和不同情况下没有闭环检测优化所用的时间，表中的相关内容包括：如果直接采用全局BA优化（20层或100层迭代）的情况，如果只用位姿图优化（10层迭代不同数量的边缘）的情况，如果先用位姿图优化再执行全局BA优化的情况。结果表明，在闭环检测之前，算法的RMSE误差较大，以至于BA优化没办法收敛，即便是迭代100次之后后误差仍旧非常大。另一方面，essential graph优化收敛速度很快，而且结果也更精确。θmin对精度影响并不大，减少边缘的数量会明显降低精度。位姿图优化后再执行一个BA优化则可以增加精度，但时间也增加了。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019110116552977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="结论和讨论"><a href="#结论和讨论" class="headerlink" title="结论和讨论"></a>结论和讨论</h1><h2 id="A、结论"><a href="#A、结论" class="headerlink" title="A、结论"></a>A、结论</h2><p>本文中，我们提出了一个新的单目SLAM系统，并详细介绍了其组成模块，最后基于公共数据库对其性能进行了全方位的测试。通过实验得知，我们的系统可以处理室内与室外的图像序列，能够用于汽车、机器人和手持设备上。其定位精度在室内小场景中约为1厘米，室外大场景的应用是几米（前提是我们与真实轨迹尺度对齐的情况下）。</p>
</blockquote>
<p>由Klein和Murray[4]提出的PTAM算法被认为是目前最精准的单目实时SLAM方法。PTAM后端是BA优化，这是众所周知的离线SFM（从运动到结构）问题[2]的经典解法。PTAM算法和Mouragnon[3]早期作品的主要贡献是将BA算法引入到机器人SLAM框架下，并具有良好的实时性。而本文的主要贡献是将PTAM算法的适用性进一步扩展，使其可以应用于原来不可应用的场景下。为了实现这一目标，我们整合了前面几年的优秀作品，引入新的想法和算法，从头设计了一种新的单目SALM系统所用到的技术包括Gálvez-López和Tardós提出的论文[5]中的闭环检测，Strasdat等人在论文[6],[7]中提出的的闭环检测程序和covisibility graph，Kuemmerle等人在论文[37]中提出的g2o优化框架以及Rubble等人提出的ORB特征[9]。到目前为止就我们所知，本文提出的ORB_SLAM方法的定位精度最高，也是最可靠最完整的单目SLAM系统。我们提出的新的生成和删除关键帧策略，允许每个几帧就创建一个关键帧，然后当关键帧冗余时则删除。这样的构图方式很灵活，在外界条件很差的情况下可以保证系统正常运行，比如相机作纯旋转运动或快速移动时。当算法在相同场景下运行时，地图在只有拍摄到新内容的情况下才会增长，可以从我们的长期构图结果中看到这个特性。</p>
<p>最后，我们还展示了ORB特征具有很好的识别能力，可识别剧烈视角变换情况下的场景信息。此外，它们能够被非常快速的提取和匹配（不需要多线程或GPU加速），这就使得跟踪和地图构建更加实时精确。</p>
<h2 id="B、离散-特征SLAM方法与稠密-直接SLAM方法对比"><a href="#B、离散-特征SLAM方法与稠密-直接SLAM方法对比" class="headerlink" title="B、离散/特征SLAM方法与稠密/直接SLAM方法对比"></a>B、离散/特征SLAM方法与稠密/直接SLAM方法对比</h2><p>最近，DTAM[44]和LSD-SLAM[10]提出了一种实时单目SALM算法，算法直接利用图像像素的亮度信息进行摄像头的定位与优化，并重构稠密或半稠密的环境地图。这类方法即为直接法，直接方法不需要特征提取，可以避免人工匹配。他们对图像模糊，弱纹理环境和像论文[45]这样的高频纹理环境的鲁棒性更好。与由稀疏点构建的地图相比，比如ORB-SLAM或PTAM算法，稠密/直接法SLAM对相机定位之外的其他应用任务可能更有用途。</p>
<p>部分重译： 然而，直接方法有他们自己的局限。首先，这些方法假设真实场景中的物体的像是由该物体本身的表面反射模型产生的，因此，算法采用的光度一致性寻找匹配点的思路就限制了匹配点之间的基线距离，通常都比特征匹配点的基线要窄。这对重构的精度影响很大，因为重构需要较宽的基线来减少深度的不确定性。如果直接建模不准确，则可能会受到快门，自动增益和自动曝光的影响（如TUM RGB-D 的对比测试）。最后，由于直接方法计算要求较高，因此为了满足计算速度，DTAM算法采用地图增量式扩张的方法，而LSD-SLAM则丢掉传感器测量信息，将地图优化降低为对位姿图的优化。</p>
<p>相反，基于特征的方法可以在更宽的基线上匹配特征，主要得益于特征匹配算法较好地视图不变特性。BA优化和相机位姿优化，地图云点通过传感器测量进行融合。在运动结构估计中，论文[46]已经指出了基于特征的方法相比直接方法的优势。在我们的实验第8部分B节中也直接提供了证据，，表明基于特征的定位精度更高。未来单目SLAM应该会整合两种最好的方法。</p>
<h2 id="C、后续"><a href="#C、后续" class="headerlink" title="C、后续"></a>C、后续</h2><p>我们系统的精度可以通过结合无限远点跟踪来进一步增强。这些在视图中看不到的平行线交点，并没有包含在本文算法构建的地图中，但对相机的旋转非常有用[21]。</p>
<p>另外一种方法是将稀疏地图更新到一个更加稠密的地图。由于我们关键帧的选择机制，关键帧组成了一个紧凑的地图，地图具有非常高精度的位姿信息和丰富的covisibility信息。所以，ORB-SLAM稀疏地图是一个非常优秀的初始估计框架，比稠密地图更好。这个方向的首次尝试在论文[47]中有详细描述。</p>
<h1 id="附录：非线性优化"><a href="#附录：非线性优化" class="headerlink" title="附录：非线性优化"></a>附录：非线性优化</h1><ul>
<li><p>Bundle Adjustment (BA)<br>地图云点3D位置 $X_{w,j}∈R^3$，关键帧位姿$T_{iw}∈SE(3)$，w表示世界坐标，通过匹配的关键点$X_{i,j}∈R^2$减少重投影误差。地图云点j在关键帧i中的误差是：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101165938350.png#pic_center"><br>其中$π_i$是影射函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101170009868.png#pic_center"><br>其中，$R_{iw}∈SO(3)$，$t_{iw}∈R3$，分别表示$T_{iw}$的旋转和平移部分，$f_{i,u} , f_{i,v}）$，$（c_{i,u} , c_{i,v}）$分别是相机i的焦点距离和主点。<br>代价函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101170602738.png#pic_center"><br>$ρ_h$是Huber鲁棒损失函数，$Ω_{i,j}=δ_{i,j}^2I_{2x2}$是协方差矩阵，与检测关键点的尺度有关。在全局BA中（用于地图初始化，请参见第IV节在第VIII-E节），我们优化了所有点和关键帧。但第一个关键帧除外，这些关键帧保持为原点。在局部BA中（请参见VI-D节），局部区域中包含的所有点均得到优化，而关键帧的子集是固定的。 在姿态优化，或者motion-only BA，（见V）将所有点固定，仅将优化相机姿态。</p>
</li>
<li><p>Sim（3）约束下的姿势图优化[6]：给定二进制边的姿势图（请参阅第VII-D节）我们将误差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101171244797.png#pic_center"></p>
<p>其中，$S_{ij}$是在姿势图优化并将比例因子设置为1之前，从SE（3）姿势计算出的两个关键帧之间的相对Sim（3）变换。在闭环边的情况下，该相对变换通过Horn角[42]的方法。 $log_{Sim3}$ [48]转换为切线空间，因此误差是$R^7$维的向量。 目标是“优化Sim（3）关键帧姿势，以最小化损失”功能：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101171657388.png#pic_center"></p>
<p>其中$Λ_{i; j}$是边缘的信息矩阵，如[48]所示，我们将其设置为恒等式。 我们修复了回路闭合关键帧，以修复7度规的自由度。 尽管“此方法”是完整BA的粗略近似，但我们在VIII-E节中通过实验证明，它比BA具有显着更快和更好的收敛性。</p>
</li>
</ul>
<ul>
<li>Relative Sim(3) Optimization<br>给定关键帧1和关键帧2之间的一组n个匹配$i\leftrightarrow j$（关键点及其关联的3D映射点），我们要优化相对Sim（3）变换$S_{12}$（请参见VII-B部分），以最大程度地减小图像间重投影误差：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101172300914.png#pic_center"><br>最小化损失函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101172336172.png#pic_center"><br>其中$Ω_{1; i}$和$Ω_{2; i}$是与比例相关的协方差矩阵，与图像1和图像2中的关键点的方差有关。 在此优化中点是固定的。</li>
</ul>
<blockquote>
<p>参考：<br><a href="http://www.jintiankansha.me/t/SlssOSIu57" target="_blank" rel="noopener">【泡泡机器人翻译专栏】ORB-SLAM：精确多功能单目SLAM系统(一)</a><br><a href="https://www.sohu.com/a/161346283_715754" target="_blank" rel="noopener">【泡泡机器人翻译专栏】ORB-SLAM：精确多功能单目SLAM系统(二)</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>ORB-SLAMB2——论文翻译（ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras）</title>
    <url>/2019/10/31/ORB-SLAMB2%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>ORB-SLAM2是基于单目，双目和RGB-D相机的一套完整的SLAM方案。它能够实现地图重用，回环检测和重新定位的功能。无论是在室内的小型手持设备，还是到工厂环境的无人机和城市里驾驶的汽车，ORB-SLAM2都能够在标准的CPU上进行实时工作。ORB-SLAM2在后端上采用的是基于单目和双目的光束法平差优化（BA）的方式，这个方法允许米制比例尺的轨迹精确度评估。此外，ORB-SLAM2包含一个轻量级的定位模式，该模式能够在允许零点漂移的条件下，利用视觉里程计来追踪未建图的区域并且匹配特征点。我们用29个广泛使用的公共数据测试的结果显示，在大多数情况下，本文方案比此前方案精度更高，此外，我们开源了ORB-SLAM2源代码，不仅仅是为了整个SLAM领域，同时也希望能够为其他领域研究者提供一套SLAM的解决方案。</p><a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>SLAM（同时定位与地图重建）在过去的20年中，一直是计算机视觉和机器人领域的热门话题，同时也吸引了很多高科技公司的关注。SLAM技术是在未知的环境当中建立一个地图并且能够在地图当中实时的定位。在不同类型的传感器当中，相机十分廉价，并且能够提供丰富的环境信息，受到研究者的青睐。相机提供的图像信息可以用作鲁棒的和精确的位置识别。位置识别是SLAM系统中回环检测的关键模块（例如，当传感器检测到一个已经建好图的位置的时候，可以进行修正在探索过程中的误差）以及，能够修正由于剧烈的震动或者在系统进行初始化的时候在相机跟踪失败后的重新定位。因此以相机为核心的视觉SLAM在过去的一年中得到快速的发展。 </p>
<p>   视觉SLAM仅仅通过一个单目相机就能够完成。单目相机也是最便宜也是最小巧的传感器设备。然而深度信息无法从单目相机中观测到，地图的尺度和预测轨迹是未知的。此外，由于不能从第一帧当中进行三角测量化，单目视觉SLAM系统的启动往往需要多个视角或者滤波技术才能产生一个初始化的地图。最后，单目SLAM可能会造成尺度漂移,以及在探索的过程中执行纯旋转的时候可能会失败。通过使用一个双目或者RGB-D相机将会解决这些问题，并且能够成为一种更加有效的视觉SLAM的解决方案。</p>
<p> 在这篇文章当中，我们在单目ORB-SLAM[1]的基础上提出ORB-SLAM2，有以下贡献：</p>
<pre><code>1. 这是首个基于单目，双目和RGB-D相机的开源SLAM方案，这个方案包括，回环检测，地图重用和重定位。
2. 我们的RGB-D结果说明，光速法平差优化（BA）比ICP或者光度和深度误差最小方法的更加精确。
3. 通过匹配远处和近处的双目匹配的点和单目观测，我们的双目的结果比直接使用双目系统更加精确。
4. 针对无法建图的情况，提出了一个轻量级的定位模式 ，能够更加有效的重用地图。
</code></pre><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031172843722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图1中显示的是双目和RGB输入下的ORBSLAM2的输出。双目例子显示的是最后轨迹和稀疏重建的地图。这里的数据集来源于KITTI的Sequence00数据集。这个城市数据集是ORB-SLAM2多次成功提取特征，并且回环检测而来。RGB-D例子是来源于TUM 的RGB-D 数据库中的fr1_room的数据集，并且进行关键帧的位姿评估而来。通过评估关键帧的位姿，映射深度图，最终形成一个稠密的点云图。指的注意的一点是，ORB-SLAM2虽不像Kinect Fusion一样进行数据融合，但是却能够很精确的估计关键帧的位姿。更多的例子在附件视频中展示。<br>在余下的篇章当中，我们将会在第二部分讨论相关的工作。在第三部分谈论ORB-SLAM2系统框架。第四部分评价ORB-SLAM2，第五部分得出结论。</p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>在这个章节，我们将会讨论双目和RGB-D SLAM的相关工作。评估部分我们放在第四部分，本章我们主要讨论的是SLAM的方法。</p>
<h2 id="A-双目SLAM"><a href="#A-双目SLAM" class="headerlink" title="A.双目SLAM"></a>A.双目SLAM</h2><p>最早研究双目SLAM方案的是Paz 等人，基于条件独立分割和扩展SLAM，其显著特点是能够在大场景中运行。更重要的是，这是第一个使用近特征点和远特征点（例如，由于双目相机差异较小，导致点的深度不能准确的估计）的双目SLAM系统，使用一个逆深度参数进行估计。经验值表明如果深度小于40倍双目的基线，那么这个点就能被三角测量化。我们就是跟随的这样思想来处理远近不同的特征点，具体解释放在第三部分。<br>最早研究双目SLAM方案的是Paz 等人[5]，基于条件独立分割和扩SLAM，其显著特点是能够在大场景中运行。更重要的是，这是第一个使用近特征点和远特征点（例如，由于双目相机差异较小，导致点的深度不能准确的估计）的双目SLAM系统，使用一个逆深度参数进行估计。经验值表明如果深度小于40倍双目的基线，那么这个点就能被三角测量化。我们就是跟随的这样思想来处理远近不同的特征点，具体解释放在第三部分。Engel等人[11]提出邻近双目LSD-SLAM方案，采用的是一种直接的半稠密方法，最小化高梯度的图像区域中的光度误差。这种方法希望能够在不依赖特征提取的条件下，能够在纹理不清或者模糊运动的过程中获得更高的鲁棒性。然而，直接法的性能会由于滚动（卷帘）快门，或者非朗伯反射的未建模的因素影响而下降。</p>
<h1 id="B-RGB-D-SLAM"><a href="#B-RGB-D-SLAM" class="headerlink" title="B.RGB-D SLAM"></a>B.RGB-D SLAM</h1><p>最早和最著名的RGB-DSLAM系统是有Newcombe等人[4]提出的KinectFusion，这种方法将深度数据进行融合，深度数据来源于传感器到深度模型，常常使用ICP算法来跟踪相机的位姿。由于体积的表现形式和缺乏回环检测，这种算法只能工作在小的工作空间。Whelan 等人[12]提出的Kintinuous能够在大环境中运行。它通过使用一个滚动循环缓冲器和包括使用位置定位和位姿优化来达到回环检测的目的。</p>
<p>或许第一个开源的RGB-DSLAM方案是由Endres[13]提出的，这是一种基于特征点提取的系统，他的前端采用提取和匹配特征点和ICP来计算帧与帧之间的运动。后端采用位姿图优化的方式，回环检测约束条件来源于一个启发式搜索。相似的是，Kerl 等人[14]提出的DVO-SLAM，是在关键帧与关键帧之间的优化位姿图，视觉里程计通过计算最小化光度和深度误差来计算约束条件。DVO-SLAM同时在以前的所有帧当中，搜索回环的候选者，而不依赖于位置识别。</p>
<p>Whelan等人[15]提出的邻近ElasticFusion算法，是建立在基于确定环境的地图。这是一种以地图为中心的方法。这种方法忽略了非刚性形变地图的位姿和回环检测的性能，也是不是一个标准的位姿图优化。这种方法在重建和定位的精度都是十分优秀的，但是目前的应用十分有限对于一个房间大小的地图，由于在地图当中面元的数量影响计算的复杂程度。</p>
<p>Strasdat等人[8]提出ORB-SLAM2这种方法，这个方法使用深度信息去合成一个三维坐标，能够精确的提取到一副图像的信息。ORB-SLAM2能够处理来自双目和RGB-D的图像，与上述方法不同的是，我们的后端是用的BA算法，来建立一个全局的稀疏的地图重建，因此我们的方法更加轻量级并且能够在标准的CPU上面运行。我们的目标是长时间并且全局精准定位，而不是建立一个有很多细节的稠密地图。然而，高精度的关键帧的位姿，能够融合深度图像以及在计算中得到精准的重建，或者能够处理所有的关键帧和深度图，以及所有的BA并且得到一个精准的3D模型。</p>
<h1 id="ORBSLAM2"><a href="#ORBSLAM2" class="headerlink" title="ORBSLAM2"></a>ORBSLAM2</h1><p>针对双目相机和RGB-D相机的ORB-SLAM2建立在单目ORB-SLAM的基础上，它的核心组件，如图2所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031210057222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图2 ORB-SLAM2由三个平行的线程组成，跟踪，局部建图和回环检测。在一次回环检测后，会执行第四个线程，去执行BA优化。跟踪的线程在双目或者RGB-D输入之前进行，因此剩下的系统模块能够跟传感器模块独立运行。单目的ORB-SLAM2工作图也是这幅图。</p>
<p>这个系统主要有3个并行的线程：</p>
<blockquote>
<p>1、通过寻找对局部地图的特征，并且进行匹配，以及只运用BA算法来最小化重投影误差，进行跟踪和定位每帧的相机。<br>2、运用局部的BA算法设置局比地图并且优化。<br>3、回环检测检能够通过执行位姿图的优化来更正累计漂移误差。在位姿优化之后，会启动第四个线程来执行全局BA算法，来计算整个系统最优结构和运动的结果。<br>这个系统是一个基于DBoW2[16]的嵌入式位置识别模型，来达到重定位，防止跟踪失败（如遮挡），或者已知地图的场景重初始化，和回环检测的目的。这个系统产生关联可见的图[8]，连接两个关键帧的共同点，连接所有关键帧的最小生成树方面。这些关键帧的图结构能够得到一个关键帧的局部的窗口，以便于跟踪和局部建图，并且在大型的环境当中的回环检测部分，作为一种图优化的结构。</p>
</blockquote>
<p>这个系统使用相同的ORB特征进行跟踪，建图和位置识别的任务。这些特征在旋转不变和尺度不变性上有良好的鲁棒性，同时对相机的自动增益，曝光和光线的变化表现出良好的稳定性。并且能够迅速的提取特征和进行匹配，能够满足实时操作的需求，能够在基于词袋的位置识别过程中，显示出良好的精度[18]。</p>
<p>在本章的剩下的部分当中，我将会展示双目或者深度信息是如何利用，和到底会影响系统中的那些部分。对每个系统块更详尽的描述，可参见论文[1]</p>
<h2 id="单目、近处双目和远处双目特征点"><a href="#单目、近处双目和远处双目特征点" class="headerlink" title="单目、近处双目和远处双目特征点"></a>单目、近处双目和远处双目特征点</h2><p>ORB-SLAM2作为一种基于特征提取的方法，在一些关键的位置上的提取进行预处理，如图2b所示，系统的所有运行都是基于输入图像的特征展开，而不依赖于双目或者RGB-D的相机。我们的系统处理单目或者双目的特征点，分成远处特征点和近处特征点两类。</p>
<p>双目特征点 通过三个坐标$x_s=(u_L,v_L,u_R)$定义，$(u_L,v_L)$是这个左边图像的坐标，$u_R$是右图当中的水平坐标。对于双目相机而言，我们提取两幅图像当中的ORB特征，对于每个左边的ORB特征我们对其匹配到右边的图像中。这对于建设双目图像校正十分有效，因此极线是水平的。之后我们会在左边的图像产生双目的ORB特征点，和一条水平的线向右边的图像进行匹配，通过修补相关性来重新定义亚像素。对于RGB-D相机，正如Strasdat等人[8]所言，我们提取在RGB图像上提取ORB特征点，d对于每个特征坐标$(u_L,v_L)$，我们将其深度值d转换为实际正确的坐标<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031213345404.png#pic_center"><br>这里$f_x$是水平焦距，b是结构光投影器和红外相机的基线<br>我们估计kinect和华硕 Xtion 基线长大约是8cm。深度传感器的不确定性由实际右坐标的不确定性表示，这样，立体声和RGB-D输入的特征由系统的其余部分均等地处理。</p>
<p>近双目特征点的定义是：匹配的深度值小于40倍双目或者RGB-D的基线，否则的话，是远特征点。近的特征点能够从一帧的深度值能够三角测量化，是精确的估计，并且能够提供尺度，平移和旋转的信息。另外一方面，远的特征点，能够提供精确的旋转信息，但是很少的尺度和平移信息。当提供多视图的时候，我们才能三角化那些远的点。</p>
<p>单目的特征点通过右边图像的两个坐标$x_m=(u_L,v_L)$定义，必须保证所有的ORB特征是一致的，否则双目特征点的提取将不能够完整，或者在RGB-D的情况下，有产生一个无效的深度值。这些点仅能够从多视图中三角测量化并且不能够提供尺度信息，但是可以提供旋转和平移的估计信息。</p>
<h2 id="系统引导"><a href="#系统引导" class="headerlink" title="系统引导"></a>系统引导</h2><p>使用双目和RGB-D相机的主要优势在于，我们可以直接获得深度信息，我们不需要像单目情况中那样做一个特定的SFM初始化。在系统初始化的时候，我们就创造了一个关键帧（也就是第一帧），将他的位姿进行初始化，从所有的立体点中创造一个初始化地图。</p>
<p>3.3 使用单目或者双目光束优化法</p>
<p>我们的系统采用光束优化法（BA），优化在跟踪过程（纯运动BA）中相机的位姿，优化本地窗口的关键帧和局部地图的特征点（局部BA），并且在回环检测之后优化所有的关键帧和特征点（全局BA）。我们在g2o当中使用Levenberg-Marquadt方法[19]。</p>
<p>纯运动BA，优化相机旋转矩阵R和位置t，最小化世界坐标系下匹配3D点云$X^i$和特征点$x^i$（单目的或双目的，其中）的重投影误差,要么<br>单目m∈R2或双目xi s∈R3，其中i∈X是所有匹配集合</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191031214735118.png#pic_center"><br>在这个式子当中，$\rho$是强健的Huber的cost函数，$\sum$是协方差矩阵，与关键点的规模有关。投影函数$\pi(.)$，单目的时候使用$\pi_m$，修正双目的时候用$\pi_s$，他们的定义如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101092309550.png#pic_center"><br>在这个式子$(f_x,f_y)$是焦距，$(c_x,c_y)$是主点，b是基线，所有的这些参数都是通过标定获得。<br>局部BA优化一系列可见的关键帧$\K_L$和所有在这些关键帧$P_L$的可见点，所有的其他关键帧$K_F$是，不在$K_L$，$P_L$观测点用于代价函数，但是在优化中是固定的。 将$X_k$定义为点之间的匹配集，这些点在$P_L$和关键帧k中的关键点上，优化问题如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101093927765.png#pic_center"><br>全局BA是局部光束法的一个特例，这个方法除了固定的来消除随机化的初始帧，所有的关键帧和地图中的点都会被优化</p>
<h2 id="闭环检测和全局BA"><a href="#闭环检测和全局BA" class="headerlink" title="闭环检测和全局BA"></a>闭环检测和全局BA</h2><p>回环检测有两步：首先，一个回环信息被确定检测到，然后利用这个回环纠正和优化位姿图。相比于单目的ORB-SLAM中可能出现尺度漂移的地方[20]，这个双目或者深度的信息将会使得尺度信息可观测。并且，几何校验和位姿图优化将不再需要处理尺度漂移，而且是基于刚体变换的，而不是基于相似性。<br>在ORB-SLAM2的位姿优化后，我们包含一个全局的BA优化，为了实现一个优化方案，我们必须采用一个独立的线程，允许系统能够持续的建图，并且检测到回环信息。但是这将会再次触发全局BA优化与当前地图的合成。如果在优化运行时检测到新的回环，我们将中止优化并继续关闭循环，这将再次启动全局的BA优化。当完整的BA结束时，我们需要将更新的关键帧子集和由完整BA优化的点与未更新的关键帧和在优化运行时插入的点合并。最后通过更新更新关键帧校正（例如，这个变换从未优化到已优化）到一个未更新关键帧通过生成树当中。根据校正参考帧来改造呢些未更新的特征点。</p>
<h2 id="关键帧的插入"><a href="#关键帧的插入" class="headerlink" title="关键帧的插入"></a>关键帧的插入</h2><p>ORB-SLAM2遵循在单目ORB-SLAM中提的法则，即经常插入关键帧并且剔除上一帧的冗余。在远近特征点的差异为我们插入一个新的关键帧提供了条件，这在大场景的条件下是至关重要的，如图3所示。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101095206294.png#pic_center"><br>图3 ＫITTI 01数据集的跟踪点。绿色的特征点深度小于40倍双目的基线，蓝色特征点大于40倍双目的基线，在这种数据集当中，需要插入大量的关键帧，以便于能够让近处的特征点更加精确的估计平移和尺度，远处的特征点来估计方向，但是不能够计算平移和尺度。</p>
</blockquote>
<p>在这样的环境中，我们需要一个大量的近点用以精确估计平移，因而如果这个被跟踪近点小于$\tau _t$并且这个帧将会创造$\tau _c$个新邻近特征点，这个系统将会插入一个新的关键帧，我们经验值认为，当$\tau _t=100$和$\tau _c=70$的条件下我们效果最好。</p>
<h2 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h2><p>ORB-SLAM2包括一个定位模式，该模式适用于轻量级以及在地图已知情况下长期运行，只要那个环境没有发生剧烈变化。在该模式中，局部建图和回环检测的线程中是停用的，并且这个相机始终都是在通过追踪进行重定位。在这个模式下，追踪模块使用视觉里程计进行匹配图像的点云。视觉里程计匹配在当前帧的ORB算子和由双目或者深度相机收集的3D点云。这些匹配使得在没有地图的区域也能够精确重新定位，但是漂移将会被累加。地图点云匹配要确保在一个已经存在的地图当中零漂移定位，这个模型在附带的video当中会显示。</p>
<h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>我们使用三个著名的数据集来评估ORB-SLAM2的算法的性能。我们在一台16G的RAM，Intel Core i7-4790的台式机运行，以低于传感器的帧率，对处理跟踪时间求平均。我们运行数据集5次，取中间值，来消除多线程系统的不确定性。我们开源了在运行这几个系统的数据集的方法包括标定具体操作实现。</p>
<h2 id="KITTI数据集"><a href="#KITTI数据集" class="headerlink" title="KITTI数据集"></a>KITTI数据集</h2><p>KITTI数据集包含双目数据，这些数据从一个正在高速公路上行驶的车上采集到的。这个双目传感器有约54厘米的基线并且在在1392*512像素上，以10Hz的采样速率进行采样，其中序列00,02,05,06，和09包含回环。我们的ORB-SLAM2能够检测出回环并且能够地图重用，除了09序列以外，09序列的回环只发生在尾端少数的几帧当中。表1显示在11个训练数据的结果，这是一个公开的真实数据，对比于原先的LSD-SLAM算法，我们展示了的双目SLAM系统测试数据结果。我们使用两个不同的米制，均方根误差(RMSE)$t_{abs}$在论文[3]中提到，并且取平均相关平移$t_{rel$和旋转误差$r_{rel}$在论文[2]，我们的系统在数据集大多数序列中都优于双目LSD-SLAM，并且总体而言，相对误差低于1％。序列01（参见图3）是训练集中唯一的高速公路序列，平移误差稍差一些。 由于高速和低帧频，很难追踪到几乎所有的闭合点，因此在数据集这个序列中很难估计平移。。然而这个方向能够被精确的评估，获得的误差是每100米做0.21度。很多较远的点能够被检测，如图4所示，显示了一些评估的例子。</p>
<blockquote>
<p>表一 KITTI数据集精度的比较<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101101839858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101102024770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图4 在KITTE数据集01,05,07和08，估计轨迹（黑色线）和以及实际运动（红色线）</p>
</blockquote>
<p>与[1]中提出的单目结果相比，提出的双目版本能够处理单目系统处理失败的序列01。 在此高速公路序列中，请参见图3，仅在几帧的情况下才能看到近点。 双目版本有仅从一个双目关键帧创建点的能力，而不是通过在两个关键帧的匹配而导致的单目延迟初始化的能力，在此序列中至关重要，不能丢失跟踪。 而且，双目系统以公制比例尺估计地图和轨迹，并且不会受到比例尺偏移的影响，如图5所示。</p>
<blockquote>
<p>在KITTI数据集08估计轨迹（黑色线）和以及实际运动（红色线）左：单目ORB-SLAM [1]，右：ORB-SLAM2（双目）。 单目ORBSLAM在此序列中有严重的标度漂移，尤其是在转弯处。 相比之下，提出的双目版本能够估计轨迹和地图的真实比例，而不会出现比例漂移。<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101103033691.png#pic_center"></p>
<h2 id="EuRoC-数据集"><a href="#EuRoC-数据集" class="headerlink" title="EuRoC 数据集"></a>EuRoC 数据集</h2><p>EuRoC 数据集包含了11个双目的序列，通过一个微型飞行器（MAV）采集到的数据，飞行在两个不同的房间和大量的工业环境。这个双目传感器有一个约11cm的基线和能够提供20HZ的WVGA格式的图像，这个序列分成，简单、中等、和困难，这取决于MAV（微型飞行器）的速度，照明和场景的纹理。在所有的序列当中，MAV（微型飞行器）再次访问这个环境的时候，ORB-SLAM2能够重用地图，回环检测当有必要时。这个表格2显示的是ORB-SLAM2的最小均方误差(RMSE)的绝对值变换，对于所有序列而言。相比较对双目的LSD-SLAM的结果。ORB-SLAM2能够实现一个厘米级精准的定位，并且比双目的LSD-SLAM更加的精确。由于一些运动模糊，在V2_ 03_ difficul序列中跟踪丢失。在论文[22]]，这个序列在处理过程中是使用IMU信息，如图5所示，显示的一些相比实际运动的估计轨迹的例子。<br>表2 EUROC数据集<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101103818187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104359603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>在EuRoCV1_02_medium, V2_02_medium, MH_03_medium, and MH_05_difficult数据集测试的估计轨迹（黑色线）和以及实际运动（红色线）</p>
<h2 id="TUM-RGB-D-Dataset"><a href="#TUM-RGB-D-Dataset" class="headerlink" title="TUM RGB-D Dataset"></a>TUM RGB-D Dataset</h2><p>TUM RGB-D数据集包含一些室内的序列，在不同的纹理下，不同的光照和不同的结构条件，从RGB-D传感器采集到的数据中分别去评估物体的重建和SLAM/视觉里程计的性能。和大多数RGB-DSLAM方法一样，我们将实验结果展示在一个序列子集当中，在表格3当中，我们比较我们的精准性和其他方法，例如ElasticFusion，Kintinuous，DVO-SLAM以及RGB-DSLAM，ORB-SLAM2是唯一一种基于光束流差法，并且比其他的方法都更加优秀。我们已经注意到RGB-DSLAM，深度地图对于freiburg2序列有一个4%的尺度误差，误差可能来自错误的标定，我们已经在运行过程中，进行了一定程度的补偿。这能够部分解释我们取得好的结果的原因。图6显示的点云的结果来源于后端映射的传感器深度的地图，从计算关键帧的位姿在四个序列当中。实验的结果显示，ORB-SLAM2很好的展示了桌子和海报的轮廓线，以及高精度的重定位。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104655260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191101104722466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>图6 TUM RGB-D数据的fr3office, fr1 room, fr2 desk and fr3 nst 序列的通过评估关键帧的位姿和深度图进行稠密的点云重建图</p>
</blockquote>
<h2 id="时序结果"><a href="#时序结果" class="headerlink" title="时序结果"></a>时序结果</h2><p>为了完成对所提出系统的评估，我们在表IV中列出了三个时序的时序结果，这些时序具有不同的图像分辨率和传感器。显示了每个线程任务的平均值和两个标准偏差范围。由于这些序列包含一个循环，因此全局BA和回环检测线程的某些任务仅执行一次，并且仅报告一次测量。每帧的平均跟踪时间低于每个序列的相机帧频的倒数，这意味着我们的系统能够实时工作。由于将双目图像中的ORB提取并行化，因此可以看出，在V2_02的立体声WVGA图像中提取1000个ORB特征类似于在fr3_office的单个VGA图像通道中提取相同数量的特征。回环中关键帧的数量显示为与回环检测有关的时间的参考。虽然KITTI 07中的回环包含更多关键帧，但为室内fr3_office构建的可见性图更加密集，因此，回环融合，姿态图优化和全局BA任务更加昂贵。可见性图的较高密度使本地地图包含更多关键帧和点，因此，本地地图跟踪和局部BA也更加昂贵。</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019110111103884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文呈现了一个基于于单目，双目和RGB-D传感器的完整SLAM框架，在实时和标准的CPU的前提下能够进行重新定位和回环检测，以及地图的重用。在实验当中，我们关心的是在大场景中建立可用的地图和长期的定位。所提出的具有系统重新定位功能的定位模式可为已知环境提供一种非常健壮，零漂移和轻量级的定位方法。此模式对于某些应用程序可能很有用，例如在映射良好的空间中跟踪虚拟现实中的用户视点。与最新技术的比较表明，ORB-SLAM2在大多数情况下都可以达到最高的精度。</p>
<p> 与最新技术的比较表明，ORB-SLAM2在大多数情况下都可以达到最高的精度。在KITTI视觉里程表测试中，ORB-SLAM2是目前最佳的双目SLAM解决方案。至关重要的是，与近年来兴起的立体视觉测距法相比，ORB-SLAM2在已经构建的地图中实现了零漂移定位。</p>
<p>出乎意料的是，我们的RGB-D结果表明，如果相机的定位精度更好，则BA性能要优于直接法或ICP，并且具有计算成本更低，不需要GPU处理实时运行的额外优势。</p>
<p>我们已经发布了系统的源代码，包括示例和说明，以便其他研究人员可以轻松使用。就我们所知，ORB-SLAM2是第一个可与单目，双目和RGB-D使用的开源视觉SLAM系统。此外，我们的源代码包含一个使用单目相机的增强现实应用程序2，以展示我们解决方案的潜力。<br>举例来说，将来的发展可能包括不重叠的多相机，鱼眼镜头或全景相机，大规模稠密融合，协作建图或增强的运动模糊鲁棒性</p>
]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>ORB-SLAM2</tag>
      </tags>
  </entry>
  <entry>
    <title>VINs-Mono——闭环检测</title>
    <url>/2019/10/31/VINs-Mono%E2%80%94%E2%80%94%E9%97%AD%E7%8E%AF%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>18.删除链表中的节点</title>
    <url>/2019/10/31/18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在O(1)时间删除链表结点。</p><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表节点与函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>       m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>删除一个节点的两种方法：</p><a id="more"></a>



<p>比如删除链表中的的节点i，j为i的下一个节点</p>
<ol>
<li><p>先从链表中的头结点遍历到i前面的一个节点，把h的m_pNext指向i的下一个节点j,再删除节点i，时间复杂度$O(n)$</p>
</li>
<li><p>把节点j的内容复制覆盖节点i，接下里再把节点i的m_pNext指向j的下一个节点，再删除节点j（把j移到i)，时间复杂度$O(1)$</p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">三种情况： </span><br><span class="line"><span class="number">1.</span> 节点是头节点且只有这一个节点                          </span><br><span class="line"><span class="number">2.</span> 节点是尾节点                          </span><br><span class="line"><span class="number">3.</span> 节点是链表中的某个节点</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">        *pListHead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;            </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">description</span></span><br><span class="line"><span class="string">    题目： 删除链表中的节点</span></span><br><span class="line"><span class="string">    1.在O（1）时间内删除链表节点</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这里我们首先定义一个链表的类</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, next = None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = next</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_node_in_o1_time</span><span class="params">(self, p, head)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param p: linknode</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        这里一共有三种情况： 节点是头节点且只有这一个节点</span></span><br><span class="line"><span class="string">                          节点是尾节点</span></span><br><span class="line"><span class="string">                          节点是链表中的某个节点</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> p == head <span class="keyword">and</span> p.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> p.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            q = head</span><br><span class="line">            <span class="keyword">while</span> q.next <span class="keyword">is</span> <span class="keyword">not</span> p:</span><br><span class="line">                q = q.next</span><br><span class="line">            q.next = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        q = p.next</span><br><span class="line">        p.value = q.value</span><br><span class="line">        p.next = q.next</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_lnode</span><span class="params">(self, lst)</span>:</span></span><br><span class="line">        head = linkNode(lst[<span class="number">0</span>])</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)):</span><br><span class="line">            p.next = linkNode(lst[i])</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_lnode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(p.value)</span><br><span class="line">            p = p.next </span><br><span class="line"> </span><br><span class="line">s = Solution()</span><br><span class="line">head = s.gen_lnode([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">p = head.next.next</span><br><span class="line">s.delete_node_in_o1_time(p, head)</span><br><span class="line">s.print_lnode(head)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>高斯分布与边缘化</title>
    <url>/2019/10/30/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8E%E8%BE%B9%E7%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h1><p>高斯分布有两种表达方式：</p><ul>
<li>协方差矩阵+均值</li>
<li>信息矩阵+信息矢量</li>
</ul><p>协方差矩阵+均值的方式比较常见，如下</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152615298.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152644545.png#pic_center"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030152656564.png#pic_center"></p><p>左边常数项记为$η$，$p(x)$可以记为：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200301827.png"></p><p>其中对称正定矩阵$Σ$为随机变量x的协方差矩阵，μ为x的均值，简记为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200243950.png"></p><p>信息矩阵+信息矢量的形式可以由上式推导而来</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200156360.png"></p><p>现在定义信息矩阵$Ω=Σ^{−1}$ ，信息矢量$ξ=Σ^{−1}μ=Ωμ$，则</p><a id="more"></a>











<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030200137498.png"></p>
<h1 id="联合高斯分布的分解"><a href="#联合高斯分布的分解" class="headerlink" title="联合高斯分布的分解"></a>联合高斯分布的分解</h1><p>设随机变量$x_a,x_b$满足联合高斯分布$p(x_a,x_b)$<br>由条件概率公式可知</p>
<script type="math/tex; mode=display">p(x_a,x_b)=p(x_a)p(x_b∣x_a)</script><p>联合高斯函数的分解就是根据$p(x_a,x_b)$求出上式中的$p(x_a)$和$p(x_b∣x_a)$</p>
<h2 id="协方差矩阵-均值"><a href="#协方差矩阵-均值" class="headerlink" title="协方差矩阵+均值"></a>协方差矩阵+均值</h2><p>假设多元变量x服从高斯分布，且由两部分组成： $x = [x_a \  x_b]^T$，变量x的概率分布为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204045547.png#pic_center"></p>
<p>其密度函数可写为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204101961.png#pic_center"></p>
<p>利用舒尔补对高斯分布进行分解：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204114634.png#pic_center"></p>
<p>将上式带入$p(x_a,x_b)$的概率密度函数，并注意到对任意矩阵<em>K</em>，有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020412790.png#pic_center"></p>
<p>可以得到:</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204144966.png#pic_center"></p>
<p>其中:</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204202528.png#pic_center"></p>
<p>由此可看出，$p(x_a)$是均值为$μ_a$，协方差矩阵为$Σ_{aa}$的高斯分布，记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204216952.png#pic_center"></p>
<p>同时，$p(x_b∣x_a)$是均值为$μ_b+Σ_{ba}Σ_{aa}^{−1}(x_a−μ_a)$，协方差矩阵为$Θ_{bb}$的高斯分布，记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204250870.png#pic_center"></p>
<h2 id="信息矩阵-信息矢量"><a href="#信息矩阵-信息矢量" class="headerlink" title="信息矩阵+信息矢量"></a>信息矩阵+信息矢量</h2><p>$p(x_a,x_b)$以信息矩阵+信息矢量的形式给出，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204311535.png#pic_center"></p>
<p>通过信息矢量与信息矩阵，可以计算出该分布的均值</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204324848.png#pic_center"></p>
<p>因此该分布的概率密度函数可写为（注意到信息矩阵与协方差矩阵为互逆关系）</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204348310.png#pic_center"></p>
<p>为了求出$p(x_a)$和$p(x_b∣x_a)$的表达式，需要再次用到舒尔补（Schur Complement），不过作用对象与之前不同，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204403932.png#pic_center"></p>
<p>将上式带入$p(x_a,x_b)$的密度函数中，并令$Ω_{aa}−Ω_{ab}Ω_{bb}^−1Ω_{ba}=Λ_{aa}$，可得</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204423266.png#pic_center"></p>
<ul>
<li><p>$p(x_a)$是一个均值为$μ_a$，协方差矩阵为$Λ_{aa}^{−1}$的高斯分布</p>
</li>
<li><p>$p(x_b∣x_a)$是一个均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，协方差矩阵为$Ω_{bb}^{−1}%$的高斯分布。</p>
</li>
</ul>
<p>$p(x_a)$的均值为$μ_a$，信息矩阵为$Λ_{aa}$，对应的信息矢量为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910302044559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>所以$p(x_a)$完全使用信息矩阵+信息矢量的形式可记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020452532.png#pic_center"></p>
<p>同理：</p>
<p>$p(x_b∣x_a)$均值为$μ_b−Ω_{bb}^{−1}Ω_{ba}(x_a−μ_a)$，信息矩阵为$Ω_{bb}$的高斯分布，对应的信息矢量为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204543853.png#pic_center"><br>$p(x_b∣x_a)$完全使用信息矩阵+信息矢量的形式可以记为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204557435.png#pic_center"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>边际概率对于协方差矩阵的操作是很容易的，但不好操作信息矩阵。条件概率恰好相反，对于信息矩阵容易操作，不好操作协方差矩阵。表格总结如下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204611958.png#pic_center"></p>
<p>根据协方差矩阵与信息矩阵的互逆关系，从上表还可以得出如下一组关系</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204627632.png#pic_center"></p>
<h2 id="边缘化与条件化"><a href="#边缘化与条件化" class="headerlink" title="边缘化与条件化"></a>边缘化与条件化</h2><p>所谓边缘化，就是求某个联合概率分布的边缘分布。比如对于联合概率$p(x_a,x_b)$，对$x_b$进行边缘化，就是对$x_b$在整个空间中积分，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204650325.png#pic_center"></p>
<p>由贝叶斯公式可知</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204702487.png#pic_center"></p>
<p>伴随着边缘化，$p(x_b∣x_a)$就是$p(x_a,x_b)$对$x_a$的条件化。</p>
<p>在信息矩阵+信息矢量的表示方式下，边缘化和条件化与最小二乘法有密切关系。在许多基于最小二乘的优化问题中，常有如下形式的优化目标：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204718621.png#pic_center"></p>
<p>为了寻找上式的最小值，常使用迭代优化的方法，每一次迭代都会寻找一个增量Δx使目标函数减小。为了求增量，往往会将e(x)在当前<em>x</em>x处展开为一阶近似（这种处理方式即Gauss-Newton Method），即<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204730880.png"></p>
<p>则优化的目标变为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019103020474264.png#pic_center"></p>
<p>这是关于Δx的二次函数，对Δx求导，并令导数等于0，有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204755898.png#pic_center"></p>
<p>即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204808181.png#pic_center"></p>
<p>令$J(x)^TW^{−1}J(x)=Ω$，表示变量Δ<em>x</em>Δx的信息矩阵，令−$J(x)^TW^{−1}e(x)=ξ$，表示信息矢量，则有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204822240.png#pic_center"></p>
<p>以上就是非线性优化时，每次都要求解的线性方程。</p>
<p>在很多优化问题中，待优化的变量有明确意义，比如在SLAM或者SfM问题中，要优化的是所有相机的位姿<em>p</em>p以及地图中所有三维点的坐标<em>m</em>m，设Δ<em>x</em>Δx由这两个分量的增量构成，即</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204837435.png#pic_center"></p>
<p>同时设</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204848663.png#pic_center"></p>
<p>则有</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204900849.png"></p>
<p>为了简化以上方程的求解，往往使用高斯消元法，具体的，对以上方程等式两边左乘</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204917817.png"></p>
<p>可得</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204930919.png#pic_center"></p>
<p>于是原方程可以转换为两个独立方程</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030204940320.png#pic_center"></p>
<p>可以发现，Δp的系数矩阵和等号右边的结果，与上文中高斯分布$p(x_a)$的信息矩阵和信息矢量有相同的形式。而Δm的系数矩阵和等号右边的结果，则与高斯分布$p(x_b∣x_a)$的信息矩阵和信息向量有相同形式</p>
<p>也就是说，这里的高斯消元法，等价于对变量Δx做了边缘化，先将Δm边缘化掉，单独求Δp，然后再在Δp已知的情况下求Δm。</p>
<p>参考：<a href="https://blog.csdn.net/AIchipmunk/article/details/86185248" target="_blank" rel="noopener">高斯分布与边缘化</a> </p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>舒尔补</title>
    <url>/2019/10/30/%E8%88%92%E5%B0%94%E8%A1%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>舒尔补定义<br>给定任意的矩阵块 M，如下所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030155959352.png"><ul>
<li>如果矩阵块 D 是可逆的，则$A − BD^{−1}C$称之为D关于M的舒尔补</li>
<li>如果矩阵块 A 是可逆的，则$D − CA^{−1}B$称之为A关于 M的舒尔补</li>
</ul>
</li>
</ul><p>将 M 矩阵变成上三角或者下三角形过程中，都会遇到舒尔补：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160209537.png"></p><p>其中：$∆A=D − CA^{−1}B$。联合起来，将 M 变形成对角形：</p><a id="more"></a>



<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160250360.png"></p>
<p>矩阵 M 的逆为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191030160322364.png"></p>
]]></content>
      <categories>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——后端优化</title>
    <url>/2019/10/29/VINs-Mono%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="状态向量"><a href="#状态向量" class="headerlink" title="状态向量"></a>状态向量</h1><p>VIO 紧耦合方案的主要思路就是通过将基于视觉构造的残差项和基于 IMU 构造的残差项放在一起构造成一个联合优化的问题，整个优化问题的最优解即可认为是比较准确的状态估计。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192151582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>为了限制优化变量的数目， VINS-Mono 采用了滑动窗口的形式， 滑动窗口中的全状态量包括滑动窗口内的n+1个关键帧时刻 IMU 坐标系的位置、姿态、姿态（旋转）、加速度计偏置、陀螺仪偏置， Camera 到 IMU 的外参， m +1个 3D 路标点的逆深度：</p><a id="more"></a>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192802133.png#pic_center"></p>
<p>优化过程中的误差状态量为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192821349.png#pic_center"></p>
<h1 id="代价函数（Minimize-residuals-from-all-sensors）"><a href="#代价函数（Minimize-residuals-from-all-sensors）" class="headerlink" title="代价函数（Minimize residuals from all sensors）"></a>代价函数（Minimize residuals from all sensors）</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029192917433.png#pic_center"></p>
<p>其中$P^{b_{k}}_{b_{k+1}}$ 为 IMU 预积分噪声项的协方差矩阵， $P^{c_j}_l$ 为视觉观测噪声的协方差矩阵。<br>三个残差项即误差项分别为边缘化的先验信息、 IMU 测量残差、视觉的重投影残差。三种残差都是用马氏距离表示。<br>根据高斯牛顿法求优化过程中最为核心的增量方程，以 IMU 测量残差为例，先将$r_{b}(\hat z^{b_k}_{b_{k+1}},\chi )$进行一阶泰勒展开</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194020513.png#pic_center"></p>
<p>其中$H^{b_k}_{b_{k+1}}$是雅可比矩阵</p>
<p>等号右边关于$\delta x$的导数，并令其为 0，得到增量方程：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029194351591.png#pic_center"></p>
<p>那么可以写出函数对应的增量方程：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195011958.png#pic_center"></p>
<p>增量方程可进一步简化为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195045773.png#pic_center"></p>
<p>其中$\wedge _p$，$\wedge _B$，$\wedge _C$为（近似的） Hessian 矩阵，上述方程称之为增量方程。</p>
<h1 id="IMU-测量约束"><a href="#IMU-测量约束" class="headerlink" title="IMU 测量约束"></a>IMU 测量约束</h1><h2 id="IMU-测量残差"><a href="#IMU-测量残差" class="headerlink" title="IMU 测量残差"></a>IMU 测量残差</h2><p>根据上面的 IMU 预积分，得到 IMU <strong>预积分残差（估计值 - 测量值）</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029195522934.png#pic_center"></p>
<p>其中$[q]_{xyz}$表示提取四元数q的虚部，$[\hat \alpha^{b_k}_{b_{k+1}},\hat \beta ^{b_k}_{b_{k+1}},\hat \gamma ^{b_k}_{b_{k+1}}]^T$为关键帧$b_k$和关键帧$b_{k+1}$时间间隔内，仅仅使用含有噪声的加速度计和陀螺仪数据计算的预积分 IMU 测量项，$\delta \theta^{b_k}_{b_{k+1}}$是四元数误差的三维表示。</p>
<h2 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h2><p>对于两帧之间的 IMU 测量残差，待优化变量为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029200304722.png#pic_center"></p>
<h2 id="雅克比矩阵"><a href="#雅克比矩阵" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>高斯迭代优化过程中会用到 IMU 测量残差对状态量的雅克比矩阵，但此处我们是对误差状<br>态量求偏导</p>
<ul>
<li>对k时刻$[\delta p^w_{b_k},\delta \theta^w_{b_k}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201345442.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta v^w_{b_k},\delta b_{a_k},\delta \theta b_{w_{k}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201641707.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta p^w_{b_{k+1}},\delta \theta^w_{b_{k+1}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201652448.png#pic_center"></p>
<ul>
<li>对k时刻$[\delta v^w_{b_{k+1}},\delta b_{a_{k+1}},\delta \theta b_{w_{k+1}}]$求偏导数</li>
</ul>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029201704647.png#pic_center"></p>
<p>上面公式在代码中对应： class IMUFactor : public ceres::SizedCostFunction<15, 9 7, 9,>对于 Evaluate 输入 double const <em>const </em>parameters, parameters[0], parameters[1], parameters[2],parameters[3]分别对应 4 个输入参数, 它们的长度依次是 7,9,7,9， 分别对应 4 个优化变量的参数块。<br>代码 IMUFactor::Evaluate()中 residual 还乘以一个信息矩阵 sqrt_info， 这是因为真正的优化项其实是 Mahalanobis 距离： $d=r^TP^{−1}r$，P 是协方差，又因为 Ceres 只接受最小二乘优化， 也就是$min(e^Te)$所以把𝑃−1做 LLT 分解， 即$LL^T=P^{-1}$, 则有：</15,></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202424429.png#pic_center"></p>
<p>令$r’=L^Tr$作为新的优化误差, 这样就能用 Ceres 求解了。 Mahalanobis 距离其实相当于一个残差加权, 协方差大的加权小, 协方差小的加权大, 着重优化那些比较确定的残差。若写成“sqrt_info.setIdentity()”相当于不加权</p>
<h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>IMU 协方差 P 为前面推导的 IMU 预积分中迭代出来的 IMU 增量误差的协方差。</p>
<h1 id="视觉测量残差"><a href="#视觉测量残差" class="headerlink" title="视觉测量残差"></a>视觉测量残差</h1><p>视觉测量残差即 特征点的重投影误差，视觉残差和雅克比矩阵计算的对应代码在ProjectionFactor::E<br>函数中。</p>
<h2 id="重投影误差（视觉测量残差）"><a href="#重投影误差（视觉测量残差）" class="headerlink" title="重投影误差（视觉测量残差）"></a>重投影误差（视觉测量残差）</h2><p>对于第 i 帧中的特征点, 它投影到第 j 帧相机坐标系下的值为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202633785.png#pic_center"></p>
<p>拆写成三维形式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202722447.png"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202739798.png#pic_center"></p>
<p>为了后面方便求导Jacobian，对$P_{c_j}$拆解，定义如下变量</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029202916771.png"></p>
<p>视觉测量残差为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203023784.png#pic_center"></p>
<h2 id="优化变量-1"><a href="#优化变量-1" class="headerlink" title="优化变量"></a>优化变量</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203801125.png#pic_center"></p>
<h2 id="雅克比矩阵-1"><a href="#雅克比矩阵-1" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><p>根据视觉残差公式，我们可以得到相对于各优化变量的 Jacobian</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203923600.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203934216.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029203946932.png"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102920400339.png"></p>
<h2 id="协方差矩阵-1"><a href="#协方差矩阵-1" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>视觉约束的噪声协方差与标定相机内参时的重投影误差，也就是偏离几个像素有关， 代<br>码对应为 ProjectionTdFactor::sqrt_info， 这里取的 1.5 个像素，信息矩阵取根号后为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029204041242.png#pic_center"></p>
<h1 id="边缘化和FEJ"><a href="#边缘化和FEJ" class="headerlink" title="边缘化和FEJ"></a>边缘化和FEJ</h1><h2 id="Marginalization"><a href="#Marginalization" class="headerlink" title="Marginalization"></a>Marginalization</h2><p>然而，将 pose 移出 windows 时，有些约束会被丢弃掉，这样势必会导致求解的精度下降，而<br>且当 MAV 进行一些退化运动 (如: 匀速运动) 时，没有历史信息做约束的话是无法求解的。所以，<br>在移出位姿或特征的时候，需要将相关联的约束转变成一个约束项作为 prior 放到优化问题中，这<br>就是 marginalization 要做的事情。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191029213408596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>边缘化的过程就是将滑窗内的某些较旧或者不满足要求的视觉帧剔除的过程，所以边缘化也被描述为将联合概率分布分解为边缘概率分布和条件概率分布的过程 (就是利用 shur 补减少优化参数的过程)。</p>
<p>直接进行边缘化而不加入先验条件的后果：</p>
<blockquote>
<ol>
<li>无故地移除这些 pose 和 feature 会丢弃帧间约束，会降低了优化器的精度，所以在移除 pose和 feature 的时候需要将相关联的约束转变为一个先验的约束条件作为 prior 放到优化问题中</li>
<li>在边缘化的过程中，不加先验的边缘化会导致系统尺度的缺失 (参考 [6])，尤其是系统在进行退化运动时 (如无人机的悬停和恒速运动)。一般来说 只有两个轴向的加速度不为 0 的时候，才能保证尺度可观，而退化运动对于无人机或者机器人来说是不可避免的。所以在系统处于退化运动的时候，要加入先验信息保证尺度的可观</li>
</ol>
</blockquote>
<p>VINS 根据次新帧是否为关键帧，分为两种边缘化策略：</p>
<blockquote>
<ol>
<li>当次新帧为关键帧时，我们将 marg 掉最老帧，及其看到的路标点和相关联的 IMU<br>数据，将其转化为先验信息加到整体的目标函数中；</li>
<li>当次新帧不是关键帧时，我们将直接扔掉次新帧及它的视觉观测边，而不对次新帧进行 marg， 因为我们认为当前帧和次新帧很相似，也就是说当前帧跟路标点之间的约束和次新帧与路标点的约束很接近，直接丢弃并不会造成整个约束关系丢失过多信息。 但是值得注意的是，我们要保留次新帧的 IMU 数据，从而保证 IMU 预积分的连贯性</li>
</ol>
</blockquote>
<p>VINS 中的先验残差项的构造可以分为以下几个步骤： </p>
<blockquote>
<ol>
<li>把上一次先验项中的残差项传递给当前先验项，并从中去除需要丢弃的状态量</li>
<li>添加与当前需要丢弃的状态量相关的约束项；</li>
<li>通过函数 MarginalizationInfo::preMarginalize()得到每个残差项(cost_function)对应<br>的参数块(parameter_blocks)，雅可比矩阵(jacobians)，残差值(residuals)；</li>
<li>通过函数 MarginalizationInfo::marginalize()将步骤 3 中得到的雅可比矩阵和残差值<br>进行组合，得到整个先验项的参数块，雅可比矩阵和残差值</li>
</ol>
</blockquote>
<p>通过以上四步先验项就算构造完成了，在对滑动窗口内的状态量进行优化时，把它与IMU 残差项和视觉残差项放在一起优化，从而得到不丢失历史信息的最新状态估计的结果。</p>
<h2 id="边缘化和舒尔补"><a href="#边缘化和舒尔补" class="headerlink" title="边缘化和舒尔补"></a>边缘化和舒尔补</h2><p>根据前面讨论的基于高斯牛顿的非线性优化理论可知， 𝐻𝛿𝑥 = 𝑏可写成如下形式：</p>
<p><img alt="1572437838552" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437838552.png"></p>
<p>INS 中则真正需要边缘化掉滑动窗口中的最老帧或者次新帧，目的是希望不再计算这一帧的位姿或者与其相关的路标点，但是希望保留该帧对窗口内其他帧的约束关系。</p>
<p>上式中的$x_a$是我们要 marg 的变量，比如一个相机的 pose，因此我们更关心如何只去求解我们希望保留的变量$x_b$，而不再求解$x_a$，但是我们也希望直接将$x_a$和与其相关的路标点直接删除，因为这样会减少约束，丢失信息。因此，采用如下 Schur 进行消元：</p>
<p><img alt="1572437967596" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572437967596.png"></p>
<p>其中，$ Λ^𝑇_𝑏Λ^{-1}_𝑎Λ_𝑏$就称为Λ𝑎在Λ𝑏中的 Schur 项，那么有了上面式子，我们就可以直接计算$𝛿x_b$了：</p>
<p><img alt="1572438049891" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438049891.png"></p>
<p>上面的公式即为要保留变量𝑥𝑏的先验信息。</p>
<h2 id="滑动窗口中的-FEJ-算法"><a href="#滑动窗口中的-FEJ-算法" class="headerlink" title="滑动窗口中的 FEJ 算法"></a>滑动窗口中的 FEJ 算法</h2><p>随着 VSLAM 系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量将不断增加。</p>
<p>为了保持优化变量的个数在一定范围内，需要使用滑动窗口算法动态增加或移除优化变量</p>
<p>滑动窗口算法大致流程</p>
<ol>
<li>增加新的变量进入最小二乘系统优化</li>
<li>如果变量数目达到了一定的维度，则移除老的变量。</li>
<li>SLAM 系统 不断循环前面两步</li>
</ol>
<p>利用边际概率移除老的变量</p>
<p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量。</p>
<p><strong>example：</strong></p>
<p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量</p>
<p><img alt="1572438273296" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438273296.png"></p>
<p>marginalization 会使得信息矩阵变稠密！原先条件独立的变量，可能变得相关。</p>
<p><img alt="1572438402148" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438402148.png"></p>
<p><img alt="1572438422145" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438422145.png"></p>
<p>marg 前，变量 $x_m$ 以及对应测量$S_m$ 构建的最小二乘信息矩阵为：</p>
<p><img alt="1572438479585" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438479585.png"></p>
<p>marg 后，变量$x_m$的测量信息传递给了变量 $x_r$:</p>
<p><img alt="1572438555840" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438555840.png"></p>
<p>下标 p 表示 prior. 即这些信息将构建一个关于$x_r$ 的先验信息。</p>
<p><img alt="1572438612496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438612496.png"></p>
<p><strong>新测量信息和旧测量信息构建新的系统</strong></p>
<p><img alt="1572438683496" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438683496.png"></p>
<p><img alt="1572438702531" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438702531.png"></p>
<p><img alt="1572438724298" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438724298.png"></p>
<p><img alt="1572438749984" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572438749984.png"></p>
<p>参考：<br><a href="https://blog.csdn.net/weixin_44580210/article/details/95748091" target="_blank" rel="noopener">VINS-Mono关键知识点总结——边缘化marginalization理论和代码详解</a><br><a href="https://blog.csdn.net/weixin_44580210/article/details/93377806" target="_blank" rel="noopener">VINS-Mono关键知识点总结——预积分和后端优化IMU部分</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——初始化</title>
    <url>/2019/10/29/VINS-Mono%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="估计器初始化"><a href="#估计器初始化" class="headerlink" title="估计器初始化"></a>估计器初始化</h1><ul>
<li>初始化的原因是单目惯性紧耦合系统是一个非线性程度很高的系统，首先单目是无法获得空间中的绝对尺度，而IMU又必然存在偏置，在后面进行求解的时候还需要用到重力加速度（包括大小和方向），对于速度比较敏感的条件下，比如说无人机，又要精确的速度信息，因此，如何有效的在紧耦合系统处理之前计算出这些量，对整个紧耦合系统的鲁棒性有着重大的意义</li>
<li>初始化要做的事其实说起来很简单，就是计算出绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li>
<li>VINS-Mono 的初始化采用松组合（loosely coupled）的方式获取初始值。 首先用 SFM求解滑动窗口内所有帧的位姿（以第一帧作为参考坐标系）和所有路标点的 3D 位置。然后将 SFM 的结果与 IMU 预积分的值进行对齐，实现对陀螺仪偏置的校正，再求解每一帧对应的速度，求解重力向量方向，恢复单目相机的尺度因子。</li>
<li>需要注意的是，在初始化过程中，并没有对加速度计的偏置进行校正，这是因为重力是初始化过程中待求的量，而加速度计偏置与重力耦合，而且系统的加速度相对于重力加速度很小，所以加速度计偏置在初始化过程中很难观测，因此初始化过程中不考虑加速度计偏置的校正。</li>
</ul><a id="more"></a>
<h2 id="滑动窗口-Sliding-Window-纯视觉SfM"><a href="#滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="滑动窗口(Sliding Window)纯视觉SfM"></a>滑动窗口(Sliding Window)纯视觉SfM</h2><p>首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，使用五点法恢复这两个帧之间的相对旋转和尺度平移。否则，将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c_0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}_{c_k}，q^{c0}_{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。</p>
<p>纯视觉初始化时，我们采用第一帧 c0 作为基准坐标系，若要转化为从 body 坐标系到 c0坐标系，可以进行如下变换，其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"></p>
<p>上式推导如下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185549508.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028185607797.png#pic_center"></p>
<h2 id="B-视觉惯性校准（Visual-Inertial-Alignment"><a href="#B-视觉惯性校准（Visual-Inertial-Alignment" class="headerlink" title="B. 视觉惯性校准（Visual-Inertial Alignment)"></a>B. 视觉惯性校准（Visual-Inertial Alignment)</h2><h3 id="陀螺仪偏置标定"><a href="#陀螺仪偏置标定" class="headerlink" title="陀螺仪偏置标定"></a>陀螺仪偏置标定</h3><p>这 一 部 分 的 内 容 对 应 于 VINS-Mono 代 码 initial_aligment.cpp 中 的<br>solveGyroscopeBias()函数。<br>考虑滑动窗口中连续两帧$b_k$和$b_{k+1}$，我们从视觉sfM中得到旋转$q^{c0}_{b_k}$和$q^{c0}_{b_{k+1}}$，从IMU预积分得到的相对约束$γ^{b_k}_{b_{k+1}}$。<br>陀螺仪的误差有两部分测量噪声和陀螺仪偏置，噪声暂时可以忽略（毕竟太小），而视觉的误差就只有观测噪声（也可以忽略不管），因此两者差值的绝对值就是陀螺仪偏置，将整个滑动窗口的所有的旋转做差构成了一个最小化误差模型：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"></p>
<p>其中B代表窗口的所有帧。<br>$q^{c0}_{b_k}$$q^{c0}_{b_{k+1}}$：相机从$b_k$到$b_{k+1}$下的相对旋转<br>$γ^{b_k}_{b_{k+1}}$：陀螺仪从$b_{k+1}$到$b_k$下的相对旋转<br>第二个式子给出了$γ^{b_k}_{b_{k+1}}$对陀螺仪偏置的一阶近似。</p>
<p>因为四元数最小值为单位四元数 [1; 0v]T，所以</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171134242.png#pic_center"></p>
<p>只考虑虚部，则有：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028171213618.png#pic_center"></p>
<p>然后取最小二乘，当然也可以使用SVD分解等方法求解，得到了陀螺仪偏置$b_w$的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}_{b_{k+1}}、\hat β^{b_k}_{b_{k+1}}、\hat γ^{b_k}_{b_{k+1}}$ 。</p>
<h3 id="速度、重力向量和尺度初始化："><a href="#速度、重力向量和尺度初始化：" class="headerlink" title="速度、重力向量和尺度初始化："></a>速度、重力向量和尺度初始化：</h3><p>这一部分的内容对应于 VINS-Mono 代码 initial_aligment.cpp 中的 LinearAlignment()<br>函数<br>在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"></p>
<p>其中，$v^{b_k}_{b_k}$是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。<br>在$c_0$坐标系的预积分：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180200742.png#pic_center"></p>
<p>$p^{c_0}_{b_{k+1}}$和$p^{c_0}_{b_{k}}$可由视觉 SFM 获得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180301129.png#pic_center"></p>
<p>将此式带入上式得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028180458901.png#pic_center"></p>
<p>将等式中速度都转换到$c_0$ 坐标系下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181635823.png#pic_center"></p>
<p>将上式转换成$Hx=b$ 的形式，这样便于利用 cholesky 进行求解，由$s\bar p^{c_0}_{b_k}=p^{c_0}_{c_k}-R^{c_0}_{c_k}p_c^b$，带入上式得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181106531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>联力等式：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028181609102.png#pic_center"></p>
<p>即： $H^{6×10}X_I^{\ 10×1} = b^{6×1}$<br>H矩阵一定是一个正定对称矩阵，以采用快速的 Cholosky 分解下面方程求解$X_I$：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028182207166.png#pic_center"></p>
<p>可以得到滑动窗口中所有关键帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及单目尺度因子 s 。</p>
<h3 id="修正重力矢量"><a href="#修正重力矢量" class="headerlink" title="修正重力矢量"></a>修正重力矢量</h3><p>这里计算的重力吸收了重力加速度计的偏置，虽然不需要计算重力加速度计的偏置，但重力还是需要优化的，说到优化重力加速度，肯定包含两个量，大小和方向，也就是三个维度，但是一般来说大小是确定已知的（这里设为9.8），因此其实我们要做的就是优化方向，是一个两维的向量，下图是优化重力的方法以及b1,b2单位向量的方向确定模型。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>将重力向量重新参数化：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183144674.png#pic_center"></p>
<p>其中g是已知的重力大小，$\bar {\hat g}$是表示重力方向的单位向量，b1、 b2为重力向量正切空间的一对<br>正交基 ，如图所示，w1和w2分别是在b1和b2上的对应位移。<br>将上式代入前面式子中，重新整理可得：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183424735.png#pic_center"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183439415.png"></p>
<p>这样，可以用 Cholosky 分解下面方程求解$X_I$：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028183526590.png#pic_center"></p>
<p>完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028160032562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>直接从estimator.cpp中的 if (solver_flag == INITIAL) 开始</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (solver_flag == INITIAL) &#123;</span><br><span class="line">    <span class="comment">// 滑窗中的Keyframe达到指定大小的时候，才开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (frame_count == WINDOW_SIZE) &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_EXTRINSIC != <span class="number">2</span> &amp;&amp; (header.stamp.toSec() - initial_timestamp) &gt; <span class="number">0.1</span>) &#123;</span><br><span class="line">            result = initialStructure(); <span class="comment">//! 初始化</span></span><br><span class="line">            initial_timestamp = header.stamp.toSec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            solver_flag = NON_LINEAR;</span><br><span class="line">            solveOdometry();</span><br><span class="line">            slideWindow();</span><br><span class="line">            f_manager.removeFailures();</span><br><span class="line">            ROS_INFO(<span class="string">"Initialization finish!"</span>);</span><br><span class="line">            last_R = Rs[WINDOW_SIZE];</span><br><span class="line">            last_P = Ps[WINDOW_SIZE];</span><br><span class="line">            last_R0 = Rs[<span class="number">0</span>];</span><br><span class="line">            last_P0 = Ps[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            slideWindow();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        frame_count++;</span><br></pre></td></tr></table></figure>
<h3 id="initialStructure-视觉惯性联合初始化"><a href="#initialStructure-视觉惯性联合初始化" class="headerlink" title="initialStructure() 视觉惯性联合初始化"></a>initialStructure() 视觉惯性联合初始化</h3><ul>
<li>1.通过计算线加速度的标准差，检测IMU的可观性，以进行初始化<br>注意这里并没有算上all_image_frame的第一帧，所以求均值和标准差的时候要减一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 通过计算预积分加速度的标准差，检测IMU的可观性</span></span><br><span class="line"><span class="comment">//check imu observibility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算均值</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it;</span><br><span class="line">    Vector3d sum_g;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        sum_g += tmp_g;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector3d aver_g = sum_g * <span class="number">1.0</span> / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方差</span></span><br><span class="line">    <span class="keyword">double</span> var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (frame_it = all_image_frame.begin(), frame_it++; frame_it != all_image_frame.end(); frame_it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum_dt  = frame_it-&gt;second.pre_integration-&gt;sum_dt;</span><br><span class="line">        Vector3d tmp_g = frame_it-&gt;second.pre_integration-&gt;delta_v / sum_dt;</span><br><span class="line">        var += (tmp_g - aver_g).transpose() * (tmp_g - aver_g);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算标准差</span></span><br><span class="line">    var = <span class="built_in">sqrt</span>(var / ((<span class="keyword">int</span>)all_image_frame.size() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//ROS_WARN("IMU variation %f!", var);</span></span><br><span class="line">    <span class="keyword">if</span>(var &lt; <span class="number">0.25</span>) <span class="comment">//! 以标准差判断可观性</span></span><br><span class="line">    &#123;</span><br><span class="line">        ROS_INFO(<span class="string">"IMU excitation not enouth!"</span>);</span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.将f_manager中的所有feature保存到vector<sfmfeature> sfm_f中，SFMFeature数组中包含了特征点状态（是否被三角化），id，2d点，3d坐标以及深度，将特征管理器中的特征信息保存到SFMFeature对象sfm_f中sfm_f.push_back(tmp_feature)。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SFMFeature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> state;<span class="comment">//状态（是否被三角化）</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,Vector2d&gt;&gt; observation;<span class="comment">//所有观测到该特征点的图像帧ID和图像坐标</span></span><br><span class="line">    <span class="keyword">double</span> position[<span class="number">3</span>];<span class="comment">//3d坐标</span></span><br><span class="line">    <span class="keyword">double</span> depth;<span class="comment">//深度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历滑窗内所有的Features，以vector&lt;SFMFeature&gt;形式保存滑窗内所有特征点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;SFMFeature&gt; sfm_f;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> imu_j = it_per_id.start_frame - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    SFMFeature tmp_feature;</span><br><span class="line">    tmp_feature.state = <span class="literal">false</span>;</span><br><span class="line">    tmp_feature.id = it_per_id.feature_id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_frame : it_per_id.feature_per_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        imu_j++;</span><br><span class="line">        Vector3d pts_j = it_per_frame.point;</span><br><span class="line">        tmp_feature.observation.push_back(make_pair(imu_j, Eigen::Vector2d&#123;pts_j.x(), pts_j.y()&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    sfm_f.push_back(tmp_feature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sfmfeature></li>
<li>3.relativePose()恢复出R、t</li>
</ul>
<blockquote>
<p> 1.先通过 FeatureManager::getCorresponding()获取滑动窗口中第i帧和最后一帧的特征匹配corres<br> 2.如果第i帧和最后一帧的特征匹配数corres大于20，且所有匹配的特征点的平均视差大于一定阈值，通过solveRelativeRT（定义在solv_5pts.cpp类中）用五点法求本质矩阵cv::findFundamentalMat 计算出当前帧到参考帧的 T</p>
<p> 值得注意：relativePose得到的位姿是第l帧的，第l帧的筛选是从第一帧开始到滑动窗口所有帧中一开始满足平均视差足够大的帧，这里的第l帧会作为参考帧到下面的全局SFM使用。这样得到图像的特征点2d坐标的提取，相机第l帧和最后一帧之间的旋转和平移</p>
</blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!relativePose(relative_R, relative_T, l))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"Not enough features or parallax; Move device around"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>bool relativePose(relative_R, relative_T, l)</strong><br>   该函数判断每帧到窗口最后一帧对应特征点的平均视差大于30，且内点数目大于12则可进行初始化，同时返回当前帧到第l帧的坐标系变换R和T<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::relativePose(Matrix3d &amp;relative_R, Vector3d &amp;relative_T, <span class="keyword">int</span> &amp;l) &#123;</span><br><span class="line">    <span class="comment">// find previous frame which contians enough correspondance and parallex with newest frame</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在滑窗内寻找与最新的关键帧共视点超过20(像素点)的关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WINDOW_SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">        <span class="comment">//获取第i帧和最后一帧的特征匹配corres</span></span><br><span class="line">        corres = f_manager.getCorresponding(i, WINDOW_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共视的Features应该大于20</span></span><br><span class="line">        <span class="keyword">if</span> (corres.size() &gt; <span class="number">20</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取匹配的特征点在图像上的视差和(归一化平面上)</span></span><br><span class="line">            <span class="keyword">double</span> sum_parallax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(corres.size()); j++) &#123;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_0</span><span class="params">(corres[j].first(<span class="number">0</span>), corres[j].first(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="function">Vector2d <span class="title">pts_1</span><span class="params">(corres[j].second(<span class="number">0</span>), corres[j].second(<span class="number">1</span>))</span></span>;</span><br><span class="line">                <span class="keyword">double</span> parallax = (pts_0 - pts_1).norm();</span><br><span class="line">                sum_parallax = sum_parallax + parallax;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求取所有匹配的特征点的平均视差</span></span><br><span class="line">            <span class="keyword">double</span> average_parallax = <span class="number">1.0</span> * sum_parallax / <span class="keyword">int</span>(corres.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视差大于一定阈值，并且能够有效地求解出变换矩阵</span></span><br><span class="line">            <span class="keyword">if</span> (average_parallax * <span class="number">460</span> &gt; <span class="number">30</span> &amp;&amp; m_estimator.solveRelativeRT(corres, relative_R, relative_T)) &#123;</span><br><span class="line">                l = i;</span><br><span class="line">                ROS_DEBUG(<span class="string">"average_parallax %f choose l %d and newest frame to triangulate the whole structure"</span>,</span><br><span class="line">                          average_parallax * <span class="number">460</span>, l);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>FeatureManager::getCorresponding()</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; FeatureManager::getCorresponding(<span class="keyword">int</span> frame_count_l, <span class="keyword">int</span> frame_count_r) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; corres;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : feature) &#123;</span><br><span class="line">        <span class="comment">// 保证两帧的id大于当前特征点的起始id小于当前特征点的终止id</span></span><br><span class="line">        <span class="keyword">if</span> (it.start_frame &lt;= frame_count_l &amp;&amp; it.endFrame() &gt;= frame_count_r) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx_l = frame_count_l - it.start_frame;</span><br><span class="line">            <span class="keyword">int</span> idx_r = frame_count_r - it.start_frame;</span><br><span class="line"></span><br><span class="line">            Vector3d a = it.feature_per_frame[idx_l].point;</span><br><span class="line">            Vector3d b = it.feature_per_frame[idx_r].point;</span><br><span class="line"></span><br><span class="line">            corres.push_back(make_pair(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> corres;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>solveRelativeRT()</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> MotionEstimator::solveRelativeRT(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;Vector3d, Vector3d&gt;&gt; &amp;corres, Matrix3d &amp;Rotation, Vector3d &amp;Translation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (corres.size() &gt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! Step1：提取匹配完的Features</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;cv::Point2f&gt; ll, rr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(corres.size()); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll.push_back(cv::Point2f(corres[i].first(<span class="number">0</span>), corres[i].first(<span class="number">1</span>)));</span><br><span class="line">            rr.push_back(cv::Point2f(corres[i].second(<span class="number">0</span>), corres[i].second(<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::Mat mask;</span><br><span class="line">        <span class="comment">//! Step2：利用Ransac算法计算本质矩阵，内外点的阈值距离设定为0.3 / 460</span></span><br><span class="line">        cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, <span class="number">0.3</span> / <span class="number">460</span>, <span class="number">0.99</span>, mask);</span><br><span class="line"></span><br><span class="line">        cv::Mat cameraMatrix = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step3：计算变换矩阵并得到内点个数</span></span><br><span class="line">        cv::Mat rot, trans;</span><br><span class="line">        <span class="keyword">int</span> inlier_cnt = cv::recoverPose(E, ll, rr, cameraMatrix, rot, trans, mask);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "inlier_cnt " &lt;&lt; inlier_cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 得到变换矩阵 ll ==&gt; rr</span></span><br><span class="line">        Eigen::Matrix3d R;</span><br><span class="line">        Eigen::Vector3d T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            T(i) = trans.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                R(i, j) = rot.at&lt;<span class="keyword">double</span>&gt;(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! Step4：得到旋转矩阵和平移量 rr ==&gt; ll</span></span><br><span class="line">        Rotation    =  R.transpose();</span><br><span class="line">        Translation = -R.transpose() * T;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! 判断求取的内点个数是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(inlier_cnt &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4.对窗口中每个图像帧求解sfm问题，调用sfm.construct(frame_count + 1, Q, T,l,relative_R, relative_T,sfm_f, sfm_tracked_points)估计slidingwindow中所有图像帧相对于参考帧（这里以第l帧作为参考帧）的旋转四元数Q、平移向量T和特征点坐标sfm_tracked_points。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三角化恢复滑窗内的Features</span></span><br><span class="line">GlobalSFM sfm;</span><br><span class="line">Quaterniond Q[frame_count + <span class="number">1</span>];</span><br><span class="line">Vector3d    T[frame_count + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; sfm_tracked_points;</span><br><span class="line"><span class="keyword">if</span>(!sfm.construct(frame_count + <span class="number">1</span>, Q, T, l, relative_R, relative_T, sfm_f, sfm_tracked_points))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"global SFM failed!"</span>);</span><br><span class="line">    marginalization_flag = MARGIN_OLD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool GlobalSFM::construct()</strong><br>函数位于inital_sfm.cpp文件中<br>纯视觉sfm，求解窗口中所有图像帧的位姿QT（相对于第l帧）和特征点坐标sfm_tracked_points<br>frame_num=frame_count + 1=11，frame_num-1表示当前帧</p>
<blockquote>
<p>1.把第l帧看作参考坐标系，根据当前帧到第l帧的relative_R，relative_T，得到当前帧在参考坐标系下的位姿，之后的pose[i]表示第l帧到第i帧的变换矩阵[R|T]<br>2.三角化第l帧（参考帧）与第frame_num-1帧（当前帧）的路标点<br>3.pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中，并与当前帧进行三角化<br>4.对第l帧与从第l+1到frame_num-2的每一帧再进行三角化<br>5.PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化<br>6.三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标<br>7.使用cares进行全局BA优化<br>8.得到的是第l帧坐标系到各帧的变换矩阵，将其转变为每一帧在第l帧坐标系上的位姿<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> GlobalSFM::construct(<span class="keyword">int</span> frame_num, Quaterniond* q, Vector3d* T, <span class="keyword">int</span> l,</span><br><span class="line">			  <span class="keyword">const</span> Matrix3d relative_R, <span class="keyword">const</span> Vector3d relative_T,</span><br><span class="line">			  <span class="built_in">vector</span>&lt;SFMFeature&gt; &amp;sfm_f, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt; &amp;sfm_tracked_points)</span><br><span class="line">&#123;</span><br><span class="line">	feature_num = sfm_f.size();</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "set 0 and " &lt;&lt; l &lt;&lt; " as known " &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">// have relative_r relative_t</span></span><br><span class="line">	<span class="comment">// intial two view</span></span><br><span class="line">	q[l].w() = <span class="number">1</span>;</span><br><span class="line">	q[l].x() = <span class="number">0</span>;</span><br><span class="line">	q[l].y() = <span class="number">0</span>;</span><br><span class="line">	q[l].z() = <span class="number">0</span>;</span><br><span class="line">	T[l].setZero();</span><br><span class="line">	q[frame_num - <span class="number">1</span>] = q[l] * Quaterniond(relative_R);</span><br><span class="line">	T[frame_num - <span class="number">1</span>] = relative_T;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "init q_l " &lt;&lt; q[l].w() &lt;&lt; " " &lt;&lt; q[l].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "init t_l " &lt;&lt; T[l].transpose() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//rotate to cam frame</span></span><br><span class="line">	Matrix3d c_Rotation[frame_num];</span><br><span class="line">	Vector3d c_Translation[frame_num];</span><br><span class="line">	Quaterniond c_Quat[frame_num];</span><br><span class="line">	<span class="keyword">double</span> c_rotation[frame_num][<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">double</span> c_translation[frame_num][<span class="number">3</span>];</span><br><span class="line">	Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">4</span>&gt; Pose[frame_num];</span><br><span class="line"></span><br><span class="line">	c_Quat[l] = q[l].inverse();</span><br><span class="line">	c_Rotation[l] = c_Quat[l].toRotationMatrix();</span><br><span class="line">	c_Translation[l] = <span class="number">-1</span> * (c_Rotation[l] * T[l]);</span><br><span class="line">	Pose[l].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[l];</span><br><span class="line">	Pose[l].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[l];</span><br><span class="line"></span><br><span class="line">	c_Quat[frame_num - <span class="number">1</span>] = q[frame_num - <span class="number">1</span>].inverse();</span><br><span class="line">	c_Rotation[frame_num - <span class="number">1</span>] = c_Quat[frame_num - <span class="number">1</span>].toRotationMatrix();</span><br><span class="line">	c_Translation[frame_num - <span class="number">1</span>] = <span class="number">-1</span> * (c_Rotation[frame_num - <span class="number">1</span>] * T[frame_num - <span class="number">1</span>]);</span><br><span class="line">	Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[frame_num - <span class="number">1</span>];</span><br><span class="line">	Pose[frame_num - <span class="number">1</span>].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[frame_num - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1: trangulate between l ----- frame_num - 1</span></span><br><span class="line">	<span class="comment">//2: solve pnp l + 1; trangulate l + 1 ------- frame_num - 1; </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; frame_num - <span class="number">1</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// solve pnp</span></span><br><span class="line">		<span class="comment">//pnp求解参考坐标系到第l+1开始的每一帧的变换矩阵R_initial, P_initial，保存在Pose中</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; l)</span><br><span class="line">		&#123;</span><br><span class="line">			Matrix3d R_initial = c_Rotation[i - <span class="number">1</span>];</span><br><span class="line">			Vector3d P_initial = c_Translation[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			c_Rotation[i] = R_initial;</span><br><span class="line">			c_Translation[i] = P_initial;</span><br><span class="line">			c_Quat[i] = c_Rotation[i];</span><br><span class="line">			Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">			Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// triangulate point based on the solve pnp result</span></span><br><span class="line">		triangulateTwoFrames(i, Pose[i], frame_num - <span class="number">1</span>, Pose[frame_num - <span class="number">1</span>], sfm_f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3: triangulate l-----l+1 l+2 ... frame_num -2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; frame_num - <span class="number">1</span>; i++)</span><br><span class="line">		triangulateTwoFrames(l, Pose[l], i, Pose[i], sfm_f);</span><br><span class="line">	<span class="comment">//4: solve pnp l-1; triangulate l-1 ----- l</span></span><br><span class="line">	<span class="comment">//             l-2              l-2 ----- l</span></span><br><span class="line">	<span class="comment">//PNP求解参考坐标系到从第l-1到第0帧的每一帧之间的变换矩阵，并进行三角化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//solve pnp</span></span><br><span class="line">		Matrix3d R_initial = c_Rotation[i + <span class="number">1</span>];</span><br><span class="line">		Vector3d P_initial = c_Translation[i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		c_Rotation[i] = R_initial;</span><br><span class="line">		c_Translation[i] = P_initial;</span><br><span class="line">		c_Quat[i] = c_Rotation[i];</span><br><span class="line">		Pose[i].block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = c_Rotation[i];</span><br><span class="line">		Pose[i].block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) = c_Translation[i];</span><br><span class="line">		<span class="comment">//triangulate</span></span><br><span class="line">		triangulateTwoFrames(i, Pose[i], l, Pose[l], sfm_f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5: triangulate all other points</span></span><br><span class="line">	<span class="comment">//三角化其他未恢复的特征点。至此得到了滑动窗口中所有图像帧的位姿以及特征点的3d坐标</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; feature_num; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sfm_f[j].state == <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">int</span>)sfm_f[j].observation.size() &gt;= <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Vector2d point0, point1;</span><br><span class="line">			<span class="keyword">int</span> frame_0 = sfm_f[j].observation[<span class="number">0</span>].first;</span><br><span class="line">			point0 = sfm_f[j].observation[<span class="number">0</span>].second;</span><br><span class="line">			<span class="keyword">int</span> frame_1 = sfm_f[j].observation.back().first;</span><br><span class="line">			point1 = sfm_f[j].observation.back().second;</span><br><span class="line">			Vector3d point_3d;</span><br><span class="line">			triangulatePoint(Pose[frame_0], Pose[frame_1], point0, point1, point_3d);</span><br><span class="line">			sfm_f[j].state = <span class="literal">true</span>;</span><br><span class="line">			sfm_f[j].position[<span class="number">0</span>] = point_3d(<span class="number">0</span>);</span><br><span class="line">			sfm_f[j].position[<span class="number">1</span>] = point_3d(<span class="number">1</span>);</span><br><span class="line">			sfm_f[j].position[<span class="number">2</span>] = point_3d(<span class="number">2</span>);</span><br><span class="line">			<span class="comment">//cout &lt;&lt; "trangulated : " &lt;&lt; frame_0 &lt;&lt; " " &lt;&lt; frame_1 &lt;&lt; "  3d point : "  &lt;&lt; j &lt;&lt; "  " &lt;&lt; point_3d.transpose() &lt;&lt; endl;</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		q[i] = c_Rotation[i].transpose(); </span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "solvePnP  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; frame_num; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		Vector3d t_tmp;</span></span><br><span class="line"><span class="comment">		t_tmp = -1 * (q[i] * c_Translation[i]);</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "solvePnP  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; t_tmp.x() &lt;&lt;"  "&lt;&lt; t_tmp.y() &lt;&lt;"  "&lt;&lt; t_tmp.z() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="comment">//full BA</span></span><br><span class="line">	<span class="comment">//使用cares进行全局BA优化</span></span><br><span class="line">	ceres::Problem problem;</span><br><span class="line">	ceres::LocalParameterization* local_parameterization = <span class="keyword">new</span> ceres::QuaternionParameterization();</span><br><span class="line">	<span class="comment">//cout &lt;&lt; " begin full BA " &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//double array for ceres</span></span><br><span class="line">		c_translation[i][<span class="number">0</span>] = c_Translation[i].x();</span><br><span class="line">		c_translation[i][<span class="number">1</span>] = c_Translation[i].y();</span><br><span class="line">		c_translation[i][<span class="number">2</span>] = c_Translation[i].z();</span><br><span class="line">		c_rotation[i][<span class="number">0</span>] = c_Quat[i].w();</span><br><span class="line">		c_rotation[i][<span class="number">1</span>] = c_Quat[i].x();</span><br><span class="line">		c_rotation[i][<span class="number">2</span>] = c_Quat[i].y();</span><br><span class="line">		c_rotation[i][<span class="number">3</span>] = c_Quat[i].z();</span><br><span class="line">		problem.AddParameterBlock(c_rotation[i], <span class="number">4</span>, local_parameterization);</span><br><span class="line">		problem.AddParameterBlock(c_translation[i], <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span> (i == l)</span><br><span class="line">		&#123;</span><br><span class="line">			problem.SetParameterBlockConstant(c_rotation[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == l || i == frame_num - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			problem.SetParameterBlockConstant(c_translation[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; feature_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sfm_f[i].state != <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">int</span>(sfm_f[i].observation.size()); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> l = sfm_f[i].observation[j].first;</span><br><span class="line">			ceres::CostFunction* cost_function = ReprojectionError3D::Create(</span><br><span class="line">												sfm_f[i].observation[j].second.x(),</span><br><span class="line">												sfm_f[i].observation[j].second.y());</span><br><span class="line"></span><br><span class="line">    		problem.AddResidualBlock(cost_function, <span class="literal">NULL</span>, c_rotation[l], c_translation[l], </span><br><span class="line">    								sfm_f[i].position);	 </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	ceres::Solver::Options options;</span><br><span class="line">	options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line">	<span class="comment">//options.minimizer_progress_to_stdout = true;</span></span><br><span class="line">	options.max_solver_time_in_seconds = <span class="number">0.2</span>;</span><br><span class="line">	ceres::Solver::Summary summary;</span><br><span class="line">	ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; summary.BriefReport() &lt;&lt; "\n";</span></span><br><span class="line">	<span class="keyword">if</span> (summary.termination_type == ceres::CONVERGENCE || summary.final_cost &lt; <span class="number">5e-03</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "vision only BA converge" &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "vision only BA not converge " &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q[i].w() = c_rotation[i][<span class="number">0</span>]; </span><br><span class="line">		q[i].x() = c_rotation[i][<span class="number">1</span>]; </span><br><span class="line">		q[i].y() = c_rotation[i][<span class="number">2</span>]; </span><br><span class="line">		q[i].z() = c_rotation[i][<span class="number">3</span>]; </span><br><span class="line">		q[i] = q[i].inverse();</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "final  q" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt;q[i].w() &lt;&lt; "  " &lt;&lt; q[i].vec().transpose() &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第l帧坐标系到各帧的变换矩阵，应将其转变为每一帧在第l帧坐标系上的位姿</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frame_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		T[i] = <span class="number">-1</span> * (q[i] * Vector3d(c_translation[i][<span class="number">0</span>], c_translation[i][<span class="number">1</span>], c_translation[i][<span class="number">2</span>]));</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "final  t" &lt;&lt; " i " &lt;&lt; i &lt;&lt;"  " &lt;&lt; T[i](0) &lt;&lt;"  "&lt;&lt; T[i](1) &lt;&lt;"  "&lt;&lt; T[i](2) &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)sfm_f.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(sfm_f[i].state)</span><br><span class="line">			sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[<span class="number">0</span>], sfm_f[i].position[<span class="number">1</span>], sfm_f[i].position[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>对于所有的图像帧，包括不在滑动窗口中的，提供初始的RT估计，然后solvePnP进行优化</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solve pnp for all frame</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Vector3d&gt;::iterator it;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_it = all_image_frame.begin( );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; frame_it != all_image_frame.end( ); frame_it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// provide initial guess</span></span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) == Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        frame_it-&gt;second.is_key_frame = <span class="literal">true</span>;</span><br><span class="line">        frame_it-&gt;second.R = Q[i].toRotationMatrix() * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">        frame_it-&gt;second.T = T[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((frame_it-&gt;first) &gt; Headers[i].stamp.toSec())</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将滑窗内第i帧的变换矩阵当做初始值</span></span><br><span class="line">    Matrix3d R_inital = (Q[i].inverse()).toRotationMatrix();</span><br><span class="line">    Vector3d P_inital = - R_inital * T[i];</span><br><span class="line">    cv::Mat rvec, t, tmp_r;</span><br><span class="line">    cv::eigen2cv(R_inital, tmp_r);</span><br><span class="line">    cv::Rodrigues(tmp_r, rvec);</span><br><span class="line">    cv::eigen2cv(P_inital, t);</span><br><span class="line"></span><br><span class="line">    frame_it-&gt;second.is_key_frame = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point3f&gt; pts_3_vector;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::Point2f&gt; pts_2_vector;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;id_pts : frame_it-&gt;second.points)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> feature_id = id_pts.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i_p : id_pts.second)</span><br><span class="line">        &#123;</span><br><span class="line">            it = sfm_tracked_points.find(feature_id);</span><br><span class="line">            <span class="keyword">if</span>(it != sfm_tracked_points.end())</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3d world_pts = it-&gt;second;</span><br><span class="line">                cv::<span class="function">Point3f <span class="title">pts_3</span><span class="params">(world_pts(<span class="number">0</span>), world_pts(<span class="number">1</span>), world_pts(<span class="number">2</span>))</span></span>;</span><br><span class="line">                pts_3_vector.push_back(pts_3);</span><br><span class="line"></span><br><span class="line">                Vector2d img_pts = i_p.second.head&lt;<span class="number">2</span>&gt;();</span><br><span class="line">                cv::<span class="function">Point2f <span class="title">pts_2</span><span class="params">(img_pts(<span class="number">0</span>), img_pts(<span class="number">1</span>))</span></span>;</span><br><span class="line">                pts_2_vector.push_back(pts_2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pts_3_vector.size() &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pts_3_vector size "</span> &lt;&lt; pts_3_vector.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ROS_DEBUG(<span class="string">"Not enough points for solve pnp !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat K = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat D;</span><br><span class="line">    <span class="keyword">if</span> (! cv::solvePnP(pts_3_vector, pts_2_vector, K, D, rvec, t, <span class="literal">true</span>)) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve pnp fail!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PnP求解出的位姿要取逆</span></span><br><span class="line">    MatrixXd R_pnp;</span><br><span class="line">    MatrixXd T_pnp;</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat r;</span><br><span class="line">        cv::Rodrigues(rvec, r);</span><br><span class="line">        MatrixXd tmp_R_pnp;</span><br><span class="line">        cv::cv2eigen(r, tmp_R_pnp);</span><br><span class="line">        R_pnp = tmp_R_pnp.transpose();</span><br><span class="line"></span><br><span class="line">        cv::cv2eigen(t, T_pnp);</span><br><span class="line">        T_pnp = R_pnp * (-T_pnp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换到IMU坐标系下</span></span><br><span class="line">    frame_it-&gt;second.R = R_pnp * RIC[<span class="number">0</span>].transpose();</span><br><span class="line">    frame_it-&gt;second.T = T_pnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6.进行视觉惯性联合初始化，imu与视觉对齐，获取绝对尺度s、陀螺仪偏置bg、加速度偏置ba、重力加速度G和每个IMU时刻的速度v</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视觉与IMU对齐</span></span><br><span class="line"><span class="keyword">if</span> (visualInitialAlign())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"misalign visual structure with IMU"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool Estimator::visualInitialAlign()</strong><br>该函数主要实现了陀螺仪的偏置校准(加速度偏置没有处理)，计算速度V[0:n]、重力g、尺度s。<br>同时更新了Bgs后，IMU测量量需要repropagate；得到尺度s和重力g的方向后，需更新所有图像帧在世界坐标系下的Ps、Rs、Vs。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Estimator::visualInitialAlign()</span><br><span class="line">&#123;</span><br><span class="line">    TicToc t_g;</span><br><span class="line"></span><br><span class="line">    VectorXd x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve scale</span></span><br><span class="line">    <span class="comment">// 要注意这个地方求解出的g是在C0坐标系下</span></span><br><span class="line">    <span class="comment">//1.计算陀螺仪偏置，尺度，重力加速度和速度</span></span><br><span class="line">    <span class="keyword">bool</span> result = VisualIMUAlignment(all_image_frame, Bgs, g, x);</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        ROS_DEBUG(<span class="string">"solve g failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change state</span></span><br><span class="line">    <span class="comment">//2.获取所有图像帧的位姿Ps、Rs，并将其置为关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix3d Ri = all_image_frame[Headers[i].stamp.toSec()].R;</span><br><span class="line">        Vector3d Pi = all_image_frame[Headers[i].stamp.toSec()].T;</span><br><span class="line">        Ps[i] = Pi;</span><br><span class="line">        Rs[i] = Ri;</span><br><span class="line">        all_image_frame[Headers[i].stamp.toSec()].is_key_frame = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有特征点的深度置为-1</span></span><br><span class="line">    VectorXd dep = f_manager.getDepthVector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dep.size(); i++)</span><br><span class="line">        dep[i] = <span class="number">-1</span>;</span><br><span class="line">    f_manager.clearDepth(dep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//triangulat on cam pose , no tic</span></span><br><span class="line">    <span class="comment">//3.重新计算特征点的深度</span></span><br><span class="line">    Vector3d TIC_TMP[NUM_OF_CAM];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">        TIC_TMP[i].setZero();</span><br><span class="line">    ric[<span class="number">0</span>] = RIC[<span class="number">0</span>];</span><br><span class="line">    f_manager.setRic(ric);</span><br><span class="line">    f_manager.triangulate(Ps, &amp;(TIC_TMP[<span class="number">0</span>]), &amp;(RIC[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> s = (x.tail&lt;<span class="number">1</span>&gt;())(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4.陀螺仪的偏置bgs改变，重新计算预积分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= WINDOW_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre_integrations[i]-&gt;repropagate(Vector3d::Zero(), Bgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.将Ps、Vs、depth尺度s缩放后转变为相对于第0帧图像坐标系下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = frame_count; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        Ps[i] = s * Ps[i] - Rs[i] * TIC[<span class="number">0</span>] - (s * Ps[<span class="number">0</span>] - Rs[<span class="number">0</span>] * TIC[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> kv = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">double</span>, ImageFrame&gt;::iterator frame_i;</span><br><span class="line">    <span class="keyword">for</span> (frame_i = all_image_frame.begin(); frame_i != all_image_frame.end(); frame_i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(frame_i-&gt;second.is_key_frame)</span><br><span class="line">        &#123;</span><br><span class="line">            kv++;</span><br><span class="line">            Vs[kv] = frame_i-&gt;second.R * x.segment&lt;<span class="number">3</span>&gt;(kv * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it_per_id : f_manager.feature)</span><br><span class="line">    &#123;</span><br><span class="line">        it_per_id.used_num = it_per_id.feature_per_frame.size();</span><br><span class="line">        <span class="keyword">if</span> (!(it_per_id.used_num &gt;= <span class="number">2</span> &amp;&amp; it_per_id.start_frame &lt; WINDOW_SIZE - <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        it_per_id.estimated_depth *= s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转矩阵rot_diff</span></span><br><span class="line">    Matrix3d R0 = Utility::g2R(g);</span><br><span class="line">    <span class="keyword">double</span> yaw = Utility::R2ypr(R0 * Rs[<span class="number">0</span>]).x();</span><br><span class="line">    R0 = Utility::ypr2R(Eigen::Vector3d&#123;-yaw, <span class="number">0</span>, <span class="number">0</span>&#125;) * R0;</span><br><span class="line">    g = R0 * g;</span><br><span class="line">    <span class="comment">//Matrix3d rot_diff = R0 * Rs[0].transpose();</span></span><br><span class="line">    Matrix3d rot_diff = R0;</span><br><span class="line">    <span class="comment">//7.所有变量从参考坐标系c0旋转到世界坐标系w</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= frame_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Ps[i] = rot_diff * Ps[i];</span><br><span class="line">        Rs[i] = rot_diff * Rs[i];</span><br><span class="line">        Vs[i] = rot_diff * Vs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"g0     "</span> &lt;&lt; g.transpose());</span><br><span class="line">    ROS_DEBUG_STREAM(<span class="string">"my R0  "</span> &lt;&lt; Utility::R2ypr(Rs[<span class="number">0</span>]).transpose()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<br><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719531" target="_blank" rel="noopener">VINS理论与代码详解4——初始化</a></p>
</blockquote>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>17.打印从1到最大的n位数</title>
    <url>/2019/10/29/17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h1><p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>用一个循环从1开始逐个打印，但当n很大时，有可能用整型(int)或长整型(long)都会溢出。</p>
</li>
<li><p>字符串模拟运算的解法，<strong>用字符串或者数组表达大数</strong></p>
<blockquote>
<p>把字符串中的每一个数字都初始化为’0’<br>每一次为字符串表示的数字加1，再打印出来</p>
</blockquote>
</li>
</ol><a id="more"></a>

<p>这题对我来说有点难，只是看懂了，python代码以后在整理.</p>
<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">'0'</span>, n);</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Increment(number))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[]number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，在 number上增加1</span></span><br><span class="line"><span class="comment">// 如果做加法溢出，则返回true；否则为false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTakeOver = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nSum = number[i] - <span class="string">'0'</span> + nTakeOver;</span><br><span class="line">        <span class="keyword">if</span> (i == nLength - <span class="number">1</span>)</span><br><span class="line">            nSum++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nSum &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                isOverflow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nSum -= <span class="number">10</span>;</span><br><span class="line">                nTakeOver = <span class="number">1</span>;</span><br><span class="line">                number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>16.数组的整数次方</title>
    <url>/2019/10/29/16.%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>当指数exponent为正</p>
</li>
<li><p>当指数为负，可以先对指数取绝对值，算出次方的结果后取倒数，要讨论底数是否为0</p>
<blockquote>
<p>底数base不为0</p>
<p>底数base为0，对0求倒数，导致程序出错，需要进行特殊处理，这里采用全局变量</p>
<p><img alt="1572402654504" data-src="/home/xiaohu/.config/Typora/typora-user-images/1572402654504.png"></p>
</blockquote>
</li>
</ol><a id="more"></a>


<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p>
<p>法1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Exponent;i++)</span><br><span class="line">            result*=base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<p>位运算效率比乘除法及求余运算符（%）的效率高很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-0.0</span>)&lt; <span class="number">1e-8</span> &amp;&amp; exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            absExponent=-exponent;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            absExponent=exponent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> Exponent)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(Exponent==<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span> base;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//用右移运算符代替除以2</span></span><br><span class="line">         <span class="keyword">double</span> result=PowerWithUnsignedExponent(base,Exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">         result*=result;</span><br><span class="line">         <span class="comment">//求余运算符（%）判断一个数是奇数还是偶数</span></span><br><span class="line">         <span class="keyword">if</span>(Exponent &amp; <span class="number">0x1</span>==<span class="number">1</span>)</span><br><span class="line">             result*=base;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent&lt;<span class="number">0</span>:</span><br><span class="line">            exponent=-exponent</span><br><span class="line">            flag=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        temp=base</span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(exponent):</span><br><span class="line">            <span class="keyword">if</span> exponent &amp; <span class="number">1</span>:</span><br><span class="line">                res*=temp</span><br><span class="line">            temp*=temp</span><br><span class="line">            exponent=exponent&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>15.二进制中1的个数</title>
    <url>/2019/10/29/15.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h1 id="二进制的5种位运算"><a href="#二进制的5种位运算" class="headerlink" title="二进制的5种位运算"></a>二进制的5种位运算</h1><blockquote>
<p>与（&amp;）</p>
<p>或（|）</p>
<p>异或（^)</p>
<p>左移(&lt;&lt;)  ：左移n位时，做左边的n位被丢弃，最右边不是那个补上n个0</p>
<p>右移(&gt;&gt;)  ：右移n位时，最右边的n位被丢弃,左边分两种情况</p>
<blockquote>
<p>1.如果数字为正，右移最左边补n个0</p>
<p>2.如果数字为负，右移最左边补n个1      </p>
</blockquote>
</blockquote><a id="more"></a>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>先判断整数二进制最右边是不是1，接着把输入的整数右移一位，再判断是不是1，直到这个整数变为0为止</p>
</li>
<li><p>怎么判断一个整数为1？</p>
<blockquote>
<ol>
<li><p>把整数与1做与运算，但当输入是负数时，如果一直右移运算，最终的数字会变成oxFFFFFFFF陷入死循环</p>
</li>
<li><p>为避免死循环，首先把n与1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算，就能判断n的次地位是不是1,反复左移……</p>
</li>
<li><p>把一个整数减去1，再和原整数做与运算，会把整个整数最右边的1变为0</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>C++</strong></p>
<p>法1：</p>
<p>一个int为8位，所以负数的情况中需要<strong>判断32个字节中</strong>1的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">                 result++;</span><br><span class="line">             flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)</span><br><span class="line">         &#123;</span><br><span class="line">             result++;<span class="comment">//一个非0数字至少有一个1</span></span><br><span class="line">             n=(n<span class="number">-1</span>)&amp;n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<p>法1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> n &amp; flag:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>法2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n &amp;= <span class="number">0xffffffff</span> <span class="comment">#获取负数补码</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>14.剪绳子</title>
    <url>/2019/10/29/14-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul>
<li>$O(n^2)$时间和$O(n)$空间的动态规划</li>
<li>$O(1)$时间和空间的贪婪算法</li>
</ul><a id="more"></a>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>第一步：确定最优策略，使得剪掉绳子的几段乘积最大。最后一步：乘积最大。子问题：假设该绳子剪成两段，剪完的两个部分都必须是最大乘积。</p>
<p>第二步：状态转移方程： dp[i] = max{ dp[i - j]<em>dp[j]} ,这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。更好的办法是按照<em>*从下而上</em></em>的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。</p>
<p>第三步：确定初始值和边界：dp[0] = 0,dp[1] = 1, dp[2] = 1</p>
<p>第四步：计算顺序，从dp[3]开始到dp[n]</p>
</blockquote>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product)</span><br><span class="line">                max = product;</span><br><span class="line"></span><br><span class="line">            products[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[length];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self,length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp=[<span class="number">0</span>]*length</span><br><span class="line">    <span class="comment">#dp = [0 for i in range(number + 1)]</span></span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">    dp[<span class="number">3</span>]=<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,length+<span class="number">1</span>):</span><br><span class="line">        cout=<span class="number">0</span></span><br><span class="line">        j=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;=i//<span class="number">2</span>:</span><br><span class="line">            cout=max(dp[i-j]*dp[j],cout)</span><br><span class="line">            dp[i]=cout</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[lentgh]</span><br></pre></td></tr></table></figure>
<h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>按如下策略来剪绳子</p>
<ul>
<li>当n&gt;=5，尽可能多剪长度为3的绳子</li>
<li>当剩下的绳子长度为4，把绳子剪成两段为2的绳子</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽可能多地减去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。</span></span><br><span class="line">    <span class="comment">// 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。</span></span><br><span class="line">    <span class="keyword">if</span>(length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        timesOf3 -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3)) * (<span class="keyword">int</span>) (<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法——排序</title>
    <url>/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="术语说明："><a href="#术语说明：" class="headerlink" title="术语说明："></a>术语说明：</h1><ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ul><a id="more"></a>
<h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类:"></a>算法分类:</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204533683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724204455511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];	<span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></span><br><span class="line">	<span class="keyword">int</span> length;			<span class="comment">/* 用于记录顺序表的长度 */</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> temp=L-&gt;r[i]; </span><br><span class="line">	L-&gt;r[i]=L-&gt;r[j]; </span><br><span class="line">	L-&gt;r[j]=temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>依次比较相邻两元素，若前一元素大于后一元素则交换之，直至最后一个元素即为最大；然后重新从首元素开始重复同样的操作，直至倒数第二个元素即为次大元素；依次类推。如同水中的气泡，依次将最大或最小元素气泡浮出水面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)  <span class="comment">/* 注意j是从后往前循环 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>]) <span class="comment">/* 若前者大于后者（注意这里与上一算法的差异）*/</span></span><br><span class="line">			&#123;</span><br><span class="line">				 swap(L,j,j+<span class="number">1</span>);<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作改进冒泡算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	Status flag=TRUE;			<span class="comment">/* flag用来作为标记 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag;i++) <span class="comment">/* 若flag为true说明有过数据交换，否则停止循环 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag=FALSE;				<span class="comment">/* 初始为False */</span></span><br><span class="line">		<span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				 swap(L,j,j+<span class="number">1</span>);	<span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">				 flag=TRUE;		<span class="comment">/* 如果有数据交换，则flag为true */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 O(n)。</p>
<h2 id="2-简单选择排序"><a href="#2-简单选择排序" class="headerlink" title="2.简单选择排序"></a>2.简单选择排序</h2><p>首先初始化最小元素索引值为首元素，依次遍历待排序数列，若遇到小于该最小索引位置处的元素则刷新最小索引为该较小元素的位置，直至遇到尾元素，结束一次遍历，并将最小索引处元素与首元素交换；然后，初始化最小索引值为第二个待排序数列元素位置，同样的操作，可得到数列第二个元素即为次小元素；以此类推。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作简单选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,min;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		min = i;						<span class="comment">/* 将当前下标定义为最小值下标 */</span></span><br><span class="line">		<span class="keyword">for</span> (j = i+<span class="number">1</span>;j&lt;=L-&gt;length;j++)<span class="comment">/* 循环之后的数据 */</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[min]&gt;L-&gt;r[j])	<span class="comment">/* 如果有小于当前最小值的关键字 */</span></span><br><span class="line">                min = j;				<span class="comment">/* 将此关键字的下标赋值给min */</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(i!=min)						<span class="comment">/* 若min不等于i，说明找到最小值，交换 */</span></span><br><span class="line">			swap(L,i,min);				<span class="comment">/* 交换L-&gt;r[i]与L-&gt;r[min]的值 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n)，但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h2><p>数列前面部分看为有序，依次将后面的无序数列元素插入到前面的有序数列中，初始状态有序数列仅有一个元素，即首元素。在将无序数列元素插入有序数列的过程中，采用了逆序遍历有序数列，相较于顺序遍历会稍显繁琐，但当数列本身已近排序状态效率会更高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i<span class="number">-1</span>]) <span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/* 设置哨兵 */</span></span><br><span class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="number">0</span>];j--)</span><br><span class="line">				L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j]; <span class="comment">/* 记录后移 */</span></span><br><span class="line">			L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/* 插入到正确位置 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n)，直接插入排序法比冒炮和简单选择排序的性能要好一些。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> increment=L-&gt;length;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		increment=increment/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">/* 增量序列 */</span></span><br><span class="line">		<span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i-increment])<span class="comment">/*  需将L-&gt;r[i]插入有序增量子表 */</span> </span><br><span class="line">			&#123; </span><br><span class="line">				L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/*  暂存在L-&gt;r[0] */</span></span><br><span class="line">				<span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)</span><br><span class="line">					L-&gt;r[j+increment]=L-&gt;r[j]; <span class="comment">/*  记录后移，查找插入位置 */</span></span><br><span class="line">				L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/*  插入 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"	第%d趟排序结果: "</span>,++k);</span><br><span class="line">		print(*L);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度：通常认为是O($N^{3/2}$) ，未验证　　稳定性：不稳定</p>
<h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h2><blockquote>
<p>堆是具有下列性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值,称为大顶堆 或者每个结点的值都小于或等于其左右孩子结点的值,称为小顶堆。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151257333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724151926815.png">堆排序 (Heap 80忱) 就是利用堆(假设利用大顶堆)进行排序的方法。它的基本思想是, 将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根结点。将官移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值) .然后将剩余的 n - 1 个序列重新构造成一个堆,这样就刽寻到 n 个元素中的次小值。如此反复执行 , 便能得到一个有序序列了 。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(i=L-&gt;length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span>   <span class="comment">/*把L中的r构建成一个大顶堆*/</span></span></span><br><span class="line"><span class="function">        <span class="title">HeadAdjust</span><span class="params">(L,i,L-&gt;length)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L,<span class="number">1</span>,i);             <span class="comment">/*将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></span><br><span class="line">        heapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);     <span class="comment">/*将当前的根结点重新调整为大顶堆 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,j;</span><br><span class="line">    temp=L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;m;j*=<span class="number">2</span>)    <span class="comment">/*沿关键字较大的孩子结点向下筛选*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            ++j;           <span class="comment">/*j为关键字中较大的记录的下标*/</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=L-&gt;r[j])   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        L-&gt;r[s]=L-&gt;r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(NlogN) 　　稳定性：不稳定<br>由于初始构建队所需的比较次数较多，并不适合待排序序列个数较少的情况。</p>
<h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h2><ul>
<li>归并排序 ( Merging Sort) 就是利用归并的思想实现的排序方法。色的原理是假设初始序列含有 n 个记录 , 则可 以看成是 n 个有序的子序列,每个子序列的长度为1 ,然后两两归并,得到[[n/2] ( [x]表示不小于 x 的最小整数)个长度为 2或1的有序子序列;再两两归并 ,……,如此重复 , 直至得到 一个长度为 n 的有序序列为止 ,这种排序方法称为2路归并排序 。<h3 id="递归实现归并排序"><a href="#递归实现归并排序" class="headerlink" title="递归实现归并排序"></a>递归实现归并排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span> <span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MSort (L-&gt;r,L-&gt;r,L-&gt;length) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">MSort (<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR1[],<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> TR2[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s==t)</span><br><span class="line">        TR1[s]=SR[s]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=(s+t)/<span class="number">2</span>;         <span class="comment">/*将SR (S..t]平分为 SR [s..m]和SR[m+1..t] */</span></span><br><span class="line">        MSort(SR,TR2,s,m); <span class="comment">/*递归将SR[s..m]归并为有序的 TR2[s..m]*/</span></span><br><span class="line">        MSort(SR,TR2,m+<span class="number">1</span>,t);<span class="comment">/*递归将SR[m+1..t]归并为有序TR2[m+1..t] */</span></span><br><span class="line">        Merge(TR2,TR1,s,m,t);<span class="comment">/*将TR2[s..m]和TR2[m+1..t]归并到TR1【s..t] */</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将有序的 SR[i..m1 和 $R [m+l..0] 归并为有序的T.R[i..n] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k,i;</span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SR[i]&lt;SR[j])</span><br><span class="line">            TR[k]=SR[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TR[k=SR[j++]]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=m-i;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;n-j;l++)</span><br><span class="line">            TR[k+<span class="number">1</span>]=SR[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设现在要对数组{50,1 0,90,30, 70.40,80, 60 ,20}进行排序, L.length=9 ,现来看看 MSort 的实现。MSort 被调用时, SR与TR1都是{50, 10,90, 30,70,40,80,60,20} , s=1 , t=9 ,最终我们的目的就是要将TR1中的数组排好顺序。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190724171640203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
</blockquote>
</li>
<li><p><strong>时间复杂度</strong>为：O(nlogn) </p>
</li>
<li><p><strong>空间复杂度</strong>：O(n+Iogn) ，由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为 Iog2 n 的横空间。</p>
<p>归并排序是一种<strong>稳定的排序算法</strong>，因为 Merge 函数 中有 if (SR[i]&lt;SR[j])语句,这就说明它需要两两比较,不存在跳跃。</p>
<h3 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h3><p>归并排序大量’引用了递归,尽管在代码上比较清晰,容易理解,但这会造成时间和空间上的性能损耗。排序追求的就是效率,<strong>将递归转化成迭代</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 非递归法 */</span></span><br><span class="line"><span class="comment">/* 对顺序表L作归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	MSort(L-&gt;r,L-&gt;r,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作归并非递归排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* TR=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(L-&gt;length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">/* 申请额外空间 */</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k&lt;L-&gt;length)</span><br><span class="line">	&#123;</span><br><span class="line">		MergePass(L-&gt;r,TR,k,L-&gt;length);</span><br><span class="line">		k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span></span><br><span class="line">		MergePass(TR,L-&gt;r,k,L-&gt;length);</span><br><span class="line">		k=<span class="number">2</span>*k;<span class="comment">/* 子序列长度加倍 */</span>       </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</span><br><span class="line">	&#123;<span class="comment">/* 两两归并 */</span></span><br><span class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</span><br><span class="line">		i=i+<span class="number">2</span>*s;        </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>) <span class="comment">/* 归并最后两个序列 */</span></span><br><span class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 若最后只剩下单个子序列 */</span></span><br><span class="line">		<span class="keyword">for</span>(j =i;j &lt;= n;j++)</span><br><span class="line">			TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h2><p>快速排序 ( Quick Sort) 的基本思想是:通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></span><br><span class="line"><span class="comment">/* 此时在它之前(后)的记录均不大(小)于它。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line">	pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">			high--;</span><br><span class="line">		 swap(L,low,high);<span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">			low++;</span><br><span class="line">		 swap(L,low,high);<span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)</span><br><span class="line">	&#123;</span><br><span class="line">			pivot=Partition(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">			QSort(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line">			QSort(L,pivot+<span class="number">1</span>,high);		<span class="comment">/*  对高子表递归排序 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSort(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Partition 函数，其实就是将选取的pivotkey 不断交换，将比它小的换到它的左边，比它大的换到它的右边，包也在交换中不断更改自己的位置，直到完全满足这个要求为止。</p>
<p>时间复杂度：最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)　<br>空间复杂度： O(logn)<br>由于关键字的比较和交换是跳跃进行的，因此，<strong>快速排序是一种不稳定</strong>的排序方法</p>
<p><strong>三数取中法</strong>。即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数， 也可以随机选取。 这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中中间数位于较为中间的值的可能性就大大提高了 。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 改进后快速排序******************************** */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivotkey;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>; <span class="comment">/* 计算数组中间的元素的下标 */</span>  </span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])			</span><br><span class="line">		swap(L,low,high);	<span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[high])</span><br><span class="line">		swap(L,high,m);		<span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[low])</span><br><span class="line">		swap(L,m,low);		<span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></span><br><span class="line">	</span><br><span class="line">	pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">	L-&gt;r[<span class="number">0</span>]=pivotkey;  <span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</span><br><span class="line">			high--;</span><br><span class="line">		 L-&gt;r[low]=L-&gt;r[high];</span><br><span class="line">		 <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</span><br><span class="line">			low++;</span><br><span class="line">		 L-&gt;r[high]=L-&gt;r[low];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high)</span><br><span class="line">		&#123;</span><br><span class="line">			pivot=Partition1(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">			QSort1(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></span><br><span class="line">			<span class="comment">/* QSort(L,pivot+1,high);		/*  对高子表递归排序 */</span></span><br><span class="line">			low=pivot+<span class="number">1</span>;	<span class="comment">/* 尾递归 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort1</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSort1(L,<span class="number">1</span>,L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法——查找</title>
    <url>/2019/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查找定义：查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><blockquote>
<p>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。</p>
</blockquote><p>查找又根据操作方式不同分为静态查找和动态查找两种，前者是仅获取数据不进行其他操作，后者则需要动态改变数据，比如在查找过程中插入新数据，或者删除某个已存在的数据。</p><a id="more"></a>


<h1 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h1><ul>
<li>定义：<br>从线性表的一段开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</li>
<li>时间复杂度：O(N）</li>
<li><p>优缺点：</p>
<blockquote>
<p>优点：对数据元素的存储没有需求，顺序存储或链式存储皆可；对表中记录的有序性也没有要求，无论记录是否按关键码有序，均可应用<br>缺点：当n较大时，平均查找长度较大，效率低</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 无哨兵顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]==key)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入哨兵的目的是使得函数内的循环不用每次都判断数组是否会越界，即不需要每次让 i与 n 作比较<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	a[<span class="number">0</span>]=key;</span><br><span class="line">	i=n;</span><br><span class="line">	<span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">	&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;<span class="comment">/*返回 0 则说明查找失败*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h1><h2 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>在有序的顺序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域元记录，查找失败为止。</p>
</blockquote>
</li>
<li>时间复杂度：O(logN）</li>
<li><p>优缺点：</p>
<blockquote>
<p>优点：折半查找的时间复杂度为O(logn)，远远优于顺序查找的O(n)，<br>缺点：二分查找的效率高，但是要求表关键字有序</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;	<span class="comment">/* 折半 */</span></span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])		<span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line">			high=mid<span class="number">-1</span>;		<span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line">			low=mid+<span class="number">1</span>;		<span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>基于二分查找算法，将查找点的选择改进为自适应选择，mid=low+(key-a[low])/(a[high]-a[low])*(high-low)<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014201459952.png#pic_center"></p>
</blockquote>
</li>
<li>时间复杂度：O(logN）</li>
<li>优缺点：<blockquote>
<p>优点：对于表长较大 且关键字分布又比较均匀的查找表，插值查找算法的平均性能比折半查找要好得多<br>缺点：极端不均匀的数据，用插值查找未必是很合适的选择</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插值查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Interpolation_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])		<span class="comment">/* 若查找值比插值小 */</span></span><br><span class="line">			high=mid<span class="number">-1</span>;		<span class="comment">/* 最高下标调整到插值下标小一位 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/* 若查找值比插值大 */</span></span><br><span class="line">			low=mid+<span class="number">1</span>;		<span class="comment">/* 最低下标调整到插值下标大一位 */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><ul>
<li><p>定义：</p>
<blockquote>
<p>1.斐波那契实在二分查找基础上，用斐波那契数列来进行分割<br>2.在斐波那契数列上找一个略大于查找元素表个数的值f(n)<br>3.将查找元素表个数扩充到f(n) 如果要补充元素用最后一个元素补充<br>4.完成后对f(n)个元素进行斐波那契分割,即分割成 前面f(n-1)个元素,后面f(n-2)个元素<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014205901920.png#pic_center"><br>5.对要查找元素的那个部分进行递归 </p>
</blockquote>
</li>
<li><p>时间复杂度：O(logN）</p>
</li>
<li><p>优缺点：</p>
<blockquote>
<p> 就平均性能而言 优于折半查找 但是若一直在左边长半区查找则低于折半查找                      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low,high,mid,i,k=<span class="number">0</span>;</span><br><span class="line">	low=<span class="number">1</span>;	<span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">	high=n;	<span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">	<span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)</span><br><span class="line">		k++;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">		a[i]=a[n];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (key&lt;a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			high=mid<span class="number">-1</span>;		</span><br><span class="line">			k=k<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			low=mid+<span class="number">1</span>;		</span><br><span class="line">			k=k<span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line">				<span class="keyword">return</span> mid;		<span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1></blockquote>
</li>
<li>索引:就是把一个关键字与它对应的记录相关联的过程。一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</li>
<li>索引按照结构可以分为线性索引，树形索引和多级索引。</li>
<li>线性索引是将索引项集合组织为线性结构，也称为索引表。包括稠密索引、分块索引、倒排索引。<h2 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h2><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211157380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
<li>稠密索引是指在线性表中，将数据集中的每个记录对应一个索引项。对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</li>
<li>优缺点：<blockquote>
<p>优点：索引项有序也就意味着，我们要查找关键字时，可以用折半，插值及斐波那契等有序查找算法。<br>缺点：如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模。对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能大大下降。</p>
</blockquote>
</li>
</ul>
<h2 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h2><ul>
<li><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:</p>
<blockquote>
<ul>
<li>块内无序，即每一块内的记录宋不要求有序，有序更好，代价比较大</li>
<li>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记景的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字</li>
</ul>
</blockquote>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。</p>
</li>
<li><p>定义的分块索引的索引项结构分三个数据项 :</p>
<blockquote>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>
<li>存储了块中的记录个数，以便于循环时使用</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记景进行遍历。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014211843755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
</ul>
</blockquote>
</li>
<li>分块索引表中查找，就是分两步进行:<blockquote>
<ul>
<li>在分块索引表中查找要查的关键字所在块。由于分块索引表是块间有序的，很容易利用折半插值等算法得到结果。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，只能顺序查找。</li>
</ul>
</blockquote>
</li>
<li>分块索引的平均查找长度：<blockquote>
<p>n 个记录的数据集被平均分成 m块，每个块中有 t 条记录，显然 n=m x t<br>Lb 为查找索引表的平均查找长，Lw为块中查找记录的平均查找长度<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213115831.png#pic_center"></p>
</blockquote>
</li>
</ul>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><ul>
<li>最基础的搜索技术<blockquote>
<p>样例:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101421402779.png#pic_center"><br>忽略大小写和复数，得出单词表，找到他们分别出现在哪篇文章中<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191014213725806.png#pic_center"><br>这张单词表就是索引衰， 索引项的通用结构是:</p>
<ul>
<li>次关键码.例如上面的”英文单词” </li>
<li>记录号表，例如上面的”文章编号”</li>
</ul>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字) 。 这样的索引方法就是倒排索引 (invered index)</p>
</blockquote>
</li>
<li>优缺点：<blockquote>
<ul>
<li>优点：显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果<br>缺点：是这个记录号不定长<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1></li>
</ul>
</blockquote>
</li>
<li>定义：二叉排序树 ( Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。.</li>
</ul>
<blockquote>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值 </li>
<li>若它的右子树不空 ，则右子树上所有结点的值均大于宫的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
</blockquote>
<p>   通过<strong>中序遍历</strong>即可得出<strong>有序的序列</strong>， 构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。</p>
<ul>
<li>二叉排序树的查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>	/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;<span class="comment">//BiTNode是该结构体的变量名,*BiTree是该结构体的类型的地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归查找二叉排序树T中是否存在key, */</span></span><br><span class="line"><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span></span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line"><span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span> (!T)	<span class="comment">/*  查找不成功 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		*p = f;  </span><br><span class="line">		<span class="keyword">return</span> FALSE; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key==T-&gt;data) <span class="comment">/*  查找成功 */</span></span><br><span class="line">	&#123; </span><br><span class="line">		*p = T;  </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data) </span><br><span class="line">		<span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);  <span class="comment">/*  在左子树中继续查找 */</span></span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">		<span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);  <span class="comment">/*  在右子树中继续查找 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */</span></span><br><span class="line"><span class="comment">/*  插入key并返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	BiTree p,s;</span><br><span class="line">	<span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line">    <span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line">	<span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		s-&gt;data = key;  </span><br><span class="line">		s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;  </span><br><span class="line">		<span class="keyword">if</span> (!p) </span><br><span class="line">			*T = s;			<span class="comment">/*  插入s为新的根结点 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;p-&gt;data) </span><br><span class="line">			p-&gt;lchild = s;	<span class="comment">/*  插入s为左孩子 */</span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			p-&gt;rchild = s;  <span class="comment">/*  插入s为右孩子 */</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> FALSE;  <span class="comment">/*  树中已有关键字相同的结点，不再插入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除<blockquote>
<p>对删除结点三种情况的分析:</p>
<ul>
<li>叶子结点</li>
<li>仅有左或右子树的结点 </li>
<li>左右子树都有的结点</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree q,s;</span><br><span class="line">	<span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; *p=(*p)-&gt;lchild; <span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">/* 只需重接它的右子树 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; *p=(*p)-&gt;rchild; <span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=*p; s=(*p)-&gt;lchild;</span><br><span class="line">		<span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span></span><br><span class="line">		&#123;</span><br><span class="line">			q=s;</span><br><span class="line">			s=s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		(*p)-&gt;data=s-&gt;data; <span class="comment">/*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span></span><br><span class="line">		<span class="keyword">if</span>(q!=*p)</span><br><span class="line">			q-&gt;rchild=s-&gt;lchild; <span class="comment">/*  重接q的右子树 */</span> </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q-&gt;lchild=s-&gt;lchild; <span class="comment">/*  重接q的左子树 */</span></span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span></span><br><span class="line"><span class="comment">/* 并返回TRUE；否则返回FALSE。 */</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span> </span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (key==(*T)-&gt;data) <span class="comment">/* 找到关键字等于key的数据元素 */</span> </span><br><span class="line">			<span class="keyword">return</span> Delete(T);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key&lt;(*T)-&gt;data)</span><br><span class="line">			<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h1><ul>
<li>平衡二叉树(Balanced Binary Tree)(简称平衡树，AVL)也是二叉排序树的一种，其特点在于，左右子树的高度之差的绝对值不超过1，左右子树高度之差被称为平衡因子，每次插入一个新的值的时候，都要检查二叉树的平衡，也就是平衡调整</li>
<li>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balanoe Factor)，平衡因乎只可能是-1、0和 1</li>
</ul>
<ul>
<li>基本思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。 在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>	/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="keyword">int</span> bf; <span class="comment">/*  结点的平衡因子 */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以p为根的二叉排序树作右旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree L;</span><br><span class="line">	L=(*P)-&gt;lchild; <span class="comment">/*  L指向P的左子树根结点 */</span> </span><br><span class="line">	(*P)-&gt;lchild=L-&gt;rchild; <span class="comment">/*  L的右子树挂接为P的左子树 */</span> </span><br><span class="line">	L-&gt;rchild=(*P);</span><br><span class="line">	*P=L; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以P为根的二叉排序树作左旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree R;</span><br><span class="line">	R=(*P)-&gt;rchild; <span class="comment">/*  R指向P的右子树根结点 */</span> </span><br><span class="line">	(*P)-&gt;rchild=R-&gt;lchild; <span class="comment">/* R的左子树挂接为P的右子树 */</span> </span><br><span class="line">	R-&gt;lchild=(*P);</span><br><span class="line">	*P=R; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">/*  左高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0  <span class="comment">/*  等高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">/*  右高 */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</span></span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree L,Lr;</span><br><span class="line">	L=(*T)-&gt;lchild; <span class="comment">/*  L指向T的左子树根结点 */</span> </span><br><span class="line">	<span class="keyword">switch</span>(L-&gt;bf)</span><br><span class="line">	&#123; <span class="comment">/*  检查T的左子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line">		 <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */</span> </span><br><span class="line">			(*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">			R_Rotate(T);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		 <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的左孩子的右子树上，要作双旋处理 */</span> </span><br><span class="line">			Lr=L-&gt;rchild; <span class="comment">/*  Lr指向T的左孩子的右子树根 */</span> </span><br><span class="line">			<span class="keyword">switch</span>(Lr-&gt;bf)</span><br><span class="line">			&#123; <span class="comment">/*  修改T及其左孩子的平衡因子 */</span> </span><br><span class="line">				<span class="keyword">case</span> LH: (*T)-&gt;bf=RH;</span><br><span class="line">						 L-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EH: (*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> RH: (*T)-&gt;bf=EH;</span><br><span class="line">						 L-&gt;bf=LH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Lr-&gt;bf=EH;</span><br><span class="line">			L_Rotate(&amp;(*T)-&gt;lchild); <span class="comment">/*  对T的左子树作左旋平衡处理 */</span> </span><br><span class="line">			R_Rotate(T); <span class="comment">/*  对T作右旋平衡处理 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */</span> </span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	BiTree R,Rl;</span><br><span class="line">	R=(*T)-&gt;rchild; <span class="comment">/*  R指向T的右子树根结点 */</span> </span><br><span class="line">	<span class="keyword">switch</span>(R-&gt;bf)</span><br><span class="line">	&#123; <span class="comment">/*  检查T的右子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line">	 <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */</span> </span><br><span class="line">			  (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">			  L_Rotate(T);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的右孩子的左子树上，要作双旋处理 */</span> </span><br><span class="line">			  Rl=R-&gt;lchild; <span class="comment">/*  Rl指向T的右孩子的左子树根 */</span> </span><br><span class="line">			  <span class="keyword">switch</span>(Rl-&gt;bf)</span><br><span class="line">			  &#123; <span class="comment">/*  修改T及其右孩子的平衡因子 */</span> </span><br><span class="line">				<span class="keyword">case</span> RH: (*T)-&gt;bf=LH;</span><br><span class="line">						 R-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EH: (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> LH: (*T)-&gt;bf=EH;</span><br><span class="line">						 R-&gt;bf=RH;</span><br><span class="line">						 <span class="keyword">break</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			  Rl-&gt;bf=EH;</span><br><span class="line">			  R_Rotate(&amp;(*T)-&gt;rchild); <span class="comment">/*  对T的右子树作右旋平衡处理 */</span> </span><br><span class="line">			  L_Rotate(T); <span class="comment">/*  对T作左旋平衡处理 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */</span> </span><br><span class="line"><span class="comment">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */</span> </span><br><span class="line"><span class="comment">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BiTree *T,<span class="keyword">int</span> e,Status *taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span>(!*T)</span><br><span class="line">	&#123; <span class="comment">/*  插入新结点，树“长高”，置taller为TRUE */</span> </span><br><span class="line">		 *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		 (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="literal">NULL</span>; (*T)-&gt;bf=EH;</span><br><span class="line">		 *taller=TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e==(*T)-&gt;data)</span><br><span class="line">		&#123; <span class="comment">/*  树中已存在和e有相同关键字的结点则不再插入 */</span> </span><br><span class="line">			*taller=FALSE; <span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (e&lt;(*T)-&gt;data)</span><br><span class="line">		&#123; <span class="comment">/*  应继续在T的左子树中进行搜索 */</span> </span><br><span class="line">			<span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			<span class="keyword">if</span>(*taller) <span class="comment">/*   已插入到T的左子树中且左子树“长高” */</span> </span><br><span class="line">				<span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，需要作左平衡处理 */</span> </span><br><span class="line">							LeftBalance(T);	*taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因左子树增高而使树增高 */</span> </span><br><span class="line">							(*T)-&gt;bf=LH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，现左、右子树等高 */</span>  </span><br><span class="line">							(*T)-&gt;bf=EH; *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; <span class="comment">/*  应继续在T的右子树中进行搜索 */</span> </span><br><span class="line">			<span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			<span class="keyword">if</span>(*taller) <span class="comment">/*  已插入到T的右子树且右子树“长高” */</span> </span><br><span class="line">				<span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，现左、右子树等高 */</span> </span><br><span class="line">							(*T)-&gt;bf=EH; *taller=FALSE;	<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因右子树增高而使树增高  */</span></span><br><span class="line">							(*T)-&gt;bf=RH; *taller=TRUE; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，需要作右平衡处理 */</span> </span><br><span class="line">							RightBalance(T); *taller=FALSE; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	BiTree T=<span class="literal">NULL</span>;</span><br><span class="line">	Status taller;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"本样例建议断点跟踪查看平衡二叉树结构"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="散列表查找-哈希表"><a href="#散列表查找-哈希表" class="headerlink" title="散列表查找(哈希表)"></a>散列表查找(哈希表)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>定义：散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。这种对应关系f称为散列函数， 又称为哈希( Hash) 函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。</p>
</li>
<li><p>散列技术既是一种存储方法，也是一种查找方法。两个关键字key1≠key2，但是却有f(key1)=f(key2) ，这种现象我们称为冲突(collision) ，并把key1 和key2 称为这个散列函数的同义词(synonym) 。</p>
</li>
</ul>
<h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>取关键字的某个线性函数值为散列地址：</p>
<script type="math/tex; mode=display">f(key)=key×a+b(a、b为常数)</script><p>适合查找表较小且连续的情况。</p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>对关键字的平方后取中间部分的值。比较适合子不知道关键字的分布，而位数又不是很大的情况。</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为:</p>
<script type="math/tex; mode=display">f(key)=key \ mod\ p(p⩽m)</script><p>mod 是取模(求余数)的意思 ，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。<br>若散列表表长为m， 通常p为小于或等于表长(最好接近m ) 的最小质数或不包含小子20质因子的合数。</p>
<h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一个随机数，取关键字的随机函数值为它的散列地址:</p>
<script type="math/tex; mode=display">f(key)=random(key)</script><h2 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>一旦发生了冲突， 就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<script type="math/tex; mode=display">fi(key)=(f(key)+di)\ MOD\ m(di=1,2,3,..,m−1)</script><p>为了不让关键字都聚集在某一块区域,一般增加平方运算：</p>
<script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)\ MOD\ m(di=12,−12,22,−22,..,q2,−q2,q⩽m/2)</script><p>在冲突时，对于位移量$d_i$，采用随机函数计算得到，我们称之为随机探测法:</p>
<script type="math/tex; mode=display">f_i(key)=(f(key)+d_i)MODm(di是一个随机数列)</script><h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>我们事先准备多个散列函数。</p>
<script type="math/tex; mode=display">fi(key)=RHi(key)(i=1,2,3,..,k)</script><p>这里RHi就是不同的散列函数。这种方法能够使得关键字不产生聚集，但也增加了计算的时间。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>
<p>它提供了绝不会出现找不到地址的保障，但也带来了查找时需要遍历单链装的性能损耗。</p>
<h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p>为所有冲突的关键字建立了一个公共的溢出区来存放。在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功； 如果不相等，则到溢出表去进行顺序查找。</p>
<h2 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12 <span class="comment">/* 定义散列表长为数组的长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY -32768</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;	<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem; <span class="comment">/* 数据元素存储基址，动态分配数组 */</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">/*  当前数据元素个数 */</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>; <span class="comment">/* 散列表表长，全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m=HASHSIZE;</span><br><span class="line">    H-&gt;count=m;</span><br><span class="line">    H-&gt;elem=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        H-&gt;elem[i]=NULLKEY;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m; <span class="comment">/* 除留余数法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入关键字进散列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key); <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = (addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;elem[addr] = key; <span class="comment">/* 直到有空位后插入关键字 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);  <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">while</span>(H.elem[*addr] != key) <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr+<span class="number">1</span>) % m; <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) <span class="comment">/* 如果循环回到原点 */</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;	<span class="comment">/* 则说明关键字不存在 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[HASHSIZE]=&#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,p,key,result;</span><br><span class="line">    HashTable H;</span><br><span class="line"></span><br><span class="line">    key=<span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">    InitHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(&amp;H,arr[i]);</span><br><span class="line"></span><br><span class="line">    result=SearchHash(H,key,&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 失败。\n"</span>,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        key=arr[i];</span><br><span class="line">        SearchHash(H,key,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找 %d 的地址为：%d \n"</span>,key,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027131236947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>VINS-Mono——预积分</title>
    <url>/2019/10/25/VINS-Mono%E2%80%94%E2%80%94%E9%A2%84%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了加深理解，参考崔华坤的《VINS论文推导及代码解析》，把相关公式推到一遍。</p><p>intergration_base.h：IMU预积分<br>imu_factor.h：IMU残差、雅可比</p><h1 id="IMU-测量方程"><a href="#IMU-测量方程" class="headerlink" title="IMU 测量方程."></a>IMU 测量方程.</h1><p>忽略地球旋转， IMU 测量方程为</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214341590.png#pic_center"></p><h1 id="预积分方程"><a href="#预积分方程" class="headerlink" title="预积分方程"></a>预积分方程</h1><h2 id="IMU-integration-in-world-frame"><a href="#IMU-integration-in-world-frame" class="headerlink" title="IMU integration in world frame"></a>IMU integration in world frame</h2><p>将第 k 帧和第 k+1 帧之间的所有 IMU 进行积分，可得第 k+1 帧的位置、速度和旋转<br>（PVQ），作为视觉估计的初始值，这里的旋转采用的四元数。</p><a id="more"></a>




<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214621188.png#pic_center"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024214759817.png#pic_center"></p>
<h1 id="IMU-integration-in-the-body-frame-of-first-pose-of-interests"><a href="#IMU-integration-in-the-body-frame-of-first-pose-of-interests" class="headerlink" title="IMU integration in the body frame of first pose of interests"></a>IMU integration in the body frame of first pose of interests</h1><p>为避免重新传播 IMU 观测值，选用 IMU 预积分模型，从世界坐标系转为本体坐标</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215210690.png#pic_center"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191024215228467.png#pic_center"></p>
<p>则 IMU 预积分模型（预积分估计值）为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152209217.png#pic_center"></p>
<p>离散状态下采用 中值积分 (mid-point) 的预积分方程（预积分测量值）为</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102815225757.png#pic_center"></p>
<p>其中：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028152316969.png#pic_center"></p>
<p>midPointIntegration中的相关代码（没有考虑噪声）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vector3d un_gyr = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">result_delta_q  = delta_q * Quaterniond(<span class="number">1</span>, un_gyr(<span class="number">0</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">1</span>) * _dt / <span class="number">2</span>, un_gyr(<span class="number">2</span>) * _dt / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Vector3d un_acc_0 =        delta_q * (_acc_0 - linearized_ba);</span><br><span class="line">Vector3d un_acc_1 = result_delta_q * (_acc_1 - linearized_ba);</span><br><span class="line">Vector3d un_acc   = <span class="number">0.5</span> * (un_acc_0 + un_acc_1);</span><br><span class="line"></span><br><span class="line">result_delta_p = delta_p + delta_v * _dt + <span class="number">0.5</span> * un_acc * _dt * _dt;</span><br><span class="line">result_delta_v = delta_v + un_acc * _dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预积分的过程中Bias没有发生改变</span></span><br><span class="line">result_linearized_ba = linearized_ba;</span><br><span class="line">result_linearized_bg = linearized_bg;</span><br></pre></td></tr></table></figure>
<p>当 bias 估计轻微改变时，我们可以使用如下的一阶近似 对中值积分得到的预积分测量值进矫正，而不重传播，从而得到 更加精确的预积分测量值（bias 修正的线性模型）</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028145945699.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150116815.png#pic_center"></p>
<p>上式可由误差项雅克比矩阵的迭代公式$J_{b_{k+1}}$得出：<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O_P = 0 , O_R = 3 , O_V = 6 , O_BA = 9 , O_BG = 12</span></span><br><span class="line">           Eigen::Matrix3d dp_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BA);</span><br><span class="line">            Eigen::Matrix3d dp_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_P, O_BG);</span><br><span class="line">            Eigen::Matrix3d dq_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_R, O_BG);</span><br><span class="line">            Eigen::Matrix3d dv_dba = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BA);</span><br><span class="line">            Eigen::Matrix3d dv_dbg = pre_integration-&gt;jacobian.<span class="keyword">template</span> block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(O_V, O_BG);</span><br></pre></td></tr></table></figure>
<h1 id="误差状态方程"><a href="#误差状态方程" class="headerlink" title="误差状态方程"></a>误差状态方程</h1><p>状态误差传递的线性递推关系可以通过两种方式实现</p>
<ul>
<li>基于误差随时间变化的递推方程</li>
<li>基于一阶泰勒展开的误差递推方程<br>本文用的第一种方法；我们还可以通过第二种方法：已知 IMU 预积分（中值积分）测量方程，通过求导计算出 F ′ 和 G′。</li>
</ul>
<h2 id="连续形式下-PVQ-增量误差的协方差及-Jacobian"><a href="#连续形式下-PVQ-增量误差的协方差及-Jacobian" class="headerlink" title="连续形式下 PVQ 增量误差的协方差及 Jacobian"></a>连续形式下 PVQ 增量误差的协方差及 Jacobian</h2><p>IMU 在每一个时刻积分出来的值是有误差的，下面我们对误差进行分析。首先我们直接给出在 t 时刻误差项的导数为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150603823.png#pic_center"><br>那么根据导数的定义有上一时刻推导下一时刻的误差如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150704700.png#pic_center"><br>上式恰好给出了如 EKF 一般对非线性系统线性化的过程，这里的意义是表示下一个时刻的 IMU 测量误差与上一个时刻的成线性关系，这样我们根据当前时刻的值，可以预测出下一个时刻的均值和协方差，而公式给出的是均值预测，协方差预测公式如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150752961.png#pic_center"><br>上式给出了协方差的迭代公式，初始值$P^{b_k}_{b_k}$ = 0。其中， Q 为表示噪声项的对角协方差<br>矩阵：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028150935869.png#pic_center#pic_center"><br>由上式可获得误差项的 Jacobian 的迭代公式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151013604.png#pic_center"><br>其中 Jacobian 的初始值为$J_{b_k}=I$。</p>
<h2 id="离散形式的-PVQ-增量误差的-Jacobian-和协方差"><a href="#离散形式的-PVQ-增量误差的-Jacobian-和协方差" class="headerlink" title="离散形式的 PVQ 增量误差的 Jacobian 和协方差"></a>离散形式的 PVQ 增量误差的 Jacobian 和协方差</h2><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151537536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>其中:</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151600894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>可以简写为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151718610.png#pic_center"></p>
<p>则 Jacobian 的迭代公式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151808834.png#pic_center"></p>
<p>其中， Jacobian 的初始值为𝐽𝑘 = 𝐼。 这里计算出来的𝐽𝑘+1只是为了给后面提供对 bias 的Jacobian。<br>协方差的迭代公式为：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151831375.png#pic_center"></p>
<p>其中， 初始值𝑃𝑘 = 0。 Q 为表示噪声项的对角协方差矩阵：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191028151847412.png#pic_center"></p>
<p>相关代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(update_jacobian)<span class="comment">//否更新雅克比矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3d w_x   = <span class="number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;</span><br><span class="line">        Vector3d a_0_x = _acc_0 - linearized_ba;</span><br><span class="line">        Vector3d a_1_x = _acc_1 - linearized_ba;</span><br><span class="line"></span><br><span class="line">        Matrix3d R_w_x, R_a_0_x, R_a_1_x;</span><br><span class="line"></span><br><span class="line">        R_w_x&lt;&lt;     <span class="number">0</span>, -w_x(<span class="number">2</span>),  w_x(<span class="number">1</span>),</span><br><span class="line">                w_x(<span class="number">2</span>),      <span class="number">0</span>, -w_x(<span class="number">0</span>),</span><br><span class="line">               -w_x(<span class="number">1</span>), w_x(<span class="number">0</span>),       <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_0_x&lt;&lt;        <span class="number">0</span>, -a_0_x(<span class="number">2</span>),  a_0_x(<span class="number">1</span>),</span><br><span class="line">                  a_0_x(<span class="number">2</span>),         <span class="number">0</span>, -a_0_x(<span class="number">0</span>),</span><br><span class="line">                 -a_0_x(<span class="number">1</span>),  a_0_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        R_a_1_x&lt;&lt;        <span class="number">0</span>, -a_1_x(<span class="number">2</span>),  a_1_x(<span class="number">1</span>),</span><br><span class="line">                  a_1_x(<span class="number">2</span>),         <span class="number">0</span>, -a_1_x(<span class="number">0</span>),</span><br><span class="line">                 -a_1_x(<span class="number">1</span>),  a_1_x(<span class="number">0</span>),         <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        MatrixXd F = MatrixXd::Zero(<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>)   = <span class="number">-0.25</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt * _dt +</span><br><span class="line">                                <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>)   = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>)   = <span class="number">-0.25</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">12</span>)  = <span class="number">-0.25</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>)   = Matrix3d::Identity() - R_w_x * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">12</span>)  = <span class="number">-1.0</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>)   = <span class="number">-0.5</span> * delta_q.toRotationMatrix() * R_a_0_x * _dt +</span><br><span class="line">                                <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * (Matrix3d::Identity() - R_w_x * _dt) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>)   = <span class="number">-0.5</span> * (delta_q.toRotationMatrix() + result_delta_q.toRotationMatrix()) * _dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">12</span>)  = <span class="number">-0.5</span> * result_delta_q.toRotationMatrix() * R_a_1_x * _dt * -_dt;</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">9</span>)   = Matrix3d::Identity();</span><br><span class="line">        F.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">12</span>) = Matrix3d::Identity();</span><br><span class="line"></span><br><span class="line">        MatrixXd V = MatrixXd::Zero(<span class="number">15</span>,<span class="number">18</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) =  <span class="number">0.25</span> * delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>) =  <span class="number">0.25</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">6</span>) =  <span class="number">0.25</span> *  result_delta_q.toRotationMatrix() * _dt * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">9</span>) =  <span class="number">0.5</span> * MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) =  <span class="number">0.5</span> * delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>) =  <span class="number">0.5</span> * -result_delta_q.toRotationMatrix() * R_a_1_x  * _dt * <span class="number">0.5</span> * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">6</span>) =  <span class="number">0.5</span> *  result_delta_q.toRotationMatrix() * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">9</span>) =  V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">9</span>, <span class="number">12</span>)  = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line">        V.block&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">12</span>, <span class="number">15</span>) = MatrixXd::Identity(<span class="number">3</span>,<span class="number">3</span>) * _dt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step_jacobian = F;</span></span><br><span class="line">        <span class="comment">//step_V = V;</span></span><br><span class="line">        jacobian   = F * jacobian;</span><br><span class="line">        covariance = F * covariance * F.transpose() + V * noise * V.transpose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过预积分误差的递推公式确实可以求出来从$b_k$帧到$b_{k+1}$帧的累积出来的误差大小，但是这个值并没有用，我们在后端需要的是误差对$b_k$ 帧和$b_{k+1}$帧的导数，而误差对$b_k$帧的导数却可以通过上式的雅克比矩阵直接计算出来，至于协方差矩阵是我们进行后端优化计算残差时用马氏距离需要用到。</p>
<p>公式推导：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181407525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025181458844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521325497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102521324273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213150727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191025213209259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/86290941" target="_blank" rel="noopener">VINS-Mono理论学习——IMU预积分 Pre-integration （Jacobian 协方差）</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>随机抽样一致RANSAC-Random-Sample-Consensus</title>
    <url>/2019/10/24/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4RANSAC-Random-Sample-Consensus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h1><p>随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法的基本假设是样本中包含正确数据(inliers，可以被模型描述的数据)，也包含异常数据(outliers，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</p><a id="more"></a>
<h1 id="RANSAC的基本假设："><a href="#RANSAC的基本假设：" class="headerlink" title="RANSAC的基本假设："></a>RANSAC的基本假设：</h1><p>“内群”数据可以通过几组模型的参数来叙述其分布，而“离群”数据则是不适合模型化的数据。<br>数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。<br>RANSAC假定，给定一组（通常很小）的内群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。</p>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><p>这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内群以及离群，其中内群为可以被拟合到线段上的点，而离群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内群的线，因为最小二乘法会受离群影响而影响其结果。而RANSAC，可以只由内群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020160728989.png#pic_center"><br>包含许多离群的一组数据，要找一条最适合的线。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910201607364.png#pic_center"><br>RANSAC找到的线，离群值对结果没影响（蓝色点为内群，红色点为离群）</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RANSAC算法的输入是一组观测数据（往往含有较大的噪声或无效点），一个用于解释观测数据的参数化模型以及一些可信的参数。RANSAC通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证： </p>
<ol>
<li>有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出。</li>
<li>用1中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li>
<li>如果有足够多的点被归类为假设的局内点，那么估计的模型就足够合理。</li>
<li>然后，用所有假设的局内点去重新估计模型（譬如使用最小二乘法），因为它仅仅被初始的假设局内点估计过。</li>
<li>最后，通过估计局内点与模型的错误率来评估模型。</li>
<li>上述过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为比现有的模型更好而被选用。<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1>伪码形式的算法如下所示：</li>
</ol>
<ul>
<li><p>输入：</p>
<blockquote>
<p>data —— 一组观测数据<br>model —— 适应于数据的模型<br>n —— 适用于模型的最少数据个数<br>k —— 算法的迭代次数<br>t —— 用于决定数据是否适应于模型的阀值<br>d —— 判定模型是否适用于数据集的数据数目</p>
</blockquote>
</li>
<li><p>输出：</p>
<blockquote>
<p>best_model —— 跟数据最匹配的模型参数（如果没有找到好的模型，返回null）<br>best_consensus_set —— 估计出模型的数据点<br>best_error —— 跟数据相关的估计出的模型错误</p>
</blockquote>
<ul>
<li>iterations = 0<blockquote>
<p>best_model = null<br>best_consensus_set = null<br>best_error = 无穷大<br>while ( iterations &lt; k )<br>maybe_inliers = 从数据集中随机选择n个点<br>maybe_model = 适合于maybe_inliers的模型参数<br>consensus_set = maybe_inliers</p>
</blockquote>
</li>
</ul>
</li>
<li><p>估计的模型就足够合理</p>
<blockquote>
<p>for ( 每个数据集中不属于maybe_inliers的点 ）<br>if ( 如果点适合于maybe_model，且错误小于t ）<br>将点添加到consensus_set<br>if （ consensus_set中的元素数目大于d ）<br>已经找到了好的模型，</p>
</blockquote>
</li>
<li><p>现在测试该模型到底有多好</p>
<blockquote>
<p>better_model = 适合于consensus_set中所有点的模型参数<br>this_error = better_model究竟如何适合这些点的度量<br>if ( this_error &lt; best_error )<br>我们发现了比以前好的模型，保存该模型直到更好的模型出现<br>best_model =  better_model<br>best_consensus_set = consensus_set<br>best_error =  this_error</p>
</blockquote>
</li>
<li><p>迭代</p>
<blockquote>
<p>增加迭代次数<br>返回 best_model, best_consensus_set, best_error</p>
</blockquote>
<p> RANSAC算法的可能变化包括以下几种：</p>
<ol>
<li><p>如果发现了一种足够好的模型（该模型有足够小的错误率），则跳出主循环。这样可能会节约计算额外参数的时间。</p>
<ol>
<li>直接从maybe_model计算this_error，而不从consensus_set重新估计模型。这样可能会节约比较两种模型错误的时间，但可能会对噪声更敏感。</li>
</ol>
<p>其实核心就是随机性和假设性。随机性用于减少计算了，那个循环次数就是利用正确数据出现的概率。所谓的假设性，就是说随机抽出来的数据我都认为是正确的，并以此去计算其他点，获得其他满足变换关系的点，然后利用投票机制，选出获票最多的那一个变换。</p>
</li>
</ol>
</li>
</ul>
<h1 id="参数决定"><a href="#参数决定" class="headerlink" title="参数决定"></a>参数决定</h1><p>假设每个点是真正内群的几率是w，则：</p>
<ul>
<li>w = 真正内群的数目 / 数据总共的数量</li>
</ul>
<p>通常我们不知道w 是多少，$w^{n}$是所选择的n 个点都是内群的几率，$1-w^{n}$ 是所选择的 n 个点至少有一个不是内群的几率， ${(1-w^{n})^{k}}$是表示重复k 次都没有全部的 {\displaystyle n} n 个点都是内群的几率，假设算法跑 k 次以后成功的几率是p，那么：</p>
<script type="math/tex; mode=display">{1-p=(1-w^{n})^{k}}</script><script type="math/tex; mode=display">{p=1-(1-w^{n})^{k}}</script><p>所以如果希望成功几率高， ${\displaystyle p=0.99}$， 当n 不变时，k 越大， {\displaystyle p} p 越大， 当w 不变时，n 越大，所需的k 就越大， 通常w 未知，所以 n 选小一点比较好。</p>
<h1 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h1><ul>
<li>RANSAC的优点是它能鲁棒的估计模型参数。例如，它能从包含大量局外点的数据集中估计出高精度的参数。</li>
<li>RANSAC的缺点是它计算参数的迭代次数没有上限；如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。</li>
<li>RANSAC只有一定的概率得到可信的模型，概率与迭代次数成正比。RANSAC的另一个缺点是它要求设置跟问题相关的阀值。</li>
<li>RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。</li>
</ul>
<p>参考：</p>
<blockquote>
<p><a href="https://blog.csdn.net/pi9nc/article/details/26596519" target="_blank" rel="noopener">RANSAC</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E6%8A%BD%E6%A8%A3%E4%B8%80%E8%87%B4" target="_blank" rel="noopener">随机抽样一致</a></p>
</blockquote>
]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>IMU测量模型、运动模型、误差模型</title>
    <url>/2019/10/24/IMU%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B%E3%80%81%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E3%80%81%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IMU测量模型"><a href="#IMU测量模型" class="headerlink" title="IMU测量模型"></a>IMU测量模型</h1><ul>
<li><p>MEMS 加速度计工作原理<br>测量原理可以用一个简单的质量块 + 弹簧 + 指示计来表示<br>加速度计测量值$a_m$为弹簧拉力对应的加速度</p>
<script type="math/tex; mode=display">a_m=\frac{f}{m}=a-g</script><p>其中m为质量块质量，a为物体在世界（惯性）坐标系下的实际加速度。</p>
</li>
<li><p>陀螺仪测量原理<br>陀螺仪的测量值即为IMU在body坐标系下的旋转角速度，要通过运动学模型转换到惯性坐标系下 ，按测量原理分有振动陀螺，光纤陀螺等。</p>
<p>低端 MEMS 陀螺上一般采用振动陀螺原理，通过测量 Coriolisforce 来间接得到角速度。</p>
<blockquote>
<p>在旋转坐标系中，运动的物体受到科氏力作用<br>MEMS 陀螺仪：一个主动运动轴 + 一个敏感轴<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017192448388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="IMU运动模型"><a href="#IMU运动模型" class="headerlink" title="IMU运动模型"></a>IMU运动模型</h1><h2 id="旋转量求导"><a href="#旋转量求导" class="headerlink" title="旋转量求导"></a>旋转量求导</h2><p>首先，如下图所示，考虑一个从原点出发的向量 r 绕单位轴 u 旋转，角速度大小为 θ˙。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017155511191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>角速度矢量可以表示为${\boldsymbol \omega}=\dot{\theta}u$，易得向量 r 末端点 P 的速度矢量，即 r的时间一阶导为</p>
<script type="math/tex; mode=display">\frac{d{r}}{dt} = {\boldsymbol \omega} \times {r}</script><p>坐标系 {B} 绕单位轴 u 旋转，如上所述，其三个轴的时间一阶导同样为</p>
<script type="math/tex; mode=display">\frac{d{\bf i}_B}{dt} = {\boldsymbol \omega} \times {\bf i}_B, \frac{d{\bf j}_B}{dt} = {\boldsymbol \omega} \times {\bf j}_B, \frac{d{\bf k}_B}{dt} = {\boldsymbol \omega} \times {\bf k}_B</script><p>$[ {\bf i}_B \quad {\bf j}_B \quad {\bf k}_B ]$ 实际上就是坐标系 {B} 相对于参考坐标系的旋转矩阵 R，R的时间一阶导为</p>
<script type="math/tex; mode=display">\dot{\bf R} =  [ {\boldsymbol \omega} \times {\bf i}_B \quad {\boldsymbol \omega} \times {\bf j}_B \quad {\boldsymbol \omega} \times {\bf k}_B ] = {\boldsymbol \omega} \times {\bf R}</script><p>叉乘运算可以转化为负对称矩阵的乘法：</p>
<script type="math/tex; mode=display">\dot{\bf R} = {\boldsymbol \omega}^{\land} {\bf R}</script><p>其中负对称矩阵${\boldsymbol \omega}^{\land}$为</p>
<script type="math/tex; mode=display">% <![CDATA[
\quad {\boldsymbol \omega}^{\land}= \begin{bmatrix}0 & -\omega_3 & \omega_2\\ \omega_3 & 0 & -\omega_1 \\ -\omega_2 & \omega_1 & 0\end{bmatrix} %]]></script><p>这里的角速度 ω 是在参考坐标系下表达的，角速度也经常表达在体坐标系 {B} 下，记为${}^B{\boldsymbol \omega} = {\bf R}^T{\boldsymbol \omega}$，即${\boldsymbol \omega} = {\bf R}{}^B{\boldsymbol \omega}$<br>上式也可以写作：</p>
<script type="math/tex; mode=display">\dot{\bf R} =w^{\land}R=(R^Bw)^{\land}R=R{}^{\land}wR^TR= R({}^Bw)^{\land}</script></blockquote>
</li>
</ul><a id="more"></a>
<blockquote>
<p>证：对任意旋转矩阵 R 和三维向量 v，都有$({\bf R v})^{\land} = {\bf Rv^{\land}R}^T$<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017160718789.png#pic_center"><br>最后一式利用向量叉乘的旋转变换不变性可证，即，对于任意${\bf v,u}\in \mathbb{R}^3$永远有</p>
<script type="math/tex; mode=display">({\bf Rv})\times({\bf Ru})={\bf R(v\times u)}</script><p>从三维几何的角度来理解：v,u 是任意两个三维向量，(v×u) 是一个和 v,u 都垂直、大小为 |v||u|sin(u,v) 的三维向量；将 v,u,v×u 三个向量都经过同一个旋转，它们的相对位姿和模长都不会改变，所以 (Rv) 和 (Ru) 的叉乘仍是 R(v×u)。</p>
</blockquote>
<h2 id="科氏加速度"><a href="#科氏加速度" class="headerlink" title="科氏加速度"></a>科氏加速度</h2><p>这次把绕惯性系 {A} 中固定单位轴 u 旋转的 {B} 作为参考坐标系。考虑下图， 点 P 相对于 {B} 运动，记 ${}^Br$ 分别为 P 在 {B} 下的坐标，r 为 P 的绝对坐标（即 {A} 下坐标）， R 仍为 {B} 相对于 {A} 的旋转矩阵，易知 $r=R{}^Br$。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017163839187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$r=R{}^Br$求一阶时间导</p>
<script type="math/tex; mode=display">{\bf v} = \dot{\bf r} = \dot{\bf R} {}^B{\bf r} + {\bf R}^B\dot{\bf r} = {\boldsymbol \omega}^{\land}{\bf R}{}^B{\bf r}+ {\bf R}^B\dot{\bf r}</script><p>记P在 {B}下速度为 ${}^Bv$，于是</p>
<script type="math/tex; mode=display">v = w^{\land}r+ {R}^B{}= w \times r+ v_r</script><p>${\bf v}_r$来表达「相对速度」的概念，准确定义为 P 相对于 {B} 的速度，在惯性系 {A} 下的表达<br>再对求时间导：</p>
<blockquote>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017165037235.png#pic_center"><br>在旋转坐标系下观察，运动的物体（运动方向和旋转轴不为同一个轴时）会受到科氏力的作用。</p>
<ul>
<li>第一项中${\boldsymbol \alpha}$为 {B} 的角加速度，所以第一项的物理意义是 {B} 旋转所造成的 P 的切向加速度</li>
<li>第二项是 {B} 旋转所造成的向心加速度</li>
<li>第三项比较特殊，为 {B} 的旋转运动与 P 相对 {B} 的平移运动耦合产生的加速度，称为科氏加速度</li>
<li>第四项为 P 相对于 {B} 的加速度，但在惯性系{A}下表达，类似于${\bf v}_r$</li>
</ul>
</blockquote>
<h1 id="IMU-误差模型"><a href="#IMU-误差模型" class="headerlink" title="IMU 误差模型"></a>IMU 误差模型</h1><p>加速度计和陀螺仪的误差可以分为：确定性误差，随机误差。</p>
<ul>
<li>确定性误差可以事先标定确定，包括： bias, scale …</li>
<li>随机误差通常假设噪声服从高斯分布，包括：高斯白噪声， bias<br>随机游走…<h2 id="确定性误差"><a href="#确定性误差" class="headerlink" title="确定性误差"></a>确定性误差</h2></li>
</ul>
<ol>
<li>Bias ，Scale<br>理论上，当没有外部作用时， IMU 传感器的输出应该为 0，但实际数据存在一个偏置 b。</li>
</ol>
<ul>
<li>加速度计 bias 对位姿估计的影响：<script type="math/tex; mode=display">v_err=b_at，p_err=\frac{1}{2}b_at^2</script></li>
<li>scale 可以看成是实际数值和传感器输出值之间的比值</li>
</ul>
<ol>
<li>Nonorthogonality/Misalignment Errors(非正交/错位错误）<br><img alt data-src="https://img-blog.csdnimg.cn/20191017182956354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"> </li>
<li>其他确定性误差<blockquote>
<ul>
<li>Run-to-Run Bias/Scale Facto</li>
<li>In Run (Stability) Bias/Scale Factor</li>
<li>Temperature-Dependent Bias/Scale Factor</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="确定性误差误差标定"><a href="#确定性误差误差标定" class="headerlink" title="确定性误差误差标定"></a>确定性误差误差标定</h3><h4 id="六面法标定加速度"><a href="#六面法标定加速度" class="headerlink" title="六面法标定加速度"></a>六面法标定加速度</h4><p><strong>bias 和 scale factor</strong></p>
<blockquote>
<p>六面法是指将加速度计的 3 个轴分别朝上或者朝下水平放置一段时间，采集 6 个面的数据完成标定。如果各个轴都是正交的，那很容易得到 bias 和 scale：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017171617729.png#pic_center"><br>其中,$l$为加速度计某个轴的测量值， g为当地的重力加速度</p>
</blockquote>
<p><strong>（Nonorthogonality/Misalignment Errors)</strong></p>
<blockquote>
<p>多轴 IMU 传感器制作的时候，由于制作工艺的问题，会使得 xyz 轴可能不垂直，如下图所示。</p>
<p>考虑轴间误差的时候，实际加速度和测量值之间的关系为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172240109.png#pic_center"><br>水平静止放置 6 面的时候，加速度的理论值为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172303634.png#pic_center"><br>对应的测量值矩阵 L ：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017172326866.png#pic_center"><br>利用最小二乘就能够把12个变量求出来。</p>
</blockquote>
<h4 id="六面法标定陀螺仪"><a href="#六面法标定陀螺仪" class="headerlink" title="六面法标定陀螺仪"></a>六面法标定陀螺仪</h4><blockquote>
<ul>
<li>六面法标定陀螺仪 bias 和 scale factor<br>和加速度计六面法不同的是，陀螺仪的真实值由高精度转台提供，这<br>里的 6 面是指各个轴顺时针和逆时针旋转。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017182109980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>参考：<a href="https://blog.csdn.net/CSDN_XCS/article/details/90339761" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_XCS/article/details/90339761</a></li>
</ul>
</blockquote>
<h4 id="温度相关的参数标定"><a href="#温度相关的参数标定" class="headerlink" title="温度相关的参数标定"></a>温度相关的参数标定</h4><ul>
<li>目的：这个标定的主要目的是对传感器估计的 bias 和 scale 进行温度补偿，获取不同温度时 bias 和 scale 的值，绘制成曲线。</li>
<li>两种标定方法：<blockquote>
<p>• soak method: 控制恒温室的温度值，然后读取传感器数值进行标定。<br>• ramp method：记录一段时间内线性升温和降温时传感器的数据来进行标定。</p>
</blockquote>
</li>
</ul>
<h2 id="随机误差"><a href="#随机误差" class="headerlink" title="随机误差"></a>随机误差</h2><h3 id="高斯白噪声与随机游走"><a href="#高斯白噪声与随机游走" class="headerlink" title="高斯白噪声与随机游走"></a>高斯白噪声与随机游走</h3><h4 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h4><p>高斯白噪声的高斯指的是概率分布为正态分布，白噪声指的是其二阶矩不相关，一阶矩为常数。故把瞬时值的概率分布服从高斯分布，功率谱密度服从均匀分布的噪声称为高斯白噪声</p>
<p>IMU 数据连续时间上受到一个均值为 0，方差为 $σ^2$，各时刻之间相互独立的高斯过程 n(t)：</p>
<script type="math/tex; mode=display">E[n(t)]=0</script><script type="math/tex; mode=display">E[n(t_1​)n(t_2​)]=σ^2δ(t_1​−t_2​)</script><p>自相关函数的数学定义：$R(τ)=∫^{−∞}_∞　x(t)x(t−τ)dt$</p>
<p>其中 $δ()$ 表示狄拉克函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190929113450104.png#pic_center"><br><strong>白噪声的离散化</strong><br>实际上， IMU 传感器获取的数据为离散采样，离散和连续高斯白噪声的方差之间存在如下转换关系：</p>
<script type="math/tex; mode=display">n_d[k] \triangleq n(t_0+\Delta t)\simeq\frac{1}{\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)dt</script><script type="math/tex; mode=display">
 \begin{aligned}
E(n_d[k]^2) & = E(\frac{1}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(\tau)n(t)d \tau dt) \\
&= E( \frac{\sigma^2}{\Delta t^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\
&= E(\frac{\sigma^2}{\Delta t})
\end{aligned}</script><p>即:</p>
<script type="math/tex; mode=display">nd[k] = σ_dw[k]</script><p>其中：$w[k] ∼ N(0, 1)$，$\sigma_d=\sigma \frac{1}{\sqrt{\bigtriangleup t}}$<br>也就是说高斯白噪声的连续时间到离散时间之间差一个 $\frac{1}{\sqrt{\bigtriangleup t}}$ ，√∆t 是传感器的采样时间。</p>
<h4 id="Bias-随机游走"><a href="#Bias-随机游走" class="headerlink" title="Bias 随机游走"></a>Bias 随机游走</h4><p>通常用维纳过程 (wiener process) 来建模 bias 随时间连续变化的过程，离散时间下称之为随机游走</p>
<script type="math/tex; mode=display">\dot{b}_{(t)}=n(t)=\sigma_bw(t)</script><p>其中 w 是方差为 1 的白噪声</p>
<p>离散和连续之间的转换：</p>
<script type="math/tex; mode=display">b_d[k] \triangleq b(t_0) + \int_{t_0}^{t_0+\Delta t}n(t)dt$$$$\begin{aligned}
E((b_d[k]-b_d[k-1])^2) 
&=E(\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}n(t)n(\tau)d \tau dt)\\
&= E({\sigma_{b}^2}\int_{t_0}^{t_0+\Delta t}\int_{t_0}^{t_0+\Delta t}\delta(t-\tau)d \tau dt)\\
&= E(\sigma_{b}^2\Delta t)
\end{aligned}</script><p>即：</p>
<script type="math/tex; mode=display">b_d[k] = b_d[k − 1] + σ_{bd}w[k]</script><p>其中：</p>
<script type="math/tex; mode=display">w[k] ∼ N(0, 1),σ_{bd} = σ_b\sqrt{\bigtriangleup t}</script><p>bias 随机游走的噪声方差从连续时间到离散之间需要乘以 $\sqrt{\bigtriangleup t}$ </p>
<h3 id="随机误差的标定"><a href="#随机误差的标定" class="headerlink" title="随机误差的标定"></a>随机误差的标定</h3><h4 id="艾伦方差标定"><a href="#艾伦方差标定" class="headerlink" title="艾伦方差标定"></a>艾伦方差标定</h4><p>Allan 方差法是 20 世纪 60 年代由美国国家标准局的 David Allan 提出的，它是一种基于时域的分析方法。</p>
<blockquote>
<p>具体的流程如下：</p>
<ol>
<li>保持传感器绝对静止获取数据</li>
<li>对数据进行分段，设定时间段的时长，如下图所示<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204504508.png#pic_center"></li>
<li>将传感器数据按照时间段进行平均</li>
<li>计算方差，绘制艾伦曲线，得到的艾伦曲线如下图所示:<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017204557636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70">Allan方差法可用于5种随机误差的标定：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191017212131103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/YunLaowang/article/details/95608107" target="_blank" rel="noopener">VIO标定IMU随机误差：Allan方差法</a><br><a href="https://blog.csdn.net/lei1105034103/article/details/89159459" target="_blank" rel="noopener">陀螺 Allan 方差分析</a></li>
</ol>
</blockquote>
<h2 id="IMU-数学模型"><a href="#IMU-数学模型" class="headerlink" title="IMU 数学模型"></a>IMU 数学模型</h2><p>以 ECI 为参考坐标系（由于 ECI 为惯性系，不需要考虑地球自转）：<br>忽略 scale 的影响，只考虑白噪声和 bias 随机游走：<br>IMU的真实值：$w^b,a^b$<br>IMU的测量值：$\widetilde{w},\widetilde{a}^b$<br>IMU机体系即b系，w系表示世界坐标系。</p>
<script type="math/tex; mode=display">\begin{aligned}
 \widetilde{w}&=w^b +b^g+n^g\\
 \widetilde{a}^b&=a^b+b^a+n^a\\&=q_{bw}(a^w+g^w)+b^a+n^a
 \end{aligned}</script><p>考虑高斯白噪声项，有：</p>
<script type="math/tex; mode=display">\begin{aligned}
 &w^b=\widetilde{w} -b^g-n^g\\
 &a^w=q_{wb}(\widetilde{a}^b-b^a-n^a)-g^w
 \end{aligned}</script><p>不考虑高斯白噪声项，有：</p>
<script type="math/tex; mode=display">\begin{aligned}
 &w^b=\widetilde{w} -b^g\\
 &a^w=q_{wb}(\widetilde{a}^b-b^a)-g^w
 \end{aligned}</script><p>参考：<a href="https://fzheng.me/2016/11/20/imu_model_eq/#1-2-%E5%89%8D%E7%BD%AE2-%E5%9B%9B%E5%85%83%E6%95%B0" target="_blank" rel="noopener">从零开始的 IMU 状态模型推导</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VIO</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16下Github+Hexo搭建博客教程</title>
    <url>/2019/10/23/Ubuntu16%E4%B8%8BGithub+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿博客网址</p><p>==<a href="https://xiao-hu.com.cn/">https://xiao-hu.com.cn/</a>==</p><h1 id="安装git、nodejs"><a href="#安装git、nodejs" class="headerlink" title="安装git、nodejs"></a>安装git、nodejs</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>升级nodejs版本，目前的最新版本v10.6.0<br>参考：<a href="https://blog.csdn.net/u010277553/article/details/80938829" target="_blank" rel="noopener">Ubuntu16 升级nodejs版本</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line"></span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><br>加速下载：<a href="https://blog.csdn.net/ibmall/article/details/81390639" target="_blank" rel="noopener">npm 安装 hexo 卡住问题解决</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hexo init xiaohu</span><br><span class="line"><span class="built_in">cd</span> xiaohu </span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹目录下有：</p>
<blockquote>
<p>   node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p>
</blockquote>
<p>再次输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hexo g <span class="comment">#生成静态页面</span></span><br><span class="line">sudo hexo server <span class="comment">#启动服务器</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这时候就可以用浏览器打开网址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 来进行预览了。</p>
<h1 id="github创建"><a href="#github创建" class="headerlink" title="github创建"></a>github创建</h1><p>以前创好了：<a href="https://mp.csdn.net/mdeditor/94998475#" target="_blank" rel="noopener">Ubuntu16.04 git安装与配置</a></p>
<h1 id="创建repo"><a href="#创建repo" class="headerlink" title="创建repo"></a>创建repo</h1><p>在github上面创建一个项目，名为Xiao-Hu-Z+github.io </p>
<h1 id="将hexo部署到github"><a href="#将hexo部署到github" class="headerlink" title="将hexo部署到github"></a>将hexo部署到github</h1><p>打开站点配置文件_config.yml，翻到最后，进行修改。其中YourgithubName就是你的GitHub账户。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br>deploy时要你输入username和password。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在站点目录下输入下面的插件安装</span></span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo generate</span><br><span class="line">sudo hexo deploy</span><br></pre></td></tr></table></figure>
<p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p>
<p>输入：<a href="https://Xiao-Hu-Z.github.io/看到自己的博客" target="_blank" rel="noopener">https://Xiao-Hu-Z.github.io/看到自己的博客</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://Xiao-Hu-Z.github.io/</span><br></pre></td></tr></table></figure>
<h1 id="绑定域名："><a href="#绑定域名：" class="headerlink" title="绑定域名："></a>绑定域名：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping Xiao-Hu-Z.github.io</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/e3169b681038" target="_blank" rel="noopener">[Hexo个人博客]域名绑定 简明教程（小白篇）</a></p>
</blockquote>
<p>参考：<a href="https://blog.csdn.net/zxwsbg/article/details/97487666" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://blog.csdn.net/wang_da_bing/article/details/82818445" target="_blank" rel="noopener">Ubuntu18下Github+Hexo搭建博客教程</a><br><a href="https://www.cnblogs.com/yangzhaonan/p/9351838.html" target="_blank" rel="noopener">使用GitHub+Hexo建立个人网站，并绑定自己的域名（Ubuntu环境下）</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo4.0 - Next7.2.4 主题优化配置</title>
    <url>/2019/10/23/hexo4.0%20-%20Next7.2.4%20%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Next主题的安装"><a href="#Next主题的安装" class="headerlink" title="Next主题的安装"></a>Next主题的安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo_blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后设置站点配置文件_config.yml，Hexo博客主题替换为Next主题。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022101546332.png#pic_center">.</p><h1 id="Next主题优化配置"><a href="#Next主题优化配置" class="headerlink" title="Next主题优化配置"></a>Next主题优化配置</h1><h2 id="1-Next主题风格："><a href="#1-Next主题风格：" class="headerlink" title="1.Next主题风格："></a>1.Next主题风格：</h2><a id="more"></a>

<p>Next提供了四中主题风格scheme，可以在主题配置文件blog/themes/next/_config.yml文件中进行选择，分别是Muse、Mist、Pisces、Gemini：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022102034549.png#pic_center"></p>
<ul>
<li>Next主题一般配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation. Introduced in NexT v6.0.0.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment">#表示添加缓存功能，这样浏览器后续打开我们的博客网站会更快</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons / item badges.</span></span><br><span class="line">menu_settings:</span><br><span class="line">  icons: <span class="literal">true</span>  <span class="comment">#是否显示各个页面的图标</span></span><br><span class="line">  badges: <span class="literal">false</span> <span class="comment">#是否显示分类/标签/归档页的内容量</span></span><br></pre></td></tr></table></figure>
<p>相应的站点配置blog/_config.yml文件的基本配置为：</p>
<h2 id="2-添加博客自定义图标"><a href="#2-添加博客自定义图标" class="headerlink" title="2.添加博客自定义图标"></a>2.添加博客自定义图标</h2><p>选择或者创建相应大小的图标文件，放置在blog/themes/next/sources/images目录下，并在主题配置文件中进行如下配置，只需要设置small和medium两个就可以：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022104457616.png#pic_center"></p>
<h2 id="3-添加动态背景"><a href="#3-添加动态背景" class="headerlink" title="3.添加动态背景"></a>3.添加动态背景</h2><p>打开 next/layout/_layout.swig<br>在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置文件，打开 /next/_config.yml,在里面添加如下代码：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022145253296.png#pic_center">.</p>
<h2 id="4-添加看板娘"><a href="#4-添加看板娘" class="headerlink" title="4.添加看板娘"></a>4.添加看板娘</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>下载模型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install live2d-widget-model-wanko</span><br></pre></td></tr></table></figure>
<h2 id="5-鼠标点击特效"><a href="#5-鼠标点击特效" class="headerlink" title="5.鼠标点击特效"></a>5.鼠标点击特效</h2><p>鼠标的点击红心特效<br>在/themes/next/source/js/src下新建文件clicklove.js ，接着把下面的代码拷贝粘贴到 love.js 文件中：<br>7.4 next没有src文件夹，先建一个src文件夹<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span>(e,t,a)&#123;<span class="keyword">function</span> <span class="function"><span class="title">n</span></span>()&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="keyword">function</span> <span class="function"><span class="title">r</span></span>()&#123;<span class="keyword">for</span>(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="keyword">function</span> <span class="function"><span class="title">o</span></span>()&#123;var t=<span class="string">"function"</span>==typeof e.onclick&amp;&amp;e.onclick;e.onclick=<span class="keyword">function</span>(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="keyword">function</span> i(e)&#123;var a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;<span class="keyword">function</span> c(e)&#123;var a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[0].appendChild(a)&#125;<span class="keyword">function</span> <span class="function"><span class="title">s</span></span>()&#123;<span class="built_in">return</span><span class="string">"rgb("</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">","</span>+~~(255*Math.random())+<span class="string">")"</span>&#125;var d=[];e.requestAnimationFrame=<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="keyword">function</span>(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure></p>
<p>在\themes\next\layout_layout.swig文件末尾添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clicklove.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="6-设置头像"><a href="#6-设置头像" class="headerlink" title="6.设置头像"></a>6.设置头像</h2><p>在主题配置文件中设置头像，将其放置到 themes/next/source/images/avatar.png 路径，rounded是否设置成圆形，rotated是否设置成可旋转的。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022134436646.png#pic_center"></p>
<h2 id="7-设置RSS订阅"><a href="#7-设置RSS订阅" class="headerlink" title="7.设置RSS订阅"></a>7.设置RSS订阅</h2><p>博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>打开根目录配置文件_config.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure>
<p>然后设置主题配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>
<h2 id="8-侧边栏社交小图标设置"><a href="#8-侧边栏社交小图标设置" class="headerlink" title="8.侧边栏社交小图标设置"></a>8.侧边栏社交小图标设置</h2><p>打开主题配置文件_config.yml，command+f搜索 Social，将你有的社交账号前面的 # 号去掉。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022135427340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="9-Tag-标签前图标修改"><a href="#9-Tag-标签前图标修改" class="headerlink" title="9.Tag 标签前图标修改"></a>9.Tag 标签前图标修改</h2><p>文章标签的显示默认前面“#”号，可以通过设置将“#”换为图标。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tag_icon: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="10-访问量统计"><a href="#10-访问量统计" class="headerlink" title="10.访问量统计"></a>10.访问量统计</h2><ul>
<li>打开themes/next/下的_config.yml，查找busuanzi<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</li>
<li>打开/themes/next/layout/_partials/footer.swig，在最后添加如下内容：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span><br><span class="line">  本站访问次数：&lt;span class=<span class="string">"busuanzi-value"</span> id=<span class="string">"busuanzi_value_site_pv"</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-实现文章统计功能"><a href="#11-实现文章统计功能" class="headerlink" title="11.实现文章统计功能"></a>11.实现文章统计功能</h2><p>统计字数和阅读分钟数<br>安装 hexo-symbols-count-time，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件 hexo _config.yaml添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  time: <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  total_symbols: <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  total_time: <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  exclude_codeblock: <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>
<p>具体可查看：<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a><br>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022142919746.png#pic_center"></p>
<h2 id="12-添加网页顶部进度加载条"><a href="#12-添加网页顶部进度加载条" class="headerlink" title="12.添加网页顶部进度加载条"></a>12.添加网页顶部进度加载条</h2><p>下载安装Progress module，如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure></p>
<p>编辑主题配置文件，command+F 搜索 pace，将其值改为 ture 就可以了。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022144354865.png#pic_center"></p>
<h2 id="13-添加站内搜索"><a href="#13-添加站内搜索" class="headerlink" title="13.添加站内搜索"></a>13.添加站内搜索</h2><p>安装 hexo-generator-search<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><br>安装 hexo-generator-searchdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>编辑站点配置文件，添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure><br>编辑主题配置文件，设置 local_search为 ture<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102215014852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="14-Footer-页脚设置"><a href="#14-Footer-页脚设置" class="headerlink" title="14.Footer / 页脚设置"></a>14.Footer / 页脚设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  icon:</span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    name: user</span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="comment">## 图标的一个动画效果，类似于心跳</span></span><br><span class="line">    animated: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="comment"># 图标颜色，可格局需要自行修改</span></span><br><span class="line">    color: <span class="string">"#808080"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo 字样，不喜欢可以设置为 false</span></span><br><span class="line">  powered:</span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 主题字样，不喜欢可以 false</span></span><br><span class="line">  theme:</span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="comment"># 备案信息，如果网站有备案号，可以在这里填写备案号</span></span><br><span class="line">  beian:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">    icp:</span><br></pre></td></tr></table></figure>
<h2 id="15-Creative-Commons-文章版权"><a href="#15-Creative-Commons-文章版权" class="headerlink" title="15.Creative Commons / 文章版权"></a>15.Creative Commons / 文章版权</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-nd</span><br><span class="line">  post: <span class="literal">true</span></span><br><span class="line">  language: deed.zh</span><br></pre></td></tr></table></figure>
<p>在文章 .md 文件中的上部，添加 copyright: true。</p>
<h2 id="16-设置阅读全文"><a href="#16-设置阅读全文" class="headerlink" title="16.设置阅读全文"></a>16.设置阅读全文</h2><p>打开主题配置文件，修改auto_excerpt:字段为true，length表示显示文本的长度<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022151038529.png#pic_center"><br>在想要隐藏的位置加入以下代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="17-开启文章目录"><a href="#17-开启文章目录" class="headerlink" title="17.开启文章目录"></a>17.开启文章目录</h2><p>修改主题配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line">toc:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  number: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  wrap: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  expand_all: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure>
<h2 id="18-GitHub-Fork-Me"><a href="#18-GitHub-Fork-Me" class="headerlink" title="18.GitHub Fork Me"></a>18.GitHub Fork Me</h2><p>修改主题配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line">github_banner:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  permalink: https://github.com/Xiao-Hu-Z</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191022161748244.png#pic_center"></p>
<h2 id="19-bookmark"><a href="#19-bookmark" class="headerlink" title="19.bookmark"></a>19.bookmark</h2><p>Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bookmark:	</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.	</span></span><br><span class="line">  color: <span class="string">"#222"</span>	</span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.	</span></span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure>
<h2 id="20-添加lazyload"><a href="#20-添加lazyload" class="headerlink" title="20. 添加lazyload"></a>20. 添加lazyload</h2><p>对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-jquery-lazyload <span class="built_in">source</span>/lib/jquery_lazyload</span><br></pre></td></tr></table></figure><br>主题配置文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Vanilla JavaScript plugin for lazyloading images.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/ApoorvSaxena/lozad.js</span></span><br><span class="line">lazyload: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="21-代码复制"><a href="#21-代码复制" class="headerlink" title="21.代码复制"></a>21.代码复制</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line">copy_button:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="22-SEO支持"><a href="#22-SEO支持" class="headerlink" title="22.SEO支持"></a>22.SEO支持</h2><p>SEO(Search Engine Optimization)意为搜索引擎优化,利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</p>
<ul>
<li>安装站点地图(sitemap)插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<ul>
<li>站点配置文件修改/添加</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SEO </span></span><br><span class="line">sitemap: </span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>启用百度推送功能，博客会自动将网址推送到百度，这对搜索引擎优化非常有帮助。<br>主题配置文件修改 baidu_push: true</p>
<h2 id="23-显示当前浏览进度"><a href="#23-显示当前浏览进度" class="headerlink" title="23.显示当前浏览进度"></a>23.显示当前浏览进度</h2><p>打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true ，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Scroll percent label in b2t button.# # 是否显示页面浏览百分比</span><br><span class="line">scrollpercent: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h1><h2 id="1-支持数学公式"><a href="#1-支持数学公式" class="headerlink" title="1.支持数学公式"></a>1.支持数学公式</h2><p>可能在一些情况下我们需要写一个公式，makdown是支持的，next也支持。</p>
<p>Next 主题提供了两个渲染引擎，分别是 mathjax 和katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations。" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/math-equations。</a></p>
<p>这里选择 mathjax ,通过修改配置即可启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>注意：使用的时候需要在 文章开头加上mathjax: true</p>
<ul>
<li><h1 id="解决语义冲突"><a href="#解决语义冲突" class="headerlink" title="解决语义冲突"></a>解决语义冲突</h1><p>由于LaTeX与markdown语法有语义冲突，在markdown中，斜体和加粗可以用<em>或者_表示，在这里我们修改变量，将_用于LaTeX，而使用</em>表示markdown中的斜体和加粗。<br>在博客根目录下，进入node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>
<p>同时把第20行的em变量也要做相应的修改:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">//  em: /^<span class="symbol">\b</span>_((?:__|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br><span class="line">em: /^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure>
<p>修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line"><span class="attr">  mathjax:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line"><span class="attr">    mhchem:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-添加APlayer音乐播放器"><a href="#2-添加APlayer音乐播放器" class="headerlink" title="2.添加APlayer音乐播放器"></a>2.添加APlayer音乐播放器</h2><p>为博客添加音乐播放器功能</p>
<p><strong>download</strong><br>点击访问Aplayer源码：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">GitHub Aplayer</a>。下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下。</p>
<p><strong>music.js</strong><br>新建themes\next\source\dist\music.js文件，添加内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const ap = new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(<span class="string">'aplayer'</span>),</span><br><span class="line">    fixed: <span class="literal">true</span>,</span><br><span class="line">    autoplay: <span class="literal">true</span>,</span><br><span class="line">    audio: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"暗涌"</span>,</span><br><span class="line">        artist: <span class="string">'王菲'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/52980.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/w8RFsMH8VJfPsBmVudYGsA==/109951163020569833.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'Wonderful U'</span>,</span><br><span class="line">        artist: <span class="string">'AGA'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/51181.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Blb_Gi0AJTWIEBLr189F4A==/18791753232142320.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'浮夸'</span>,</span><br><span class="line">        artist: <span class="string">'陈奕迅'</span>,</span><br><span class="line">        url: <span class="string">'http://www.ytmp3.cn/down/49639.mp3'</span>,</span><br><span class="line">        cover: <span class="string">'http://p1.music.126.net/Bl1hEdJbMSj5YJsTqUjr-w==/109951163520311175.jpg?param=130y130'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>源码参数解释<a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">APlayer 中文文档</a></p>
<p>audio对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：<a href="http://up.mcyt.net/" target="_blank" rel="noopener">http://up.mcyt.net/</a> ，搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。</p>
<p><strong>_layout.swig</strong><br>打开themes\next\layout_layout.swig文件,在<body><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body> 里面添加以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"aplayer"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/APlayer.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/music.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>重新生成，访问页面，就能看到左下角的音乐播放器了。</p>
<h2 id="3-DaoVoice在线联系功能"><a href="#3-DaoVoice在线联系功能" class="headerlink" title="3.DaoVoice在线联系功能"></a>3.DaoVoice在线联系功能</h2><p><a href="https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/" target="_blank" rel="noopener">https://yfzhou.coding.me/2018/08/08/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%9B%86%E6%88%90DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD%EF%BC%89/</a></p>
<h1 id="自定义样式支持"><a href="#自定义样式支持" class="headerlink" title="自定义样式支持"></a>自定义样式支持</h1><h2 id="1-文章末尾统一添加“本文结束”标记"><a href="#1-文章末尾统一添加“本文结束”标记" class="headerlink" title="1.文章末尾统一添加“本文结束”标记"></a>1.文章末尾统一添加“本文结束”标记</h2><p>主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  postBodyEnd: <span class="built_in">source</span>/_data/post-body-end.swig</span><br></pre></td></tr></table></figure>
<p>接着打开\themes\next\layout_macro\post.swig文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在路径 /source/_data 下创建/修改 post-body-end.swig文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------本文结束&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-主题及标题栏背景图"><a href="#2-主题及标题栏背景图" class="headerlink" title="2.主题及标题栏背景图"></a>2.主题及标题栏背景图</h2><p>首先主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>
<p> 在路径~/hexo_blog/source/_data创建/修改 styles.styl文件，并添加以下内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line">body &#123;</span><br><span class="line">      background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址</span><br><span class="line">      background-size: cover;</span><br><span class="line">      background-repeat: no-repeat;</span><br><span class="line">      background-attachment: fixed;</span><br><span class="line">      background-position: 50% 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 标题栏背景</span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: 20px 0;</span><br><span class="line">    color: <span class="comment">#fff;</span></span><br><span class="line">    background: <span class="variable">$blue</span>;</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:center;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 修改主体透明度</span><br><span class="line">.main-inner&#123;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    opacity: 0.95;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改菜单栏透明度，会引起本地搜索菜单bug</span><br><span class="line">//.header-inner &#123;</span><br><span class="line">//    opacity: 0.95;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 主页文章添加阴影效果</span><br><span class="line">.post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-修改主副标题字体颜色"><a href="#3-修改主副标题字体颜色" class="headerlink" title="3.修改主副标题字体颜色"></a>3.修改主副标题字体颜色</h2><p>继续在/source/_data/styles.styl文件中添加，帮你挑选颜色的网站： <a href="https://www.color-hex.com/" target="_blank" rel="noopener">color-hex</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主标题颜色</span></span><br><span class="line">.brand&#123;</span><br><span class="line">    color: $white</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//副标题颜色</span></span><br><span class="line">.site-subtitle &#123;</span><br><span class="line">    margin-top: <span class="number">10</span>px;</span><br><span class="line">    font-size: <span class="number">13</span>px;</span><br><span class="line">    color: <span class="meta">#ffffff;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-修改按钮，选择区域，代码块，表格等样式"><a href="#4-修改按钮，选择区域，代码块，表格等样式" class="headerlink" title="4.修改按钮，选择区域，代码块，表格等样式"></a>4.修改按钮，选择区域，代码块，表格等样式</h2><p>首先主题配置文件取消注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/variables.styl</span><br></pre></td></tr></table></figure>
<p>在路径 /source/_data 下创建/修改 variables.styl文件（相当于修改主题文件 next/source/css/_variables/base.styl），并添加以下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buttons</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$btn-<span class="keyword">default</span>-bg                 = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-color              = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-font-size          = $font-size-small;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-width       = <span class="number">2</span>px;</span><br><span class="line">$btn-<span class="keyword">default</span>-border-color       = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-bg           = #<span class="number">49b</span>1f5;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-color        = white;</span><br><span class="line">$btn-<span class="keyword">default</span>-hover-border-color = #<span class="number">49b</span>1f5;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Selection</span></span><br><span class="line">$selection-bg                 = #<span class="number">49b</span>1f5;</span><br><span class="line">$selection-color              = white;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code &amp; Code Blocks</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$code-font-family               = $font-family-monospace;</span><br><span class="line">$code-border-radius             = <span class="number">3</span>px;</span><br><span class="line">$code-foreground                = $black-light;</span><br><span class="line">$code-background                = #edf1ff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Table</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">$table-width                    = normal;  <span class="comment">//next默认100%</span></span><br><span class="line">$table-border-color             = $gray-lighter;</span><br><span class="line">$table-font-size                = $font-size-small;</span><br><span class="line">$table-content-alignment        = left;</span><br><span class="line">$table-content-vertical         = middle;</span><br><span class="line">$table-th-font-weight           = <span class="number">700</span>;</span><br><span class="line">$table-cell-padding             = <span class="number">8</span>px;</span><br><span class="line">$table-cell-border-right-color  = $gainsboro;</span><br><span class="line">$table-cell-border-bottom-color = $gray-lighter;</span><br><span class="line">$table-row-odd-bg-color         = #f9f9f9;</span><br><span class="line">$table-row-hover-bg-color       = $whitesmoke;</span><br></pre></td></tr></table></figure>
<h1 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h1><h2 id="托管-Hexo-博客到-Coding"><a href="#托管-Hexo-博客到-Coding" class="headerlink" title="托管 Hexo 博客到 Coding"></a>托管 Hexo 博客到 Coding</h2><p>注意：coding账号注册时请选择个人版（如果注册了团队版，你会发现跟网上给的教程不太一样，而且，部署出来的网页地址无法修改成xxx.coding.me）。</p>
<ul>
<li>创建项目<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191027145840374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></li>
<li>配置SSH公钥<br>首先点击右上角的头像-个人设置-SSH公钥-新增公匙-输入你自己的SSH公匙-永久有效(推荐)-确定即可。</li>
<li>修改站点配置文件<br>对该配置进行修改如下(注意缩进)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https://github.com/Xiao-Hu-Z/Xiao-Hu-Z.github.io.git</span><br><span class="line">    coding: git@git.dev.tencent.com:Xiao-Hu-Z/Xiao-Hu-Z.coding.me.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>该配置指定了Coding仓库的地址，并通过HTTPS方式进行连接。同样我们也可以通过SSH方式。<br>安装完成后，开始项目的部署操作，用的是HTTPS方式，会弹出输入用户名密码的输入框，键入你的coding用户名密码即可。</p>
<h2 id="gulp-4-0实现静态资源压缩"><a href="#gulp-4-0实现静态资源压缩" class="headerlink" title="gulp 4.0实现静态资源压缩"></a>gulp 4.0实现静态资源压缩</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install gulp</span><br></pre></td></tr></table></figure>
<ul>
<li>安装这些功能模块</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify --save</span><br></pre></td></tr></table></figure>
<ul>
<li>创建任务在站点根目录下新建gulpfile.js文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var gulp = require(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">//Plugins模块获取</span><br><span class="line">var minifycss = require(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line">var uglify = require(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">var htmlmin = require(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line">var htmlclean = require(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line">//压缩css</span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">//压缩html</span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">.pipe(htmlclean())</span><br><span class="line">.pipe(htmlmin(&#123;</span><br><span class="line">removeComments: <span class="literal">true</span>,</span><br><span class="line">minifyJS: <span class="literal">true</span>,</span><br><span class="line">minifyCSS: <span class="literal">true</span>,</span><br><span class="line">minifyURLs: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩js 不压缩min.js</span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line"><span class="built_in">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.0以前的写法</span><br><span class="line">//gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">  //  <span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span></span><br><span class="line">//]);</span><br><span class="line">//4.0以后的写法</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // Do something after a, b, and c are finished.</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/qq_41518277/article/details/101766036#_355" target="_blank" rel="noopener">NexT主题进阶</a><br><a href="https://blog.csdn.net/colton_null/article/details/97622079" target="_blank" rel="noopener">Hexo Theme NexT 主题个性化配置最佳实践</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86556971" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列4-加速Hexo博客</a><br><a href="https://blog.csdn.net/Fitz1318/article/details/86538306" target="_blank" rel="noopener">Hexo+Coding搭建自己的博客网站系列2-部署博客到Coding上</a><br><a href="https://hanhanhanxu.github.io/2019/05/15/coding/" target="_blank" rel="noopener">使用coding加快博客网站访问速度</a><br><a href="http://ju.outofmemory.cn/entry/105418" target="_blank" rel="noopener">托管 Hexo 博客到 Coding</a><br><a href="https://www.cnblogs.com/aoguai/p/11405829.html" target="_blank" rel="noopener">2019hexo博客部署到coding该绕的坑</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——视觉前段处理</title>
    <url>/2019/10/23/VINS-Mono%E2%80%94%E2%80%94%E8%A7%86%E8%A7%89%E5%89%8D%E6%AE%B5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h1><p>每当进入新的图像，都会使用KLT稀疏光流法进行跟踪，同时提取100-300个角点信息，我的理解是角点是用来建立图像，光流跟踪是用来快速定位。同时在这里还进行了关键帧的选取（注意这一过程在代码中是由vins_estimate文件中实现的），主要是两个剔除关键帧的策略，分别是平均视差法和跟踪质量法。平均视差法：如果当前帧的和上一个关键帧跟踪点的平均视差超出了一个设定的阈值，就将当前帧设为关键帧。这里有一个问题，就是旋转和平移都会产生视差（不只是平移哦），当出现纯旋转的时候特征点无法被三角化，无法计算出旋转值，也就无法计算跟踪点间的平均视差，为了解决这一问题，采用短时的陀螺仪观测值来补偿旋转，从而计算出视差，这一过程只应用到平均视差的计算，不会影响真实的旋转结果。</p><a id="more"></a>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023190400778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h1 id="节点概览"><a href="#节点概览" class="headerlink" title="节点概览"></a>节点概览</h1><p>该节点的功能是：接收图像数据，进行角点提取和光流跟踪，输出跟踪的特征点（角点）。feature_tracker_node的消息订阅发布如下表：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191023221410832.png"></p>
<h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>主要负责图像角点提取和光流跟踪，主要是三个源程序，分别是feature_tracker、feature_tracker_node以及parameters。feature_tracker_node是特征跟踪线程的系统入口，feature_tracker是特征跟踪算法的具体实现，parameters是设备等参数的读取和存放。</p>
<h2 id="程序入口main-函数"><a href="#程序入口main-函数" class="headerlink" title="程序入口main()函数"></a>程序入口main()函数</h2><ul>
<li>1、ros初始化和设置句柄，设置logger级别</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"feature_tracker"</span>);</span><br><span class="line">ros::<span class="function">NodeHandle <span class="title">n</span><span class="params">(<span class="string">"~"</span>)</span></span>;</span><br><span class="line">ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info);</span><br></pre></td></tr></table></figure>
<ul>
<li>2、readParameters(n);读取参数，如config-&gt;euroc-&gt;euroc_config.yaml中的一些配置参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">readParameters(n);</span><br></pre></td></tr></table></figure>
<ul>
<li>3、读取每个相机实例读取对应的相机内参，NUM_OF_CAM=1为单目</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++) </span><br><span class="line">       trackerData[i].readIntrinsicParameter(CAM_NAMES[i]);</span><br></pre></td></tr></table></figure>
<p>节点在启动时会先读取相机内参，根据config_file文件中model_type的值决定采用何种相机模型，并创建相应模型的对象指针，读取在该模型下需要的参数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readIntrinsicParameter(<span class="keyword">const</span> <span class="built_in">string</span> &amp;calib_file)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"reading paramerter of camera %s"</span>, calib_file.c_str());</span><br><span class="line">    m_camera = CameraFactory::instance()-&gt;generateCameraFromYamlFile(calib_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CameraPtr</span><br><span class="line">CameraFactory::generateCameraFromYamlFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename)</span><br><span class="line">&#123;</span><br><span class="line">    cv::<span class="function">FileStorage <span class="title">fs</span><span class="params">(filename, cv::FileStorage::READ)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fs.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> CameraPtr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Camera::ModelType modelType = Camera::MEI;</span><br><span class="line">    <span class="keyword">if</span> (!fs[<span class="string">"model_type"</span>].isNone())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> sModelType;</span><br><span class="line">        fs[<span class="string">"model_type"</span>] &gt;&gt; sModelType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//卡特鱼眼相机</span></span><br><span class="line">        <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"kannala_brandt"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::KANNALA_BRANDT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"mei"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::MEI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"scaramuzza"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::SCARAMUZZA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (boost::iequals(sModelType, <span class="string">"pinhole"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            modelType = Camera::PINHOLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"# ERROR: Unknown camera model: "</span> &lt;&lt; sModelType &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> CameraPtr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (modelType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> Camera::KANNALA_BRANDT:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">EquidistantCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> EquidistantCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        EquidistantCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::PINHOLE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">PinholeCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> PinholeCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        PinholeCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::SCARAMUZZA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">OCAMCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> OCAMCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        OCAMCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Camera::MEI:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">CataCameraPtr <span class="title">camera</span><span class="params">(<span class="keyword">new</span> CataCamera)</span></span>;</span><br><span class="line"></span><br><span class="line">        CataCamera::Parameters params = camera-&gt;getParameters();</span><br><span class="line">        params.readFromYamlFile(filename);</span><br><span class="line">        camera-&gt;setParameters(params);</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CameraPtr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、判断是否加入鱼眼mask来去除边缘噪声</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(FISHEYE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//FISHEYE_MASK  fisheye_mask.jpg 路径</span></span><br><span class="line">        trackerData[i].fisheye_mask = cv::imread(FISHEYE_MASK, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!trackerData[i].fisheye_mask.data)</span><br><span class="line">        &#123;</span><br><span class="line">            ROS_INFO(<span class="string">"load mask fail"</span>);</span><br><span class="line">            ROS_BREAK();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ROS_INFO(<span class="string">"load mask success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、订阅话题IMAGE_TOPIC(如/cam0/image_raw)，执行回调函数img_callback，对新来的图像进行特征点追踪、处理和发布<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros::Subscriber sub_img = n.subscribe(IMAGE_TOPIC, <span class="number">100</span>, img_callback);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>单目时：FeatureTracker::readImage() 函数读取图像数据进行处理<br>单目i=0<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> FeatureTracker::readImage(<span class="keyword">const</span> cv::Mat &amp;_img, <span class="keyword">double</span> _cur_time)</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat img;</span><br><span class="line">    TicToc t_r;</span><br><span class="line">    cur_time = _cur_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (EQUALIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">        cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">        TicToc t_c;</span><br><span class="line">        clahe-&gt;apply(_img, img);</span><br><span class="line">        ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        img = _img;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">        prev_img = cur_img = forw_img = img;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forw_img = img;</span><br><span class="line"></span><br><span class="line">    forw_pts.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_pts.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TicToc t_o;</span><br><span class="line">        <span class="built_in">vector</span>&lt;uchar&gt; status;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; err;</span><br><span class="line">        cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">            <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">                status[i] = <span class="number">0</span>;</span><br><span class="line">        reduceVector(prev_pts, status);</span><br><span class="line">        reduceVector(cur_pts, status);</span><br><span class="line">        reduceVector(forw_pts, status);</span><br><span class="line">        reduceVector(ids, status);</span><br><span class="line">        reduceVector(cur_un_pts, status);</span><br><span class="line">        reduceVector(track_cnt, status);</span><br><span class="line">        ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : track_cnt)</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectWithF();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">        TicToc t_m;</span><br><span class="line">        setMask();</span><br><span class="line">        ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">        TicToc <span class="keyword">t_t</span>;</span><br><span class="line">        <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">        <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mask.empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n_pts.clear();</span><br><span class="line">        ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">        ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">        TicToc t_a;</span><br><span class="line">        addPoints();</span><br><span class="line">        ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">    &#125;</span><br><span class="line">    prev_img = cur_img;</span><br><span class="line">    prev_pts = cur_pts;</span><br><span class="line">    prev_un_pts = cur_un_pts;</span><br><span class="line">    cur_img = forw_img;</span><br><span class="line">    cur_pts = forw_pts;</span><br><span class="line">    undistortedPoints();</span><br><span class="line">    prev_time = cur_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6、发布feature，实例feature_points，跟踪的特征点，给后端优化用<br>发布feature_img，实例ptr，跟踪的特征点图，给RVIZ用和调试用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pub_img = n.advertise&lt;sensor_msgs::PointCloud&gt;(<span class="string">"feature"</span>, <span class="number">1000</span>);</span><br><span class="line">pub_match = n.advertise&lt;sensor_msgs::Image&gt;(<span class="string">"feature_img"</span>,<span class="number">1000</span>);</span><br><span class="line">pub_restart = n.advertise&lt;std_msgs::Bool&gt;(<span class="string">"restart"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="回调函数img-callback"><a href="#回调函数img-callback" class="headerlink" title="回调函数img_callback()"></a>回调函数img_callback()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">img_callback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::ImageConstPtr &amp;img_msg)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数是ROS的回调函数，主要功能包括：readImage()函数对新来的图像使用光流法进行特征点跟踪，并将追踪的特征点封装成feature_points发布到pub_img的话题下，将图像封装成ptr发布在pub_match下。</p>
<ul>
<li>1、判断是否是第一帧</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为第一帧</span></span><br><span class="line"><span class="keyword">if</span>(first_image_flag)</span><br><span class="line">&#123;</span><br><span class="line">    first_image_flag = <span class="literal">false</span>;</span><br><span class="line">    first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    last_image_time  = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、判断时间间隔是否正确，有问题则restart</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (img_msg-&gt;header.stamp.toSec() - last_image_time &gt; <span class="number">1.0</span> || img_msg-&gt;header.stamp.toSec() &lt; last_image_time)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_WARN(<span class="string">"image discontinue! reset the feature tracker!"</span>);</span><br><span class="line">    first_image_flag = <span class="literal">true</span>; </span><br><span class="line">    last_image_time = <span class="number">0</span>;</span><br><span class="line">    pub_count = <span class="number">1</span>;</span><br><span class="line">    std_msgs::Bool restart_flag;</span><br><span class="line">    restart_flag.data = <span class="literal">true</span>;</span><br><span class="line">    pub_restart.publish(restart_flag);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、发布频率控制，并不是每读入一帧图像，就要发布特征点，通过判断间隔时间内的发布次数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> tmp_freq = <span class="number">1.0</span> * pub_count / (img_msg-&gt;header.stamp.toSec() - first_image_time);</span><br><span class="line"> <span class="keyword">if</span> (round(tmp_freq) &lt;= FREQ)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//PUB_THIS_FRAME 是否需要发布特征点</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">// // 时间间隔内的发布频率十分接近设定频率时，更新时间间隔起始时刻，并将数据发布次数置0</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp_freq - FREQ) &lt; <span class="number">0.01</span> * FREQ)</span><br><span class="line">     &#123;</span><br><span class="line">         first_image_time = img_msg-&gt;header.stamp.toSec();</span><br><span class="line">         pub_count = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     PUB_THIS_FRAME = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、将图像编码8UC1转换为mono8</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv_bridge::CvImageConstPtr ptr;</span><br><span class="line"><span class="keyword">if</span> (img_msg-&gt;encoding == <span class="string">"8UC1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将图像编码8UC1转换为mono8</span></span><br><span class="line">    sensor_msgs::Image img;</span><br><span class="line">    img.header = img_msg-&gt;header;</span><br><span class="line">    img.height = img_msg-&gt;height;</span><br><span class="line">    img.width = img_msg-&gt;width;</span><br><span class="line">    img.is_bigendian = img_msg-&gt;is_bigendian;</span><br><span class="line">    img.step = img_msg-&gt;step;</span><br><span class="line">    img.data = img_msg-&gt;data;</span><br><span class="line">    img.encoding = <span class="string">"mono8"</span>;</span><br><span class="line">    ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);</span><br></pre></td></tr></table></figure>
<ul>
<li>5、单目时：FeatureTracker::readImage() 函数读取图像数据进行处理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_CAM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ROS_DEBUG(<span class="string">"processing camera %d"</span>, i);</span><br><span class="line">    <span class="comment">//双目跟踪则为1,单目false</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span> || !STEREO_TRACK) <span class="comment">// 针对单目相机读入图像，进入KLT跟踪阶段</span></span><br><span class="line">        <span class="comment">//ROW = fsSettings["image_height"]  rowRange和colRange函数可以获取某些范围内行或列的指针</span></span><br><span class="line">        trackerData[i].readImage(ptr-&gt;image.rowRange(ROW * i, ROW * (i + <span class="number">1</span>)), img_msg-&gt;header.stamp.toSec());</span><br></pre></td></tr></table></figure>
<ul>
<li>6、更新特征点ID</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> completed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_OF_CAM; j++)</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span> || !STEREO_TRACK)</span><br><span class="line">                <span class="comment">////更新特征点id</span></span><br><span class="line">                completed |= trackerData[j].updateID(i);</span><br><span class="line">        <span class="keyword">if</span> (!completed)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始FeatureTracker::n_id = 0;id初始化-1</span></span><br><span class="line"><span class="keyword">bool</span> FeatureTracker::updateID(<span class="keyword">unsigned</span> <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; ids.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ids[i] == <span class="number">-1</span>)</span><br><span class="line">            ids[i] = n_id++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>7、如果PUB_THIS_FRAME=1则进行发布<blockquote>
<ul>
<li>将特征点id，矫正后归一化平面的3D点(x,y,z=1)，像素2D点(u,v)，像素的速度(vx,vy)，封装成sensor_msgs::PointCloudPtr类型的feature_points实例中,发布到pub_img;</li>
<li>将图像封装到cv_bridge::cvtColor类型的ptr实例中发布到pub_match</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="图像特征跟踪FeatureTracker-readImage"><a href="#图像特征跟踪FeatureTracker-readImage" class="headerlink" title="图像特征跟踪FeatureTracker::readImage()"></a>图像特征跟踪FeatureTracker::readImage()</h2><ul>
<li>1、通过EQUALIZE值判断是否进行自适应直方图均衡化，如果EQUALIZE=1（表示太亮或则太暗)，调用cv::CLAHE对图像做直方图均衡化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果EQUALIZE=1，表示太亮或则太暗</span></span><br><span class="line"><span class="keyword">if</span> (EQUALIZE)<span class="comment">//判断是否进行直方图均衡化处理</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Contrast Limited AHE(Adaptive histogram equalization)</span></span><br><span class="line">    cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE(<span class="number">3.0</span>, cv::Size(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line">    TicToc t_c;</span><br><span class="line">    clahe-&gt;apply(_img, img);</span><br><span class="line">    ROS_DEBUG(<span class="string">"CLAHE costs: %fms"</span>, t_c.toc());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    img = _img;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、 区分是否为第一次读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (forw_img.empty())</span><br><span class="line">    <span class="comment">//如果当前帧的图像数据forw_img为空，说明当前是第一次读入图像数据</span></span><br><span class="line">    <span class="comment">//将读入的图像赋给前帧forw_img</span></span><br><span class="line">    <span class="comment">//同时，还将读入的图像赋给prev_img、cur_img，这是为了避免后面使用到这些数据时，它们是空的</span></span><br><span class="line">    prev_img = cur_img = forw_img = img;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则，说明之前就已经有图像读入</span></span><br><span class="line">    <span class="comment">//所以只需要更新前帧forw_img的数据</span></span><br><span class="line">    forw_img = img;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、calcOpticalFlowPyrLK() 从cur_pts到forw_pts做LK金字塔光流法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用cv::calcOpticalFlowPyrLK()对前一帧的特征点cur_pts进行LK金字塔光流跟踪，得到forw_pts</span></span><br><span class="line"><span class="comment">//status标记了从前一帧cur_img到forw_img特征点的跟踪状态，无法被追踪到的点标记为0</span></span><br><span class="line">cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(<span class="number">21</span>, <span class="number">21</span>), <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>4、根据status，把跟踪失败的和位于图像边界外的点剔除，剔除时不仅要从当前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts、cur_pts，记录特征点id的ids，和记录特征点被跟踪次数的track_cnt中剔除；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//将位于图像边界外的点标记为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(forw_pts.size()); i++)</span><br><span class="line">        <span class="keyword">if</span> (status[i] &amp;&amp; !inBorder(forw_pts[i]))</span><br><span class="line">            status[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据status,把跟踪失败的点剔除</span></span><br><span class="line">    <span class="comment">//不仅要从前帧数据forw_pts中剔除，而且还要从cur_un_pts、prev_pts和cur_pts中剔除</span></span><br><span class="line">    <span class="comment">//prev_pts和cur_pts中的特征点是一一对应的</span></span><br><span class="line">    <span class="comment">//记录特征点id的ids，和记录特征点被跟踪次数的track_cnt也要剔除</span></span><br><span class="line">    reduceVector(prev_pts, status);</span><br><span class="line">    reduceVector(cur_pts, status);</span><br><span class="line">    reduceVector(forw_pts, status);</span><br><span class="line">    reduceVector(ids, status);</span><br><span class="line">    reduceVector(cur_un_pts, status);</span><br><span class="line">    reduceVector(track_cnt, status);</span><br><span class="line">    ROS_DEBUG(<span class="string">"temporal optical flow costs: %fms"</span>, t_o.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、根据PUB_THIS_FRAME是否发布特征，<ul>
<li>如果不需要发布特征点,则到这步就完了,把当前帧forw赋给上一帧cur, 然后退出 </li>
<li>如果发布特征：<blockquote>
<p>1、先调用rejectWithF()对prev_pts和forw_pts做ransac剔除outlier.(实际就是调用了findFundamentalMat函数), 在光流追踪成功就记被追踪+1，数值代表被追踪的次数，数值越大，说明被追踪的就越久<br>2、调用setMask(), 先对跟踪点forw_pts按跟踪次数降排序, 然后依次选点, 选一个点, 在mask中将该点周围一定半径的区域设为0, 后面不再选取该区域内的点. 有点类似与non-max suppression, 但区别是这里保留track_cnt最高的点<br>3、在mask中不为0的区域,调用goodFeaturesToTrack() 寻找新的特征点(shi-tomasi角点)，添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点<br>4、通过addPoints()函数push到forw_pts中, id初始化-1,track_cnt初始化为1.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (PUB_THIS_FRAME)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//主要是通过基本矩阵（F）去除外点outliers</span></span><br><span class="line">    rejectWithF();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask begins"</span>);</span><br><span class="line">    TicToc t_m;</span><br><span class="line">    <span class="comment">//对跟踪点进行排序并去除密集点。</span></span><br><span class="line">    setMask();</span><br><span class="line">    ROS_DEBUG(<span class="string">"set mask costs %fms"</span>, t_m.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature begins"</span>);</span><br><span class="line">    TicToc <span class="keyword">t_t</span>;</span><br><span class="line">    <span class="comment">//计算是否需要提取新的特征点,MAX_CNT:特征点最大个数150</span></span><br><span class="line">    <span class="keyword">int</span> n_max_cnt = MAX_CNT - <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(forw_pts.size());</span><br><span class="line">    <span class="keyword">if</span> (n_max_cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.type() != CV_8UC1)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"mask type wrong "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask.size() != forw_img.size())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong size "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MIN_DIST:特征点之间的最小间隔30</span></span><br><span class="line">        <span class="comment">//寻找新的特征点(shi-tomasi角点),添加(MAX_CNT - forw_pts.size())个点以确保每帧都有足够的特征点</span></span><br><span class="line">        cv::goodFeaturesToTrack(forw_img, n_pts, n_max_cnt, <span class="number">0.01</span>, MIN_DIST, mask);</span><br><span class="line">    &#125;</span><br><span class="line">                  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n_pts.clear();</span><br><span class="line">    ROS_DEBUG(<span class="string">"detect feature costs: %fms"</span>, <span class="keyword">t_t</span>.toc());</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"add feature begins"</span>);</span><br><span class="line">    TicToc t_a;</span><br><span class="line">    <span class="comment">//添将新检测到的特征点n_pts添加到forw_pts中，id初始化-1,track_cnt初始化为1.</span></span><br><span class="line">    addPoints();</span><br><span class="line">    ROS_DEBUG(<span class="string">"selectFeature costs: %fms"</span>, t_a.toc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>6、undistortedPoints() 对特征点的图像坐标根据不同的相机模型进行去畸变矫正和深度归一化，计算每个角点的速度</li>
</ul>
<p>待写！！！</p>
<p>参考：<a href="https://blog.csdn.net/qq_41839222/article/details/85797156" target="_blank" rel="noopener">VINS-Mono代码解读——视觉跟踪 feature_trackers</a><br><a href="https://blog.csdn.net/wangshuailpp/article/details/78719401" target="_blank" rel="noopener">VINS理论与代码详解2——单目视觉跟踪</a><br><a href="https://blog.csdn.net/q597967420/article/details/76099425" target="_blank" rel="noopener">VINS-Mono源码解析（二）前端：特征跟踪</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>11.旋转数组的最小数字</title>
    <url>/2019/10/22/11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目：<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p> <strong>思路1：</strong><br>暴力解法：根据给定的数组特点，从左到右遍历数组元素，当首次遇到数组中某个元素比上一个元素小时，该元素就是我们需要的元素</p><a id="more"></a>

<p><strong>思路2：</strong></p>
<ul>
<li>二分查找：<blockquote>
<ul>
<li>用两个指针，分别指向数组的第一个和最后一个元素</li>
<li>接着找到中间元素，如果中间元素位于前面的递增子数组（中间元素大于或等于第一个元指针指向元素）把第一个指针指向中间元素</li>
<li>如果中间元素位于后面的递增子数组（中间元素大于或等于第一个元指针指向元素），把第二个指针指向中间元素</li>
<li>最终，两指针会指向相邻的元素，第二个指针刚好指向是最小元素</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[i]&lt;=rotateArray[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>二分查找：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = low;<span class="comment">//防止数组的前面0个元素搬到最后面</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(rotateArray[low]&gt;=rotateArray[high])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(high-low==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid=high;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[low]==rotateArray[high] &amp;&amp; rotateArray[low]==rotateArray[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> result=rotateArray[low];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=high;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rotateArray[i]&lt;result)</span><br><span class="line">                        result=rotateArray[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid]&gt;=rotateArray[low])</span><br><span class="line">                low=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid]&lt;=rotateArray[high])</span><br><span class="line">                high=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(rotateArray)):</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i<span class="number">-1</span>]&gt;rotateArray[i]):</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        high=len(rotateArray)<span class="number">-1</span></span><br><span class="line">        mid=low</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> rotateArray[low]&gt;=rotateArray[high]:</span><br><span class="line">            <span class="keyword">if</span> high-low==<span class="number">1</span>:</span><br><span class="line">                mid=high</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            mid=(low+high)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[low]==rotateArray[high] <span class="keyword">and</span> rotateArray[low]==rotateArray[mid]:</span><br><span class="line">                result = rotateArray[low]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(low,high+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> result &gt; rotateArray[i]:</span><br><span class="line">                        result = rotateArray[i]</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid]&gt;=rotateArray[low]:</span><br><span class="line">                low=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high=mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>10.斐波那契数列（跳台阶）</title>
    <url>/2019/10/20/10.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿题目一：<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><p>思路</p><ul>
<li>如果只有一阶台阶，一种跳法，如果只有两阶台阶，两种跳法</li>
<li>把n阶台阶时的跳法看成n的函数，记法f(n)，f(n)=f(n-1)+f(n-2)</li>
</ul><p>采用循环方式实现，递归实践效率太低<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result[n];         </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibOne=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibTwo=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fibN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fibN=fibOne+fibTwo;</span><br><span class="line">            fibOne=fibTwo;</span><br><span class="line">            fibTwo=fibN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibN;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        result=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> result[n]</span><br><span class="line">        </span><br><span class="line">        f1=<span class="number">1</span></span><br><span class="line">        f2=<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            fn=f1+f2</span><br><span class="line">            f1=f2</span><br><span class="line">            f2=fn</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>相关题目：</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> result[number];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">2</span>,fn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fn=f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=fn;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f=<span class="number">2</span>*f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//return pow(2,number-1);</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>KLT 光流算法</title>
    <url>/2019/10/20/KLT-%E5%85%89%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Optical-Flow"><a href="#Optical-Flow" class="headerlink" title="Optical Flow"></a>Optical Flow</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132123717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132137931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><h1 id="KLT"><a href="#KLT" class="headerlink" title="KLT"></a>KLT</h1><p>KLT 算法本质上也基于光流的三个假设，不同于前述直接比较像素点灰度值的作法，KLT 比较像素点周围的窗口像素，来寻找最相似的像素点。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019102013215737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020132228980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>参考：<a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流—LK光流—基于金字塔分层的LK光流—中值流</a><br><a href="https://leijiezhang001.github.io/KLT/" target="_blank" rel="noopener">KLT 光流算法详解</a><br><a href="https://blog.csdn.net/irobot_davinci/article/details/29635199" target="_blank" rel="noopener">KLT角点跟踪算法(LK)学习（一）——算法原理</a></p>]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>9.用两个栈实现队列</title>
    <url>/2019/10/20/9.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：</p><ul>
<li>首先把元素插入stack1;</li>
<li>当stack2为空时，把stack1的元素逐个弹出并压入stack2</li>
<li>当stack2步为空时，在stack2的栈顶元素最先进入队列的元素，可以弹出</li>
</ul><p><strong>C++</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s.empty();         //如果栈为空则返回true, 否则返回false;</span></span><br><span class="line"><span class="comment">s.size();          //返回栈中元素的个数</span></span><br><span class="line"><span class="comment">s.top();           //返回栈顶元素, 但不删除该元素</span></span><br><span class="line"><span class="comment">s.pop();           //弹出栈顶元素, 但不返回其值</span></span><br><span class="line"><span class="comment">s.push();          //将元素压入栈顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> data=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> head=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>




<p><strong>Python</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                <span class="comment">#.pop(i)将列表中第i项元素取出并删除该元素</span></span><br><span class="line">                self.stack2.append(self.stack1.pop(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>Harris角点检测</title>
    <url>/2019/10/20/Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为角点"><a href="#何为角点" class="headerlink" title="何为角点"></a>何为角点</h1><p>下面有两幅不同视角的图像，通过找出对应的角点进行匹配。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095257386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>再看下图所示，放大图像的两处角点区域：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095313814.png#pic_center"><br>角点在保留图像图形重要特征的同时，可以有效地减少信息的数据量，使其信息的含量很高，有效地提高了计算的速度，有利于图像的可靠匹配，使得实时处理成为可能。</p><p>我们可以直观的概括下角点所具有的特征：</p><ul>
<li>轮廓之间的交点；</li>
<li>对于同一场景，即使视角发生变化，通常具备稳定性质的特征；<ul>
<li>该点附近区域的像素点无论在梯度方向上还是其梯度幅值上有着较大变化；<h1 id="角点检测算法基本思想"><a href="#角点检测算法基本思想" class="headerlink" title="角点检测算法基本思想"></a>角点检测算法基本思想</h1>算法基本思想是使用一个固定窗口在图像上进行任意方向上的滑动，比较滑动前与滑动后两种情况，窗口中的像素灰度变化程度，如果存在任意方向上的滑动，都有着较大灰度变化，那么我们可以认为该窗口中存在角点。<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1></li>
</ul>
</li>
</ul><a id="more"></a>


<p>当窗口发生[u,v]移动时，那么滑动前与滑动后对应的窗口中的像素点灰度变化描述如下：</p>
<script type="math/tex; mode=display">E(u, v)=\sum_{x_{s}, y} w(x, y)[I(x+u, y+v)-I(x, y)]^{2}</script><p>[u,v]是窗口的偏移量<br>(x,y)是窗口内所对应的像素坐标位置，窗口有多大，就有多少个位置<br>w(x,y)是窗口函数，最简单情形就是窗口内的所有像素所对应的w权重系数均为1。但有时候，我们会将w(x,y)函数设定为以窗口中心为原点的二元正态分布。如果窗口中心点是角点时，移动前与移动后，该点的灰度变化应该最为剧烈，所以该点权重系数可以设定大些，表示窗口移动时，该点在灰度变化贡献较大；而离窗口中心(角点)较远的点，这些点的灰度变化几近平缓，这些点的权重系数，可以设定小点，以示该点对灰度变化贡献较小，那么我们自然想到使用二元高斯函数来表示窗口函数，所以通常窗口函数有如下两种形式：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020095759748.png#pic_center"><br>根据上述表达式，当窗口处在平坦区域上滑动，可以想象的到，灰度不会发生变化，那么E(u,v) = 0；如果窗口处在比纹理比较丰富的区域上滑动，那么灰度变化会很大。算法最终思想就是计算灰度发生较大变化时所对应的位置，当然这个较大是指针任意方向上的滑动，并非单指某个方向。</p>
<p>$I(x+u, y+v)$泰勒展开可得：</p>
<script type="math/tex; mode=display">I(x+u, y+v)=I(x, y)+I_{x} u+I_{y} v+O\left(u^{2}, v^{2}\right)</script><p>当发生微小位移时，忽略无穷小量，写成矩阵形式：</p>
<script type="math/tex; mode=display">E(u, v)=\sum_w[u, v]\left[\begin{array}{cc}{I_{x}^{2}} & {I_{x} I_{y}} \\ {I_{x} I_{y}} & {I_{y}^{2}}\end{array}\right]\left[\begin{array}{l}{u} \\ {v}\end{array}\right]=[u, v]M\left[\begin{array}{l}{u} \\ {v}\end{array}\right]</script><p>所以E(u,v)表达式可以更新为：</p>
<script type="math/tex; mode=display">E(u,v)\cong \begin{bmatrix}
u\\ v\end{bmatrix}M\begin{bmatrix}
u & 
v\end{bmatrix}</script><p>矩阵M为:</p>
<script type="math/tex; mode=display">M(x,y)=\Sigma_w \left[ \begin{matrix} I_x^2& I_xI_y \\ I_xI_y & I_y^2\end{matrix} \right]</script><p>E(u,v)是一个二次型，而由下述定理可知<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101744919.png#pic_center"><br>M分解可得：</p>
<script type="math/tex; mode=display">M=X\Sigma X^T = X \left[ \begin{matrix} \lambda_1& 0\\ 0& \lambda_2\end{matrix} \right] X^T</script><p>令E(u,v)=常数，我们可用一个椭圆来描绘这一函数<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101810715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>椭圆的长短轴是与结构张量M的两个特征值相对应的量。通过判断的情况我们就可以区分出‘flat’，‘edge’，‘corner’这三种区域，因为最直观的印象：</p>
<ul>
<li>corner：在水平、竖直两个方向上变化均较大的点，即Ix、Iy都较大 <ul>
<li>edge ：仅在水平、或者仅在竖直方向有较大的点，即Ix和Iy只有其一较大 </li>
<li>flat   ： 在水平、竖直方向的变化量均较小的点，即Ix、Iy都较小</li>
</ul>
</li>
</ul>
<p>M是由Ix，Iy构成，它的特征值正好可以反映Ix，Iy的情况，下面我以一种更容易理解的方式来讲述椭圆的物理意义。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101904206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br>下图是对这三种情况窗口中的对应像素的梯度分布进行绘制：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020101940485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>如果使用椭圆进行数据集表示，则绘制图示如下：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020103310120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以得出下列结论：</p>
<blockquote>
<p>特征值都比较大时，即窗口中含有角点<br>特征值一个较大，一个较小，窗口中含有边缘<br>特征值都比较小，窗口处在平坦区域<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020102013942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
</blockquote>
<h1 id="度量角点响应"><a href="#度量角点响应" class="headerlink" title="度量角点响应"></a>度量角点响应</h1><p>特征值计算一般比较繁琐，所以把M写为：</p>
<script type="math/tex; mode=display">M(x,y)=\Sigma_w \left[ \begin{matrix} I_x^2& I_xI_y \\ I_xI_y & I_y^2\end{matrix} \right] = \left[ \begin{matrix} A& C\\ C& B\end{matrix} \right]</script><p>定义角点响应函数R（corner response function），采用近似的形式，α为常数，一般取0.04-0.06：</p>
<script type="math/tex; mode=display">R = detM-\alpha (traceM)^2\\
detM=\lambda_1 \lambda_2=AB-C^2\\
traceM=\lambda_1 + \lambda_2 = A+B</script><blockquote>
<p>可以通过判断R的值来判断某个点是不是角点了。</p>
<ul>
<li>角点：R为大数值整数</li>
<li>边缘：R为大数值负数</li>
<li>平坦区：绝对值R是小数值<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020102127533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center#pic_center"><h1 id="harris角点性质"><a href="#harris角点性质" class="headerlink" title="harris角点性质"></a>harris角点性质</h1>参数α对角点检测的影响：增大α的值，将减小角点响应值R，减少被检测角点的数量；减小α的值，将增大角点响应值R，增加被检测角点的数量。</li>
</ul>
</blockquote>
<ul>
<li>Harris角点检测对亮度和对比度的变化不敏感。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020104945973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></li>
<li>Harris角点检测具有旋转不变性，不具备尺度不变性。如下图所示，在小尺度下的角点被放大后可能会被认为是图像边缘。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191020105015840.png#pic_center"></li>
</ul>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>harris角点检测算法步骤</p>
<ol>
<li><p>利用Soble计算出XY方向的梯度值</p>
</li>
<li><p>计算出$I_x^2,I_y^2,I_xI_y$</p>
</li>
<li><p>利用高斯函数对$I_x^2,I_y^2,I_xI_y$进行滤波</p>
</li>
<li><p>计算局部特征结果矩阵M的特征值和响应函数$C(i,j)=Det(M)-k(trace(M))^2   (0.04&lt;=k&lt;=0.06)$</p>
</li>
<li><p>将计算出响应函数的值C进行非极大值抑制，滤除一些不是角点的点，同时要满足大于设定的阈值</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include "opencv2/imgproc/imgproc.hpp"  </span></span><br><span class="line"><span class="comment">#include "opencv2/highgui/highgui.hpp"  </span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">RGB转换成灰度图像的一个常用公式是：</span><br><span class="line">Gray = R*0.299 + G*0.587 + B*0.114</span><br><span class="line">*/</span><br><span class="line">//******************灰度转换函数*************************  </span><br><span class="line">//第一个参数image输入的彩色RGB图像的引用；  </span><br><span class="line">//第二个参数imageGray是转换后输出的灰度图像的引用；  </span><br><span class="line">//*******************************************************</span><br><span class="line">void ConvertRGB2GRAY(const Mat &amp;image, Mat &amp;imageGray);</span><br><span class="line"> </span><br><span class="line">//******************Sobel卷积因子计算X、Y方向梯度和梯度方向角********************  </span><br><span class="line">//第一个参数imageSourc原始灰度图像；  </span><br><span class="line">//第二个参数imageSobelX是X方向梯度图像；  </span><br><span class="line">//第三个参数imageSobelY是Y方向梯度图像；  </span><br><span class="line">//第四个参数pointDrection是梯度方向角数组指针  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelGradDirction(Mat &amp;imageSource, Mat &amp;imageSobelX, Mat &amp;imageSobelY);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的X方向梯度幅值的平方*************************  </span><br><span class="line">//第一个参数imageGradX是X方向梯度图像；    </span><br><span class="line">//第二个参数SobelAmpXX是输出的X方向梯度图像的平方  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelXX(const Mat imageGradX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXX);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的Y方向梯度幅值的平方*************************    </span><br><span class="line">//第一个参数imageGradY是Y方向梯度图像；  </span><br><span class="line">//第二个参数SobelAmpXX是输出的Y方向梯度图像的平方  </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelYY(const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpYY);</span><br><span class="line"> </span><br><span class="line">//******************计算Sobel的XY方向梯度幅值的乘积*************************    </span><br><span class="line">//第一个参数imageGradX是X方向梯度图像；</span><br><span class="line">//第二个参数imageGradY是Y方向梯度图像；</span><br><span class="line">//第二个参数SobelAmpXY是输出的XY方向梯度图像 </span><br><span class="line">//*************************************************************  </span><br><span class="line">void SobelXY(const Mat imageGradX, const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXY);</span><br><span class="line"> </span><br><span class="line">//****************计算一维高斯的权值数组*****************</span><br><span class="line">//第一个参数size是代表的卷积核的边长的大小</span><br><span class="line">//第二个参数sigma表示的是sigma的大小</span><br><span class="line">//*******************************************************</span><br><span class="line">double *getOneGuassionArray(int size, double sigma);</span><br><span class="line"> </span><br><span class="line">//****************高斯滤波函数的实现*****************</span><br><span class="line">//第一个参数srcImage是代表的输入的原图</span><br><span class="line">//第二个参数dst表示的是输出的图</span><br><span class="line">//第三个参数size表示的是卷积核的边长的大小</span><br><span class="line">//*******************************************************</span><br><span class="line">void MyGaussianBlur(Mat_&lt;<span class="built_in">float</span>&gt; &amp;srcImage, Mat_&lt;<span class="built_in">float</span>&gt; &amp;dst, int size);</span><br><span class="line"> </span><br><span class="line">//****计算局部特涨结果矩阵M的特征值和响应函数H = (A*B - C) - k*(A+B)^2******</span><br><span class="line">//M</span><br><span class="line">//A  C</span><br><span class="line">//C  B</span><br><span class="line">//Tr(M)=a+b=A+B</span><br><span class="line">//Det(M)=a*b=A*B-C^2</span><br><span class="line">//计算输出响应函数的值得矩阵</span><br><span class="line">//****************************************************************************</span><br><span class="line">void harrisResponse(Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussYY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData,<span class="built_in">float</span> k);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//***********非极大值抑制和满足阈值及某邻域内的局部极大值为角点**************</span><br><span class="line">//第一个参数是响应函数的矩阵</span><br><span class="line">//第二个参数是输入的灰度图像</span><br><span class="line">//第三个参数表示的是输出的角点检测到的结果图</span><br><span class="line">void LocalMaxValue(Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData, Mat &amp;srcGray, Mat &amp;ResultImage,int kSize);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	const Mat srcImage = imread(<span class="string">"3.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!srcImage.data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"could not load image...\n"</span>);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"srcImage"</span>, srcImage);</span><br><span class="line">	Mat srcGray;</span><br><span class="line">	ConvertRGB2GRAY(srcImage, srcGray);</span><br><span class="line">	Mat imageSobelX;</span><br><span class="line">	Mat imageSobelY;</span><br><span class="line">	Mat resultImage;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelXX;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelYY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; imageSobelXY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianXX;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianYY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; GaussianXY;</span><br><span class="line">	Mat_&lt;<span class="built_in">float</span>&gt; HarrisRespond;</span><br><span class="line">	//计算Soble的XY梯度</span><br><span class="line">	SobelGradDirction(srcGray, imageSobelX, imageSobelY);</span><br><span class="line">	//计算X方向的梯度的平方</span><br><span class="line">	SobelXX(imageSobelX, imageSobelXX);</span><br><span class="line">	SobelYY(imageSobelY, imageSobelYY);</span><br><span class="line">	SobelXY(imageSobelX, imageSobelY, imageSobelXY);</span><br><span class="line">	//计算高斯模糊XX YY XY</span><br><span class="line">	MyGaussianBlur(imageSobelXX, GaussianXX,3);</span><br><span class="line">	MyGaussianBlur(imageSobelYY, GaussianYY, 3);</span><br><span class="line">	MyGaussianBlur(imageSobelXY, GaussianXY, 3);</span><br><span class="line">	harrisResponse(GaussianXX, GaussianYY, GaussianXY, HarrisRespond, 0.05);</span><br><span class="line">	LocalMaxValue(HarrisRespond, srcGray, resultImage, 3);</span><br><span class="line">	imshow(<span class="string">"imageSobelX"</span>, imageSobelX);</span><br><span class="line">	imshow(<span class="string">"imageSobelY"</span>, imageSobelY);</span><br><span class="line">	imshow(<span class="string">"resultImage"</span>, resultImage);</span><br><span class="line">	waitKey(0);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">void ConvertRGB2GRAY(const Mat &amp;image, Mat &amp;imageGray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!image.data || image.channels() != 3)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//创建一张单通道的灰度图像</span><br><span class="line">	imageGray = Mat::zeros(image.size(), CV_8UC1);</span><br><span class="line">	//取出存储图像像素的数组的指针</span><br><span class="line">	uchar *pointImage = image.data;</span><br><span class="line">	uchar *pointImageGray = imageGray.data;</span><br><span class="line">	//取出图像每行所占的字节数</span><br><span class="line">	size_t stepImage = image.step;</span><br><span class="line">	size_t stepImageGray = imageGray.step;</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; imageGray.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; imageGray.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			pointImageGray[i*stepImageGray + j] = (uchar)(0.114*pointImage[i*stepImage + 3 * j] + 0.587*pointImage[i*stepImage + 3 * j + 1] + 0.299*pointImage[i*stepImage + 3 * j + 2]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//存储梯度膜长</span><br><span class="line">void SobelGradDirction(Mat &amp;imageSource, Mat &amp;imageSobelX, Mat &amp;imageSobelY)</span><br><span class="line">&#123;</span><br><span class="line">	imageSobelX = Mat::zeros(imageSource.size(), CV_32SC1);</span><br><span class="line">	imageSobelY = Mat::zeros(imageSource.size(), CV_32SC1);</span><br><span class="line">	//取出原图和X和Y梯度图的数组的首地址</span><br><span class="line">	uchar *P = imageSource.data;</span><br><span class="line">	uchar *PX = imageSobelX.data;</span><br><span class="line">	uchar *PY = imageSobelY.data;</span><br><span class="line"> </span><br><span class="line">	//取出每行所占据的字节数</span><br><span class="line">	int step = imageSource.step;</span><br><span class="line">	int stepXY = imageSobelX.step;</span><br><span class="line"> </span><br><span class="line">	int index = 0;//梯度方向角的索引</span><br><span class="line">	<span class="keyword">for</span> (int i = 1; i &lt; imageSource.rows - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 1; j &lt; imageSource.cols - 1; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			//通过指针遍历图像上每一个像素   </span><br><span class="line">			double gradY = P[(i + 1)*step + j - 1] + P[(i + 1)*step + j] * 2 + P[(i + 1)*step + j + 1] - P[(i - 1)*step + j - 1] - P[(i - 1)*step + j] * 2 - P[(i - 1)*step + j + 1];</span><br><span class="line">			PY[i*stepXY + j*(stepXY / step)] = abs(gradY);</span><br><span class="line"> </span><br><span class="line">			double gradX = P[(i - 1)*step + j + 1] + P[i*step + j + 1] * 2 + P[(i + 1)*step + j + 1] - P[(i - 1)*step + j - 1] - P[i*step + j - 1] * 2 - P[(i + 1)*step + j - 1];</span><br><span class="line">			PX[i*stepXY + j*(stepXY / step)] = abs(gradX);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//将梯度数组转换成8位无符号整型</span><br><span class="line">	convertScaleAbs(imageSobelX, imageSobelX);</span><br><span class="line">	convertScaleAbs(imageSobelY, imageSobelY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void SobelXX(const Mat imageGradX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXX)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpXX = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpXX.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpXX.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpXX.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradX.at&lt;uchar&gt;(i, j)*imageGradX.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpXX, SobelAmpXX);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void SobelYY(const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpYY)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpYY = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradY.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpYY.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpYY.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpYY.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradY.at&lt;uchar&gt;(i, j)*imageGradY.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpYY, SobelAmpYY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void SobelXY(const Mat imageGradX, const Mat imageGradY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;SobelAmpXY)</span><br><span class="line">&#123;</span><br><span class="line">	SobelAmpXY = Mat_&lt;<span class="built_in">float</span>&gt;(imageGradX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; SobelAmpXY.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; SobelAmpXY.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			SobelAmpXY.at&lt;<span class="built_in">float</span>&gt;(i, j) = imageGradX.at&lt;uchar&gt;(i, j)*imageGradY.at&lt;uchar&gt;(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//convertScaleAbs(SobelAmpXY, SobelAmpXY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//计算一维高斯的权值数组</span><br><span class="line">double *getOneGuassionArray(int size, double sigma)</span><br><span class="line">&#123;</span><br><span class="line">	double sum = 0.0;</span><br><span class="line">	//定义高斯核半径</span><br><span class="line">	int kerR = size / 2;</span><br><span class="line"> </span><br><span class="line">	//建立一个size大小的动态一维数组</span><br><span class="line">	double *arr = new double[size];</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line"> </span><br><span class="line">		// 高斯函数前的常数可以不用计算，会在归一化的过程中给消去</span><br><span class="line">		arr[i] = exp(-((i - kerR)*(i - kerR)) / (2 * sigma*sigma));</span><br><span class="line">		sum += arr[i];//将所有的值进行相加</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	//进行归一化	</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] /= sum;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MyGaussianBlur(Mat_&lt;<span class="built_in">float</span>&gt; &amp;srcImage, Mat_&lt;<span class="built_in">float</span>&gt; &amp;dst, int size)</span><br><span class="line">&#123;</span><br><span class="line">	CV_Assert(srcImage.channels() == 1 || srcImage.channels() == 3); // 只处理单通道或者三通道图像</span><br><span class="line">	int kerR = size / 2;</span><br><span class="line">	dst = srcImage.clone();</span><br><span class="line">	int channels = dst.channels();</span><br><span class="line">	double* arr;</span><br><span class="line">	arr = getOneGuassionArray(size, 1);//先求出高斯数组</span><br><span class="line"> </span><br><span class="line">									   //遍历图像 水平方向的卷积</span><br><span class="line">	<span class="keyword">for</span> (int i = kerR; i &lt; dst.rows - kerR; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = kerR; j &lt; dst.cols - kerR; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> GuassionSum[3] = &#123; 0 &#125;;</span><br><span class="line">			//滑窗搜索完成高斯核平滑</span><br><span class="line">			<span class="keyword">for</span> (int k = -kerR; k &lt;= kerR; k++)</span><br><span class="line">			&#123;</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (channels == 1)//如果只是单通道</span><br><span class="line">				&#123;</span><br><span class="line">					GuassionSum[0] += arr[kerR + k] * dst.at&lt;<span class="built_in">float</span>&gt;(i, j + k);//行不变，列变换，先做水平方向的卷积</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)//如果是三通道的情况</span><br><span class="line">				&#123;</span><br><span class="line">					Vec3f bgr = dst.at&lt;Vec3f&gt;(i, j + k);</span><br><span class="line">					auto a = arr[kerR + k];</span><br><span class="line">					GuassionSum[0] += a*bgr[0];</span><br><span class="line">					GuassionSum[1] += a*bgr[1];</span><br><span class="line">					GuassionSum[2] += a*bgr[2];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (int k = 0; k &lt; channels; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (GuassionSum[k] &lt; 0)</span><br><span class="line">					GuassionSum[k] = 0;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (GuassionSum[k] &gt; 255)</span><br><span class="line">					GuassionSum[k] = 255;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (channels == 1)</span><br><span class="line">				dst.at&lt;<span class="built_in">float</span>&gt;(i, j) = static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)</span><br><span class="line">			&#123;</span><br><span class="line">				Vec3f bgr = &#123; static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[1]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[2]) &#125;;</span><br><span class="line">				dst.at&lt;Vec3f&gt;(i, j) = bgr;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//竖直方向</span><br><span class="line">	<span class="keyword">for</span> (int i = kerR; i &lt; dst.rows - kerR; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = kerR; j &lt; dst.cols - kerR; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> GuassionSum[3] = &#123; 0 &#125;;</span><br><span class="line">			//滑窗搜索完成高斯核平滑</span><br><span class="line">			<span class="keyword">for</span> (int k = -kerR; k &lt;= kerR; k++)</span><br><span class="line">			&#123;</span><br><span class="line"> </span><br><span class="line">				<span class="keyword">if</span> (channels == 1)//如果只是单通道</span><br><span class="line">				&#123;</span><br><span class="line">					GuassionSum[0] += arr[kerR + k] * dst.at&lt;<span class="built_in">float</span>&gt;(i + k, j);//行变，列不换，再做竖直方向的卷积</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)//如果是三通道的情况</span><br><span class="line">				&#123;</span><br><span class="line">					Vec3f bgr = dst.at&lt;Vec3f&gt;(i + k, j);</span><br><span class="line">					auto a = arr[kerR + k];</span><br><span class="line">					GuassionSum[0] += a*bgr[0];</span><br><span class="line">					GuassionSum[1] += a*bgr[1];</span><br><span class="line">					GuassionSum[2] += a*bgr[2];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (int k = 0; k &lt; channels; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (GuassionSum[k] &lt; 0)</span><br><span class="line">					GuassionSum[k] = 0;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (GuassionSum[k] &gt; 255)</span><br><span class="line">					GuassionSum[k] = 255;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (channels == 1)</span><br><span class="line">				dst.at&lt;<span class="built_in">float</span>&gt;(i, j) = static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (channels == 3)</span><br><span class="line">			&#123;</span><br><span class="line">				Vec3f bgr = &#123; static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[0]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[1]), static_cast&lt;<span class="built_in">float</span>&gt;(GuassionSum[2]) &#125;;</span><br><span class="line">				dst.at&lt;Vec3f&gt;(i, j) = bgr;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete[] arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void harrisResponse(Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXX, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussYY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;GaussXY, Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData,<span class="built_in">float</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	//创建一张响应函数输出的矩阵</span><br><span class="line">	resultData = Mat_&lt;<span class="built_in">float</span>&gt;(GaussXX.size(), CV_32FC1);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; resultData.rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = 0; j &lt; resultData.cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">float</span> a = GaussXX.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			<span class="built_in">float</span> b = GaussYY.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			<span class="built_in">float</span> c = GaussXY.at&lt;<span class="built_in">float</span>&gt;(i, j);</span><br><span class="line">			resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) = a*b - c*c - k*(a + b)*(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//非极大值抑制</span><br><span class="line">void LocalMaxValue(Mat_&lt;<span class="built_in">float</span>&gt; &amp;resultData, Mat &amp;srcGray, Mat &amp;ResultImage, int kSize)</span><br><span class="line">&#123;</span><br><span class="line">	int r = kSize / 2;</span><br><span class="line">	ResultImage = srcGray.clone();</span><br><span class="line">	<span class="keyword">for</span> (int i = r; i &lt; ResultImage.rows - r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (int j = r; j &lt; ResultImage.cols - r; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i - 1, j + 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i, j + 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j - 1) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j) &amp;&amp;</span><br><span class="line">				resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; resultData.at&lt;<span class="built_in">float</span>&gt;(i + 1, j + 1))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> ((int)resultData.at&lt;<span class="built_in">float</span>&gt;(i, j) &gt; 18000)</span><br><span class="line">				&#123;</span><br><span class="line">					circle(ResultImage, Point(i, j), 5, Scalar(0,0,255), 2, 8, 0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/linqianbi/article/details/78930239" target="_blank" rel="noopener">https://blog.csdn.net/linqianbi/article/details/78930239</a></p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
        <category>VSLAM</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——论文翻译（A Robust and Versatile Monocular Visual-Inertial State Estimator）</title>
    <url>/2019/10/19/%E3%80%90VINS%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E3%80%91VINS-Mono-A-Robust-and-Versatile-Monocular-Visual-Inertial-State-Estimator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><font color="gray" size="10"><center>VINS-Mono：一种鲁棒且通用的单目视觉惯性状态估计器</center></font><p><strong>摘要</strong>：由一个相机和一个低成本惯性测量单元(IMU)组成的单目视觉惯性系统(VINS)，构成了用于度量六自由度状态估计的最小传感器套件。然而，由于缺乏直接距离测量，在IMU处理、估计器初始化、外部标定和非线性优化等方面提出了重大挑战。本文提出了VINS-Mono：一种具有鲁棒性和通用性的单目视觉惯性状态估计器。该方法从用于估计器初始化和故障恢复的鲁棒的程序开始。采用一种基于紧耦合、非线性优化的方法，通过融合预积分后的IMU测量值和特征观测值，获得高精度的视觉惯性里程计。结合紧耦合方法，回环检测模块能够以最小的计算代价实现重定位。此外，我们还进行四自由度位姿图优化，以加强全局一致性。我们验证了该系统在公共数据集和真实环境实验的性能，并与其他最先进的算法进行了比较。我们还在MAV平台上执行机载闭环自主飞行，并将算法移植到基于iOS的demo中。特别强调的是，本文提出的工作是一个可靠、完整和通用的系统，适用于需要高精度定位的不同应用。我们为PC和iOS移动设备开源了我们的实现方法。<br>关键词：单目视觉惯性系统，状态估计，传感器融合，SLAM</p><a id="more"></a>


<h1 id="I-引言"><a href="#I-引言" class="headerlink" title="I. 引言"></a>I. 引言</h1><p>状态估计无疑是机器人导航、自主驾驶、虚拟现实(VR)和增强现实(AR)等广泛应用中最基本的模块。仅使用单目摄像机的方法由于其体积小、成本低和硬件设置简单而获得了社会的极大兴趣[1]-[5]。然而，单目视觉系统无法恢复度量尺度，因此限制了它们在实际机器人中的应用。近年来，我们看到了一种发展趋势，即用低成本惯性测量单元(IMU)辅助单目视觉系统。这种单目视觉-惯性系统(VINS)的主要优点是具有可观测的度量尺度，以及翻滚角(roll)和俯仰角(pitch)。这让需要有尺度的状态估计的导航任务成为可能。此外，==对IMU测量值的积分可以显著提高运动跟踪性能，弥补光照变化、缺少纹理的区域或运动模糊的视觉轨迹损失的差距==。事实上，单目VINS不仅广泛应用于移动机器人、无人机和移动设备上，还是满足充分自我感知和环境感知的最小传感器。</p>
<p>然而，所有这些优点都是有代价的。对于单目VINS，众所周知，需要加速度激励以测量尺度。这意味着==单目VIN估计器不能从静止状态启动，而是从未知的移动状态发动==。同时要认识到视觉惯性系统高度非线性的事实，在估计器初始化方面还有重大挑战。两个传感器的存在也使得摄像机-IMU的外部校准至关重要。最后，为了消除在可接受的处理窗口内的长期漂移，提出了一个完整的系统，包括视觉惯性里程计、回环检测、重定位和全局优化。</p>
<p>为了解决所有这些问题，我们提出了VINS-Mono，一个鲁棒且通用的单目视觉惯性状态估计器。我们的解决方案开始于即时估计初始化。这个初始化模块也用于故障恢复。我们的解决方案的核心是一个鲁棒的基于紧耦合的滑动窗非线性优化的单目视觉惯性里程计(VIO)。==单目VIO模块不仅提供精确的局部姿态、速度和方位估计，而且还以在线方式执行摄像机IMU外部校准和IMU偏置校正==。使用DBoW2[6]进行回环检测。==重新定位是在对单目VIO进行特征级别融合的紧耦合设置中完成==。这使得重新定位具有鲁棒性和精确性且有最小的计算代价。最后，几何验证的回环被添加到位姿图中，并且由于来自单目VIO的可观测的翻滚角和俯仰角，生成四自由度(DOF)位姿图以确保全局一致性。</p>
<p>VINS-Mono结合并改进了我们先前在单目视觉-惯性融合方面的工作[7]-[10]。它建立在我们紧耦合、基于优化的单目VIO的公式之上[7][8]，并结合了[9]中引入的改进初始化过程。[10]中给出了移植到移动设备的第一次尝试。与我们以前的工作相比，VINS-Mono的进一步改进包括改进的含偏置校正的IMU预积分、紧耦合重定位、全局位姿图优化、广泛的实验评估以及鲁棒和通用的开源实现。</p>
<p>整个系统完整且易于使用。它已经被成功应用于小规模AR场景、中型无人机导航和大规模状态估计任务。与其他最先进的方法相比具有优异的性能。为此，我们总结了我们的贡献，如下所示：<br>1、一个鲁棒的初始化过程，它能够从未知的初始状态引导系统。<br>2、一个紧耦合、基于优化的单目视觉惯性里程计，具有相机-IMU外部校准和IMU偏置估计。<br>3、在线回环检测与紧耦合重定位。<br>4、四自由度全局位姿图优化。<br>5、用于无人机导航、大规模定位和移动AR应用的实时性能演示。<br>6、完全集成于ros的pc版本以及可在iphone 6或更高版本上运行的IOS版本的开源代码。</p>
<p>论文的其余部分如下：在第二节中，我们讨论了相关的文献。在第三节中，我们对完整的系统框架进行了概述。在第四节中，给出了视觉的预处理和IMU测量值的预积分步骤。在第五节中，我们讨论了估计器的初始化过程。在第六节中提出了一种紧耦合、自标定、非线性优化的单目VIO。第七节和第八节分别给出了紧耦合重定位和全局位姿图优化。实施细节和实验结果见第九节。最后，第十节本文对研究方向进行了探讨和展望。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019194830365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h1><p>关于基于单目视觉的状态估计/里程计SLAM的学术工作非常广泛。值得注意的方法包括PTAM[1]、SVO[2]、LSD-SLAM[3]、DSO[5]和ORB-SLAM[4]。显然，尝试对任何方法进行全面回顾都无法完整。然而，在这一节中，我们跳过了关于只使用视觉的方法的讨论，而只专注于关于单目视觉惯性状态估计的最相关的结果。<br>处理视觉和惯性测量的最简单的方法是松耦合的传感器融合[11][12]，其中IMU被视为一个独立的模块，用于辅助运动的视觉结构(sfm)获得的纯视觉位姿估计。融合通常由扩展卡尔曼滤波(EKF)完成，其中IMU用于状态传播，而视觉位姿用于更新。进一步说，紧耦合视觉惯性算法要么基于EKF[13]-[15]，要么基于图优化[7][8][16][17]，其中相机和IMU测量值是从原始测量水平联合优化的。一种流行的基于EKF的VIO方法是MSCKF[13][14]。MSCKF在状态向量中维护以前的几个摄像机位姿，并使用多个摄像机视图中相同特征的视觉测量来形成多约束更新。SR-ISWF[18][19]是MSCKF的扩展。它采用squareroot形式[20]实现单精度表示，避免了较差的数值性质。该方法采用逆滤波器进行迭代再线性化，使其与基于优化的算法相当。批量图优化或集束调整技术（BA）维护和优化所有测量值以获得最优状态估计。为了达到恒定的处理时间，==流行的基于图的VIO方法[8][16][17]通常采用边缘化过去的状态和测量来优化最近状态的有界滑动窗口==。由于对非线性系统迭代求解的计算要求很高，很少有基于图的非线性系统能够在资源受限的平台（如手机上）实现实时性能。</p>
<p>对于视觉测量处理，根据视差模型的定义，算法可分为直接法和间接法。直接法[2][3][21]最小化光度误差，而间接法最小化几何位移。直接法因其吸引区域小，需要很好的初始估计，而间接法在提取和匹配特征时需要额外的计算资源。间接法由于其成熟性和鲁棒性，在实际工程部署中得到了广泛的应用。然而，直接法更容易扩展到稠密建图，因为它们是直接在像素级别上操作的。</p>
<p>在实践中，IMU通常以比摄像机更高的速率获取数据。不同的方法被提出来处理高速率的IMU测量值。最简单的方法是在基于EKF的方法中使用IMU进行状态传播[11][13]。在图优化公式中，为了避免重复的IMU重复积分，提出了一种有效的方法，即IMU预积分(IMU pre-integration)。这种方法在[22]中首次提出的，它用欧拉角来参数化旋转误差。在我们先前的工作中[7]，我们提出了一种流形上的IMU预积分旋转公式，利用连续IMU误差状态动力学推导了协方差传递方程。然而IMU偏置被忽略了。在[23]中通过增加后验IMU偏置校正，进一步改进了预积分理论。</p>
<p>精确的初始值对于引导任何单目VINS是至关重要的。在[8][24]中提出了一种利用短期IMU预积分相对旋转的线性估计器初始化方法。但是，该方法不对陀螺仪偏置进行建模，无法在原始投影方程中对现代传感器噪声进行建模。在实际应用中，当视觉特性远离传感器套件时，这会导致不可靠的初始化。在[25]中给出了单目视觉惯性初始化问题的一种封闭解。随后，在[26]中提出了对这种封闭形式的解决方案的扩展，增加了陀螺仪的偏置校准。这些方法依赖于长时间内IMU测量的双重积分，无法模拟惯性积分的不确定性。在[27]中，提出了一种基于SVO的重初始化和故障恢复算法。这是一种基于松耦合融合框架的实用方法。然而，需要额外的朝下的距离传感器来恢复度量尺度。在[17]中引入了一种建立在ORB-SLAM[4]上的初始化算法。给出了一组ORB-SLAM的关键帧，计算了视觉惯性全局BA的尺度、重力方向、速度和IMU偏置的初步估计。然而，尺度收敛所需的时间可能超过10秒。这可能会给需要在一开始就进行尺度估计的机器人导航任务带来问题。</p>
<p>VIO方法，不管它们所依赖的基本数学公式，在全局的平移和旋转中长期受到漂移的影响。为此，回环检测在长期操作中起着重要的作用。ORB-SLAM[4] 利用了词袋模型能够闭合回环并重用地图。回环检测之后进行7自由度（位置、方向和尺度）的位姿图优化。相对于单目VINS，由于IMU的加入，漂移只发生在4自由度，即三维平移，和围绕重力方向的旋转（偏航角）。因此，本文选择在最小四自由度设定下，优化具有回环约束的位姿图。</p>
<h1 id="III-概述"><a href="#III-概述" class="headerlink" title="III.概述"></a>III.概述</h1><p>提出的单目视觉惯性状态估计器的结构如图2所示。该系统从测量预处理(IV)开始，在其中提取和跟踪特征，对两个连续帧间的IMU测量值进行预积分。初始化过程(V)提供了所有必要的值，包括姿态、速度、重力向量、陀螺仪偏置和三维特征位置，用于引导随后的基于非线性优化的VIO。VIO(VI)与重定位(VII)模块紧密地融合了预先积分的IMU测量、特征观测和回环重新检测到的特征。最后，位姿图优化模块(VIII)接受几何验证的重定位结果，并进行全局优化以消除漂移。VIO、重新定位和位姿图优化模块在多线程设置中同时运行。每个模块有不同的运行速度和实时保证，以确保在任何时候可靠运行。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920013857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们现在对整篇论文中使用的符号和坐标系进行定义。我们认为(.)w(.)w是世界坐标系(world frame)。重力方向与世界坐标系z轴对齐。$(⋅)b$是本体坐标系(body frame)，我们把它定义为与IMU坐标系相同。$(⋅)c$是相机坐标系(camera frame)。我们同时使用旋转矩阵R和Hamilton四元数q来表示旋转。我们主要在状态向量中使用四元数，也用旋转矩阵来表示三维向量的旋转。$q_{wb}，p_{wb}$​表示从本体坐标系到世界坐标系的旋转和平移。$b_k$​表示获取第k个图像时的本体坐标系。$c_k$表示获取第k个图像时的相机坐标系。⊗表示两个四元数之间的乘法运算。$g_w=[0,0,g]T$是世界坐标系上的重力向量。最后，我们将(^)表示为某一具体量的噪声测量值或估计值。</p>
<h1 id="IV-测量预处理"><a href="#IV-测量预处理" class="headerlink" title="IV.测量预处理"></a>IV.测量预处理</h1><p>本节介绍VIO的预处理步骤。对于视觉测量，我们跟踪连续帧之间的特征，并在最新帧中检测新特征。对于IMU测量，我们在两个连续帧之间做预积分。请注意，我们使用的低成本IMU的测量值受到偏置和噪声的影响。因此，我们在IMU预积分过程中特别考虑偏置。</p>
<h2 id="A-视觉处理前端"><a href="#A-视觉处理前端" class="headerlink" title="A.视觉处理前端"></a>A.视觉处理前端</h2><p>对于每一幅新图像，KLT稀疏光流算法对现有特征进行跟踪[29]。同时，检测新的角点特征[30]以保证每个图像特征的最小数目(100-300)。该检测器通过设置两个相邻特征之间像素的最小间隔来执行均匀的特征分布。二维特征首先是不失真的，然后在通过外点剔除后投影到一个单位球面上。利用基本矩阵模型的RANSAC算法进行外点剔除。<br>在此步骤中还选择了关键帧。我们有两个关键帧选择标准。第一是与上一个关键帧的平均视差。如果在当前帧和最新关键帧之间跟踪的特征点的平均视差超出某个特定阈值，则将该帧视为新的关键帧。请注意，不仅平移，旋转也会产生视差。然而，特征点无法在纯旋转运动中三角化。为了避免这种情况，在计算视差时我们使用陀螺仪测量值的短时积分来补偿旋转。请注意，此旋转补偿仅用于关键帧选择，而不涉及VINS公式中的旋转计算。为此，即使陀螺仪含有较大的噪声或存在偏置，也只会导致次优的关键帧选择结果，不会直接影响估计质量。另一个标准是跟踪质量。如果跟踪的特征数量低于某一阈值，我们将此帧视为新的关键帧。这个标准是为了避免跟踪特征完全丢失。</p>
<h1 id="B-IMU预积分"><a href="#B-IMU预积分" class="headerlink" title="B.IMU预积分"></a>B.IMU预积分</h1><p>IMU预积分是在[22]中首次提出的，它将欧拉角的旋转误差参数化。在我们先前的工作中[7]，我们提出了一个流形上的IMU预积分旋转公式。该文利用连续时间的IMU误差状态动力学推导协方差传递函数，但忽略了IMU偏置。文[23]通过增加后验IMU偏置校正，进一步改进了预积分理论。本文通过引入IMU偏置校正，扩展了我们在前面工作[7]中提出的IMU预积分。<br>IMU的原始陀螺仪和加速度计测量结果$\hat w$ 和$\hat a$如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019201549992.png#pic_center"><br>IMU测量值是在本体坐标系中测量的，它是平衡重力和平台动力的合力，并受到加速度偏置$b_a$、陀螺仪偏置$b_w$和附加噪声的影响。假设加速度计和陀螺仪测量值中的附加噪声为高斯噪声，$n_a～N(0,sigma^2_a)$，$n_w～N(0,sigma^2_w)$​。加速度计偏置和陀螺仪偏置被建模为随机游走，其导数为高斯性的，$n_{ba}～N(0,σ^2_{ba})$，$n_{bw}～N(0,σ^2_{bw})$。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202057834.png#pic_center"></p>
<p>给定对应于体坐标系$b_k$和$b_{k+1}$的两个时刻，位置、速度和方向状态可以在时间间隔$[t_k,t_{k+1}]$间，在世界坐标系下中通过惯性测量值传递：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202237245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$∆t_k$是时间间隔$[t_k,t_{k+1}]$之间的持续时间。</p>
<p>可见，IMU状态传递需要坐标系$b_k$的旋转、位置和速度。当这些起始状态改变时，我们需要重新传递IMU测量值。特别是在基于优化的算法中，每次调整位姿时，都需要在它们之间重新传递IMU测量值。这种传递策略在计算上要求很高。为了避免重新传递，我们采用了预积分算法。<br>将参考坐标系从世界坐标系转变为局部坐标系$b_k$后，我们只能对线性的加速度$\hat a$和角速度$\hat w$相关的部分进行预积分，如下所示：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202449110.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202554843.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920251370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以看出预积分项(6)能通过将$b_k$视为参考帧的IMU测量值单独得到。$α^{b_k}_{k+1}$、$β^{b-k}b_{k+1}$、$γ^{b-k}_{k+1}$只与$b_k$和$b_{k+1}$中的IMU偏置有关，与其他状态无关。当偏置估计发生变化时，若偏置变化很小，我们将$α^{bk}_{k+1}、β^{bk}b_{k+1}、γ^{bk}_{k+1}$按其对偏置的一阶近似来调整，否则就进行重新传递。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传递IMU测量值。</p>
<p>对于离散时间的实现，可以采用不同的数值积分方法，如欧拉积分、中点积分、RK4积分等。这里选择了欧拉积分来演示易于理解的过程(我们在代码中使用了中点积分)。</p>
<p>在开始时，$\alpha^{bk}_{k}$、$β^{bk}_{k}$是0，$\gamma^{bk}_{k}$是单位四元数。$α$，$β$，$γ$在(6)中的平均值是如下逐步传递的。注意，增加的噪声项$n_a$，$n_w$是未知的，在实现中被视为零。这得到了预积分的估计值，标记为$(\hat⋅)$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203125870.png#pic_center"><br>i是在$[t_k,t_{k+1}]$中IMU测量值对应的离散时刻，$δ_t$是IMU测量值i和i+1之间的时间间隔。</p>
<p>然后讨论协方差传递问题。由于四维旋转四元数$γ^{b_k}_t$被过参数化，我们将其误差项定义为围绕其平均值的扰动：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203259791.png#pic_center"><br>其中$δθ^{b_k}_t$是三维小扰动。</p>
<p>我们可以导出误差项的连续时间线性化方程(6)：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203414375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$P^{bk}_{b_{k+1}}$可以通过初始协方差$P^{b_k}_{b_k}=0$的一阶离散时间协方差更新递归计算：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203627976.png#pic_center"><br>其中Q是噪声的对角线协方差矩阵$(σ^2_a,σ^2_w,σ^2_{b_a},σ^2_{b_w})$</p>
<p>同时，$δz_{b_{k+1}}^{b_k}$​的一阶雅可比矩阵$J_{b_{k+1}}$​​相对于δzbk​bk​​也可以用初始雅可比矩阵$J_{b_k}=I$ 递归计算。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203912837.png#pic_center"><br>利用这个递推公式，得到协方差矩阵$P^{b_k}_{b_{k+1}}$​​和雅可比矩阵$J^{b_k}_{b_{k+1}}$​​、$α^{b_k}_{b_{k+1}}$、$β^{b_k}_{b_{k+1}}$、$γ^{b_k}_{b_{k+1}}$关于偏置的一阶近似可以写为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203947220.png#pic_center"><br>其中$J^α_{b_a}$是$J_b{k+1}$中的子块矩阵，其位置对应于$\frac{δα^{b_k}_{b_{k+1}}}{δb_{a_k}}$。<br>$J^α_{b_w}、J^β_{b_a}、J^β_{b_w}、J^γ_{b_w}$也使用同样的含义。当偏置估计发生轻微变化时，我们使用(12)近似校正预积分结果，而不重新传递。</p>
<p>现在我们可以写下IMU测量模型所其对应的协方差$P^{b_k}_{b_{k+1}}$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204124533.png#pic_center"></p>
<h1 id="V-估计器初始化"><a href="#V-估计器初始化" class="headerlink" title="V.估计器初始化"></a>V.估计器初始化</h1><p>单目紧耦合VIO是一个高度非线性的系统。由于单目相机无法直接观测到尺度，因此，如果没有良好的初始值，很难直接将这两种测量结果融合在一起。可以假设一个静止的初始条件来启动单目VINS估计器。然而，这种假设是不合适的，因为在实际应用中经常会遇到运动下的初始化。当IMU测量结果被大偏置破坏时，情况就变得更加复杂了。事实上，初始化通常是单目VINS最脆弱的步骤。需要一个鲁棒的初始化过程以确保系统的适用性。</p>
<p>我们采用松耦合的传感器融合方法得到初始值。我们发现纯视觉SLAM，或从运动中恢复结构(SfM)，具有良好的初始化性质。在大多数情况下，纯视觉系统可以通过从相对运动方法（如八点法[32]或五点法[33]或估计单应性矩阵）中导出初始值来引导自己。通过对齐IMU预积分与纯视觉SfM结果，我们可以粗略地恢复尺度、重力、速度，甚至偏置。这足以引导非线性单目VINS估计器，如图4所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204212487.png#pic_center"><br>与在初始阶段同时估计陀螺仪和加速度计偏置的[17]相比，我们在初始阶段选择忽略加速度计偏置项。加速度计偏置与重力耦合，且由于重力向量相对于平台动力学的大量级，以及初始阶段相对较短，这些偏置项很难被观测到。我们以前的工作对加速度计偏置标定进行了详细的分析[34]。</p>
<h1 id="A-滑动窗口-Sliding-Window-纯视觉SfM"><a href="#A-滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="A. 滑动窗口(Sliding Window)纯视觉SfM"></a>A. 滑动窗口(Sliding Window)纯视觉SfM</h1><p>初始化过程从纯视觉SfM估计相机尺度位姿(up-to-scale)和特征位置图开始。</p>
<p>我们保持了一个帧的滑动窗口来限制计算复杂度。首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，我们使用五点法[33]恢复这两个帧之间的相对旋转和尺度平移。否则，我们将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，我们任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP[35]来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)[36]最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c_0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}_{c_k}，q^{c0}_{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"><br>其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p>
<h2 id="B-视觉惯性校准"><a href="#B-视觉惯性校准" class="headerlink" title="B. 视觉惯性校准"></a>B. 视觉惯性校准</h2><p>1）陀螺仪偏置标定：考虑窗口中连续两帧bk和bk+1，我们从视觉sfM中得到旋转$q^{c0}_{b_k}$和$q^{c0}_{b_{k+1}}$​​，从IMU预积分得到的相对约束$γ^{b_k}_{b_{k+1}}$​。我们对陀螺仪偏置求IMU预积分项的线性化，并最小化以下代价函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"><br>其中B代表窗口的所有帧。利用第四部分导出的偏置雅可比，给出了$γ^{b_k}_{b_{k+1}}$​对陀螺仪偏置的一阶近似。这样，我们得到了陀螺仪偏置bw的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}_{b_{k+1}}、\hat β^{b_k}_{b_{k+1}}、\hat γ^{b_k}_{b_{k+1}}$ 。</p>
<p>2）速度、重力向量和尺度初始化：在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"><br>其中，$v^{b_k}_{b_k}$​​是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。</p>
<p>考虑窗口中两个连续帧$b_k$和$b_{k+1}$，那么(5)可以写成：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205047939.png#pic_center"><br>我们可以将(14)和(17)合并成以下线性测量模型：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204900731.png#pic_center"><br>可以看出，$R^{c_0}_{b_k}，R^{c_0}_{b_{k+1}}，\hat p^{c_0}_{c_k}，\hat p^{c_0}_{c_{k+1}}$是从带尺度的单目视觉中得到的，$∆t_k$是两个连续帧之间的时间间隔。通过求解线性最小二乘问题：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205002105.png#pic_center"><br>我们可以得到窗口中每一帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及尺度参数。</p>
<p>3）重力细化：通过约束量值，可以对原线性初始化步骤得到的重力向量进行细化。在大多数情况下，重力向量的大小是已知的。这导致重力向量只剩2个自由度。因此，我们在其切线空间上用两个变量重新参数化重力。参数化将重力向量表示为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205157776.png#pic_center"><br>其中g是已知的重力大小，$\bar {\hat g}$​​是表示重力方向的单位向量，b1和b2是跨越切平面的两个正交基，如图5所示，w1和w2分别是在b1和b2上的对应位移。通过算法1的叉乘运算，可以找到一组b1、b2。然后用</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920522547.png#pic_center"><br>代替(17)中的g，并与其它状态变量一起求解w1和w2。此过程迭代到$\bar {\hat g}$收敛为止。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205247493.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>4）完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$​。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p>
<h1 id="VI-紧耦合单目VIO"><a href="#VI-紧耦合单目VIO" class="headerlink" title="VI. 紧耦合单目VIO"></a>VI. 紧耦合单目VIO</h1><p>在估计器初始化后，我们采用基于滑动窗口的紧耦合单目VIO进行高精度和鲁棒的状态估计。图3显示了滑动窗口的图示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205519675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="A-公式"><a href="#A-公式" class="headerlink" title="A. 公式"></a>A. 公式</h2><p>滑动窗口中的完整状态向量定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205554259.png#pic_center"><br>其中$x_k$是捕获第k图像时的IMU状态。它包含了IMU在世界坐标系中的位置、速度和方向，以及在IMU本体坐标系中的加速度计偏置和陀螺仪偏置。n是关键帧的总数，m是滑动窗口中的特征总数，$λ_l$是第一次观测到第l个特征的逆深度。</p>
<p>我们使用视觉惯性BA。我们最小化所有测量残差的先验和Mahalanobis范数之和，得到最大后验估计：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205631782.png#pic_center"><br>$r_B​(z^{b_k}_{b_{k+1}},X)$和$r_C(\hat z_l^{c_j},X)$分别是IMU和视觉测量的残差。残差的详细定义将在第六节的B和C中提出。B是所有IMU测量的集合，C是在当前滑动窗口中至少观察到两次的一组特征。${r_p,H_p}$是来自边缘化的先验信息。Ceres Solver[38]被用来解决这个非线性问题。</p>
<h2 id="B-IMU测量残差"><a href="#B-IMU测量残差" class="headerlink" title="B. IMU测量残差"></a>B. IMU测量残差</h2><p>考虑滑动窗口中连续两个帧$b_k$和$b_{k+1}$内的IMU测量，根据(13)中定义的IMU测量模型，预积分IMU测量的残差可以定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205738287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>其中，$[·]_{xyz}$是提取四元数q的向量部分，以进行误差状态表示。$δθ^{bk}_{b_{k+1}}$​​是四元数的三维误差状态表示。$[\hat α^{b_k}_{b{k+1}}、\hat β^{b_k}_{b{k+1}}      \hat γ^{b_k}_{b{k+1}}]^T$是在两个连续图像帧的间隔时间内使用仅包含噪声的加速度计和陀螺仪测量值预积分的IMU测量项。加速度计和陀螺仪偏置也包括在在线校正的剩余项中。</p>
<h2 id="C-视觉测量残差"><a href="#C-视觉测量残差" class="headerlink" title="C. 视觉测量残差"></a>C. 视觉测量残差</h2><p>与在广义图像平面上定义重投影误差的传统针孔相机模型相比，我们在单位球面上定义摄像机的测量残差。几乎所有类型相机的光学，包括广角、鱼眼或全向相机，都可以模拟为连接单位球体表面的单位射线。假设第l个特征在第i幅图像中被第一次观察到，第j幅图像中的特征观测的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205925902.png#pic_center"><br>其中$[u^{c_i}_l,v^{c_i}_l]$是第一次观测到出现在第i图像中的第l个特征。$[\hat u^{c_i}_l,\hat v^{c_i}_l]$是在第j图像中对相同特征的观察。$π^{−1}_c$​是利用摄像机内参将像素位置转换成单位向量的反投影函数。由于视觉残差的自由度是2，所以我们将残差向量投影到切平面上。如图6所示，b1、b2是在切平面$\hat {\bar P^{c_j}_l}$上的两个任意选择的正交基。我们可以很容易地找到一组$b_1、b_2$，如算法1所示。在(22)中使用的$P^{c_j}_l$​​是正切空间中固定长度的标准协方差。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210021988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="D-边缘化"><a href="#D-边缘化" class="headerlink" title="D. 边缘化"></a>D. 边缘化</h2><p>为了限制基于优化的VIO的计算复杂度，本文引入了边缘化。我们有选择地从滑动窗口中将IMU状态xK和特征λ1边缘化，同时将对应于边缘状态的测量值转换为先验。</p>
<p>如图7所示，当倒数第二帧是关键帧时，它将停留在窗口中，而最旧的帧与其相应的测量值被边缘化。但如果倒数第二帧是非关键帧，我们丢掉视觉测量值，保留连接到这个非关键帧的IMU测量值。为了保持系统的稀疏性，我们不会边缘化非关键帧的所有测量值。我们的边缘化方案旨在保持窗口中空间分离的关键帧。这确保了特征三角化有足够的视差，并且最大化了在大激励下获得加速度计测量值的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210401727.png#pic_center"></p>
<h2 id="E-摄像机速率状态估计的纯运动视觉惯性BA"><a href="#E-摄像机速率状态估计的纯运动视觉惯性BA" class="headerlink" title="E. 摄像机速率状态估计的纯运动视觉惯性BA"></a>E. 摄像机速率状态估计的纯运动视觉惯性BA</h2><p>对于计算能力较低的设备如手机，由于对非线性优化的计算要求很高，紧耦合单目VIO无法实现摄像机速率输出。为此，我们采用了一种轻量级的纯运动视觉惯性BA，以提升状态估计速率到相机速率(30Hz)。</p>
<p>纯运动单目视觉惯性BA的代价函数与(22)中单目VIO的代价函数相同。然而我们只对固定数量的最新IMU状态的姿态和速度进行了优化，而不是对滑动窗口中的所有状态进行优化。我们将特征深度、外部参数、偏置和旧的IMU状态这些不希望优化的状态作为常量来处理。我们使用所有的视觉和惯性测量来进行纯运动的BA。这导致了比单帧PnP方法更平滑的状态估计。图8显示了提出方法的插图。与在最先进的嵌入式计算机上可能导致超过50ms的完全紧耦合单目VIO不同，这种纯运动的视觉惯性BA只需大约5ms来计算。这使得低延迟的相机频率进行位姿估计对无人机和AR应用特别有利。<br>F. IMU前向传递以达到IMU速率状态估计</p>
<p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="F-IMU前向传递以达到IMU速率状态估计"><a href="#F-IMU前向传递以达到IMU速率状态估计" class="headerlink" title="F. IMU前向传递以达到IMU速率状态估计"></a>F. IMU前向传递以达到IMU速率状态估计</h2><p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="G-故障检测与恢复"><a href="#G-故障检测与恢复" class="headerlink" title="G. 故障检测与恢复"></a>G. 故障检测与恢复</h2><p>虽然我们紧耦合的单目视觉对各种具有挑战性的环境和运动是鲁棒的。由于强烈的光照变化或剧烈的运动，故障仍然是不可避免的。主动故障检测和恢复策略可以提高系统的实用性。故障检测是一个独立的模块，它检测估计器的异常输出。我们目前使用以下标准进行故障检测：<br>1、在最新帧中跟踪的特征数小于某一阈值；<br>2、最近两个估计器输出之间的位置或旋转有较大的不连续性；<br>3、偏置或外部参数估计有较大的变化；</p>
<p>一旦检测到故障，系统将切换回初始化阶段。一旦单目VIO被成功初始化，将新建一个独立的位姿图。</p>
<h1 id="VII-重定位"><a href="#VII-重定位" class="headerlink" title="VII. 重定位"></a>VII. 重定位</h1><p>我们的滑动窗口和边缘化方案限制了计算的复杂性，但也给系统带来了累积漂移。更确切地说，漂移发生在全局三维位置(x,y,z)和围绕重力方向的旋转(yaw)。为了消除漂移，提出了一种与单目VIO无缝集成的紧耦合重定位模块。重定位过程从一个循环检测模块开始，该模块识别已经访问过的地方。然后建立回环检测候选帧和当前帧之间的特征级连接。这些特征的对应关系紧密地集成到单目VIO模块中，从而以最小计算代价得到无漂移状态估计。多个特征的多个观测直接用于重定位，从而提高了定位的精度和状态估计的平滑性。重定位过程如图9(a)所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210456719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-特征恢复"><a href="#B-特征恢复" class="headerlink" title="B. 特征恢复"></a>B. 特征恢复</h2><p>当检测到回路时，通过检索特征对应关系建立局部滑动窗口与回环候选帧之间的连接。通过BRIEF描述子匹配找到对应关系。直接描述子匹配可能会造成大量异常值。为此，我们使用两步进行几何异常值剔除，如图10所示。<br>1、2D-2D：RANSAC[31]的基本矩阵检验。我们利用当前图像中检索到的特征的二维观测和回环候选图像进行基本矩阵检验。<br>2、3D-2D：RANSAC的PNP检验。基于特征在局部滑动窗口中已知的三维位置，以及回环候选图像中的二维观测，进行PNP检验。</p>
<p>当内点超过一定阈值时，我们将该候选帧视为正确的循环检测并执行重定位。</p>
<h2 id="C-紧耦合重定位"><a href="#C-紧耦合重定位" class="headerlink" title="C. 紧耦合重定位"></a>C. 紧耦合重定位</h2><p>重定位过程有效地使单目VIO(VI)维持的当前滑动窗口与过去的位姿图对齐。在重定位过程中，我们将所有回环帧的位姿作为常量。利用所有IMU测量值、局部视觉测量和从回环中提取特征对应值，共同优化滑动窗口。我们可以轻松地为回环帧v观察到的检索特征编写视觉测量模型，使其与VIO中的视觉测量相同，如(25)所示。唯一的区别是，从位姿图(VIII)或直接从上一个里程计的输出（如果这是第一次重定位）获得的回环帧的姿态$(\hat q^w_v,\hat p^w_v)$<br>(q^​vw​,p^​vw​)被视为常数。为此，我们可以在(22)中稍微修改非线性代价函数，增加回环项：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210641949.png#pic_center"><br>其中L是回环帧中检索到的特征的观测集。$(l,v)$是指在回环帧v中观察到的第l个特征。虽然代价函数与(22)略有不同，但待解状态的维数保持不变，因为回环帧的构成被视为常数。当用当前滑动窗口建立多个回环时，我们同时使用来自所有帧的所有回环特征对应进行优化。这就为重定位提供了多视角的约束，从而提高了定位的精度和平滑性。请注意，过去的姿态和回环帧的全局优化发生在重定位之后，将在第八节中讨论。</p>
<h1 id="VIII-全局位姿图优化"><a href="#VIII-全局位姿图优化" class="headerlink" title="VIII. 全局位姿图优化"></a>VIII. 全局位姿图优化</h1><p>重新定位后，局部滑动窗口移动并与过去的位姿对齐。利用重定位结果，开发了额外的位姿图优化步骤，以确保过去位姿集注册到全局一致的配置中。</p>
<p>由于视觉惯性的建立使翻滚角和俯仰角完全可观测，累积漂移只发生在四个自由度(x，y，z和yaw)。为此，我们忽视对无漂移翻滚和俯仰状态的估计，只进行了四自由度位姿图的优化。</p>
<h2 id="A-在位姿图中添加关键帧"><a href="#A-在位姿图中添加关键帧" class="headerlink" title="A. 在位姿图中添加关键帧"></a>A. 在位姿图中添加关键帧</h2><p>当关键帧从滑动窗口被边缘化时，它将被添加到位姿图中。这个关键帧在位姿图中作为顶点，它通过两种类型的边与其他顶点连接：</p>
<p>1）顺序边(Sequential Edge)：关键帧将建立与之前关键帧的若干顺序边。顺序边表示局部滑动窗口中两个关键帧之间的相对转换，其值直接从VIO中获取。考虑到新边缘化的关键帧i及其先前的一个关键帧j，顺序边只包含相对位置和偏航角。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210857102.png#pic_center">)<br>2）回环边(Loop Closure Edge)：如果新边缘化的关键帧有一个回环连接，它将与回环帧通过一个回环边在位姿图图中连接。同样，闭环边缘只包含与(27)相同定义的四自由度相对位姿变换。回环边的值由重定位结果得出。</p>
<h2 id="B-4自由度位姿图优化"><a href="#B-4自由度位姿图优化" class="headerlink" title="B. 4自由度位姿图优化"></a>B. 4自由度位姿图优化</h2><p>我们将帧i和j之间边的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210815393.png#pic_center"><br>其中，$\hat \phi _i，\hat    θ_i$是直接从单目VIO中得到的翻滚角和俯仰角的估计。</p>
<p>通过最小化以下代价函数，对顺序边和回环边的整个图进行优化：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921101530.png#pic_center"></p>
<p>其中S是所有顺序边的集合，L是回环边的集合。尽管紧耦合的重定位已经有助于消除错误的回环，但我们添加了另一个Huber范数 $ρ(·)$，以进一步减少任何可能的错误回环的影响。相反，我们不对顺序边使用任何鲁棒范数，因为这些边是从VIO中提取出来的，VIO已经包含了足够多的外点排除机制。</p>
<p>位姿图优化和重定位(VII-C)异步运行在两个独立的线程中。以便在需要重定位时，能立即使用最优化的位姿图。同样，即使当前的位姿图优化尚未完成，仍然可以使用现有的位姿图配置进行重新定位。这一过程如图9(b)所示。</p>
<h2 id="C-位姿图管理"><a href="#C-位姿图管理" class="headerlink" title="C. 位姿图管理"></a>C. 位姿图管理</h2><p>随着行程距离的增加，位姿图的大小可能会无限增长，从而限制了长时间系统的实时性。为此，我们实行了一个下采样过程，将位姿图数据库保持在有限的大小。所有具有回环约束的关键帧都将被保留，而其他与相邻帧过近或方向非常相似的关键帧可能会被删除。关键帧被移除的概率和其相邻帧的空间密度成正比。</p>
<h1 id="IX-实验结果"><a href="#IX-实验结果" class="headerlink" title="IX. 实验结果"></a>IX. 实验结果</h1><p>我们进行了三个实验和两个应用，以评估所提出的VINS-Mono系统。在第一个实验中，我们将提出的算法与另一种最先进算法在公共数据集上进行比较。我们通过数值分析以验证了系统的精度。然后在室内环境中测试我们的系统，以评估在重复场景中的性能。通过大量的实验验证了系统的长期实用性。此外，我们还将所提出的系统应用于两个应用。对于空中机器人的应用，我们使用VINS-Mono作为位置反馈来控制无人机跟踪预定的轨迹。然后我们将我们的方法移植到iOS移动设备上，并与Google Tango进行比较。</p>
<h2 id="A-数据集比较"><a href="#A-数据集比较" class="headerlink" title="A. 数据集比较"></a>A. 数据集比较</h2><p>我们使用EuRoC MAV视觉-惯性数据集[41]评估我们提出的VINS-Mono。这个数据集是在一架微型飞行器上收集的，它包含立体图像(Aptina MT9V034全局快门、WVGA单色、20 FPS)、同步IMU测量(ADIS 16448、200 Hz)和地面真实状态(Vicon和Leica MS 50)。我们只使用左边相机的图像。在这数据集中会观察到较大的IMU偏置和光照变化。</p>
<p>在这些实验中，我们将VINS-Mono和OKVIS进行了比较，这是一种最先进的单目和立体相机VIO。OKVIS是另一种基于优化的滑动窗口算法。我们的算法与OKVIS在许多细节上是不同的，如技术部分所示。我们的系统具有良好的初始化和回环功能。我们使用MH_03_median和MH_05_difficult两组序列来证明该方法的性能。为了简化表示，我们使用VINS来表示我们只使用单目VIO的方法，而VINS_loop表示含重定位和位姿图优化的完全版本。我们分别用OKVIS_Mono和OKVIS_stereo表示OKVIS使用单目和立体图像的结果。为了进行公平的比较，我们丢弃前100个输出，并使用接下来的150个输出对齐地面真值，并比较其余的估计器输出。</p>
<p>MH_03_median序列轨迹如图11所示。我们只比较平移误差，因为旋转运动在这个序列中是可以忽略的。图12显示了x、y、z误差与时间的关系，以及平移误差与距离的关系。在误差图中，具有回环的VINS-Mono具有最小的平移误差。我们在MH_05_difficult上观察到类似的结果。该方法具有最小的平移误差。平移和旋转误差如图14所示。由于该序列运动平稳，偏角变化不大，只发生位置漂移。显然，回环闭合有效地约束了累积漂移。OKVIS在翻滚角和俯仰角估计方面表现更好。一个可能的原因是VINS-Mono采用了预积分技术，即IMU传递的一阶近似，以节省计算资源。</p>
<p>VINS-Mono在所有Euroc数据集中都表现良好，即使在最具挑战性的序列V1_03_difficult中，它具有剧烈性的运动、纹理较少的区域和显著的光照变化。由于采用了专用的初始化过程，该方法可以在V1_03_difficult快速初始化。</p>
<p>对于纯VIO，VINS-Mono和OKVIS具有相似的精度，很难区分哪个比较好。然而，VINS-Mono在系统级别上优于OKVIS。它是一个完整的系统，具有鲁棒的初始化和回环闭合功能来辅助单目视觉。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211301627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211334529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-室内实验"><a href="#B-室内实验" class="headerlink" title="B. 室内实验"></a>B. 室内实验</h2><p>在室内实验中，我们选择实验室环境作为实验区域。我们使用的传感器套件如图15所示。它搭载在DJI A3控制器上，包含一个单目照相机（20Hz）和一个IMU（100 Hz）。我们手握传感器套件，在实验室以正常的速度行走。如图16所示，我们遇到行人，光线较弱的位置，纹理较少的区域，玻璃和反射。多媒体附件中可以找到视频。 </p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211501205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们将我们的结果与OKVIS进行了比较，如图17所示。图17(a)是OKVIS的VIO输出。图17(b)是所提出的无回环方法的VIO结果。图17©是所提出的具有重定位和回环闭合的方法的结果。当我们在室内转圈时，会出现明显的漂移。OKVIS和只有VIO版本的VINS-Mono在x、y、z和偏航角上积累了大量漂移。我们的重定位和回环闭合模块有效地消除了所有这些漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211551914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="C-大范围环境"><a href="#C-大范围环境" class="headerlink" title="C. 大范围环境"></a>C. 大范围环境</h2><p>1）走出实验室：我们在室内和室外混合环境中测试VINS-Mono。传感器套件与图15所示的相同。我们从实验室的一个座位上开始，在室内空间里走来走去。然后我们下楼，在大楼外的操场上走来走去。接下来，我们回到楼里并上楼。最后，我们回到了实验室的同一个座位。整个轨迹超过700米，持续约10分钟。在多媒体附件中可以找到实验的视频。</p>
<p>轨迹如图19所示。图19(a)是OKVIS的轨迹。当我们上楼时，OKVIS显示出不稳定的特征跟踪，导致估计错误。我们看不到红色街区楼梯的形状。VINS-Mono的纯VIO结果如图19(b)所示。有闭环的轨迹如图19©所示。该方法的楼梯形状清晰。为验证其准确性，将闭环轨迹与谷歌地图对齐，如图18所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921164349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>OKVIS的 x、y和z轴的最终漂移为[13.80,-5.26,7.23]米。VINS-Mono无环闭路的最终漂移为[-5.47,2.76,-0.29]m，占整个轨迹长度的0.88%，小于OKVIS的2.36%。经回环修正，最终漂移上界为[-0.032,0.09,-0.07]m，与整个轨迹长度相比这是微不足道的。虽然我们没有地面真值，但我们仍然可以直观地检查优化后的轨迹是否平滑并能精确地与卫星地图对齐。</p>
<p>2）环游校园：这张环绕整个科大校园的非常大规模的数据集是用一个手持的VI-Sensor 4记录下来的。该数据集覆盖的地面长度约为710米，宽度为240米，高度变化为60米。总路径长度为5.62km。数据包含25Hz图像和200Hz IMU，持续1小时34分钟。对VINS-Mono的稳定性和耐久性进行测试是一个非常有意义的实验。</p>
<p>在这个大规模的测试中，我们将关键帧数据库的大小设置为2000，以提供足够的回环信息并达到实时性。我们运行此数据集时，采用英特尔i7-4790 CPU运行在3.60GHz。时间统计数据显示在表I中。如图20，估计的轨迹与谷歌地图一致。与谷歌地图相比，我们的结果在这个非常长时间的测试中几乎没有漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921174092.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211751315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>D. 应用1：航空机器人的反馈控制</p>
<p>如图21(a)所示，我们将VINS-Mono应用于航空机器人的自主反馈控制。我们使用了一个具有752×480分辨率的前向全局曝光相机(MatrixVisionMvBlueFOXMLC200w)，并配备了190度鱼眼镜头。DJIA3飞行控制器用于IMU测量和姿态稳定控制。机载计算资源是Intel i7-5500 U CPU运行在3.00GHz。传统的针孔摄像机模型不适用于大视场摄像机。我们使用MEI[42]模型，由[43]介绍的工具包进行校准。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211839510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>在本实验中，我们测试使用VINS_Mono的状态估计来进行自主轨迹跟踪的性能。实验中回环检测被禁止。四旋翼被命令跟踪一个八字形图案，每个圆圈半径为1.0米，如图21(b)所示。在轨迹周围设置了四个障碍物，以验证VINS-Mono无闭环的准确性。在实验过程中，四旋翼连续四次跟踪这一轨迹。100 Hz机载状态估计(VI-F)支持对四旋翼的实时反馈控制。</p>
<p>地面真值是用OptiTrack 5获得的。总轨迹长度为61.97 m。最终漂移为[0.08，0.09，0.13]m，为0.29%的位置漂移。平移和旋转的细节以及它们相应的误差如图23所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211919318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="E-应用2：移动设备"><a href="#E-应用2：移动设备" class="headerlink" title="E. 应用2：移动设备"></a>E. 应用2：移动设备</h2><p>我们将VINS-Mono移植到移动设备上，并提供一个简单的AR应用程序来展示其准确性和鲁棒性。我们将我们的移动实现命名为VINS-Mobile6，并将其与Google Tango Device 7进行了比较，后者是移动平台在商业上最好的增强现实解决方案之一。</p>
<p>VINS-Mono运行在iPhone7 Plus上。我们使用iPhone采集的30 Hz、分辨率为640×480的图像，以及内置InvenSense MP67B 6轴陀螺仪和加速度计获得的100 Hz 的IMU数据。如图24所示，我们将iPhone与一个启用Tango功能的联想Phab 2 Pro一起安装。Tango设备使用全局快门、鱼眼相机和同步IMU进行状态估计。首先，我们在从估计的视觉特征中提取出来的平面上插入一个虚拟立方体，如图25(a)所示。然后，我们拿着这两个装置，以正常的速度在房间内外行走。当检测到回环时，我们使用四自由度位姿图优化(VIII-B)，以消除x，y，z和yaw漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212019875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212037844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921210026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>有趣的是，当我们打开一扇门时，Tango的偏航角估计会跳转到一个很大的角度，如图25(b)所示。其原因可能是由于不稳定的特征跟踪或主动故障检测和恢复而导致的估计器崩溃。然而，VINS-Mono在这个具有挑战性的情况中仍然表现很好。行走了大约264米后我们回到起点。最后的结果可以在图25( c)中看到，Tango的轨迹在最后一圈会漂移，而我们的VINS会回到起点。四自由度位姿图的优化消除了总轨迹的漂移。这与开始相比，立方体被标记到图像上的同一位置也印证了这一点。</p>
<p>诚然，尤其是对局部状态的估计，Tango比我们的实现更准确。但是实验结果表明，我们的方法可以在通用移动设备上运行，并且具有媲美特殊工程设备的潜力。实验还证明了该方法的鲁棒性。视频可以在多媒体附件中找到。</p>
<h1 id="X-结论和未来工作"><a href="#X-结论和未来工作" class="headerlink" title="X. 结论和未来工作"></a>X. 结论和未来工作</h1><p>本文提出了一种鲁棒、通用的单目视觉惯性估计器。我们的方法在IMU预积分，估计器初始化和故障恢复，在线外部校准，紧耦合视觉惯性里程计，重定位和有效的全局优化上，具有最先进的和新颖的解决方案。我们通过与最先进的开源实现和高度优化的行业解决方案进行比较，显示出更好的性能。我们开源了PC和iOS的实现，以造福社会。</p>
<p>虽然基于特征的VINS估计器已经达到了实际使用的成熟程度，我们仍然看到了未来研究的许多方向。单目VINS可能会根据运动和环境而达到较难观测甚至退化的状态。我们最感兴趣的是在线方法来评估单目VINS的可观测性，以及在线生成运动计划来恢复可观测性。另一个研究方向是在大量消费设备上大规模部署单目VINS，例如移动电话。这一应用要求在线校准几乎所有传感器的内参和外参，以及在线鉴定校准质量。最后，我们感兴趣的是制作由单目VINS给出的稠密地图。我们在[44]中首次给出了用于无人机导航的单目视觉-惯性稠密地图的结果。然而，仍需进行广泛的研究以进一步提高系统的精度和鲁棒性。</p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>VINS-Mono——论文翻译（A Robust and Versatile Monocular Visual-Inertial State Estimator）</title>
    <url>/2019/10/19/VINS-Mono%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%88VINS-Mono-A-Robust-and-Versatile-Monocular-Visual-Inertial-State-Estimator%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><font color="gray" size="10"><center>VINS-Mono：一种鲁棒且通用的单目视觉惯性状态估计器</center></font><p><strong>摘要</strong>：由一个相机和一个低成本惯性测量单元(IMU)组成的单目视觉惯性系统(VINS)，构成了用于度量六自由度状态估计的最小传感器套件。然而，由于缺乏直接距离测量，在IMU处理、估计器初始化、外部标定和非线性优化等方面提出了重大挑战。本文提出了VINS-Mono：一种具有鲁棒性和通用性的单目视觉惯性状态估计器。该方法从用于估计器初始化和故障恢复的鲁棒的程序开始。采用一种基于紧耦合、非线性优化的方法，通过融合预积分后的IMU测量值和特征观测值，获得高精度的视觉惯性里程计。结合紧耦合方法，回环检测模块能够以最小的计算代价实现重定位。此外，我们还进行四自由度位姿图优化，以加强全局一致性。我们验证了该系统在公共数据集和真实环境实验的性能，并与其他最先进的算法进行了比较。我们还在MAV平台上执行机载闭环自主飞行，并将算法移植到基于iOS的demo中。特别强调的是，本文提出的工作是一个可靠、完整和通用的系统，适用于需要高精度定位的不同应用。我们为PC和iOS移动设备开源了我们的实现方法。<br>关键词：单目视觉惯性系统，状态估计，传感器融合，SLAM</p><a id="more"></a>


<h1 id="I-引言"><a href="#I-引言" class="headerlink" title="I. 引言"></a>I. 引言</h1><p>状态估计无疑是机器人导航、自主驾驶、虚拟现实(VR)和增强现实(AR)等广泛应用中最基本的模块。仅使用单目摄像机的方法由于其体积小、成本低和硬件设置简单而获得了社会的极大兴趣[1]-[5]。然而，单目视觉系统无法恢复度量尺度，因此限制了它们在实际机器人中的应用。近年来，我们看到了一种发展趋势，即用低成本惯性测量单元(IMU)辅助单目视觉系统。这种单目视觉-惯性系统(VINS)的主要优点是具有可观测的度量尺度，以及翻滚角(roll)和俯仰角(pitch)。这让需要有尺度的状态估计的导航任务成为可能。此外，==对IMU测量值的积分可以显著提高运动跟踪性能，弥补光照变化、缺少纹理的区域或运动模糊的视觉轨迹损失的差距==。事实上，单目VINS不仅广泛应用于移动机器人、无人机和移动设备上，还是满足充分自我感知和环境感知的最小传感器。</p>
<p>然而，所有这些优点都是有代价的。对于单目VINS，众所周知，需要加速度激励以测量尺度。这意味着==单目VIN估计器不能从静止状态启动，而是从未知的移动状态发动==。同时要认识到视觉惯性系统高度非线性的事实，在估计器初始化方面还有重大挑战。两个传感器的存在也使得摄像机-IMU的外部校准至关重要。最后，为了消除在可接受的处理窗口内的长期漂移，提出了一个完整的系统，包括视觉惯性里程计、回环检测、重定位和全局优化。</p>
<p>为了解决所有这些问题，我们提出了VINS-Mono，一个鲁棒且通用的单目视觉惯性状态估计器。我们的解决方案开始于即时估计初始化。这个初始化模块也用于故障恢复。我们的解决方案的核心是一个鲁棒的基于紧耦合的滑动窗非线性优化的单目视觉惯性里程计(VIO)。==单目VIO模块不仅提供精确的局部姿态、速度和方位估计，而且还以在线方式执行摄像机IMU外部校准和IMU偏置校正==。使用DBoW2[6]进行回环检测。==重新定位是在对单目VIO进行特征级别融合的紧耦合设置中完成==。这使得重新定位具有鲁棒性和精确性且有最小的计算代价。最后，几何验证的回环被添加到位姿图中，并且由于来自单目VIO的可观测的翻滚角和俯仰角，生成四自由度(DOF)位姿图以确保全局一致性。</p>
<p>VINS-Mono结合并改进了我们先前在单目视觉-惯性融合方面的工作[7]-[10]。它建立在我们紧耦合、基于优化的单目VIO的公式之上[7][8]，并结合了[9]中引入的改进初始化过程。[10]中给出了移植到移动设备的第一次尝试。与我们以前的工作相比，VINS-Mono的进一步改进包括改进的含偏置校正的IMU预积分、紧耦合重定位、全局位姿图优化、广泛的实验评估以及鲁棒和通用的开源实现。</p>
<p>整个系统完整且易于使用。它已经被成功应用于小规模AR场景、中型无人机导航和大规模状态估计任务。与其他最先进的方法相比具有优异的性能。为此，我们总结了我们的贡献，如下所示：<br>1、一个鲁棒的初始化过程，它能够从未知的初始状态引导系统。<br>2、一个紧耦合、基于优化的单目视觉惯性里程计，具有相机-IMU外部校准和IMU偏置估计。<br>3、在线回环检测与紧耦合重定位。<br>4、四自由度全局位姿图优化。<br>5、用于无人机导航、大规模定位和移动AR应用的实时性能演示。<br>6、完全集成于ros的pc版本以及可在iphone 6或更高版本上运行的IOS版本的开源代码。</p>
<p>论文的其余部分如下：在第二节中，我们讨论了相关的文献。在第三节中，我们对完整的系统框架进行了概述。在第四节中，给出了视觉的预处理和IMU测量值的预积分步骤。在第五节中，我们讨论了估计器的初始化过程。在第六节中提出了一种紧耦合、自标定、非线性优化的单目VIO。第七节和第八节分别给出了紧耦合重定位和全局位姿图优化。实施细节和实验结果见第九节。最后，第十节本文对研究方向进行了探讨和展望。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019194830365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h1><p>关于基于单目视觉的状态估计/里程计SLAM的学术工作非常广泛。值得注意的方法包括PTAM[1]、SVO[2]、LSD-SLAM[3]、DSO[5]和ORB-SLAM[4]。显然，尝试对任何方法进行全面回顾都无法完整。然而，在这一节中，我们跳过了关于只使用视觉的方法的讨论，而只专注于关于单目视觉惯性状态估计的最相关的结果。<br>处理视觉和惯性测量的最简单的方法是松耦合的传感器融合[11][12]，其中IMU被视为一个独立的模块，用于辅助运动的视觉结构(sfm)获得的纯视觉位姿估计。融合通常由扩展卡尔曼滤波(EKF)完成，其中IMU用于状态传播，而视觉位姿用于更新。进一步说，紧耦合视觉惯性算法要么基于EKF[13]-[15]，要么基于图优化[7][8][16][17]，其中相机和IMU测量值是从原始测量水平联合优化的。一种流行的基于EKF的VIO方法是MSCKF[13][14]。MSCKF在状态向量中维护以前的几个摄像机位姿，并使用多个摄像机视图中相同特征的视觉测量来形成多约束更新。SR-ISWF[18][19]是MSCKF的扩展。它采用squareroot形式[20]实现单精度表示，避免了较差的数值性质。该方法采用逆滤波器进行迭代再线性化，使其与基于优化的算法相当。批量图优化或集束调整技术（BA）维护和优化所有测量值以获得最优状态估计。为了达到恒定的处理时间，==流行的基于图的VIO方法[8][16][17]通常采用边缘化过去的状态和测量来优化最近状态的有界滑动窗口==。由于对非线性系统迭代求解的计算要求很高，很少有基于图的非线性系统能够在资源受限的平台（如手机上）实现实时性能。</p>
<p>对于视觉测量处理，根据视差模型的定义，算法可分为直接法和间接法。直接法[2][3][21]最小化光度误差，而间接法最小化几何位移。直接法因其吸引区域小，需要很好的初始估计，而间接法在提取和匹配特征时需要额外的计算资源。间接法由于其成熟性和鲁棒性，在实际工程部署中得到了广泛的应用。然而，直接法更容易扩展到稠密建图，因为它们是直接在像素级别上操作的。</p>
<p>在实践中，IMU通常以比摄像机更高的速率获取数据。不同的方法被提出来处理高速率的IMU测量值。最简单的方法是在基于EKF的方法中使用IMU进行状态传播[11][13]。在图优化公式中，为了避免重复的IMU重复积分，提出了一种有效的方法，即IMU预积分(IMU pre-integration)。这种方法在[22]中首次提出的，它用欧拉角来参数化旋转误差。在我们先前的工作中[7]，我们提出了一种流形上的IMU预积分旋转公式，利用连续IMU误差状态动力学推导了协方差传递方程。然而IMU偏置被忽略了。在[23]中通过增加后验IMU偏置校正，进一步改进了预积分理论。</p>
<p>精确的初始值对于引导任何单目VINS是至关重要的。在[8][24]中提出了一种利用短期IMU预积分相对旋转的线性估计器初始化方法。但是，该方法不对陀螺仪偏置进行建模，无法在原始投影方程中对现代传感器噪声进行建模。在实际应用中，当视觉特性远离传感器套件时，这会导致不可靠的初始化。在[25]中给出了单目视觉惯性初始化问题的一种封闭解。随后，在[26]中提出了对这种封闭形式的解决方案的扩展，增加了陀螺仪的偏置校准。这些方法依赖于长时间内IMU测量的双重积分，无法模拟惯性积分的不确定性。在[27]中，提出了一种基于SVO的重初始化和故障恢复算法。这是一种基于松耦合融合框架的实用方法。然而，需要额外的朝下的距离传感器来恢复度量尺度。在[17]中引入了一种建立在ORB-SLAM[4]上的初始化算法。给出了一组ORB-SLAM的关键帧，计算了视觉惯性全局BA的尺度、重力方向、速度和IMU偏置的初步估计。然而，尺度收敛所需的时间可能超过10秒。这可能会给需要在一开始就进行尺度估计的机器人导航任务带来问题。</p>
<p>VIO方法，不管它们所依赖的基本数学公式，在全局的平移和旋转中长期受到漂移的影响。为此，回环检测在长期操作中起着重要的作用。ORB-SLAM[4] 利用了词袋模型能够闭合回环并重用地图。回环检测之后进行7自由度（位置、方向和尺度）的位姿图优化。相对于单目VINS，由于IMU的加入，漂移只发生在4自由度，即三维平移，和围绕重力方向的旋转（偏航角）。因此，本文选择在最小四自由度设定下，优化具有回环约束的位姿图。</p>
<h1 id="III-概述"><a href="#III-概述" class="headerlink" title="III.概述"></a>III.概述</h1><p>提出的单目视觉惯性状态估计器的结构如图2所示。该系统从测量预处理(IV)开始，在其中提取和跟踪特征，对两个连续帧间的IMU测量值进行预积分。初始化过程(V)提供了所有必要的值，包括姿态、速度、重力向量、陀螺仪偏置和三维特征位置，用于引导随后的基于非线性优化的VIO。VIO(VI)与重定位(VII)模块紧密地融合了预先积分的IMU测量、特征观测和回环重新检测到的特征。最后，位姿图优化模块(VIII)接受几何验证的重定位结果，并进行全局优化以消除漂移。VIO、重新定位和位姿图优化模块在多线程设置中同时运行。每个模块有不同的运行速度和实时保证，以确保在任何时候可靠运行。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920013857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们现在对整篇论文中使用的符号和坐标系进行定义。我们认为(.)w(.)w是世界坐标系(world frame)。重力方向与世界坐标系z轴对齐。$(⋅)b$是本体坐标系(body frame)，我们把它定义为与IMU坐标系相同。$(⋅)c$是相机坐标系(camera frame)。我们同时使用旋转矩阵R和Hamilton四元数q来表示旋转。我们主要在状态向量中使用四元数，也用旋转矩阵来表示三维向量的旋转。$q_{wb}，p_{wb}$​表示从本体坐标系到世界坐标系的旋转和平移。$b_k$​表示获取第k个图像时的本体坐标系。$c_k$表示获取第k个图像时的相机坐标系。⊗表示两个四元数之间的乘法运算。$g_w=[0,0,g]T$是世界坐标系上的重力向量。最后，我们将(^)表示为某一具体量的噪声测量值或估计值。</p>
<h1 id="IV-测量预处理"><a href="#IV-测量预处理" class="headerlink" title="IV.测量预处理"></a>IV.测量预处理</h1><p>本节介绍VIO的预处理步骤。对于视觉测量，我们跟踪连续帧之间的特征，并在最新帧中检测新特征。对于IMU测量，我们在两个连续帧之间做预积分。请注意，我们使用的低成本IMU的测量值受到偏置和噪声的影响。因此，我们在IMU预积分过程中特别考虑偏置。</p>
<h2 id="A-视觉处理前端"><a href="#A-视觉处理前端" class="headerlink" title="A.视觉处理前端"></a>A.视觉处理前端</h2><p>对于每一幅新图像，KLT稀疏光流算法对现有特征进行跟踪[29]。同时，检测新的角点特征[30]以保证每个图像特征的最小数目(100-300)。该检测器通过设置两个相邻特征之间像素的最小间隔来执行均匀的特征分布。二维特征首先是不失真的，然后在通过外点剔除后投影到一个单位球面上。利用基本矩阵模型的RANSAC算法进行外点剔除。<br>在此步骤中还选择了关键帧。我们有两个关键帧选择标准。第一是与上一个关键帧的平均视差。如果在当前帧和最新关键帧之间跟踪的特征点的平均视差超出某个特定阈值，则将该帧视为新的关键帧。请注意，不仅平移，旋转也会产生视差。然而，特征点无法在纯旋转运动中三角化。为了避免这种情况，在计算视差时我们使用陀螺仪测量值的短时积分来补偿旋转。请注意，此旋转补偿仅用于关键帧选择，而不涉及VINS公式中的旋转计算。为此，即使陀螺仪含有较大的噪声或存在偏置，也只会导致次优的关键帧选择结果，不会直接影响估计质量。另一个标准是跟踪质量。如果跟踪的特征数量低于某一阈值，我们将此帧视为新的关键帧。这个标准是为了避免跟踪特征完全丢失。</p>
<h1 id="B-IMU预积分"><a href="#B-IMU预积分" class="headerlink" title="B.IMU预积分"></a>B.IMU预积分</h1><p>IMU预积分是在[22]中首次提出的，它将欧拉角的旋转误差参数化。在我们先前的工作中[7]，我们提出了一个流形上的IMU预积分旋转公式。该文利用连续时间的IMU误差状态动力学推导协方差传递函数，但忽略了IMU偏置。文[23]通过增加后验IMU偏置校正，进一步改进了预积分理论。本文通过引入IMU偏置校正，扩展了我们在前面工作[7]中提出的IMU预积分。<br>IMU的原始陀螺仪和加速度计测量结果$\hat w$ 和$\hat a$如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019201549992.png#pic_center"><br>IMU测量值是在本体坐标系中测量的，它是平衡重力和平台动力的合力，并受到加速度偏置$b_a$、陀螺仪偏置$b_w$和附加噪声的影响。假设加速度计和陀螺仪测量值中的附加噪声为高斯噪声，$n_a～N(0,sigma^2_a)$，$n_w～N(0,sigma^2_w)$​。加速度计偏置和陀螺仪偏置被建模为随机游走，其导数为高斯性的，$n_{ba}～N(0,σ^2_{ba})$，$n_{bw}～N(0,σ^2_{bw})$。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202057834.png#pic_center"></p>
<p>给定对应于体坐标系$b_k$和$b_{k+1}$的两个时刻，位置、速度和方向状态可以在时间间隔$[t_k,t_{k+1}]$间，在世界坐标系下中通过惯性测量值传递：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202237245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$∆t_k$是时间间隔$[t_k,t_{k+1}]$之间的持续时间。</p>
<p>可见，IMU状态传递需要坐标系$b_k$的旋转、位置和速度。当这些起始状态改变时，我们需要重新传递IMU测量值。特别是在基于优化的算法中，每次调整位姿时，都需要在它们之间重新传递IMU测量值。这种传递策略在计算上要求很高。为了避免重新传递，我们采用了预积分算法。<br>将参考坐标系从世界坐标系转变为局部坐标系$b_k$后，我们只能对线性的加速度$\hat a$和角速度$\hat w$相关的部分进行预积分，如下所示：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202449110.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019202554843.png#pic_center"></p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920251370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>可以看出预积分项(6)能通过将$b_k$视为参考帧的IMU测量值单独得到。$α^{b_k}_{k+1}$、$β^{b-k}b_{k+1}$、$γ^{b-k}_{k+1}$只与$b_k$和$b_{k+1}$中的IMU偏置有关，与其他状态无关。当偏置估计发生变化时，若偏置变化很小，我们将$α^{bk}_{k+1}、β^{bk}b_{k+1}、γ^{bk}_{k+1}$按其对偏置的一阶近似来调整，否则就进行重新传递。这种策略为基于优化的算法节省了大量的计算资源，因为我们不需要重复传递IMU测量值。</p>
<p>对于离散时间的实现，可以采用不同的数值积分方法，如欧拉积分、中点积分、RK4积分等。这里选择了欧拉积分来演示易于理解的过程(我们在代码中使用了中点积分)。</p>
<p>在开始时，$\alpha^{bk}_{k}$、$β^{bk}_{k}$是0，$\gamma^{bk}_{k}$是单位四元数。$α$，$β$，$γ$在(6)中的平均值是如下逐步传递的。注意，增加的噪声项$n_a$，$n_w$是未知的，在实现中被视为零。这得到了预积分的估计值，标记为$(\hat⋅)$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203125870.png#pic_center"><br>i是在$[t_k,t_{k+1}]$中IMU测量值对应的离散时刻，$δ_t$是IMU测量值i和i+1之间的时间间隔。</p>
<p>然后讨论协方差传递问题。由于四维旋转四元数$γ^{b_k}_t$被过参数化，我们将其误差项定义为围绕其平均值的扰动：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203259791.png#pic_center"><br>其中$δθ^{b_k}_t$是三维小扰动。</p>
<p>我们可以导出误差项的连续时间线性化方程(6)：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203414375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>$P^{bk}_{b_{k+1}}$可以通过初始协方差$P^{b_k}_{b_k}=0$的一阶离散时间协方差更新递归计算：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203627976.png#pic_center"><br>其中Q是噪声的对角线协方差矩阵$(σ^2_a,σ^2_w,σ^2_{b_a},σ^2_{b_w})$</p>
<p>同时，$δz_{b_{k+1}}^{b_k}$​的一阶雅可比矩阵$J_{b_{k+1}}$​​相对于δzbk​bk​​也可以用初始雅可比矩阵$J_{b_k}=I$ 递归计算。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203912837.png#pic_center"><br>利用这个递推公式，得到协方差矩阵$P^{b_k}_{b_{k+1}}$​​和雅可比矩阵$J^{b_k}_{b_{k+1}}$​​、$α^{b_k}_{b_{k+1}}$、$β^{b_k}_{b_{k+1}}$、$γ^{b_k}_{b_{k+1}}$关于偏置的一阶近似可以写为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019203947220.png#pic_center"><br>其中$J^α_{b_a}$是$J_b{k+1}$中的子块矩阵，其位置对应于$\frac{δα^{b_k}_{b_{k+1}}}{δb_{a_k}}$。<br>$J^α_{b_w}、J^β_{b_a}、J^β_{b_w}、J^γ_{b_w}$也使用同样的含义。当偏置估计发生轻微变化时，我们使用(12)近似校正预积分结果，而不重新传递。</p>
<p>现在我们可以写下IMU测量模型所其对应的协方差$P^{b_k}_{b_{k+1}}$：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204124533.png#pic_center"></p>
<h1 id="V-估计器初始化"><a href="#V-估计器初始化" class="headerlink" title="V.估计器初始化"></a>V.估计器初始化</h1><p>单目紧耦合VIO是一个高度非线性的系统。由于单目相机无法直接观测到尺度，因此，如果没有良好的初始值，很难直接将这两种测量结果融合在一起。可以假设一个静止的初始条件来启动单目VINS估计器。然而，这种假设是不合适的，因为在实际应用中经常会遇到运动下的初始化。当IMU测量结果被大偏置破坏时，情况就变得更加复杂了。事实上，初始化通常是单目VINS最脆弱的步骤。需要一个鲁棒的初始化过程以确保系统的适用性。</p>
<p>我们采用松耦合的传感器融合方法得到初始值。我们发现纯视觉SLAM，或从运动中恢复结构(SfM)，具有良好的初始化性质。在大多数情况下，纯视觉系统可以通过从相对运动方法（如八点法[32]或五点法[33]或估计单应性矩阵）中导出初始值来引导自己。通过对齐IMU预积分与纯视觉SfM结果，我们可以粗略地恢复尺度、重力、速度，甚至偏置。这足以引导非线性单目VINS估计器，如图4所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204212487.png#pic_center"><br>与在初始阶段同时估计陀螺仪和加速度计偏置的[17]相比，我们在初始阶段选择忽略加速度计偏置项。加速度计偏置与重力耦合，且由于重力向量相对于平台动力学的大量级，以及初始阶段相对较短，这些偏置项很难被观测到。我们以前的工作对加速度计偏置标定进行了详细的分析[34]。</p>
<h1 id="A-滑动窗口-Sliding-Window-纯视觉SfM"><a href="#A-滑动窗口-Sliding-Window-纯视觉SfM" class="headerlink" title="A. 滑动窗口(Sliding Window)纯视觉SfM"></a>A. 滑动窗口(Sliding Window)纯视觉SfM</h1><p>初始化过程从纯视觉SfM估计相机尺度位姿(up-to-scale)和特征位置图开始。</p>
<p>我们保持了一个帧的滑动窗口来限制计算复杂度。首先，我们检查了最新帧与之前所有帧之间的特征对应。如果我们能在滑动窗口中的最新帧和任何其他帧之间，找到稳定的特征跟踪(超过30个跟踪特征)和足够的视差(超过20个的旋转补偿像素)，我们使用五点法[33]恢复这两个帧之间的相对旋转和尺度平移。否则，我们将最新的帧保存在窗口中，并等待新的帧。如果五点算法成功的话，我们任意设置尺度，并对这两个帧中观察到的所有特征进行三角化。基于这些三角特征，采用PnP[35]来估计窗口中所有其他帧的姿态。最后，应用全局光束平差法(BA)[36]最小化所有特征观测的重投影误差。由于我们还没有任何世界坐标系的知识，我们将第一个相机坐标系$(·)^{c_0}$设置为SfM的参考坐标系。所有帧的位姿$(\bar p^{c0}_{c_k}，q^{c0}_{c_k})$和特征位置表示相对于$(·)^{c_0}$。假设摄像机和IMU之间有一个粗略测量的外部参数$(p^b_c,q^b_c)$，我们可以将姿态从相机坐标系转换到物体(IMU)坐标系。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/201910192045598.png#pic_center"><br>其中s是匹配视觉结构与距离尺度的尺度参数，解出尺度参数是实现成功初始化的关键。</p>
<h2 id="B-视觉惯性校准"><a href="#B-视觉惯性校准" class="headerlink" title="B. 视觉惯性校准"></a>B. 视觉惯性校准</h2><p>1）陀螺仪偏置标定：考虑窗口中连续两帧bk和bk+1，我们从视觉sfM中得到旋转$q^{c0}_{b_k}$和$q^{c0}_{b_{k+1}}$​​，从IMU预积分得到的相对约束$γ^{b_k}_{b_{k+1}}$​。我们对陀螺仪偏置求IMU预积分项的线性化，并最小化以下代价函数：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204702396.png#pic_center"><br>其中B代表窗口的所有帧。利用第四部分导出的偏置雅可比，给出了$γ^{b_k}_{b_{k+1}}$​对陀螺仪偏置的一阶近似。这样，我们得到了陀螺仪偏置bw的初始校准。然后我们用新的陀螺仪偏置重新传递所有的IMU预积分项$\hat α^{b_k}_{b_{k+1}}、\hat β^{b_k}_{b_{k+1}}、\hat γ^{b_k}_{b_{k+1}}$ 。</p>
<p>2）速度、重力向量和尺度初始化：在陀螺仪偏置初始化后，我们继续初始化导航的其他基本状态，即速度、重力向量和尺度：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204809433.png#pic_center"><br>其中，$v^{b_k}_{b_k}$​​是第k帧图像本体坐标系的速度，$g^{c_0}$是$c_0$坐标系中的重力向量，s是单目SfM到公制单位的尺度。</p>
<p>考虑窗口中两个连续帧$b_k$和$b_{k+1}$，那么(5)可以写成：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205047939.png#pic_center"><br>我们可以将(14)和(17)合并成以下线性测量模型：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019204900731.png#pic_center"><br>可以看出，$R^{c_0}_{b_k}，R^{c_0}_{b_{k+1}}，\hat p^{c_0}_{c_k}，\hat p^{c_0}_{c_{k+1}}$是从带尺度的单目视觉中得到的，$∆t_k$是两个连续帧之间的时间间隔。通过求解线性最小二乘问题：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205002105.png#pic_center"><br>我们可以得到窗口中每一帧的本体坐标系速度，视觉参照系$(·)^{c_0}$的重力向量，以及尺度参数。</p>
<p>3）重力细化：通过约束量值，可以对原线性初始化步骤得到的重力向量进行细化。在大多数情况下，重力向量的大小是已知的。这导致重力向量只剩2个自由度。因此，我们在其切线空间上用两个变量重新参数化重力。参数化将重力向量表示为<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205157776.png#pic_center"><br>其中g是已知的重力大小，$\bar {\hat g}$​​是表示重力方向的单位向量，b1和b2是跨越切平面的两个正交基，如图5所示，w1和w2分别是在b1和b2上的对应位移。通过算法1的叉乘运算，可以找到一组b1、b2。然后用</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101920522547.png#pic_center"><br>代替(17)中的g，并与其它状态变量一起求解w1和w2。此过程迭代到$\bar {\hat g}$收敛为止。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205247493.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205318309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>4）完成初始化：经过对重力向量的细化，通过将重力旋转到z轴上，得到世界坐标系与摄像机坐标系c0之间的旋转$q^w_{c_0}$​。然后我们将所有变量从参考坐标系$(·)^{c_0}$ 旋转到世界坐标系$(·)^w$。本体坐标系的速度也将被旋转到世界坐标系。视觉SfM的变换矩阵将被缩放到度量单位。此时，初始化过程已经完成，所有这些度量值都将被输入到一个紧耦合的单目VIO中。</p>
<h1 id="VI-紧耦合单目VIO"><a href="#VI-紧耦合单目VIO" class="headerlink" title="VI. 紧耦合单目VIO"></a>VI. 紧耦合单目VIO</h1><p>在估计器初始化后，我们采用基于滑动窗口的紧耦合单目VIO进行高精度和鲁棒的状态估计。图3显示了滑动窗口的图示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205519675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="A-公式"><a href="#A-公式" class="headerlink" title="A. 公式"></a>A. 公式</h2><p>滑动窗口中的完整状态向量定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205554259.png#pic_center"><br>其中$x_k$是捕获第k图像时的IMU状态。它包含了IMU在世界坐标系中的位置、速度和方向，以及在IMU本体坐标系中的加速度计偏置和陀螺仪偏置。n是关键帧的总数，m是滑动窗口中的特征总数，$λ_l$是第一次观测到第l个特征的逆深度。</p>
<p>我们使用视觉惯性BA。我们最小化所有测量残差的先验和Mahalanobis范数之和，得到最大后验估计：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205631782.png#pic_center"><br>$r_B​(z^{b_k}_{b_{k+1}},X)$和$r_C(\hat z_l^{c_j},X)$分别是IMU和视觉测量的残差。残差的详细定义将在第六节的B和C中提出。B是所有IMU测量的集合，C是在当前滑动窗口中至少观察到两次的一组特征。${r_p,H_p}$是来自边缘化的先验信息。Ceres Solver[38]被用来解决这个非线性问题。</p>
<h2 id="B-IMU测量残差"><a href="#B-IMU测量残差" class="headerlink" title="B. IMU测量残差"></a>B. IMU测量残差</h2><p>考虑滑动窗口中连续两个帧$b_k$和$b_{k+1}$内的IMU测量，根据(13)中定义的IMU测量模型，预积分IMU测量的残差可以定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205738287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>其中，$[·]_{xyz}$是提取四元数q的向量部分，以进行误差状态表示。$δθ^{bk}_{b_{k+1}}$​​是四元数的三维误差状态表示。$[\hat α^{b_k}_{b{k+1}}、\hat β^{b_k}_{b{k+1}}      \hat γ^{b_k}_{b{k+1}}]^T$是在两个连续图像帧的间隔时间内使用仅包含噪声的加速度计和陀螺仪测量值预积分的IMU测量项。加速度计和陀螺仪偏置也包括在在线校正的剩余项中。</p>
<h2 id="C-视觉测量残差"><a href="#C-视觉测量残差" class="headerlink" title="C. 视觉测量残差"></a>C. 视觉测量残差</h2><p>与在广义图像平面上定义重投影误差的传统针孔相机模型相比，我们在单位球面上定义摄像机的测量残差。几乎所有类型相机的光学，包括广角、鱼眼或全向相机，都可以模拟为连接单位球体表面的单位射线。假设第l个特征在第i幅图像中被第一次观察到，第j幅图像中的特征观测的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019205925902.png#pic_center"><br>其中$[u^{c_i}_l,v^{c_i}_l]$是第一次观测到出现在第i图像中的第l个特征。$[\hat u^{c_i}_l,\hat v^{c_i}_l]$是在第j图像中对相同特征的观察。$π^{−1}_c$​是利用摄像机内参将像素位置转换成单位向量的反投影函数。由于视觉残差的自由度是2，所以我们将残差向量投影到切平面上。如图6所示，b1、b2是在切平面$\hat {\bar P^{c_j}_l}$上的两个任意选择的正交基。我们可以很容易地找到一组$b_1、b_2$，如算法1所示。在(22)中使用的$P^{c_j}_l$​​是正切空间中固定长度的标准协方差。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210021988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="D-边缘化"><a href="#D-边缘化" class="headerlink" title="D. 边缘化"></a>D. 边缘化</h2><p>为了限制基于优化的VIO的计算复杂度，本文引入了边缘化。我们有选择地从滑动窗口中将IMU状态xK和特征λ1边缘化，同时将对应于边缘状态的测量值转换为先验。</p>
<p>如图7所示，当倒数第二帧是关键帧时，它将停留在窗口中，而最旧的帧与其相应的测量值被边缘化。但如果倒数第二帧是非关键帧，我们丢掉视觉测量值，保留连接到这个非关键帧的IMU测量值。为了保持系统的稀疏性，我们不会边缘化非关键帧的所有测量值。我们的边缘化方案旨在保持窗口中空间分离的关键帧。这确保了特征三角化有足够的视差，并且最大化了在大激励下获得加速度计测量值的概率。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210401727.png#pic_center"></p>
<h2 id="E-摄像机速率状态估计的纯运动视觉惯性BA"><a href="#E-摄像机速率状态估计的纯运动视觉惯性BA" class="headerlink" title="E. 摄像机速率状态估计的纯运动视觉惯性BA"></a>E. 摄像机速率状态估计的纯运动视觉惯性BA</h2><p>对于计算能力较低的设备如手机，由于对非线性优化的计算要求很高，紧耦合单目VIO无法实现摄像机速率输出。为此，我们采用了一种轻量级的纯运动视觉惯性BA，以提升状态估计速率到相机速率(30Hz)。</p>
<p>纯运动单目视觉惯性BA的代价函数与(22)中单目VIO的代价函数相同。然而我们只对固定数量的最新IMU状态的姿态和速度进行了优化，而不是对滑动窗口中的所有状态进行优化。我们将特征深度、外部参数、偏置和旧的IMU状态这些不希望优化的状态作为常量来处理。我们使用所有的视觉和惯性测量来进行纯运动的BA。这导致了比单帧PnP方法更平滑的状态估计。图8显示了提出方法的插图。与在最先进的嵌入式计算机上可能导致超过50ms的完全紧耦合单目VIO不同，这种纯运动的视觉惯性BA只需大约5ms来计算。这使得低延迟的相机频率进行位姿估计对无人机和AR应用特别有利。<br>F. IMU前向传递以达到IMU速率状态估计</p>
<p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="F-IMU前向传递以达到IMU速率状态估计"><a href="#F-IMU前向传递以达到IMU速率状态估计" class="headerlink" title="F. IMU前向传递以达到IMU速率状态估计"></a>F. IMU前向传递以达到IMU速率状态估计</h2><p>IMU测量的速度远高于视觉测量。虽然我们的VIO频率受到图像捕获频率的限制，但是我们仍然可以通过最近的IMU测量来直接传递最新的VIO估计，以达到IMU速率的性能。高频状态估计可以作为回环检测的状态反馈。利用这种IMU速率状态估计进行的自主飞行实验在第九节的D中给出。</p>
<h2 id="G-故障检测与恢复"><a href="#G-故障检测与恢复" class="headerlink" title="G. 故障检测与恢复"></a>G. 故障检测与恢复</h2><p>虽然我们紧耦合的单目视觉对各种具有挑战性的环境和运动是鲁棒的。由于强烈的光照变化或剧烈的运动，故障仍然是不可避免的。主动故障检测和恢复策略可以提高系统的实用性。故障检测是一个独立的模块，它检测估计器的异常输出。我们目前使用以下标准进行故障检测：<br>1、在最新帧中跟踪的特征数小于某一阈值；<br>2、最近两个估计器输出之间的位置或旋转有较大的不连续性；<br>3、偏置或外部参数估计有较大的变化；</p>
<p>一旦检测到故障，系统将切换回初始化阶段。一旦单目VIO被成功初始化，将新建一个独立的位姿图。</p>
<h1 id="VII-重定位"><a href="#VII-重定位" class="headerlink" title="VII. 重定位"></a>VII. 重定位</h1><p>我们的滑动窗口和边缘化方案限制了计算的复杂性，但也给系统带来了累积漂移。更确切地说，漂移发生在全局三维位置(x,y,z)和围绕重力方向的旋转(yaw)。为了消除漂移，提出了一种与单目VIO无缝集成的紧耦合重定位模块。重定位过程从一个循环检测模块开始，该模块识别已经访问过的地方。然后建立回环检测候选帧和当前帧之间的特征级连接。这些特征的对应关系紧密地集成到单目VIO模块中，从而以最小计算代价得到无漂移状态估计。多个特征的多个观测直接用于重定位，从而提高了定位的精度和状态估计的平滑性。重定位过程如图9(a)所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210456719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-特征恢复"><a href="#B-特征恢复" class="headerlink" title="B. 特征恢复"></a>B. 特征恢复</h2><p>当检测到回路时，通过检索特征对应关系建立局部滑动窗口与回环候选帧之间的连接。通过BRIEF描述子匹配找到对应关系。直接描述子匹配可能会造成大量异常值。为此，我们使用两步进行几何异常值剔除，如图10所示。<br>1、2D-2D：RANSAC[31]的基本矩阵检验。我们利用当前图像中检索到的特征的二维观测和回环候选图像进行基本矩阵检验。<br>2、3D-2D：RANSAC的PNP检验。基于特征在局部滑动窗口中已知的三维位置，以及回环候选图像中的二维观测，进行PNP检验。</p>
<p>当内点超过一定阈值时，我们将该候选帧视为正确的循环检测并执行重定位。</p>
<h2 id="C-紧耦合重定位"><a href="#C-紧耦合重定位" class="headerlink" title="C. 紧耦合重定位"></a>C. 紧耦合重定位</h2><p>重定位过程有效地使单目VIO(VI)维持的当前滑动窗口与过去的位姿图对齐。在重定位过程中，我们将所有回环帧的位姿作为常量。利用所有IMU测量值、局部视觉测量和从回环中提取特征对应值，共同优化滑动窗口。我们可以轻松地为回环帧v观察到的检索特征编写视觉测量模型，使其与VIO中的视觉测量相同，如(25)所示。唯一的区别是，从位姿图(VIII)或直接从上一个里程计的输出（如果这是第一次重定位）获得的回环帧的姿态$(\hat q^w_v,\hat p^w_v)$<br>(q^​vw​,p^​vw​)被视为常数。为此，我们可以在(22)中稍微修改非线性代价函数，增加回环项：</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210641949.png#pic_center"><br>其中L是回环帧中检索到的特征的观测集。$(l,v)$是指在回环帧v中观察到的第l个特征。虽然代价函数与(22)略有不同，但待解状态的维数保持不变，因为回环帧的构成被视为常数。当用当前滑动窗口建立多个回环时，我们同时使用来自所有帧的所有回环特征对应进行优化。这就为重定位提供了多视角的约束，从而提高了定位的精度和平滑性。请注意，过去的姿态和回环帧的全局优化发生在重定位之后，将在第八节中讨论。</p>
<h1 id="VIII-全局位姿图优化"><a href="#VIII-全局位姿图优化" class="headerlink" title="VIII. 全局位姿图优化"></a>VIII. 全局位姿图优化</h1><p>重新定位后，局部滑动窗口移动并与过去的位姿对齐。利用重定位结果，开发了额外的位姿图优化步骤，以确保过去位姿集注册到全局一致的配置中。</p>
<p>由于视觉惯性的建立使翻滚角和俯仰角完全可观测，累积漂移只发生在四个自由度(x，y，z和yaw)。为此，我们忽视对无漂移翻滚和俯仰状态的估计，只进行了四自由度位姿图的优化。</p>
<h2 id="A-在位姿图中添加关键帧"><a href="#A-在位姿图中添加关键帧" class="headerlink" title="A. 在位姿图中添加关键帧"></a>A. 在位姿图中添加关键帧</h2><p>当关键帧从滑动窗口被边缘化时，它将被添加到位姿图中。这个关键帧在位姿图中作为顶点，它通过两种类型的边与其他顶点连接：</p>
<p>1）顺序边(Sequential Edge)：关键帧将建立与之前关键帧的若干顺序边。顺序边表示局部滑动窗口中两个关键帧之间的相对转换，其值直接从VIO中获取。考虑到新边缘化的关键帧i及其先前的一个关键帧j，顺序边只包含相对位置和偏航角。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210857102.png#pic_center">)<br>2）回环边(Loop Closure Edge)：如果新边缘化的关键帧有一个回环连接，它将与回环帧通过一个回环边在位姿图图中连接。同样，闭环边缘只包含与(27)相同定义的四自由度相对位姿变换。回环边的值由重定位结果得出。</p>
<h2 id="B-4自由度位姿图优化"><a href="#B-4自由度位姿图优化" class="headerlink" title="B. 4自由度位姿图优化"></a>B. 4自由度位姿图优化</h2><p>我们将帧i和j之间边的残差定义为：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019210815393.png#pic_center"><br>其中，$\hat \phi _i，\hat    θ_i$是直接从单目VIO中得到的翻滚角和俯仰角的估计。</p>
<p>通过最小化以下代价函数，对顺序边和回环边的整个图进行优化：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921101530.png#pic_center"></p>
<p>其中S是所有顺序边的集合，L是回环边的集合。尽管紧耦合的重定位已经有助于消除错误的回环，但我们添加了另一个Huber范数 $ρ(·)$，以进一步减少任何可能的错误回环的影响。相反，我们不对顺序边使用任何鲁棒范数，因为这些边是从VIO中提取出来的，VIO已经包含了足够多的外点排除机制。</p>
<p>位姿图优化和重定位(VII-C)异步运行在两个独立的线程中。以便在需要重定位时，能立即使用最优化的位姿图。同样，即使当前的位姿图优化尚未完成，仍然可以使用现有的位姿图配置进行重新定位。这一过程如图9(b)所示。</p>
<h2 id="C-位姿图管理"><a href="#C-位姿图管理" class="headerlink" title="C. 位姿图管理"></a>C. 位姿图管理</h2><p>随着行程距离的增加，位姿图的大小可能会无限增长，从而限制了长时间系统的实时性。为此，我们实行了一个下采样过程，将位姿图数据库保持在有限的大小。所有具有回环约束的关键帧都将被保留，而其他与相邻帧过近或方向非常相似的关键帧可能会被删除。关键帧被移除的概率和其相邻帧的空间密度成正比。</p>
<h1 id="IX-实验结果"><a href="#IX-实验结果" class="headerlink" title="IX. 实验结果"></a>IX. 实验结果</h1><p>我们进行了三个实验和两个应用，以评估所提出的VINS-Mono系统。在第一个实验中，我们将提出的算法与另一种最先进算法在公共数据集上进行比较。我们通过数值分析以验证了系统的精度。然后在室内环境中测试我们的系统，以评估在重复场景中的性能。通过大量的实验验证了系统的长期实用性。此外，我们还将所提出的系统应用于两个应用。对于空中机器人的应用，我们使用VINS-Mono作为位置反馈来控制无人机跟踪预定的轨迹。然后我们将我们的方法移植到iOS移动设备上，并与Google Tango进行比较。</p>
<h2 id="A-数据集比较"><a href="#A-数据集比较" class="headerlink" title="A. 数据集比较"></a>A. 数据集比较</h2><p>我们使用EuRoC MAV视觉-惯性数据集[41]评估我们提出的VINS-Mono。这个数据集是在一架微型飞行器上收集的，它包含立体图像(Aptina MT9V034全局快门、WVGA单色、20 FPS)、同步IMU测量(ADIS 16448、200 Hz)和地面真实状态(Vicon和Leica MS 50)。我们只使用左边相机的图像。在这数据集中会观察到较大的IMU偏置和光照变化。</p>
<p>在这些实验中，我们将VINS-Mono和OKVIS进行了比较，这是一种最先进的单目和立体相机VIO。OKVIS是另一种基于优化的滑动窗口算法。我们的算法与OKVIS在许多细节上是不同的，如技术部分所示。我们的系统具有良好的初始化和回环功能。我们使用MH_03_median和MH_05_difficult两组序列来证明该方法的性能。为了简化表示，我们使用VINS来表示我们只使用单目VIO的方法，而VINS_loop表示含重定位和位姿图优化的完全版本。我们分别用OKVIS_Mono和OKVIS_stereo表示OKVIS使用单目和立体图像的结果。为了进行公平的比较，我们丢弃前100个输出，并使用接下来的150个输出对齐地面真值，并比较其余的估计器输出。</p>
<p>MH_03_median序列轨迹如图11所示。我们只比较平移误差，因为旋转运动在这个序列中是可以忽略的。图12显示了x、y、z误差与时间的关系，以及平移误差与距离的关系。在误差图中，具有回环的VINS-Mono具有最小的平移误差。我们在MH_05_difficult上观察到类似的结果。该方法具有最小的平移误差。平移和旋转误差如图14所示。由于该序列运动平稳，偏角变化不大，只发生位置漂移。显然，回环闭合有效地约束了累积漂移。OKVIS在翻滚角和俯仰角估计方面表现更好。一个可能的原因是VINS-Mono采用了预积分技术，即IMU传递的一阶近似，以节省计算资源。</p>
<p>VINS-Mono在所有Euroc数据集中都表现良好，即使在最具挑战性的序列V1_03_difficult中，它具有剧烈性的运动、纹理较少的区域和显著的光照变化。由于采用了专用的初始化过程，该方法可以在V1_03_difficult快速初始化。</p>
<p>对于纯VIO，VINS-Mono和OKVIS具有相似的精度，很难区分哪个比较好。然而，VINS-Mono在系统级别上优于OKVIS。它是一个完整的系统，具有鲁棒的初始化和回环闭合功能来辅助单目视觉。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211301627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211334529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="B-室内实验"><a href="#B-室内实验" class="headerlink" title="B. 室内实验"></a>B. 室内实验</h2><p>在室内实验中，我们选择实验室环境作为实验区域。我们使用的传感器套件如图15所示。它搭载在DJI A3控制器上，包含一个单目照相机（20Hz）和一个IMU（100 Hz）。我们手握传感器套件，在实验室以正常的速度行走。如图16所示，我们遇到行人，光线较弱的位置，纹理较少的区域，玻璃和反射。多媒体附件中可以找到视频。 </p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211501205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>我们将我们的结果与OKVIS进行了比较，如图17所示。图17(a)是OKVIS的VIO输出。图17(b)是所提出的无回环方法的VIO结果。图17©是所提出的具有重定位和回环闭合的方法的结果。当我们在室内转圈时，会出现明显的漂移。OKVIS和只有VIO版本的VINS-Mono在x、y、z和偏航角上积累了大量漂移。我们的重定位和回环闭合模块有效地消除了所有这些漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211551914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="C-大范围环境"><a href="#C-大范围环境" class="headerlink" title="C. 大范围环境"></a>C. 大范围环境</h2><p>1）走出实验室：我们在室内和室外混合环境中测试VINS-Mono。传感器套件与图15所示的相同。我们从实验室的一个座位上开始，在室内空间里走来走去。然后我们下楼，在大楼外的操场上走来走去。接下来，我们回到楼里并上楼。最后，我们回到了实验室的同一个座位。整个轨迹超过700米，持续约10分钟。在多媒体附件中可以找到实验的视频。</p>
<p>轨迹如图19所示。图19(a)是OKVIS的轨迹。当我们上楼时，OKVIS显示出不稳定的特征跟踪，导致估计错误。我们看不到红色街区楼梯的形状。VINS-Mono的纯VIO结果如图19(b)所示。有闭环的轨迹如图19©所示。该方法的楼梯形状清晰。为验证其准确性，将闭环轨迹与谷歌地图对齐，如图18所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921164349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>OKVIS的 x、y和z轴的最终漂移为[13.80,-5.26,7.23]米。VINS-Mono无环闭路的最终漂移为[-5.47,2.76,-0.29]m，占整个轨迹长度的0.88%，小于OKVIS的2.36%。经回环修正，最终漂移上界为[-0.032,0.09,-0.07]m，与整个轨迹长度相比这是微不足道的。虽然我们没有地面真值，但我们仍然可以直观地检查优化后的轨迹是否平滑并能精确地与卫星地图对齐。</p>
<p>2）环游校园：这张环绕整个科大校园的非常大规模的数据集是用一个手持的VI-Sensor 4记录下来的。该数据集覆盖的地面长度约为710米，宽度为240米，高度变化为60米。总路径长度为5.62km。数据包含25Hz图像和200Hz IMU，持续1小时34分钟。对VINS-Mono的稳定性和耐久性进行测试是一个非常有意义的实验。</p>
<p>在这个大规模的测试中，我们将关键帧数据库的大小设置为2000，以提供足够的回环信息并达到实时性。我们运行此数据集时，采用英特尔i7-4790 CPU运行在3.60GHz。时间统计数据显示在表I中。如图20，估计的轨迹与谷歌地图一致。与谷歌地图相比，我们的结果在这个非常长时间的测试中几乎没有漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921174092.png#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211751315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>D. 应用1：航空机器人的反馈控制</p>
<p>如图21(a)所示，我们将VINS-Mono应用于航空机器人的自主反馈控制。我们使用了一个具有752×480分辨率的前向全局曝光相机(MatrixVisionMvBlueFOXMLC200w)，并配备了190度鱼眼镜头。DJIA3飞行控制器用于IMU测量和姿态稳定控制。机载计算资源是Intel i7-5500 U CPU运行在3.00GHz。传统的针孔摄像机模型不适用于大视场摄像机。我们使用MEI[42]模型，由[43]介绍的工具包进行校准。</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211839510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>在本实验中，我们测试使用VINS_Mono的状态估计来进行自主轨迹跟踪的性能。实验中回环检测被禁止。四旋翼被命令跟踪一个八字形图案，每个圆圈半径为1.0米，如图21(b)所示。在轨迹周围设置了四个障碍物，以验证VINS-Mono无闭环的准确性。在实验过程中，四旋翼连续四次跟踪这一轨迹。100 Hz机载状态估计(VI-F)支持对四旋翼的实时反馈控制。</p>
<p>地面真值是用OptiTrack 5获得的。总轨迹长度为61.97 m。最终漂移为[0.08，0.09，0.13]m，为0.29%的位置漂移。平移和旋转的细节以及它们相应的误差如图23所示。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019211919318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="E-应用2：移动设备"><a href="#E-应用2：移动设备" class="headerlink" title="E. 应用2：移动设备"></a>E. 应用2：移动设备</h2><p>我们将VINS-Mono移植到移动设备上，并提供一个简单的AR应用程序来展示其准确性和鲁棒性。我们将我们的移动实现命名为VINS-Mobile6，并将其与Google Tango Device 7进行了比较，后者是移动平台在商业上最好的增强现实解决方案之一。</p>
<p>VINS-Mono运行在iPhone7 Plus上。我们使用iPhone采集的30 Hz、分辨率为640×480的图像，以及内置InvenSense MP67B 6轴陀螺仪和加速度计获得的100 Hz 的IMU数据。如图24所示，我们将iPhone与一个启用Tango功能的联想Phab 2 Pro一起安装。Tango设备使用全局快门、鱼眼相机和同步IMU进行状态估计。首先，我们在从估计的视觉特征中提取出来的平面上插入一个虚拟立方体，如图25(a)所示。然后，我们拿着这两个装置，以正常的速度在房间内外行走。当检测到回环时，我们使用四自由度位姿图优化(VIII-B)，以消除x，y，z和yaw漂移。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212019875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191019212037844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019101921210026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkwNTE0MQ==,size_16,color_FFFFFF,t_70#pic_center"><br>有趣的是，当我们打开一扇门时，Tango的偏航角估计会跳转到一个很大的角度，如图25(b)所示。其原因可能是由于不稳定的特征跟踪或主动故障检测和恢复而导致的估计器崩溃。然而，VINS-Mono在这个具有挑战性的情况中仍然表现很好。行走了大约264米后我们回到起点。最后的结果可以在图25( c)中看到，Tango的轨迹在最后一圈会漂移，而我们的VINS会回到起点。四自由度位姿图的优化消除了总轨迹的漂移。这与开始相比，立方体被标记到图像上的同一位置也印证了这一点。</p>
<p>诚然，尤其是对局部状态的估计，Tango比我们的实现更准确。但是实验结果表明，我们的方法可以在通用移动设备上运行，并且具有媲美特殊工程设备的潜力。实验还证明了该方法的鲁棒性。视频可以在多媒体附件中找到。</p>
<h1 id="X-结论和未来工作"><a href="#X-结论和未来工作" class="headerlink" title="X. 结论和未来工作"></a>X. 结论和未来工作</h1><p>本文提出了一种鲁棒、通用的单目视觉惯性估计器。我们的方法在IMU预积分，估计器初始化和故障恢复，在线外部校准，紧耦合视觉惯性里程计，重定位和有效的全局优化上，具有最先进的和新颖的解决方案。我们通过与最先进的开源实现和高度优化的行业解决方案进行比较，显示出更好的性能。我们开源了PC和iOS的实现，以造福社会。</p>
<p>虽然基于特征的VINS估计器已经达到了实际使用的成熟程度，我们仍然看到了未来研究的许多方向。单目VINS可能会根据运动和环境而达到较难观测甚至退化的状态。我们最感兴趣的是在线方法来评估单目VINS的可观测性，以及在线生成运动计划来恢复可观测性。另一个研究方向是在大量消费设备上大规模部署单目VINS，例如移动电话。这一应用要求在线校准几乎所有传感器的内参和外参，以及在线鉴定校准质量。最后，我们感兴趣的是制作由单目VINS给出的稠密地图。我们在[44]中首次给出了用于无人机导航的单目视觉-惯性稠密地图的结果。然而，仍需进行广泛的研究以进一步提高系统的精度和鲁棒性。</p>
]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
        <tag>VSLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>8.二叉树的下一节点</title>
    <url>/2019/10/19/8.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目：<br>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。<br>树中的结点不仅包含左右子节点的指针，同时包含指向父结点的指针。<br>思路：</p><ul>
<li>如果一个节点有右子树，那么它的下一个节点就是它的右子树的最左子节点</li>
<li>没有右子树，分两种情况<blockquote>
<p>1.它是它父节点的左子节点，那么它的下一个节点就是它的父节点<br>2.它是它父节点的右子节点，可以沿着指向父节点的指针一直向上遍历，直到找到==一个是它的父节点的左子节点的节点==，如果这个节点存在，那么这个节点的父节点就是要找的下一个节点<br><strong>C++</strong></p>
</blockquote>
</li>
</ul><a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode *father;</span><br><span class="line"> *     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), father(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        TreeNode* p_next=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p_right=p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(p_right-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">               p_right=p_right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p_next=p_right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;father)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* p_current=p;</span><br><span class="line">            TreeNode* p_father=p-&gt;father;</span><br><span class="line">            <span class="keyword">while</span>(p_father &amp;&amp; p_current==p_father-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                p_current=p_father;</span><br><span class="line">                p_father=p_father-&gt;father;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p_next=p_father;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p_next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.father = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> p==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        p_next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span>(p.right):</span><br><span class="line">            p_right=p.right</span><br><span class="line">            <span class="keyword">while</span> p_right.left:</span><br><span class="line">                p_right=p_right.left</span><br><span class="line">            p_next=p_right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span>(p.father):</span><br><span class="line">            p_current=p</span><br><span class="line">            p_father=p.father</span><br><span class="line">            <span class="keyword">while</span>(p_father <span class="keyword">and</span> p_current==p_father.right):</span><br><span class="line">                p_current=p_father</span><br><span class="line">                p_father=p_father.father</span><br><span class="line">                </span><br><span class="line">            p_next=p_father</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> p_next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>7.重建二叉树</title>
    <url>/2019/10/19/7.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>在二叉树的前序遍历和中序遍历中确定根节点的值，分别找到前序遍历和中序遍历左右子树对应的子序列，再以同样的方法，构建左右子树，用递归方法完成。<br><strong>C++</strong></p><a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty()||vin.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//前序遍历的第一个数值就是根节点的值</span></span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//在中序遍历序列中找到根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> root_index,i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==pre[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                root_index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_left,pre_right,vin_left,vin_right;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;root_index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_left.push_back(pre[i+<span class="number">1</span>]);</span><br><span class="line">            vin_left.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=root_index+<span class="number">1</span>;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_right.push_back(pre[i]);</span><br><span class="line">            vin_right.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/* 递归调用，层层调用，直到调用到叶子节点，返回NULL*/</span></span><br><span class="line">        <span class="comment">//构建左子树</span></span><br><span class="line">        root-&gt;left=reConstructBinaryTree(pre_left,vin_left);</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root-&gt;right=reConstructBinaryTree(pre_right,vin_right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span>(len(pre)==<span class="number">0</span> <span class="keyword">or</span> len(tin)==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root=TreeNode(pre[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#         for i in range(len(tin)):</span></span><br><span class="line"><span class="comment">#             if tin[i]==pre[0]:</span></span><br><span class="line"><span class="comment">#                 root_index=i </span></span><br><span class="line"><span class="comment">#                 break </span></span><br><span class="line">                </span><br><span class="line">        root_index=tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root.left=self.reConstructBinaryTree(pre[<span class="number">1</span>:<span class="number">1</span>+root_index],tin[:root_index])</span><br><span class="line">        root.right=self.reConstructBinaryTree(pre[root_index+<span class="number">1</span>:],tin[root_index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>9.用两个栈实现队列</title>
    <url>/2019/10/19/6.%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>仅仅需要打印数值,而不是反转链表,这个还是有区别.如果单纯的反转打印链表的值的话,我们可以使用stack操作.<br><strong>C++</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt;nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">        ListNode* node=head;</span><br><span class="line">        <span class="keyword">while</span>(node !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(node);</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node=nodes.top();<span class="comment">//返回栈顶元素, 但不删除该元素</span></span><br><span class="line">            ArrayList.push_back(node-&gt;val);</span><br><span class="line">            nodes.pop();<span class="comment">//弹出栈顶元素, 但不返回其值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>Python</strong></p><a id="more"></a>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ArrayList=[]</span><br><span class="line">        head=listNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ArrayList.insert(<span class="number">0</span>,head.val)</span><br><span class="line">            head=head.next</span><br><span class="line">        <span class="keyword">return</span> ArrayList</span><br><span class="line">        </span><br><span class="line"><span class="comment">#        while head:</span></span><br><span class="line"><span class="comment">#            ArrayList.append(head.val)</span></span><br><span class="line"><span class="comment">#            head=head.next</span></span><br><span class="line"><span class="comment">#        return ArrayList[::-1]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>5.替换空格</title>
    <url>/2019/10/19/5.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><ul>
<li>从前往后替换，时间复杂度$O(n^2)$</li>
<li>从后往前替换，时间复杂度$O(n)$</li>
</ul><p><strong>C++</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 指向字符数组的字符指针str，字符数组长度length</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> originalLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlank=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，统计空格个数、替换前字符个数、替换后字符个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            originalLength++;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">                numberOfBlank++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 替换空格</span></span><br><span class="line">        <span class="keyword">int</span> newLength = originalLength +<span class="number">2</span>* numberOfBlank;</span><br><span class="line">        <span class="keyword">if</span>(newLength+<span class="number">1</span>&gt;length)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *p1 = str+originalLength;	<span class="comment">// 字符指针指向原始字符串的末尾</span></span><br><span class="line">        <span class="keyword">char</span> *p2 = str+newLength;		<span class="comment">// 字符指针指向替换后字符串的末尾</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p1 == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *p2-- = <span class="string">'0'</span>;</span><br><span class="line">                *p2-- = <span class="string">'2'</span>;</span><br><span class="line">                *p2-- = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                *p2-- = *p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*original_length为字符串str的实际长度*/</span></span><br><span class="line">        <span class="keyword">int</span> original_length = <span class="number">0</span>;			<span class="comment">//原始长度</span></span><br><span class="line">        <span class="keyword">int</span> number_blank = <span class="number">0</span>;				<span class="comment">//空格数</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;				<span class="comment">//遍历字符串</span></span><br><span class="line">            original_length++;				<span class="comment">//长度+1</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                number_blank++;				<span class="comment">//遇到空格+1</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*new_length为把空格替换成'%20'之后的长度*/</span></span><br><span class="line">        <span class="keyword">int</span> new_length = original_length + <span class="number">2</span> * number_blank;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p1 = original_length;	<span class="comment">//原始字符串末尾索引值</span></span><br><span class="line">        <span class="keyword">int</span> p2 = new_length;		<span class="comment">//计算长度后的字符串末尾索引值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*index_original指针开始向前移动，如果遇到空格，替换成'%20'，否则进行复制操作*/</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt; p1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[p1] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[p2--] = <span class="string">'0'</span>;</span><br><span class="line">                str[p2--] = <span class="string">'2'</span>;</span><br><span class="line">                str[p2--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[p2--] = str[p1];</span><br><span class="line">            &#125;</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#string（区别于list）是一种不可变的数据类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        origianl_length=len(s)</span><br><span class="line">        number_blank=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">' '</span>:</span><br><span class="line">                number_blank+=<span class="number">1</span></span><br><span class="line">        p1=origianl_length<span class="number">-1</span></span><br><span class="line">        p2=origianl_length+<span class="number">2</span>*number_blank<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        new_s=[<span class="string">' '</span>]*(p2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[p1]==<span class="string">' '</span>:</span><br><span class="line">                new_s[p2]=<span class="string">'0'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">                new_s[p2]=<span class="string">'2'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">                new_s[p2]=<span class="string">'%'</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_s[p2]=s[p1]</span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            p1-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>4.二维数组中的查找</title>
    <url>/2019/10/19/4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目描述<br>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>Python</strong><br>遍历二维数组<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> target==array[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><a id="more"></a>
<p>规律：首先选取数组右上角的数字</p>
<ul>
<li>如果该数字等于要查找的数字，则查找结束</li>
<li>该数字大于要查找的数字，则剔除这个数字所在的列</li>
<li>该数字小于要查找的数字，则剔除这个数字所在的行<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        row=<span class="number">0</span></span><br><span class="line">        column=len(array[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;len(array) <span class="keyword">and</span> column&gt;=<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(array[row][column]==target):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span>(array[row][column]&gt;target):</span><br><span class="line">                column-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<strong>C++</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">array</span>[<span class="number">0</span>].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target==<span class="built_in">array</span>[i][j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column=<span class="built_in">array</span>[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;<span class="built_in">array</span>.size()&amp;&amp; column&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="built_in">array</span>[row][column])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;<span class="built_in">array</span>[row][column])</span><br><span class="line">                column--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>VINS-Mono论文学习与代码解读</title>
    <url>/2019/10/18/VINS-Mono%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86564879" target="_blank" rel="noopener">VINS-Mono代码解读——启动文件launch与参数配置文件yaml介绍</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86030962" target="_blank" rel="noopener">VINS-Mono代码解读——各种数据结构 sensor_msgs</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/85797156" target="_blank" rel="noopener">VINS-Mono代码解读——视觉跟踪 feature_trackers</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86290941" target="_blank" rel="noopener">VINS-Mono理论学习——IMU预积分 Pre-integration （Jacobian 协方差）</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/86293038" target="_blank" rel="noopener">VINS-Mono代码解读——状态估计器流程 estimator 写在初始化和非线性优化前</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/88942414" target="_blank" rel="noopener">VINS-Mono代码解读——视觉惯性联合初始化 initialStructure sfm</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/89106128" target="_blank" rel="noopener">VINS-Mono理论学习——视觉惯性联合初始化与外参标定</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/93593844" target="_blank" rel="noopener">VINS-Mono理论学习——后端非线性优化</a></li>
<li><a href="https://blog.csdn.net/qq_41839222/article/details/87878550" target="_blank" rel="noopener">VINS-Mono代码解读——回环检测与重定位 pose graph loop closing</a></li>
</ol>]]></content>
      <categories>
        <category>VINS-Mono</category>
      </categories>
      <tags>
        <tag>VINS-Mono</tag>
      </tags>
  </entry>
</search>
